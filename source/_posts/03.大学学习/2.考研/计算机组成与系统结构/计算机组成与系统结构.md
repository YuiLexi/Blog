---
title: 计算机组成与系统结构
date: 2023-9-5:00:00:00
categories:
  - [大学学习, 考研]
  - [计算机学习，计算机组成，计算机系统结构]
tags: [计算机学习, 大学学习, 考研, 计算机组成, 计算机系统结构]
description: 了解计算机体系结构和基本工作原理。
mathjax: true
katex: true
image_path: University/计算机组成与系统结构/计算机组成与系统结构/
---

# 前言

# 第一章 绪论

## 1.1 计算机的发展历史

### 1.1.1 发展历史

1. 第一代：电子管计算机（1946——1957 年）
   1. 第一代计算机是由**电磁继电器**、**电子管**等器件构成的。
2. 第二代：晶体管计算机（1957——1964 年）
   1. 第二代计算机由**晶体管**、**磁芯存储器**等构成。
   2. 软件上采用监控程序对计算机进行管理，并且**开始使用高级语言**。
   3. 与电子管相比，晶体管体积更小，功耗更低，可靠性更高。
3. 第三代：中小规模集成电路计算机（1965——1971 年）
   1. 第三代计算机由中小规模的集成电路芯片、多层印刷电路板以及磁芯存储器等结构。
4. 第四代：大规模和超大规模集成电路计算机（1972——2010 年）
   1. 第四代计算机由大规模、超大规模的集成电路构成。
5. 第五代：巨大规模集成电路（2010——至今）

### 1.1.2 摩尔定律

1965 年 4 月，摩尔在《电子学》杂志上的文章中讲述：如何将 50 个晶体管集成在一块芯片上，并且预言，到 1975 年，就可以将 6.5 万只这样的元件密植在一块芯片上，支撑高度复杂的集成电路。

文章的核心思想：预测集成电路芯片内可集成的晶体管数量差不多每年可增加一倍，在后来的技术发展过程中证明是正确的，并被称为**摩尔定律**。

现在人们根据几十年走过的技术历程将莫俄日的那个率描述为：**集成电路芯片的集成度每 18 个月翻一番**。

> 后来摩尔与其他人共同成立了英特尔（Intel）公司。

**摩尔定律的影响**体现在如下几个方面：

1. 更低的成本（单位价格，更高的性能）；
2. 更高的集成度；
3. 更小的尺寸；
4. 更低的功耗；
5. 更好的可靠性。

## 1.2 计算机 的基本组成

<font color="red">计算机由**硬件**和**软件**两大部分组成，其基本功能为**控制**、**运算**、**存储**和**控制**</font>。

### 1.2.1 硬件系统

#### 1.2.1.1 硬件组成

1946 年，冯·诺依曼提出的一种计算机结构，称之为<font red =“color">**冯·诺依曼结构**</font>。

<img src="https://imageshack.yuilexi.cn/University/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.svg" alt="冯诺依曼结构" style="zoom:50%" />

⚡⚡⚡⚡ 早期的计算机由**运算器**、**控制器**、**存储器**、**输入设备**、**输出设备**这五大部件构成。⚡⚡⚡⚡

- 运算器：实现**算术运算**和**逻辑运算**；
- 控制器：根据指令，产生相应的控制信号，并且控制其他部件；
- 存储器：存放**数据**和**程序**；
- 输入设备：将外部信息输入到计算机中；
- 输出设备：接收计算机的处理结果，并做出显示、存储等操作。

#### 1.2.1.2 冯·诺依曼计算机的特点

👑👑👑👑👑 冯·诺依曼计算机的特点：👑👑👑👑👑

1. 计算机由**运算器（ALU）**、**控制器**、**存储器**、**输入设备**、**输出设备**这五大部件构成。
2. 指令和数据以二进制形式表示，**以同等地位存放在存储器中**，并且按照地址访问。
3. **指令由操作码可地址码组成**。
4. 将计算机要处理的问题用指令编写成**程序**（程序化问题解决方案）。
5. 指令逐条（顺序）从存储器中取出并且执行（指令的顺序执行性）。
6. 特定情况下，跳转类指令可改变指令的执行顺序（指令的可跳转性）。
7. 早期的冯·诺依曼计算机**以运算器为中心**，输入/输出设备通过运算器与存储器传送数据。

#### 1.2.1.3 计算机硬件结构的发展

1. 不管扩充硬件及功能：增加了更多的通用寄存器、多种寻址方式，支持**浮点数据类型**、**中断**和**异步 I/O 结构**。
2. 存储器分层：**引入高速缓存（`Cache`）**、虚拟存储器等
3. **总线结构**：通过总线连接计算机系统的各个模块。

### 1.2.2 软件系统

1. 系统软件
   1. **操作系统**：包括五大功能：**处理器管理、存储管理、文件管理、设备管理和作业管理**。
   2. 语言处理程序
   3. 各种服务支持软件
2. 应用软件

### 1.2.3 指令集体系结构

**计算机系统的底层逻辑只能识别机器语言，也就是存储在主存中的指令**。

#### 1.2.3.1 指令集体系结构的（`IAS`）的概述

处理器支持的指令和指令的字节级编码成为**指令集体系结构**。

ISA 需要规定计算机程序员可见的所有组件及操作，包括：

1. 指令集：处理器可执行的指令的集合
   1. 指令格式；
   2. 数据类型；
   3. 寻址方式。
2. 软件可见的处理器状态
   1. 寄存器的个数、名称、长度和用途；
   2. 指令执行过程中的控制方式。
3. 存储模型
   1. 主存组织；
   2. 字节次序；
   3. 存储保护；
   4. 虚拟存储器的管理方式；
   5. 输入/输出接口的访问与管理方式。
4. 系统模型
   1. 处理器状态；
   2. 特权级别；
   3. 中断和异常的处理方式。

#### 1.2.3.2 典型的 ISA

1. x86

   注重兼容性，

2. ARM

   ARM 处理器在设计时，降低功耗、低成本的优先级排在高性能之前，主要面向嵌入式应用。

3. POWER

4. MIPS

5. SPARC

6. PISC-V

   全新、简单且开放免费的指令集架构。

## 1.3 计算机的层次概念

### 1.3.1 计算机系统的层次结构

<img src="https://imageshack.yuilexi.cn/University/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1i%E7%BB%93%E6%9E%84.svg" alt="计算机系统的层次i结构" style="zoom:50%" />

1. 第一级：**硬件逻辑层**。
2. 第二级：**机器语言层**。该层的主要设计工作是计算机体系结构设计，包括指令系统设计，所以该层也成为**指令集体系结构层**。
3. 第三级：**操作系统层**。
4. 第四级：**汇编语言层**。
5. **第五级**：**高级语言层**。
6. 第六级：**应用语言层**。

### 1.3.2 计算机体系结构、组成与实现

1. 计算机体系结构

   计算机体系结构是程序员所能看到的计算机系统的属性，即概念性结构及功能特性。

   今天的计算机体系结构所指的计算机的属性主要有：

   1. 数据的表示形式；
   2. 寻址方式；
   3. 内部寄存器组；
   4. 指令集；
   5. 中断系统；
   6. 处理器工作状态及其切换；
   7. 存储系统结构；
   8. 输入/输出结构；
   9. 信息保护及特权；
   10. 高性能设计等。

2. 计算机组成

   计算机组成也被称为计算机组织，使计算机系统的逻辑实现，包括最底层内部算法、数据流、控制流的逻辑实现。

   计算机组成的设计主要包括：

   1. 数据通路的宽度（带宽）；
   2. 专用部件（如乘除法专用部件、浮点运算专用部件）的设置；
   3. 各功能部件的并行程度；
   4. 控制器的组成方法；
   5. 存储器使用的技术；
   6. 缓冲与排队技术的应用；
   7. 预估、预判方法；
   8. 高可靠性技术等。

3. 计算机实现

   计算机实现就是指**计算机组成的物理实现**。

## 1.4 计算机分类及性能描述

### 1.4.1 计算机分类 🏆🏆🏆🏆🏆🏆

1. 按用途分类

   1. 通用计算机：
      1. 个人计算机；
      2. 服务器；
      3. 超级计算机。
   2. 嵌入式计算机

2. **Flynn 分类法**🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥

   在程序执行中，存在三种信息流：

   1. 指令流（IS）；
   2. 数据流（DS）；
   3. 控制流（CS）

   按照 **Flynn** 分类法，可以将计算机分为四类：（相当重要 🐲🐲🐲🐲🐲🐲🐲）

   1. **单指令流单数据流**；
   2. **单指令流多数据流**；
   3. **多指令流单数据流**；
   4. **多指令流多数据流**。

### 1.4.2 计算机系统的性能描述

1. 计算机 系统的性能计算

   1. **执行时间**：也称**响应时间**，定义为**一个任务从开始到完成所有的时间或者计算机完成一个任务所有的总时间**。

   2. **吞吐量**：定义为**在给定的时间内（并行）完成的总任务数**。

   3. 计算机的性能计算：
      $$
      \displaystyle \text{性能} P = \frac{1}{\text{执行时间} T}
      $$
      也能得到：
      $$
      \displaystyle \text{性能} P = \frac{\text{完成的总任务数} }{\text{完成任务所需的时间}}  = \text{吞吐率}
      $$
      也即**计算机的性能**与其**吞吐率**成正比。

### 1.4.3 Amdahl 定律

**`Amdahl`定律**的内容是：计算机系统中，某一部件采用更快的执行方式后，整个系统性能的提高于与**这种执行方式的使用频率**或**占中执行时间的比例**有关。`Amdahl`定律给出加速比的定义：

$$
\displaystyle \text{加速比} = \frac{\text{改进后的系统性能} }{\text{改进前的系统性能}}  =\frac{\text{改进后的系统总执行时间} }{\text{改进前的系统总执行时间}}
$$

**计算机的加速比取决于下面两个因素**：

1. 可改进部分在原系统中执行时间中所占的比例，成为**可改进比例**，记作 $f_{e}$ ；
2. 可改进部分改进后，性能提升的程度：通常用**部件加速比 $r_{e}$ 来表示**。

假设改进前系统总执行时间为 $\displaystyle T_{0}$ ，可以得出改进后的系统总执行时间 $T_{n}$ 为

$$
\displaystyle T_{n} = T_{0}\left ( 1-f_{e} + \frac{f_{e}}{r_{e}}  \right )
$$

如果用加速比 $\displaystyle S_{p}$ 表示，那么可以表示为：

$$
\displaystyle {\LARGE \mathbf{ {\color{Green} S_{p} = \frac{1}{ 1-f_{e} + \frac{f_{e} }{r_{e} } } } } }
$$

# 第二章 计算机系统中的数据表示

## 2.1 概述

### 2.1.1 数的进制及转换

常见的进位计数制有：**二进制**、**八进制**、**十进制**和**十六进制**。

1. 十进制：**十进制数的后面常用字母 D 表示**；
2. 二进制：**二进制数的后面常用字母 B 标记**；
3. 八进制： **八进制的后面常用字母 O 标记**；
4. 十六进制：十六进制数的后面常用 H 标记，也可以**在数前面加前缀 “0x” **。

**任何一种进位计数制表示的数都可以写成按权展开的多项式之和**，即

$$
\displaystyle  N_{r} =\sum_{i=-n}^{m} D_{i} \times r^{i}
$$

其中， $D_{i}$ 为该数制采用的基本数码， $r^{i}$ 是权， $r$ 是基数。



### 2.1.2 无符号数和有符号数的定义

1. 无符号数：

      所谓无符号数，即没有**正负号**的数，**数中的每一位均用来表示数值**。

2. 有符号数

      在数值位前面添加一位**符号位**，并且规定 $0$ 为正号，1 为负号。



### 2.1.3 定点数与浮点数的定义

1. 定点数：

      在机器数表示中，约定小数点的位置固定不变，则称为**定点数**。包含：定整数（纯整数）和定点小数（纯小数）

2. 浮点数：

      既可以是纯整数，也可以是纯小数，还可以是同时含有整数和小数的数据，其小数点的位置是不固定的，故称**浮点数**。

      基数为 2 的浮点数 $F$ 的表示为
    $$
    \displaystyle F = M\times 2^{E} 
    $$
    其中，**$M$ 称为尾数， $E$ 称为阶码**。显然，**尾数的位数决定了浮点数的精度，阶码的大小决定了浮点数的大小**。





## 2.2 定点数

### 2.2.1 原码

1. 整数的原码

      若整数用 $n$ 位二进制表示，则整数的原码的定义为：
    $$
    \displaystyle \left [ X  \right ] _{\text{原码} } =\left\{\begin{matrix} X & 0\le X< 2^{n-1}  \\  2^{n-1} -X(2^{n-1}+\left | X \right | ) & -2^{n-1} < X\le 0\end{matrix}\right.
    $$
    原码又称作**带符号的绝对值表示**。显然，**0 有两种表示方式**。

    > 
    >
    > **正数的原码就是其本身的二进制表示，并且在最高位添加一位符号位0**；
    >
    > **负数的原码是其本身绝对值的二进制表示，并且在最高位添加一位符号位 1** 。

2. **小数的原码**

      若小数用 $n$ 位二进制表示，则小数的原码的定义为：
    $$
    \displaystyle \left [ X  \right ] _{\text{原码} } =\left\{\begin{matrix} X & 0\le X<1 \\ 1-X & -1< X\le 0\end{matrix}\right.
    $$
    显然，**0 有两种表示方式**。

    > 小数的原码：“小数点”之后的部分，就是**小数绝对值的二进制表示**，而“小数点”之前是符号位：0，正数；1，负数。

3. **原码的特点**

    1. **数值原码表示方法简单直观，但是加减运算很麻烦**；
    2. **对于数值 0 ，原码的表示方法不唯一**。
    3.  $n$ 位原码表示的范围：
        1. 纯整数：$\displaystyle -(2^{n-1}-1) \to (2^{n-1}-1)$ ；
        2. 纯小数： $\displaystyle -(1-2^{-(n-1)}) \to (1-2^{-(n-1)})$ 。



### 2.2.2 补码

1. 补数的概念

2. 补码的定义
    1. 整数补码
    
          如果整数用 $n$ 位二进制表示，则整数的补码的定义为：
        $$
        \displaystyle \left [ X \right ] _{\text{补码}} =\left\{\begin{matrix} X & ,& 0\le X<2^{n-1}  \\ 2^{n} + X & ,&-2^{n-1}\le X<0\end{matrix}\right.\quad (\mathrm{mod}\quad 2^{2} )
        $$
        
    
        > 非负数的补码就是其原码；负数的补码就是其原码<font color="red">按位（**不含符号位**）取反</font>，然后再加 1 。
    2. 小数补码
    
          如果小数用 $n$ 位二进制表示，则小数的补码的定义为：
        $$
        \displaystyle \left [ X \right ] _{\text{补码}} =\left\{\begin{matrix} X & ,& 0\le X<1  \\ 2 + X & ,&-1\le X<0\end{matrix}\right.\quad (\mathrm{mod}\quad 2)
        $$
        
    
3. **补码的特点**：🦋🦋🦋🦋🦋🦋
    1.  $n$ 位补码表示的整数数值范围： $\displaystyle -(2^{n-1}) \to (2^{n-1}-1)$ ，小数数值范围： $\displaystyle -1 \to (1-2^{-(n-1)})$ ；
    
    2.  **0 的表示是唯一的**。
    
    3.  **变形码**。前面的纯小数的补码定义，是按照**模 2 **的形式；当**模数为 4 **时，可形成**双符号位补码**。即
        $$
        \displaystyle \begin{matrix}\text{非负数}& = 00.x_{1}x_{2}x_{3}\cdots X_{n-1}\\\text{负数}& = 11.x_{1}x_{2}x_{3}\cdots X_{n-1}\end{matrix}
        $$
    
    4.  **求补运算**。
    
    5.  **简化加减法**。
    
          **补码的加法运算规则**：
        $$
        \displaystyle {\color{Red} \left [ X+Y \right ]_{\text{补码} } 
         =\left [ X \right ]_{\text{补码} } 
        +\left [ Y \right ]_{\text{补码} } } 
        $$
          并且减法运算也可以用加法实现，即
        $$
        \displaystyle {\color{Red} \left [ \left [ X \right ]_{\text{补码} } \right ]_{\text{补码} }    =\left [- X \right ]_{\text{补码} } ,\quad  \left [ \left [- X \right ]_{\text{补码} } \right ]_{\text{补码} }    =\left [ X \right ]_{\text{补码} }}
        $$
    
        > 这样，在运算器中，就可以不设置**减法器**，从而简化了运算器的结构。
    
    6.  **算术或逻辑左移**



### 2.2.3 反码（了解）

**反码通常用作来作为原码求补码或者补码求原码的中间过渡**



### 2.2.4 移码



### 2.2.5 不同编码的比较

- 原码表示很直观，但是原码的加减运算比较复杂；
- 补码加减运算比较简单，并且计算机可以只设加法器；
- 反码作为原码求补码或者补码求原码的中间过渡。





## 2.3 浮点数

### 2.3.1 浮点数的表示方法

例如，二进制 $\displaystyle F = 11.0101$ ，使用浮点数可以表示为一下不同的形态：
$$
\displaystyle F = 11.0101 = 0.110101\times 2^{010} =1.10101\times 2^{001}
$$
其中，尾数与阶码均用**二进制**表示，**基数用十进制表示**。

1. 浮点数的编码

    1. 尾数 $M$ 必须为小数，用 $n+1$ 位有符号定点小数表示；**阶码 $E$ 必须为整数**，用 $k+1$ 位有符号定点整数表示。因此，**浮点数编码位数为 $m=(n+1)+(k+1)$**。

    2. 浮点数的编码格式不止一种。下面是其中一种常用的编码格式

        <img src="https://imageshack.yuilexi.cn/University/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F-2.svg" alt="浮点数的编码格式-2" style="zoom:50%" />

      需要强调的是：

    1. **阶码是整数**，其**位数决定浮点数的数值范围**，也就决定了数据的大小。**阶符决定阶码的正负**。
    2. **尾数是小数**，其**位数决定浮点数的精度**。
    3. **尾数的符号表示浮点数的正负**

2. 非规格化浮点数

3. 规格化浮点数

      所谓规格化浮点数，就是将尾数的绝对值限定在规定的数值范围内，即 $\displaystyle \frac{1}{2}\le  \left | M \right | < 1$ 。

      如果尾数用**补码**表示。那么，当



## 2.4 BCD码🍉🍉🍉🍉🍉🍉🍉🍉

**计算机中，采用 4 位二进制编码来表示 1 位十进制数，这种编码称为 BCD 码**。但是，4 位二进制有 16 中编码，但是十进制数有 10 个数字符。因此，**BCD 码有多种形式，使用最多的就是 8421 码**。

|  D3  |  D2  |  D1  |  D0  |  N   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  0   |  0   |  0   |  1   |  1   |
|  0   |  0   |  1   |  0   |  2   |
|  0   |  0   |  1   |  1   |  3   |
|  0   |  1   |  0   |  0   |  4   |
|  0   |  1   |  0   |  1   |  5   |
|  0   |  1   |  1   |  0   |  6   |
|  0   |  1   |  1   |  1   |  7   |
|  1   |  0   |  0   |  0   |  8   |
|  1   |  0   |  0   |  1   |  9   |



## 2.5 非数值数据

> 现代计算机，不仅要处理数值领域的问题，而且还要处理大量的非数值领域问题。

### 2.5.1 ASCII 码

目前，国际上普遍采用的一种字符系统是 **ASCII 码**。包含 10 个十进制数码，26 个英文字母的大小写，一定数量的专用符号及控制命令等 128 个元素，用 **7 位二进制编码表示**。如果加一个奇偶校验位，则共 8 位，用**一字节**表示。

| 校验位 | 高3位 | 高3位 | 高3位 | 低四位 | 低四位 | 低四位 | 低四位 |
| :----: | :---: | :---: | :---: | :----: | :----: | :----: | :----: |
|   D7   |  D6   |  D5   |  D4   |   D3   |   D2   |   D1   |   D0   |



**ASCII 编码表**

|      | 000  | 001  | 010  | 011  | 100  | 101  | 110  | 111  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0000 | NUL  | DLE  |  SP  |  0   |  @   |  P   |  `   |  p   |
| 0001 | SOH  | DC1  |  !   |  1   |  A   |  Q   |  a   |  q   |
| 0010 | STX  | DC2  |  “   |  2   |  B   |  R   |  b   |  r   |
| 0011 | ETX  | DC3  |  #   |  3   |  C   |  S   |  c   |  s   |
| 0100 | EOT  | DC4  |  $   |  4   |  D   |  T   |  d   |  t   |
| 0101 | ENQ  | NAK  |  %   |  5   |  E   |  U   |  e   |  u   |
| 0110 | ACK  | SYN  |  &   |  6   |  F   |  V   |  f   |  v   |
| 0111 | BEL  | ETB  |  ‘   |  7   |  G   |  W   |  g   |  w   |
| 1000 |  BS  | CAN  |  (   |  8   |  H   |  X   |  h   |  x   |
| 1001 |  HT  |  EM  |  )   |  9   |  I   |  Y   |  i   |  y   |
| 1010 |  LF  | SUB  |  *   |  :   |  J   |  Z   |  j   |  z   |
| 1011 |  VT  | ESC  |  +   |  ;   |  K   |  [   |  k   |  {   |
| 1100 |  FF  |  FS  |  ,   |  <   |  L   |  \\  |  l   |  \|  |
| 1101 |  CR  |  GS  |  -   |  =   |  M   |  ]   |  m   |  }   |
| 1110 |  SO  |  RS  |  .   |  >   |  N   |  ^   |  n   |  ~   |
| 1111 |  SI  |  US  |  /   |  ?   |  O   |  _   |  o   | DEL  |



















# 说明

## 更新日志

{% folding 更新日志 %}

{% timeline 更新日志,orange %}

<!-- timeline 2023-9-5 -->

1. 创建文档，并且

<!-- endtimeline -->

{% endtimeline %}

{% endfolding %}
