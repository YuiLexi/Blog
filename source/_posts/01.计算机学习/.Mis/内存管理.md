---
title: 内存管理
date: 2023-6-1 00:00:00
update: 2023-7-24 00:00:00
categories: [编程]
tags: [编程, 计算机组成, 内存管理, C, C++, Java, C#, Rust]
description: 此文章主要介绍计算机的内存管理，以及一些主流语言如C/C++、Java、C#以及Rust的内存管理方式。
img_path: Programming/Mis/内存管理/
---

# 前言

此文章主要介绍计算机的内存管理，以及一些主流语言如 C/C++、Java、C#以及 Rust 的内存管理方式。

# 一、内存

计算机的内存是指用于存储和访问数据的物理硬件设备，它也是计算机系统中非常重要的组成部分。在计算机内存中，存在着几个重要的知识点，其中包括**堆**和**栈**。

## 1.1 栈（Stack）

栈（Stack）：栈是用于存储程序执行期间函数调用和局部变量等信息的一种数据结构。**栈内存的分配和释放是自动进行的，遵循先进后出（LIFO）的原则**。每当调用一个函数时，函数的参数、返回地址和局部变量等信息都会被存储在栈上。当函数执行完毕后，这些信息会被自动释放。**栈的大小一般比较小，并且会随着函数的调用和返回而动态地增加和减少**。

在一般的桌面操作系统（如 Windows、Linux 和 macOS）中，每个线程都会有一个栈，用于存储局部变量、函数调用和其他与线程执行相关的信息。栈的大小通常是以字节为单位进行管理。

**在 32 位系统中，栈的大小通常为几兆字节（MB）到几十兆字节之间。常见的默认栈大小是 1 MB。然而，栈的大小可以通过操作系统或编译器的配置进行调整**。

**在 64 位系统中，由于更大的地址空间，栈的大小通常会更大一些，可以达到几十兆字节甚至更多**。

需要注意的是，栈的大小是有限的，当栈上的内存空间被耗尽时，可能会导致栈溢出（Stack Overflow）错误。栈溢出通常发生在递归调用层级过深或者在栈上分配了过多的局部变量和大对象时。为了避免栈溢出错误，需要合理设计和管理函数调用、局部变量的使用以及递归算法的实现。

总之，计算机的栈区大小是由操作系统决定的，它可以根据系统配置和需要进行调整。在实际开发中，应该注意栈的大小限制，避免栈溢出错误。

## 1.2 堆（Heap）

堆（Heap）：堆是用于动态分配内存的一种数据结构。**它的内存分配是在运行时进行的，称为动态内存分配**。在堆中，内存块的分配和释放可以由程序员控制，可以根据需要动态地分配和释放内存。堆内存的大小一般比较大，不会因为函数的调用和返回而发生变化。堆的分配和释放通常使用特定的函数（如 malloc 和 free）来完成。

在一般的桌面操作系统（如 Windows、Linux 和 macOS）中，堆的大小可以根据系统配置和需求进行调整。操作系统为每个进程提供一定的堆内存空间。

在**32 位系统中，由于地址空间的限制，堆的大小通常受到更为严格的限制，一般可以达到几百兆字节（MB）到几千兆字节（GB）**。

**在 64 位系统中，由于更大的地址空间，堆的大小可以更大，可以达到几千兆字节到几百万兆字节（TB）的范围**。

需要注意的是，**堆的大小受到操作系统和硬件资源的限制**。当堆上的内存空间被耗尽时，进一步的内存分配请求将无法满足，可能导致内存分配失败。这通常被称为堆耗尽（Heap Exhaustion）。

在编程中，合理管理堆内存是非常重要的，包括适时释放不再使用的内存、避免内存泄漏和内存碎片等问题。一些高级语言（如 C#和 Java）提供了自动垃圾回收机制，负责管理堆内存的分配和释放，帮助开发者简化内存管理的工作。

总之，堆区的大小是由操作系统决定的，它提供了动态分配内存的能力，可以根据系统配置和需求进行调整。在开发中，需要合理管理堆内存，避免堆耗尽和其他内存相关的问题。

## 1.3 内存管理和泄露

**内存管理**：操作系统负责管理计算机的内存资源。它通过分配和回收内存来满足程序的需求。内存管理包括内存分配、内存释放、内存保护等操作。常见的内存管理技术包括虚拟内存、分页机制、分段机制等。

**内存泄漏**（Memory Leak）：内存泄漏指的是程序在分配了内存后，**没有正确释放或回收这些内存空间，导致这部分内存无法再被程序使用**。内存泄漏会导致程序运行时内存消耗不断增加，最终可能导致系统性能下降或崩溃。

## 1.4 堆栈溢出

堆栈溢出（Stack Overflow）：堆栈溢出是指当栈的空间不足以容纳新的数据时，数据会溢出到其他内存区域中。这通常是由于递归调用或者函数调用层次太深导致的。堆栈溢出可能导致程序崩溃或产生不可预测的行为。

# 二、数据的作用空间

## 1.1 值类型

值类型的变量，是直接在内存（栈区）中存储数据的**值**。C/C++/Java 的值类型是存储在栈上的，而 C#中的值类型有时存储在栈上，有时存储在堆上。

存储在栈上的数据，超出其作用域就会被立刻释放。例如下面的代码：

```c
#include <stdio.h>
int main()
{
    int GetIntof10();
    int b = GetIntof10();
    printf("%d", b);
    return 0;
}
int GetIntof10()
{// a 没有声明，不能使用
    int a = 5; // a 声明
    return a; // 使用变量 a
}//函数结束，a 释放
```

我们在函数 `GetIntof10()` 中定义了**值类型的变量**，那么 `a` 的作用域就会在函数中，超出函数的返回就会释放。因此当我们在上述函数之外，去使用变量 `a` ，那么就会出错。例如下图所示：

![函数中创建的变量的作用域](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/函数中创建的变量的作用域.png)

我们可以将函数的运行用下面的状态模拟：

![值类型的作用域](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/值类型的作用域.svg)

> 上述函数的参数传递方式为：值传递，即将当前实参进行 Copy ，将复制后的一个副本传入到函数中去，**这时并没有对实参进行操作**。
>
> ```c
> /*----------值传递----------*/
> #include <stdio.h>
> int main()
> {
>     int doubleInt(int a);
>     int a = 5;
>     int b = doubleInt(a);
>     printf("%d   %d", a, b);
> }
> int doubleInt(int a)
> {
>     a = a * 2;
>     return a;
> }
> ```
>
> 结果为：
>
> ```powershell
> 5   10
> ```

在 C/C++/C#/Java/Rust 等主流的语言中，一般情况下都遵循上述的方式。

## 1.2 堆中的指针类型

通常，在 C/C++中，我们可以使用 `malloc()` 函数，在堆上开辟一块内存，并且返回一个指针（该指针指向对应的内存空间）。数据是存储在堆上的，而指针是存储在栈上的，因此，我们访问数据时，会先访问指针变量，然后根据指针变量的值，确定数据的地址，即通过指针寻找到对应的数据，这样的操作使我们拥有更大的内存空间，但是也会对我们造成不便。

![指针与堆数据](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/指针与堆数据.svg)

像是 C/C++这种传统的语言，并没有**内存管理机制（垃圾回收【GC】）**，而堆上的数据并不会像栈一样，超出作用域就会被系统释放，相反，我们需要手动通过 `free()` 函数进行释放。虽然。没有 GC 能提高代码的访问速度，但是同时就要对程序员提出更高的要求，因为一不小心就会出现内存泄漏的情况。

通过下面的例子进行说明：

```c
#include <stdio.h>
#include <malloc.h>
int main()
{
    CreateInt();
    //这里p超出作用域了，所以会报错。
    //但是这里的内存没有释放，这就是内存泄露
    printf("Hello World!\n", *p);
    return 0;
}
char* CreateInt()
{
    char *p = (char *)malloc(100); //在这里在堆区申请了内存，并且把地址赋值给了p（P在栈区）
    *p = "Hello World!\n"; //这里把字符串赋值给了p指向的地址，但是p指向的地址是在堆区，而不是栈区
}// 函数结束，p 释放，但是堆区的内存没有释放，这就是内存泄露
```

通过上述例子，我们理解到了，当一个指针类型的数据没有被释放，与此同时，已经没有指针指向数据的地址，这时候，我们既无法释放内存，同时也不能使用内存，这就是 C/C++最大的内存安全问题——**内存泄露**。<font color="red">C/C++是内存不安全的语言</font>。

> 微软安全工程师马特·米勒在 2019 年以色列安全大会上表示，微软旗下的产品在过去 12 年修复的所有漏洞中，有七成是内存安全问题。

上述例子比较简单，只需要我们手动释放内存就可以避免一些**内存泄露的问题**，但是，在面对庞大的数据操作时候，有时也搞不清楚到底何时该释放内存，或者当前的内存到底释放了没有，因此，这极大程度上，挑战了程序员的能力（“没有真正精通 C/C++的人” -> “没有真正全部掌控 C/C++的数据内存的人”）。

## 1.3 野指针和越界指针

指针问题通常是由于以下原因引起的：

1. 指针未初始化：如果指针没有被初始化，它可能会指向随机的内存地址，从而导致指针越界。

2. 指针被释放后仍被使用：如果指针所指向的内存已经被释放，但程序仍然使用该指针，就会导致指针越界。

3. 数组越界：如果使用指针访问数组元素时超出了数组的范围，就会导致指针越界。

首先先了解一下什么是**野指针**：野指针是一种指针类型，它指向一个**未知的内存地址**或**已经释放的内存**的地址。野指针通常是由于指针变量没有被初始化或者指针变量在释放内存之后没有被置为 NULL 而产生的。使用野指针会导致程序崩溃或产生不可预知的结果，因为它们指向的内存地址可能已经被其他程序或系统所使用。为了避免野指针问题，应该始终将指针初始化为 NULL，并在释放内存后将指针置为 NULL。此外，使用指针变量之前应该检查它是否为 NULL，以确保指针指向的内存地址是有效的。

在 C/C++语言中，同样存在**指针越界**的问题。**指针越界是指指针所指向的内存区域超出了它所指向的对象的范围**。指针越界可能会导致程序崩溃、数据损坏或安全漏洞等问题。

---

例如下面**错误代码**：

```c
/* ----------指针越界问题---------- */
#include <stdio.h>
#include <malloc.h>
int main()
{
    int *a; //指针 a 没有初始化，不能使用
    int *b = (int *)malloc(10 * sizeof(int));
    int c[5] = {1, 2, 3, 4, 5};
    for (int i = 0; i < 10; i++)
    {
        b[i] = i;
        printf("%d  ", b[i]);
    }
    printf("\n");
    free(b); // 此时 b 指向的内存已经释放了，但是 b 没有释放

    /*数组名相当于地址，即c == &c[0]，即 c+i == &c[i]；同时 *(c+i) == c[i] */

    printf("a的地址是：%d， a的值是：", a, *a); // a 没有初始化，
    printf("%d\n", b[0]);                       // b 指向的内存已经释放了，但是 b 没有释放
    printf("%d\n", c[5]);                       // c[5] 越界了，但是没有报错
}
```

首先，在**编译期间**（并不是编译前），会出现一个报错，如下：

![未初始化的指针调用出现异常](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/未初始化的指针调用出现异常.png)

上述错误就是由于没有对指针进行初始化，因此，指针指向不确定位置，这时就会报错。我们将这行代码注释掉，并接着往下看。

![野指针和指针越界](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/野指针和指针越界.png)

<div align="center">野指针的演示</div>

![野指针](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/野指针.svg)

<div align="center">越界指针的演示</div>

![越界指针的演示](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/越界指针的演示.svg)

紧接着，**被释放内存的指针**以及**越界指针**，虽然我们知道这样的代码是存在问题的，但是程序却没有报错，这跟**未初始化指针**不太一样。这是为什么呢？

首先我们观察一下区别，**被释放内存的指针**和**越界指针**，它们指向的地址是确定的，而**未初始化指针**指向的地址不确定，因此，对于不确定指向地址的指针，程序会直接出错。

但是，程序不出错，就代表着我们的程序没有问题吗？不一定，除了语法错误外，还有逻辑错误、内存错误等。因为**被释放内存的指针**和**越界指针**并不会在程序编译期间报错，这会让我们**误以为程序是正确的**，但是实际运行时，由于其指向的地址中的数据是不确定性的，因此我们在程序中使用这两种指针时，就会出现意想不到的结果（C/C++：出不出错，全看我今天的心情）。例如：我们一开始给数组 `b` 赋值，但是释放后，对应内存的值明显和原来不一样 `0 -> 8022160` ，这是程序运行可能会出现逻辑错误；又或者我们希望数组 `c` 是正整数的数组，并且把它拿来作为分数的分母，那么越界指针能取到 `0` ，也会出现程序错误。

综上所述：**未初始化指针**会在编译期间报错，这其实很友好，因为我们能及时发现问题；但是**被释放内存的指针**和**越界指针**由于不会报错，只有在运行期间，才**可能**出现逻辑错误，因此，想要定位和解决问题是十分困难的，甚至是不可能的。

> **上述的演示，充分表明了 C/C++的内存不安全。**

> 在 C/C++中，当我们声明一个指针，但是没有想好该怎么用时，最好初始化为 `NULL` ，这是一种特殊的指针，表示为 “空” ，同时他不指向任何**有效数据**的内存地址。这是一种非常好的习惯。

为了避免指针越界问题，程序员应该仔细检查和管理指针的生命周期，确保指针指向的内存区域是有效的，并且不超出其所指向的对象的范围。可以使用一些工具，如内存检测工具、静态代码分析工具等来帮助发现和预防指针越界问题。

## 1.4 浅拷贝和深拷贝

由于存储在堆上的数据可能十分庞大，并且操作起来会比较慢，因此，当我们想要传递数据时，如果想值传递一样 Copy 一份数据，势必会大大增加运行时间，同时内存的开销也会更大。

值的赋值，也是复制（Copy）：

```c
int a = 5;
int b = a;
```

![值的复制](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/值的复制.svg)

浅拷贝：应用场景有地址传递、引用等。下面介绍向函数传递参数时，指针传递（地址传递）的相关内存问题。

什么是浅拷贝？由于 Copy 一份堆中的数据，有时不太现实，因此，只需要将指向该内存位置的指针传进函数中，函数会将指针进行 Copy ，并且对 Copy 的指针进行操作。

![浅拷贝_2](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/浅拷贝_2.svg)

上述图示表明，**在 C/C++语言中，在同一时刻，可以有两个指针指向同一个内存位置**，因此，这样就能做到：在不用 Copy 数据 A 的前提下，将数据传入到函数域中去。当函数运行结束的时候，会将 `指针P-副本` 释放，但是不会释放**堆中的数据**，同时 `指针p` 还存在，因此这时候还有指向 `数据A` 内存地址的指针，看起来并不会出现所谓的内存问题。

但是，如果在函数运行期间，我们通过 `指针P-副本` 把堆中的 `数据A` 释放了，那么这时候 `指针p` 和 `指针P-副本` 指向位置中的数据不确定，因此，这两个指针就会成为**野指针（指向已释放内存的指针）**。同时，我们还知道，在函数运行结束后 `指针P-副本` 会被释放，但是 `指针p` 并不会被释放，这时候， `指针p` 就会成为一个完完全全的**野指针**。

还有一种情况，我们在函数中，通过 `指针P-副本` 释放一次内存，但是我们没有立刻意识到；然后，在函数结束后，我们又通过 `指针p` 释放一次内存。这时候可以看作是，将 `数据A` 释放了两次，只是不被系统所允许的，因此必定会出现错误。

> 如果一个内存有多个地址指向，那么，通过某一个指针，对数据进行修改，所有指针指向的数据都会被修改。
>
> 原因是：所有指针指向的数据是相同的。

> 从上面的结果来看，如果一个内存在同一时刻，有多个指针指向该位置，那么可能会造成**野指针**或者**两次释放**这样的严重内存问题，因此，浅拷贝也是**内存不安全的**。

深拷贝：就是和值的复制一样，将堆上的数据 Clone 一份。虽然，这样会减少内存的问题，但是会消耗大量的计算机资源，在运行速度以及内存占用方面，都没有优势，因此在项目开发的时候，一般情况下避免使用深拷贝。

> 深拷贝的好处是：修改 Clone 的副本中的数据，并不会影响原来的数据。

# 三、带有 GC 的语言

## 3.1 什么是 GC

C#依赖 .NET ，Java 依赖虚拟机，二者都是带有 GC 的高级编程语言。

GC（Garbage Collection）是一种自动内存管理技术，它通过自动识别和回收不再使用的内存来减少程序员的内存管理负担。在使用 GC 的编程语言中，程序员不需要手动分配和释放内存，而是由 GC 自动完成这些任务。

GC 通过跟踪内存中的对象引用来确定哪些对象可以被回收。当一个对象不再被任何引用所引用时，GC 就会将其标记为垃圾，并回收其所占用的内存。GC 的回收策略可以是基于引用计数或基于可达性分析的。

GC 技术的优点是可以减少内存泄漏和野指针等内存管理问题的发生，提高程序的健壮性和安全性，是程序员不需要关心内存的问题，把内存的管理交由系统来操作，因此，这些语言是**内存安全的**，尤其是 `java` 。

**缺点是： GC 会占用一定的系统资源，会影响程序的性能**。尤其是 `java` 。

## 3.2 堆内存管理（与指针类似）

C#以及 java，由于其具有垃圾回收机制（GC），因此，当我们在堆上开辟一块新的内存空间的时候，系统会将该内存地址进行标记，并且返回一个对应的数据的**`引用`** 。我们通过引用，间接获取数据对象。

引用和地址类似，并且同一块内存，在同一时刻，也能存在多个引用，但是，作为程序员，并不需要手动进行释放，因此，就大大减少了内存的问题。

## 3.3 动态内存管理技术

我们知道，在 C/C++中，可以使用 `malloc()` 函数开辟一块内存空间，但是这块内存空间是静态的，即对应数据在堆内存的位置不会自动变化，而是静态固定的，因此，我们可以使用指针去捕获对应位置的数据。

但是，上述的方式，对于内存资源的利用，并不是最有效的方式。我们知道，在计算机的堆内存中，时刻发生着内存的开辟与释放，对于复杂的数据来说，它在堆上是开辟一块**大小不确定的连续排列的**内存，如果某个位置，释放了一个小内存的数据，那么声明一个大数据时，就不能往小的地方开辟，需要找到足够大的空间进行开辟。

![静态内存管理](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/静态内存管理.svg)

上述的静态内存管理，对内存的使用并不是充分可利用，因此，在计算机资源的调度上，不是很理想。

---

拥有内存管理系统的 C# 和 java 来说，系统会动态的改变数据对象在内存中的位置，以提升对内存的利用率，这一点的提升非常好。但是，缺点就是需要占用一定的时间进行数据转移，在转移数据的过程中，会进行**深拷贝**，因此，对性能会有较大的影响。

> 有关引用，本质上也是地址，但是，就算引用的对象的位置发生改变，引用的关系也不会改变。这也是在 C#/Java 中，基本没有指针的原因（C#的不安全代码，保留了指针）。因为数据在内存中的位置会发生变化，指针（静态的，不会自动变化）也就失去了该有的作用。

# 四、Rust 的内存管理机制

带有 GC 的语言，它的内存是安全的，但是 GC 会严重拖慢系统资源。不带有 GC 的语言，它的运行效率非常高，但是内存很不安全。

为什么要创造出 Rust ？那是我们现在急需一门无 GC 、内存安全、运行效率高、并发式、线程安全的语言。

Rust 的数据也主要分为值类型（栈区）和引用类型（堆区），其中引用类型在栈区上，存储对应数据的地址。

## 4.1 所有权

### 4.1.1 什么是所有权

- **Rust 的核心特性就是所有权**
- 所有程序在运行时，都必须管理它们使用计算机内存的方式
  - 有些语言有垃圾回收机制，在程序运行时，他们会不断寻找不再使用的内存，将它们收集和释放
  - 在一些其他的语言中，程序员必须显示的分配和释放内存
- Rust 采用了第三种方式
  - 内存是通过一个所有权系统来管理的，其中包含一些编译器在编译时检查的规则
  - 在程序运行时，所有权特性不会减慢程序的运行速度，因为它是在编译期间完成的（因此，Rust 的编译过程非常缓慢）

### 4.1.2 Stack 和 Heap（栈和堆）

- 在像 Rsut 这样的系统级编程语言里，一个值在 Stack 上还是在 Heap 上，对语言的行为和你为什么要做某些决定是有更大影响的
- 当你在代码运行的时候，Stack 和 Heap 都是你可用的内存，但是它们的结构很不相同
  - Stack 按照值的接受顺序来存储，按相反的顺序将它们移除（先进后出）
    - 添加数据叫做压栈
    - 移除数据叫做出栈
  - 所有存储在 Stack 上的数据必须拥有已知的固定的大小
    - 编译时大小未知的数据或者运行时大小可能发生改变的数据必须存放在 Heap 上
  - Heap 对内存的组织性差
    - 当你把数据放入 Heap 是，会请求**一定数量**的空间
    - 操作系统在 Heap 里找到一块足够大的内存是，把它标记为在用，并返回一个指针（引用），也就是这个空间的地址
  - 把值压到 Stack 上不叫分配
  - 因为指针是已知固定大小的，可以把指针存放在 Stack 上
    - 但如果想要实际数据，必须使用指针（引用）来定位
  - 把数据压到 Stack 上要比在 Heap 上分配快得多
    - 因为操作系统不需要寻找用来存储数据的新空间，那位置永远都在 Stack 的顶端
  - 在 Heap 上分配空间需要做更多的工作
    - 操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配
  - 访问 Heap 中的数据比访问 Stack 中的数据要慢的多，因为需要通过指针才能找到 Heap 中的数据，多了指针跳转的环节
    - 对于现代的处理器来说，由于缓存的缘故，如果指令在内存中的跳转的次数越少，那么速度越快
  - 如果数据存放的比较近，那么处理器的处理速度就会更快一些（Stack 上）
  - 如果数据之间的距离比较远，那么处理速度就会慢一些（ Heap 上）
    - 另外，在 Heap 上分配内存空间，也是需要不少时间的
  - 当你的代码调用函数时，值被传入到函数（这也包括指向 Heap 的指针）。函数本地的变量被压到 Stack 上。当函数结束后，这些值会从 Stack 上弹出

### 4.1.3 所有权存在的原因

- 所有权解决的问题
  - 跟踪代码的那部分正在使用 Heap 的哪些数据（因为这，导致 Rust 的运行速略慢于 C++，不过可以通过手动消除这种差距，甚至超越 C++直逼 C 语言的速度）
  - 最小化 Heap 上的重复数据量
  - 清理 Heap 上未使用的数据以避免不足
- 一旦理解了所有权，那么就不需要经常去想 Stack 或 Heap 了
- 但是要知道，管理 Heap 数据才是所有权存在的原因

### 4.1.4 所有权的规则（重中之重）

1. 每个值都有一个变量，这个变量是该值的所有者（唯一绑定）
2. 每个值同时只能有**一个所有者**
3. 当**所有者**超出作用域（Scope）的时候，该值将被删除（包括堆上的数据）

### 4.1.5 变量的作用域

- Scope 就是程序中，一个项目的有效范围

  ```rust
  fn main() {
      // s 没有声明，所以它无效
      let s = String::new(); // s 声明并初始化，所以它有效
  } // 函数结束，s 超出作用域，因此会失效
  ```

### 4.1.6 String 类型（堆数据的一种，借此说明问题）

- 字符串字面值，程序中手写的字符串的值。它们是不可变的
- Rust 还有第二种字符串类型：String （长度可变，编译期间不确定内存大小）
  - 在 Heap 上分配。能够存储在编译时未知数量的文本

#### 4.1.6.1 创建 String 类型

- 使用 from 函数，从字符串字面值中创建出 String 类型

  ```rust
  fn main() {
      // :: 表示 String 类型的 from 函数是 String 类型的一个关联函数（associated function）
      let mut s = String::from("我是字面值");
      s.push_str("，我要添加进去");
      println!("{}", s);
  }
  ```

- 这类字符串是可以修改的

- 为什么 String 类型的值可以修改，而字符串字面值不能修改呢？

  - 因为它们处理内存的方式不同

#### 4.1.6.2 内存和分配

- 字符串字面值，在编译期间就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里
  - 速度快、高效。究其原因就是因为其不可变性
- String 类型，为了支持可变性，需要在 Heap 上分配内存来保存编译时位置的文本内容
  - 操作系用必须在运行时，请求内存；这一步是通过 `String::from` 来实现的
  - 当用完 String 之后，需要使用某种方式，将内存返回给操作系统
    - 这一步，在拥有 GC 的语言中，GC 会跟踪并清理不再使用的内存
    - 没有 GC ，就需要我们自己去识别内存何时不再使用，并调用代码将它返回
      - 如果忘记释放，内存就会浪费
      - 如果提前了，变量就会非法
      - 如果做了两次，也是 Bug 。必须一次分配一次释放
    - Rust 采用了不同的方式：对于某个值来说，当**拥有它的变量**走出作用范围，内存会**立即自动的**交还给操作系统
      - 其实在变量离开作用域的前一刻，会自动调用 `Drop` 去释放

#### 4.1.6.3 变量与数据的交互方式：移动（Move）

- 多个数据可以与同一个数据，使用一种独特的方式来交互

  ```rust
  fn main() {
      let x = 5;
      let y = x;
      print!("x = {}, y = {}", x, y)
  }
  ```

  - 在**所有权规则中**，有 “每个值同时只能有**一个所有者**”，这里为什么 x 还能被打印呢？
  - 其实上面的，是把 x 的值进行复制，再绑定给 y 。
  - 整数是已知且固定的大小的简单的值，这两个 5 被压到了 Stack 中

- 对于 String 这种存储在堆上的数据，和上面不同

  ```rust
  fn main() {
      let s1 = String::from("hello");
      let s2 = s1;
      println!("{}, world!", s1);
      println!("{}, world!", s2);
  }
  ```

  ​ 这样的写法与前面的代码类似，但是这里却出现一个报错**borrow of moved value: `s1`**，翻译一下就是**借用移动的值：`s1`**。

  ![所有权转义_1](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/所有权转义_1.png)

- String 的组成：一个指向存放字符串内容的指针、一个表示长度的字节、一个表示容量的字节

  ![String的存储结构](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/String的存储结构.svg)

- 上面这些东西放在 Stack 上，存放字符串内容的部分存储在 Heap 上

- 当把 s1 赋给 s2 时， String 的数据被复制了一份，但是字符串数据没有被复制。即会出现下面的情况。

  ![String的存储结构_赋值操作](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/String的存储结构_赋值操作.svg)

- 上面的，两个指针（引用）同时指向一个位置，这是在 C/C++（C#/Java）中被允许的。但是，我们在之前也介绍过，**这种在同一时刻，同时有多个指针指向同一位置的行为，其实是内存不安全的，可能会出现野指针或者释放两次的问题**

- 因此，Rust 并没有采用 C/C++ 的方式，而是将 s1 对字符串数据（堆数据）的`所有权` 移动给 s2 ，并且 s1 会丧失对字符串数据的所有权，这时候 s1 会失效。

  ![所有权转移](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/所有权转移.svg)

  - 对于有一个数据而言，由于在同一时刻，只有一个指向该位置的指针，也就不会出现**二次释放内存的问题**，同时，因为**超出作用域自动释放内存，包括栈和堆内存**，也就不会出现**野指针**以及**内存泄漏**的情况了

    > 同时，上面的特性，也使得 Rust 是一门线程安全的语言。

- Rust 的一个设计原则：不会自动创建数据的深拷贝。

- 如果真想堆 Heap 上面的 String 数据进行深度拷贝，而不仅仅是在 Stack 上的数据，可以使用 clone 方法

  ```rust
  fn main() {
      let s1 = String::from("hello");
      let s2 = s1.clone();
      println!("{}, world!", s1);
      println!("{}, world!", s2);
  }
  ```

  ![克隆](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/克隆.svg)

- 针对 Stack 上的数据，我们不叫做克隆，而称它为**复制**

  - Copy trait ：可以用于像整数这样完全存放在 Stack 上面的类型
  - 如果一个类型实现了 Copy 这个操作，那么旧的变量在赋值后仍然可用
  - 如果一个类型或者该类型的一部非实现了 Drop trait，呢么 Rust 不允许让它再去实现 Copy trait

- 一些拥有 Copy trait 的类型（**存放在栈上的值类型**）

  - 任何简单标量的组合类型都可以是 Copy 的
  - 任何需要分配内存或者某种资源的都不是 Copy 的
  - 所有的整数类型、bool、char、所有的浮点类型、Tuple（元组，前提是所有字段都是 Copy 类型的）

### 4.1.7 所有权与函数

- 在语义上，将值传递给函数和把值赋给变量是类似的

  - 将值传递给函数，要么会发生**移动**，要么会发生**复制**

    ```rust
    fn main() {
        let s = String::from("hello"); // s 获得所有权
        let num = 5; // number 获得所有权

        // s 的值的所有权移动给函数中的 str
        // s 失去了所有权，所以在这里不能再使用它
        // str 在函数结束时释放
        print_string(s);

        // num 的值，复制一份，将副本的所有权移动给函数中的 n
        // num 本身不会失去所有权，所以在这里仍然可以使用它
        print_int(num);

        println!("s = {}", s); // error
        println!("num = {}", num); // ok
    }
    //打印字符串
    fn print_string(str: String) {
        println!("{}", str);
    }
    fn print_int(number: i32) {
        println!("{}", number);
    }
    ```

    ![所有权与函数](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/所有权与函数.png)

### 4.1.8 返回值与作用域

函数在返回值的过程中，同样也会发生所有权的转移。

```rust
fn main() {
    let s2 = getstr();
    let s3 = String::from("world");
    let s5 = movestr(s3);

    println!("{}", s2); // ok
    println!("{}", s3); //err
    println!("{}", s5); // ok

    // 所有权转移的顺序为
    //s1 -> s2
    // s3 -> s4 -> s5
    // 最终，只有s2和s5有所有权
}
//打印字符串
fn getstr() -> String {
    let s1 = String::from("Hello");
    s1 // 值(逻辑/字符串)表达式，放在域的最后一行，不加分号，代表返回值
}
fn movestr(s4: String) -> String {
    s4 // 值(逻辑/字符串)表达式，放在域的最后一行，不加分号，代表返回值
}
```

一个变量的所有权总是遵循同样的模式：

1. 把一个值（非 Copy trait）赋给其他变量时，就会发生移动
2. 当一个包含 Heap 数据的变量离开作用域时，它的值就会被 drop 函数清理，除非数据的所有权移动到另一个变量上了（例如：以返回值的形式转移所有权）

### 4.1.9 不获取所有权，但能使用数据

1. 方法一：元组返回值

   ```rust
   fn main() {
       let s1 = String::from("hello");
       let (l, s1) = get_len(s1);
       println!("{}", l);
       println!("{}", s1);
       // 所有权传递
       // s1 -> s -> s1
   }
   // 获取字符串的长度
   fn get_len(s: String) -> (usize, String) {
       let len = s.len();
       (len, s) // 返回一个元组，包含字符串长度和字符串本身
   }
   ```

   ​ 但是这种做法，不得不将字符串作为参数返回，使用起来比较麻烦。

2. 方法二：引用

   Rust 有一个特性，叫做 **`引用(Reference)`** 。（不要将这里的引用与其余语言混混淆，尽管功能相近）

## 4.2 引用与借用

### 4.2.1 引用

例子：

```rust
fn main() {
    let s1 = String::from("hello");

    // & 表示引用，不会获取所有权，但是可以访问
    let l = get_len(&s1);

    println!("The length of '{}' is {}.", s1, l);
}
// 获取字符串的长度
fn get_len(s: &String) -> usize {
    let len = s.len();
    len
}

```

- 参数的类型是 `&String` 而不是 `String`

- `&` 符号就是表示引用，允许引用某些值而不获取所有权

  ![引用](https://imageshack.yuilexi.cn/Programming/Mis/内存管理/引用.svg)

- 由于函数中的 s 并未取得字符串数据的所有权，因此，在函数结束后，s 被释放，并且不会释放堆中的字符串数据。

### 4.2.2 借用

- 我们把引用作为函数参数的这个行为叫做借用
- 不可以修改借用的数据
- 和变量一样，引用默认也是不可变的变量

### 4.2.3 可变引用

```rust
fn main() {
    // 1、首先在声明 s1 时，使其为可变的变量
    let mut s1 = String::from("hello");

    // & 表示引用，不会获取所有权，但是可以访问
    let l = get_len(&mut s1); // 3、传递参数时，也需要使用 &mut

    println!("The length of '{}' is {}.", s1, l);
}
// 获取字符串的长度
// 2、函数的参数列表中，添加 mut ，表示参数是可变的
fn get_len(s: &mut String) -> usize {
    s.push_str(" world"); // 添加字符串
    s.len() // 这是一个表达式，不需要使用 return，返回值是 s 的长度，usize 类型
}
```

可变引用的限制：

- **在特定的作用域内，对于某一块数据来说，只能有一个可变引用（这是为了防止多个可变引用同时修改同一个数据）**

  ```rust
  fn main() {
      let mut s1 = String::from("hello");
      let s2 = &mut s1; // s2 是可变引用
      let s3 = &mut s1;
  }
  ```

  上述代码会在编译期间发出警告，并且导致编译不成功。

  - 好处是可以在编译时防止数据竞争
  - 无惧并发的数据访问问题

- 以下三种行为会发生数据竞争

  - 两个或多个指针同时访问一个数据
  - 至少有一个指针用于写入数据
  - 没有使用任何机制，来同步对数据的访问

- 可以通过创建新的作用域，来允许非同时的创建多个可变引用

  ```rust
  fn main() {
      let mut s1 = String::from("hello");
      {
          let _s2 = &mut s1; // s2 是可变引用
      }
      let _s3 = &mut s1;
  }

  ```

- 不可以同时拥有一个可变引用和一个不可变引用，但是多个不可变引用是允许的

### 4.2.4 悬空引用

悬空指针：一个指针引用了内存中的某个地址，而这块内存可能已经释放，并分配个其他变量使用

- 在 Rust 里，编译器可保证引用永远不会是悬空引用
  - 如果你引用了某些数据，编译器将保证在引用离开作用域之前，数据不会离开作用域

### 4.2.5 引用的规则

- 在任何给定的时刻，只能满足下列条件之一：

  1.  一个可变的引用

  1.  任意数量的不可变引用

- 引用一直有效

## 4.3 切片

Rust 的另一种**不持有所有权**的**数据类型**：切片（Slice）。

例如有这么一道题：百年写一个函数，它接收字符串作为参数，返回在字符串里找到的第一个单词，如果没有找到任何空格，那么整个字符串就会被返回。

```rust
//下面例子只返回空格的位置，如果没有空格，就会返回字符串的长度
fn main() {
    let s = String::from("Hello world");
    let word = first_world(&s);
    println!("The first word is: {}", word);
}

fn first_world(str: &String) -> usize {
    let bytes = str.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    str.len()
}
```

### 4.3.1 字符串切片

- 字符串切片是指向字符串中一部分内容的引用

  ```rust
  fn main() {
      let s = String::from("Hello world");

      let _s1 = &s[0..5]; //指向s的第一个字节，从0开始，到5结束，不包括5
      let _s2 = &s[6..11]; //指向s的第一个字节,从6开始,到s结束,不包括s
  }

  ```

- 形式： `[开始索引..终止索引]` ，左闭右开

- 语法糖：

  ```rust
  &s[0..5];
  &s[..5];
  &s[6..11];
  &s[6..];
  &s[..]
  ```

- 字符串切片的索引必须发生在有效的 UTF-8 字符边界内

- 如果尝试从一个多字节的字符中创建字符切片，程序就会报错并退出

```rust
fn main() {
    let s = String::from("Hello world");
    let word = first_world(&s);

    s.clear(); // error!
    println!("The first word is: {}", word);
}

fn first_world(str: &String) -> &str {
    let bytes = str.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &str[..i];
        }
    }
    &str[..]
}
```

上述程序在第五行会报错，原因是因为，在第二行，我们声明了 s 为可变的，但是在第三行我们借用 s 的时候，是将其作为**不可变引用**来使用的，但是在第五行，我们想清除 s 却是借用作为**可变引用**来使用的。违反了同一域中的同一变量，不能同时存在可变和不可变引用，因此，这里报错。

### 4.3.2 将字符串切片作为参数传递

有经验的开发者会采用字符串切片 `&str` 作为参数类型，因为这样就可以同时接收 `String` 和 `&str` 类型的参数了

```rust
fn main() {
    let s = String::from("Hello world");
    let word = first_world(&s);

    s.clear(); // error!
    println!("The first word is: {}", word);
}

fn first_world(str: &str) -> &str {
    let bytes = str.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &str[..i];
        }
    }
    &str[..]
}
```

- 使用字符串切片，直接调用该函数
- 使用 String ，可以创建一个完整的 String 切片，再来调用该函数
- `&str` 可以接受字符串切片以及字符串引用。

定义函数时，使用字符串切片来代替字符串引用，会使我们的 API 更加通用，且不会损失任何功能。

### 4.3.4 其它类型的切片

数组等

# 说明

## 更新日志

{% folding 更新日志 %}

{% timeline 更新日志,orange %}

<!-- timeline 2023-6-3 -->

1. 介绍了第四章内容

<!-- endtimeline -->

<!-- timeline 2023-6-2 -->

1. 介绍了第三章内容

<!-- endtimeline -->

<!-- timeline 2023-6-1 -->

1. 创建文件，并且添加第一、二章知识点

<!-- endtimeline -->

{% endtimeline %}

{% endfolding %}
