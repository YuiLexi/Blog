---
title: 第七章 图(Graph)【数据结构】
date: 2023-4-29 00:00:07
categories:
	- [大学学习, 考研]
	- [C语言, 数据结构]
tags: [C语言, 数据结构, 考研, 大学学习]
description: 数据结构(C语言版)学习笔记，包括线性表、栈、队列、串、树、图、查找、排序等内容。
mathjax: true
katex: true
imagehost_path: Blog/Post/01.计算机学习/02.计算机基础学习/02.数据结构/07.图(Graph).md/
---

# 前言

> 快速导航：
>
> - [第一章 绪论【数据结构】](./01.绪论)
> - [第二章 线性表【数据结构】](./02.线性表)
> - [第三章 栈和队列【数据结构】](./03.栈和队列)
> - [第四章 串【数据结构】](./04.串)
> - [第五章 数组和广义表【数据结构】](./05.数组和广义表)
> - [第六章 数和二叉树【数据结构】](./06.数和二叉树)
> - [第七章 图(Graph)【数据结构】](./07.图Graph)
> - [第九章 查找【数据结构】](./09.查找)

**图(Graph)**是一种较线性表和树更为复杂的数据结构。

- 在**线性表**中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；
- 在**树形结构**中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关；
- 而在**图形结构**中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。

# 一、图的定义和术语

在图中的数据元素通常称做**顶点(Vertex)**， $V$ 是顶点的有穷非空集合； $\displaystyle VR$ 是两个顶点之间的关系的集合。

基本术语：

- **顶点(Vertex)**：图中的数据元素；
- **弧（Arc）**：两个顶点之间链接的 $\displaystyle \left \langle v,w \right \rangle $ ；并且 $\displaystyle v$ 称为**弧尾（Tail）**， $\displaystyle w$ 称为**弧头（Head）**；
- **有向图**：有弧头和弧尾的图，即弧带有方向；
- **无向图**：没有弧头和弧尾的图，此时用**边（Edge）**来替代**弧**，即弧不带方向；
- **完全图**：有 $\displaystyle \frac{1}{2} n(n-1)$ 条边的无向图，即：任意两个顶点都有边的无向图；
- **有向完全图**：有 $\displaystyle n(n-1)$ 条边的有向图，即：任意两个顶点都有两条正反方向的弧的有向图；
- **稀疏图**：有很少条边或者弧的图；$\displaystyle e< n\log_{}{n} $ ；
- **稠密图**：不是稀疏图的剩余图；（**显然，完全图和有向完全图都是稠密图**）
- **权(Weight)**：图的边或者弧带有一个相关数，这个数称为**权**；
- **网**：带权的图，称为**网**；
- **邻接点**：两个顶点之间有边或者弧，那么这两个顶点之间互为**邻接点**，并且称“边”**依附**与顶点，或者说“边”和顶点**相关联**；
- **度(degree)**：和顶点相关联的边的数目；以该顶点为头的弧的数目称为**入度**；以该顶点为尾的弧的数目称为**出度**；
- **路径**：从一个顶点到另一个顶点，所走的顶点序列；
- **路径长度**：路径上所有的边的数目
- **回路或者环**：第一个顶点和最后一个顶点相同的路径；
- **简单路径**：序列中顶点不重复出现的路径；
- **连通**：无向图中，如果从一个顶点到另一个顶点有路径，那么称该两个顶点是**连通的**；
- **连通图**：无向图中，任意两个顶点都是连通的图；
- **连通分量**：无向图中，极大连通子图；
- **强连通图**：有向图中，任意两个顶点之间都能相互连通的图；
- **强连通分量**：有向图中，加大强连通子图；
- **生成树**：一个连通图的**生成树**是一个**极小连通子图**（用尽可能少的边，构成连通图），它含有图中的全部顶点，但只有足以构成一棵树的 $\displaystyle n-1$ 条边，即：去掉任意一条边，都会成为非连通图；

# 二、图的存储结构

## 2.1 数组表示法

**用两个数组分别存储数据元素的信息和数据元素之间的关系的信息**。其数据结构模型如下：

```c
#define INFINITY __INT_MAX__ // 无穷大
#define MAX_VERTEX_NUM 20    // 最大顶点个数
typedef enum
{
    DG, DN, UDG, UDN
} GraphKind; // {有向图，有向网，无向图，无向网}

typedef struct ArcCell
{
    int adj; // 顶点关系类型。对无权图，用1或0表示相邻否；对带权图，则为权值类型
    // InfoType *info; // 该弧相关信息的指针
} ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

typedef struct
{
    char vexs[MAX_VERTEX_NUM]; // 顶点向量
    AdjMatrix arcs;            // 邻接矩阵
    int vexnum, arcnum;        // 图的当前顶点数和弧数
    GraphKind kind;            // 图的种类标志
} MGraph;
```

上面的代码中， `AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM]` 表示的是**邻接矩阵**。以二维数组表示有 $n$ 个顶点的图时，需存放 $n$ 个顶点信息和 $\displaystyle 2^{n} $ 个弧信息的存储量。若考虑无向图的邻接矩阵的对称性，则可采用压缩存储的方式，只存入矩阵的下三角（或上三角）元素。

> 显然，邻接矩阵的主对角线上的元素**恒为 0** 。

借助于邻接矩阵容易判定任意两个顶点之间是否有边（或弧）相连，并容易求得各个顶点的度。

对于无向图，顶点 $\displaystyle v_{i} $ 的度是邻接矩阵中第 $\displaystyle i$ 行（或第列）的元素之和，即：

$$
\displaystyle \mathrm{TD}(v_{i} ) = \sum_{j=0}^{n-1} A[i][j]\quad (n=\text{INT-MAX} )
$$

对于有向图来说，第 $\displaystyle i$ 行元素之和为顶点 $\displaystyle v_{i} $ 的出度 $\displaystyle \mathrm{OD} $ ，第 $\displaystyle i$ 列元素之和为顶点 $\displaystyle v\_{i} $ 的出度 $\displaystyle \mathrm{ID} $ 。

**网的邻接矩阵**可定义为：

$$
\displaystyle A[i][j]=\left\{\begin{matrix} w_{ij}  & if\left \langle v_{i},v_{j} \right \rangle \\ \infty  & else\end{matrix}\right.
$$

**构造一个具有 $\displaystyle n$ 个顶点和 $\displaystyle e$ 条边的无向网 $\displaystyle G$ 的时间复杂度是 $\displaystyle O(n^{2} +e\times n)$**，其中，对邻接矩阵的初始化耗费了 $\displaystyle O(n^{2})$ 的时间。

其数据结构模型算法如下：

```c
Status GreatGraph(MGraph &G)
{
    scanf("%s", G.kind); // 输入图的种类
    switch (G.kind)
    {
    case DG:
        return CreateDG(G);
    case DN:
        return CreateDN(G);
    case UDG:
        return CreateUDG(G);
    case UDN:
        return CreateUDN(G);
    default:
        return ERROR;
    }
}
Status CreatDG(MGraph &G)
{
    scanf("%d%d", G.vexnum, G.arcnum); // 输入顶点数和弧数
    // 顶点向量
    for (int i = 0; i < G.vexnum; i++)
    {
        scanf("%c", G.vexs[i]); // 输入顶点向量
    }
    // 邻接矩阵
    for (int i = 0; i < G.vexnum; i++)
    {
        for (int j = 0; j < G.vexnum; j++)
        {
            G.arcs[i][j].adj = 0; // 初始化邻接矩阵
        }
    }
    for (int k = 0; k < G.arcnum; k++)
    {
        int i, j;
        scanf("%d%d", i, j); // 输入一条弧依附的顶点
        G.arcs[i][j].adj = 1;
    }
    return OK;
}
Status CreatDN(MGraph &G)
{
    scanf("%d%d", G.vexnum, G.arcnum); // 输入顶点数和弧数
    // 顶点向量
    for (int i = 0; i < G.vexnum; i++)
    {
        scanf("%c", G.vexs[i]); // 输入顶点向量
    }
    // 邻接矩阵
    for (int i = 0; i < G.vexnum; i++)
    {
        for (int j = 0; j < G.vexnum; j++)
        {
            G.arcs[i][j].adj = INFINITY; // 初始化邻接矩阵
        }
    }
    for (int k = 0; k < G.arcnum; k++)
    {
        int i, j, w;
        scanf("%d%d%d", i, j, w); // 输入一条弧依附的顶点和权值
        G.arcs[i][j].adj = w;
    }
    return OK;
}
Status CreatUDG(MGraph &G)
{
    scanf("%d%d", G.vexnum, G.arcnum); // 输入顶点数和弧数
    // 顶点向量
    for (int i = 0; i < G.vexnum; i++)
    {
        scanf("%c", G.vexs[i]); // 输入顶点向量
    }
    // 邻接矩阵
    for (int i = 0; i < G.vexnum; i++)
    {
        for (int j = 0; j < G.vexnum; j++)
        {
            G.arcs[i][j].adj = 0; // 初始化邻接矩阵
        }
    }
    for (int k = 0; k < G.arcnum; k++)
    {
        int i, j;
        scanf("%d%d", i, j); // 输入一条弧依附的顶点
        G.arcs[i][j].adj = 1;
        G.arcs[j][i].adj = 1;
    }
    return OK;
}
Status CreatUDN(MGraph &G)
{
    scanf("%d%d", G.vexnum, G.arcnum); // 输入顶点数和弧数
    // 顶点向量
    for (int i = 0; i < G.vexnum; i++)
    {
        scanf("%c", G.vexs[i]); // 输入顶点向量
    }
    // 邻接矩阵
    for (int i = 0; i < G.vexnum; i++)
    {
        for (int j = 0; j < G.vexnum; j++)
        {
            G.arcs[i][j].adj = INFINITY; // 初始化邻接矩阵
        }
    }
    for (int k = 0; k < G.arcnum; k++)
    {
        int i, j, w;
        scanf("%d%d%d", i, j, w); // 输入一条弧依附的顶点和权值
        G.arcs[i][j].adj = w;
        G.arcs[j][i].adj = w;
    }
    return OK;
}
```

## 2.2 邻接表（和逆邻接表）

**邻接表**是图的一种链式存储结构。在邻接表中，对图中的每个顶点建立一个单链表，以顶点为头结点，依次链接该顶点的弧的表结点。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/邻接表的头结点和表结点.svg" alt="邻接表的头结点和表结点" style="zoom: 100%">

**邻接表的数据结构模型**如下：

```c
/* ---------- 图的邻接表存储 ---------- */
#define MAX_VERTEX_NUM 20

typedef struct ArcNode /* 顶点的单链表种，弧结点的结构体 */
{
    int adjvex;           // 该弧指向的顶点位置
    struct ArcNode *next; // 指向的下一条弧的指针
    InfoType *info;       // 该弧相关信息的指针
} ArcNode;

typedef struct VNode /* 表示顶点的结构体 */
{
    int data;          // 顶点信息
    ArcNode *firstArc; // 指向第一条依附该结点的弧的指针
} AdjList, AdjList[MAX_VERTEX_NUM];

typedef struct ALGraph /* 表示图的结构体 */
{
    AdjList vertices;   // 图的顶点列表
    int vexnum, arcnum; // 图的顶点数和弧数
    int kind;           // 图的种类标志
} ALGraph;
```

对于无向图来说，如果有 $\displaystyle n$ 个顶点、 $\displaystyle e$ 条边，则它的邻接表需要 $\displaystyle n$ 个顶点结点（头结点）和 $\displaystyle 2e$ 个弧结点（表结点）。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/邻接表和逆邻接表.png" alt="邻接表和逆邻接表" style="zoom: 100%">

- 在无向图的邻接表中，求顶点 $\displaystyle v_{i} $ 的**度**，只需要计算第 $\displaystyle i$ 个链表中的结点数。
- 在有向图中，求顶点 $\displaystyle v_{i} $ 的**出度**，和无向图求顶的的度一样，只需要计算第 $\displaystyle i$ 个链表中的结点数；但是求顶点 $\displaystyle v_{i} $ 的**入度**时，必须遍历整个邻接表。

为了便于确定**顶点的入度**或者**以某顶点为头的弧**，建立以和有向图的**逆邻接表**，即：对每个顶点 $\displaystyle v_{i} $ 建立一个链接以 $\displaystyle v_{i} $ 为头的弧结点的表。

> 在建立邻接表或者逆邻接表时，如果输入的顶点信息，就是顶点的编号，则建立邻接表的时间复杂度为 $\displaystyle O(n+e)$ ；否则，需要通过遍历查询，才能得到顶点在图中的位置，则时间复杂度为 $\displaystyle O(n\times e)$ 。

## 2.3 十字链表

**十字链表（Orthogonal List）**是有向图的另一种链式存储结构。_可以看成是将有向图的邻接表和逆邻接表组合起来得到的一种链表_。

在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/图的存储之十字链表.svg" alt="图的存储之十字链表.svg" style="zoom: 100%">

**十字链表的数据结构模型**如下：

```c
/* ---------- 十字链表 ---------- */
#define MAX_VERTEX_NUM 20
typedef struct InfoType
{
} InfoType;
typedef struct VertexType
{
} VertexType;
// =======================
typedef struct ArcBox /* 顶点的单链表种，弧结点的结构体 */
{
    int tailvex, headvex; // 该弧的尾和头顶点的位置
    struct ArcBox *hlink, *tlink;
    InfoType *info; // 该弧相关信息的指针
} ArcBox;
typedef struct VexNode
{
    VertexType data;
    ArcBox *firstin, *firstout; // 分别指向该顶点的第一条入弧和出弧
} VexNode;
typedef struct
{
    VexNode xLinst[MAX_VERTEX_NUM]; // 顶点列表
    int vexnum, arcnum;             // 有向图的定点数和弧数
} OLGraph;
```

有向图的十字链表的图示如下：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/有向图的十字链表.png" alt="有向图的十字链表" style="zoom: 100%">

## 2.4 邻接多重表

**邻接多重表**是无向图的另一种链式存储结构。

_虽然邻接表是无向图的一种很有效的存储额机构，在邻接表中容易求得顶点和边的各种信息。但是，在邻接表中每一条边，都存在两个结点，这给某些图的操作带来不便_。

邻接多重表的结构和十字链表类似。在邻接多重链表中，每一条边用一个结点表示，有 6 部分组成：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/邻接多重表.svg" alt="邻接多重表.svg" style="zoom: 100%">

**邻接多重表的数据结构模型**如下：

```c
/* ------------- 邻接多重表 -------------- */
typedef struct InfoType
{
    /* data */
} InfoType;
typedef struct VertexType
{
} VertexType;
// ===========================
#define MAX_VERTEX_NUM 20
typedef enum
{
    unisited = 0,
    visited = 1
} VisitIf;

typedef struct ArcEBox
{
    VisitIf mark;
    int ivex, jvex;                // 该边依附的两个顶点的位置
    struct ArcEBox *ilink, *jlink; // 分别指向依附这两个顶点的下一条边
    InfoType *info;                // 该边信息
} ArcEBox;
typedef struct VexBox
{
    VertexType data;
    ArcEBox *firstedge; // 指向第一条依附该顶点的边
} VexBox;
typedef struct
{
    VexBox adjmulist[MAX_VERTEX_NUM];
    int vexnum, arcnum; // 图的当前顶点数和边数
} AMLGraph;
```

得到的结构的图示如下：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/无向图的邻接多重表.png" alt="无向图的邻接多重表" style="zoom: 100%">

# 三、图的遍历

从图中某一顶点出发，访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做**图的遍历(Traversing Graph)**。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。

## 3.1 深度优先

**深度优先搜索(DFS)**遍历类似于树的先根遍历，是树的先根遍历的推广。

**DFS的搜索过程**：假设初始状态下，图的全部顶点都未曾访问过，然后随机挑选一个顶点，开始进行遍历访问；然后访问此顶点的某一个邻接顶点；然后在访问该邻接顶点的某一个邻接顶点，依次进行；**直至，最后访问的顶点已经没有邻接顶点或者没有未访问的邻接顶点**；然后，退回该路径中的上一个结点，**访问上一个结点的下一个未访问邻接点**，依次进行；直至，整个连通图访问完毕。如果有非连通图，接着选取非连通图的另一个子图的某一个顶点，继续按照上述过程进行。

> 最直观的例子就是“走迷宫”。假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。

显然，这是一个递归的过程。为了在遍历过程中，便于区分顶点是否已被访问，需要附设访问标志数组 `visited[0..n-1]` ，其初始值为 `"false"` ，一旦某个顶点被访问，择其相应的分量置为 `"true"` 。

深度优先搜索遍历的算法如下：（主要是针对非连通图）

~~~c
#include "stdio.h"

#define MAX 20
typedef enum Status
{
    ERROR = 0,
    OK = 1
} Status;
typedef enum Boolean
{
    false = 0,
    true = 1
} Boolean;

Boolean visited[MAX];       // 访问标志数组
Status (*VisitFunc)(int v); // 函数指针

int main()
{
    return 0;
}

/// 邻接矩阵--访问顶点操作
Status VisitFunc(int v)
{
    /* 函数指针，对图的顶点访问操作 */
    // 具体实现由用户定义，图的遍历操作调用该函数来访问顶点
}
/// 邻接矩阵--获取结点 v 的第一个邻接点
int FirstNeighbor(Graph G, int v)
{
    /* 获取结点 v 的第一个邻接点 */
    // 由于图的存储结构不同，该算法不同，依次不做具体实现
}
/// 邻接矩阵--获取结点 v 的第 w 个邻接点
int NextNeighbor(Graph G, int v, int w)
{
    /* 获取结点 v 的第 w 个邻接点的下一个邻接点 */
    // 由于图的存储结构不同，该算法不同，依次不做具体实现
}

/// 邻接矩阵--深度优先遍历
void DFSTranverse(Graph G, Status (*Visit)(int v))
{
    /* 对图 G 进行深度优先遍历 */
    for (int v = 0; v < G.vexnum; v++)
    {
        visited[v] = false; // 访问标志数组初始化
    }
    VisitFunc = Visit; // 使用全局变量VisitFunc，使DFS不必设函数指针参数
    for (int v = 0; v < G.vexnum; v++)
    {
        if (!visited[v])
        {
            DFS(G, v);
        }
    }
}

/// 递归算法--深度优先遍历
void DFS(Graph G, int v)
{
    visited[v] = true; // 访问标志数组置1
    VisitFunc(v);      // 访问第v个顶点
    for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
    {
        if (visited[w] = false)
        {
            DFS(G, w);
        }
    }
}


~~~



使用二维数组表示邻接矩阵，作为图的存储结构时，查找每个顶点的邻接点所需要的时间为 $\displaystyle O(n^{2} )$ ，其中 $\displaystyle n$ 为途中顶点数。

以邻接表作为图的存储结构时，找邻接点所需要的时间为 $\displaystyle O(e)$ ，其中， $\displaystyle e$ 为无向图中边的数量或者有向图中弧的数量，并且时间复杂度为 $\displaystyle O(n+e)$ 。



## 3.2 广度优先

**广度优先搜索(BFS)**遍历类似于树的按层次遍历。

**DFS的搜索过程**：假设初始状态下，图的全部顶点都未曾访问过，然后随机挑选一个顶点，开始进行遍历访问；然后依次访问该顶点的**未访问邻接点**；然后，再对刚刚访问的邻接点，因此进行 $\displaystyle \mathrm{BFS} $ 访问；直至整个图全部访问完毕。

~~~c
void BFSTranverse(Graph G, Status (*Visit)(int v))
{
    /* 对图 G 进行广度优先遍历 */
    for (int v = 0; v < G.vexnum; v++)
    {
        visited[v] = Boolean.false; // 访问标志数组初始化
    }
    InitQueue(Q); // 初始化辅助队列
    for (int v = 0; v < G.vexnum; v++)
    {
        if (visited[v] == Boolean.false)
        {
            visited[v] = Boolean.true;
            Visit(v);
            EnQueue(Q, v); // v 入队列
            while (!QueueEmpty(Q))
            {
                DeQueue(Q, v); // 队头元素出队并置为 v
                for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
                {
                    if (visited[w] == Boolean.false)
                    {
                        visited[w] = Boolean.true;
                        Visit(w);
                        EnQueue(Q, w);
                    }
                }
            }
        }
    }
}
~~~



# 四、图的连通性

## 4.1 无向图的连通分量和生成树

- 对于连通图的遍历，只需要从图中任一顶点出发；
- 对于非连通图的遍历，需要从图中的多个顶点出发；**一次遍历访问得到的顶点集合，恰好是图的连通分量**。

对于一个连通图来书，对它进行一次**深度优先**或者**广度优先**的遍历后，其访问的路径会形成一个**生成树**。并且称由深度优先搜索得到的为深度优先生成树；由广度优先搜索得到的为广度优先生成树。

对于非连通图，每个连通分量会形成一个**生成树**，并且这些**生成树**会构成一个**森林**。



## 4.2 有向图的强连通分量

【略】

## 4.3 最小生成树

问题：假设要在 $n$ 个城市之间建立通信网络，则连通 $n$ 个城市只需要 $n-1$ 条线路。这时，如何在最省经费的前提下建立这个通信网？



有 $n$ 个结点，这些结点之间任意连接构成**连通网**。而对于 $n$ 个结点的连通网，可以建立许多不同的生成树，每一棵生成树都可以是一个**连通网**。在这些连通网中，选出权值之和最小的。这个问题就是构造连通网的最小代价生成树（`Minimum Cost Spanning Tree`），简称**最小生成树**。**一棵生成树的代价就是树上各边的代价之和**。



**普利姆算法（Prim）**：假设 $\displaystyle N=(V,\left \{ E \right \} )$ 是连通网， $\displaystyle \mathrm{TE} $ 是 $\displaystyle \mathrm{N} $ 上最小生成树中边的集合。设定顶点集合 $\displaystyle \mathrm{U} $ 。

1. 在连通网中，首先找到**权**最小的边，并且将该边的两个顶点加入到 $\displaystyle \mathrm{U} $ 中去，并且将该边添加到 $\displaystyle \mathrm{TE} $ 中去；
2. 然后，在**依附于 $\displaystyle \mathrm{U} $ 中的顶点的边中，找到最短且不在 $\displaystyle \mathrm{TE} $ 中的一条边**，之后将新的顶点加入到 $\displaystyle \mathrm{U} $ 中去，将新的边加入到 $\displaystyle \mathrm{TE} $ 中去；（简单来讲，找到的边，一端是 $\displaystyle \mathrm{U} $ 集合中的顶点，一端不是 $\displaystyle \mathrm{U} $ 集合中的顶点；不能是两端都是 $\displaystyle \mathrm{U} $ 集合中的顶点；也不能是两端都不是 $\displaystyle \mathrm{U} $ 集合中的顶点）
3. 重复步骤（2），直至将全部的顶点都加入到 $\displaystyle \mathrm{U} $ 中；
4. 此时的 $\displaystyle T=(U,TE)$ 就是一个**最小生成树**。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/Prim最小生成树.png" alt="Prim最小生成树" style="zoom: 100%">

> `Prim` 算法的**时间复杂度为 $\displaystyle O(n^{2} )$**，与网中的边数无关，因此，**适用于求稠密的网的最小生成树**。



**克鲁斯卡尔算法（Kruskal）**：假设 $\displaystyle N=(V,\left \{ E \right \} )$ 是连通网，则令最小生成树的初始状态为：只有 $n$ 个顶点，没有边的非连通图 $\displaystyle T=(V,\left \{ \quad  \right \} )$ ，图中每个顶点自成一个连通分量。

1. 选择代价最小的一条边；
    1. 如果该边依附的顶点，落在 $\displaystyle T$ 中不同的连通分量上，则将次边加入到 $\displaystyle T$ 中；
    2. 反之，则舍弃，并且寻找下一条代价最小的边；
    3. （这样的选边方式，简单来讲，在同一个连通分量上的顶点之间的边，就舍弃）
2. 以此类推，直至 $\displaystyle T$ 上所有的顶点都在同一连通分量上。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/Kruskal最小生成树过程示例图.png" alt="Kruskal最小生成树过程示例图" style="zoom: 100%">



### 7.4.4 关节点和重连通分量

【略】



# 五、有向无环图及其应用

## 5.1 拓扑排序

什么是**拓扑排序**？简单地说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。

回顾离散数学中关于偏序和全序的定义：

- 若集合 $\displaystyle X$ 上的关系 $\displaystyle R$ 是**自反的**、**反对称的**和**传递的**，则称 $\displaystyle R$ 是集合 $\displaystyle X$ 上的**偏序关系**。
- 设 $\displaystyle R$ 是集合 $\displaystyle X$ 上的偏序，如果对每个 $\displaystyle x,y\in X$ 必有 $\displaystyle xRy$ 或 $\displaystyle yRx$ ，则称 $\displaystyle R$ 是集合 � 上的**全序关系**。
- 直观地看，偏序指集合中仅有部分成员之间可比较，而全序指集合中全体成员之间均可比较。

例如，下图所示的两个有向图，图中弧 $\displaystyle \left \langle x,y \right \rangle $ 表示 $\displaystyle x\le y$ ，则 `(a)`表示偏序， `(b)` 表示全序。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/表示偏序和全序的有向图.png" alt="表示偏序和全序的有向图" style="zoom: 100%">



若在`(a)`的有向图上人为地加一个表示 $\displaystyle v_{2} \le v_{3} $ 的弧，则 `(a)`表示的亦为全序，且这个全序称为**拓扑有序(Topological Order)**，而**由偏序定义得到拓扑有序的操作便是拓扑排序**。

**AOV-网**：用顶点表示活动，用弧表示活动之间优先关系的有向图，称为**顶点表示活动网（Activity On Vertex Network）**，简称**AOV-网**。

> 在**AOV-网**中不应该出现有向环，因为存在环意味着某项活动应该以自己为先决条件。



进行拓扑排序的方法：

1. 在有向图中选一个没有前驱的顶点，并且输出该顶点；
2. 从图中删除该顶点和所有以他为尾的弧；
3. 重复上述两步，直至全部顶点均已输出。**如果当前不存在无前驱的顶点，但是还有顶点给剩余时，说明图中有环**。



<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/AOV-网及其拓扑有序序列产生的过程.png" alt="AOV-网及其拓扑有序序列产生的过程" style="zoom: 100%">



针对上述两步操作，采用[邻接表](https://blog.yuilexi.cn/2023/04/29/大学学习/数据结构/数据结构_2/#邻接表)作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组(indegree)。入度为零的顶点，即为没有前驱的顶点，删除顶点及以它为尾的弧的操作，则可换以弧头顶点的入度减 1 来实现。

为了避免重复检测入度为零的顶点，可另设一栈暂存所有入度为零的顶点，由此，可得拓扑排序的算法如下：

~~~c
Status TopologicSort(ALGraph G)
{
    int i, k, count;
    int top = 0; // 用于栈指针下标
    int *stack;  // 建栈存储入度为0的顶点
    stack = (int *)malloc(G.vexnum * sizeof(int));
    for (i = 0; i < G.vexnum; i++)
    {
        if (G.vertices[i].in == 0)
        {
            stack[++top] = i; // 将入度为0的顶点入栈
        }
    }
    count = 0; // 对输出顶点计数
    while (top != 0)
    {
        i = stack[top--]; // 出栈
        printf("%d", i);  // 输出
        count++;          // 对输出顶点计数
        for (p = G.vertices[i].firstarc; p; p = p->nextarc)
        {
            k = p->adjvex; // 对i号顶点的每个邻接点的入度减1
            if (!(--G.vertices[k].in))
            {
                stack[++top] = k; // 若入度减为0，则入栈，以便于下次循环输出
            }
        }
    }
    if (count < G.vexnum)
    {
        return ERROR; // 该有向图有回路
    }
    else
    {
        return OK;
    }
}
~~~

分析算法：对有 $n$ 个顶点和 $e$ 条弧的有向图而言，建立求各顶点的入度的时间复杂度为 $\displaystyle O(e)$；建立零入度顶点栈的时间复杂度为 $\displaystyle O(n)$；在拓扑排序过中，若有向图无环，则每个顶点进一次栈，出一次栈，度减 1的操作在 `While` 语中总共执行 $e$ 次，所以，总的时间复杂度为 $\displaystyle O(n+e)$。



## 5.2 关键路径

与`AOV-网` 相对应是`AOE-网`(Activity On Edge)，即**边表示活动的网**。**AOE-网**是一个带权的有向无环图，其中，顶点表示事件(Event)，弧表示活动,权表示活动持续的时间。通常，**AOE-网可用来估算工程的完成时间**。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/一个简单的AOE-网.png" alt="一个简单的AOE-网" style="zoom: 100%">

上述的 `AOE-网` ，有 9 个事件、 11 个活动，并且从 �1 事件开始，期间经历相关的活动，并且最终到 �9 结束。

由于整个工程只有一个开始点和一个完成点，故在正常的情况（无环）下，网中只有一个入度为零的点（称做源点），和一个出度为零的点（叫做汇点）。

和AOV-网不同，对AOE-网有待研究的问题是：

1. 完成整项工程至少需要多少时间？
2. 哪些活动是影响工程进度的关键？



由于在 `AOE-网` 中，有些活动可以**并行地进行**，所以完成工程的最短时间是从开始点到完成点的最长路径的长度（这里所说的路径长度，是指路径上各活动持续时间之和，不是路径上孤的数目）。**路径长度最长的路径叫做 `关键路径` (Critical Path)**。

假设开始点是 $\displaystyle V_{1} $ ，从 $\displaystyle V_{1} $ 到 $\displaystyle V_{i} $ 的最长路径长度叫做事件 $\displaystyle V_{i} $ 的最早发生时间；这个时间决定了所有以 $\displaystyle V_{i} $ 为弧尾的弧，所表示的活动的最早开始时间。

**我们用 $\displaystyle e(i)$ 表示活动 $\displaystyle a_{i}$ 的最早开始时间。还可以定义一个活动的最迟开始时间 $\displaystyle l(i)$ ，这是在不推迟整个工程完成的前提下，活动 $\displaystyle a_{i}$ 最迟必须开始进行的时间**。两者之差 $\displaystyle l(i)-e(i)$ 意味着完成活动 $\displaystyle a_{i}$ 的时间（~~余量~~）裕量。我们把 $\displaystyle l(i)=e(i)$ 的活动叫做**关键活动**。

显然，关键路径上的所有活动都是关键活动。因此，提前完成非关键活动并不能加快工程的进度。因此，分析关键路径的目的是辨别哪些是关键活动，以便争取提高关活动的工作效率，缩短整个工期。



由上面的分析可知，辨别关键活动就是要找到 $\displaystyle l(i)=e(i)$ 的活动。为了求得 **AOE-网**中活动的 $\displaystyle e(i)$ 和 $\displaystyle l(i)$ ，首先应该求得时间 $\displaystyle ve(j)$ 和最早发生时间和最迟发生时间 $\displaystyle vl(j)$ 。如果活动由弧 $$ ，则有如下关系：
$$
\begin{align}\displaystyle e(i) & = ve(j)\\l(i)&=vl(k)-\mathrm{d}ut \end{align}
$$
由此，得到如下所述，求关键路径的算法：

1. 输入 $e$ 条弧 $\displaystyle \left \langle j,k \right \rangle $ ，建立 **AOE-网**的存储结构；
2. 从源点出发，
3. 从汇点出发，



# 六、最短路径

## 6.1 从某个源点到其余各顶点的最短路径





## 6.2 每一对顶点之间的最短路径



