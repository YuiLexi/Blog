---
title: 第二章 线性表【数据结构】
date: 2023-4-29 00:00:02
categories:
	- [大学学习, 考研]
	- [C语言, 数据结构]
tags: [C语言, 数据结构, 考研, 大学学习]
description: 数据结构(C语言版)学习笔记，包括线性表、栈、队列、串、树、图、查找、排序等内容。
mathjax: true
katex: true
imagehost_path: Blog/Post/01.计算机学习/02.计算机基础学习/02.数据结构/02.线性表.md/
---

# 前言

## 概括

线性结构的特点是：在数据元素的非空有限集中，

1. 存在唯一一个被称作“第一个”的数据元素；
2. 存在唯一一个被称为“最后一个”的数据元素；
3. 除第一个数据元素外，其余每个数据元素只有一个“前驱”元素；
4. 除最后一个元素外，每个元素只有一个“后继”元素。

# 一、线性表的类型定义

**线性表**是最常用的且最简单的一种数据结构。一个线性表是 $n$ 个数据元素的有限序列。例如：
$$
\displaystyle \left ( A,B,C,D,\cdots  \right )
$$

在复杂的线性表中，一个数据元素可以有若干个**数据项**组成。在这种情况下，常把数据元素称为**记录**，含有大量记录的线性表又称为**文件**。

线性表中元素的个数 $\displaystyle n(n\ge 0)$ 定义为线性表的**长度**， $\displaystyle n=0$ 时称为空表。在非空表中的每个数据元素都有一个确定的位置，如 $\displaystyle a_{1} $ 是第一个元素， $\displaystyle a_{n} $ 是最后一个数据元素， $\displaystyle a_{i} $ 是第 $\displaystyle i $ 个元素，称 $\displaystyle i $ 为数据元素 $\displaystyle a_{i} $ 在线性表中的**位序**。

抽象数据类型的线性表的定义如下：

```c
ADT List
{
    // 数据
    Data data; // 数据元素的集合
    Relation relation; // 集合中两两数据元素之间的关系

    //方法
    List InitList( &L ); // 构造一个空的线性表L，其地址为&L
    DestoryList( &L ); // 线性表L存在的前提下，销毁线性表L(释放内存)
    ClearList( &L ); // 线性表L存在的前提下，清空线性表L(不释放内存)
    ListEmpty( L ); // 线性表L存在的前提下，若L为空表，则返回TURE；反之，返回FALSE
    ListLength( L ); // 线性表L存在的前提下，返回L中数据元素的个数
    GetElem( L , i , &e ); // 线性表L存在，并且i不超过最大索引值。返回第 i 个元素，并且用地址&e接收
    LocationElem( L, e, compare()); // 返回L中第1个与e满足关系compare()的数据元素的位置。不存在则返回0
    PriorElem( L, cur_e, &pre_e); // 返回cur_e的前驱给&pre_e；否则操作失败，&pre_e无定义
    NextElem( L, cur_e, &next_e); // 返回cur_e的后继给&next_e；否则操作失败，&next_e无定义
    ListInsert( &L, i , e); // 在L中的第i个元素位置，插入元素e
    ListDelete( &L, i, &e); // 删除L中的第i个数据元素
    ListTraverse( L, visit()); // 依次对L的每个数据元素调用函数visit()
}
```

# 二、线性表的顺序表示和实现

## 2.1 顺序表的结构

**线性表的“顺序表示”指的是：用一组地址连续的存储单元，依次存储线性表的数据元素**。

假设线性表的每个元素需占用 $l$ 个存储单元，应以所占的第一个单元的存储地址作为数据元素的存储位置。则线性表中第 $i+1$ 个数据元素的存储位置为：

$$
\displaystyle Loc(a_{i+1}) = Loc(a_{i}) + l
$$

一般来说，线性表的第 $i$ 个数据元素 $\displaystyle a_{i} $ 的存储位置为：

$$
\displaystyle Loc( a_{i} ) = Loc(a_{1} ) + l\times (i-1)
$$

@**线性表的顺序存储结构的数据结构**如下：

```c
// ---------- 线性表的动态分配顺序存储结构 ----------
#define LIST_INIT_SIZE 100 // 线性表存储空间的初始分配量
#define LISTINCREMENT 10 // 线性表存储空间的分配增量
typedef struct
{
	ElemType *elem; // 存储空间基址
	int length; // 当前长度
	int listsize; // 当前分配的存储容量(以sizeof(ElemType)为单位)
}SqList;
```

由上述定义可知，线性表的顺序存储结构的特点是：

1. 数组的长度是固定的，需要事先定义；
2. 如果插入元素而导致空间不足，可进行再分配。

---

@线性表的动态分配顺序存储结构的初始化，其算法如下：

```c
// 算法2.3 线性表的动态分配顺序存储结构的初始化
Status InitList_Sq(SqList& L)
{
	// 构造一个空的线性表L
	L.elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));
	if (!L.elem) exit(OVERFLOW); // 存储分配失败
	L.length = 0; // 空表长度为0
	L.listsize = LIST_INIT_SIZE; // 初始存储容量
	return OK;
}// InitList_Sq
```

## 2.2 插入操作

**线性表的插入操作**：在线性表的第 $i-1$ 个数据元素和第 $i$ 个数据元素之间，插入一个新的数据元素，并且线性表的长度由 $n$ 变为 $n+1$ ，同时，原本第 $i$ 个元素至第 $n$ 个元素以此向后移一个位置。

**一般情况下，在第 $\displaystyle i(0\le i \le n)$ 个元素之前，插入一个元素时，需将第 $i$ 至第第 $n$ 元素（共第 $n-(i-1) = n-i+1$ 个元素）向后移动一个位置**。

@线性表的顺序存储结构的插入操作，其算法如下：

```c
// 算法2.4 线性表的顺序存储结构的插入操作
Status ListInsert_Sq(SqList& L, int i, ElemType e)
{
	// 在顺序线性表L中第i个位置之前插入新的元素e
	// i的合法值为 1 <= i <= ListLength_Sq(L)+1
	if (i<1 || i>L.length + 1) return ERROR; // i值不合法

	if (L.length >= L.listsize) // 当前存储空间已满,增加分配
	{
		ElemType *newbase = (ElemType *)realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(ElemType));
		if (!newbase) exit(OVERFLOW); // 存储分配失败
		L.elem = newbase; // 新基址
		L.listsize += LISTINCREMENT; // 增加存储容量
	}

	ElemType *q = &(L.elem[i - 1]); // q为插入位置
	for (ElemType *p = &(L.elem[L.length - 1]); p >= q; --p) // 插入位置及之后的元素右移
		*(p + 1) = *p;
	*q = e; // 插入e
	++L.length; // 表长增1
	return OK;
}// ListInsert_Sq
```

## 2.3 删除操作

线性表的删除操作，与插入操作相反。**一般情况下，删除第 $\displaystyle i(0\le i \le n)$ 个元素，需将第 $i+1$ 至第 $n$ 元素（共 $n-i$ 个元素）依次向前移动一个位置**。

@算法 2-5 ：顺序表的删除操作：

```c
// 算法2.5 线性表的顺序存储结构的删除操作
Status ListDelete_Sq(SqList& L, int i, ElemType& e)
{
	// 在顺序线性表L中删除第i个元素,并用e返回其值
	// i的合法值为 1 <= i <= ListLength_Sq(L)
	if (i<1 || i>L.length) return ERROR; // i值不合法
	
    ElemType *p = &(L.elem[i - 1]); // p为被删除元素的位置
	e = *p; // 被删除元素的值赋给e
	ElemType *q = L.elem + L.length - 1; // 表尾元素的位置
	for (p +=1 ; p <= q; ++p) // 被删除元素之后的元素左移
		*(p - 1) = *p;
	--L.length; // 表长减1
	return OK;
}// ListDelete_Sq
```

## 2.4 算法分析

假定在线性表中的，任何位置上的插入或者删除元素都是等概率的，那么在顺序存储结构的线性表中，插入或者删除一个数据元素，平均需要移动表中一半的元素。**时间复杂度为 $O(n)$ **。

# 三、线性表的链式表示和实现

## 3.1 线性链表

线性表的链式存储结构特点是：用一组“任意”的存储单元存储线性表的数据元素。除了存储本身外，还需要存储一个指示其直接后继的信息。这两部分信息组成的数据元素的存储映像，称为**结点**。它包含有两个域：

- 存储数据元素的域称为**数据域**
- 存储直接后继存储位置的域称为**指针域**

指针域中存储的信息称为**指针或链**。 $n$ 个结点链结成一个**链表**，即为线性表：

$$
\displaystyle (a_{1}, a_{2},\cdots ,a_{n})
$$

的**链式存储结构**。又有于此链表的每个节点中只包含一个指针域，故又称**线性链表**或**单链表**。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/2_线性表.md/单链表.svg" alt="单链表.svg" style="zoom: 100%">

整个链表的存取必须从**头指针**开始进行，头指针指示链表中第一个结点的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为“空”，即`NULL`。

有时，我们在单链表的第一个结点之前附设一个结点，称之为**头结点**。**头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等类的附加信息，头结点的指针域存储指向第一个元素结点的指针**。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/2_线性表.md/带头结点的单链表.svg" alt="带头结点的单链表.svg" style="zoom: 100%">

**单链表的数据结构**如下：

```c
// 单链表
typedef struct LNode
{
	ElemType data;      // 数据域
	struct LNode* next; // 指针域
} LNode, * LinkList;
```

> 在单链表中，取得第 $i$ 个元素，必须从头指针出发寻找，因此，**单链表是非随机存取的存储结构**。

@算法 2-8 ：获取单链表中，第 $i$ 个元素：

```c
// 算法2.8 获取单链表的第 i 个元素
Status GetElem_L(LinkList L, int i, ElemType& e)
{
	// L为带头结点的单链表的头指针
	// 当第i个元素存在时,其值赋给e并返回OK,否则返回ERROR
	LNode *p = L->next; // 初始化,p指向第一个结点,j为计数器
	int j = 1; // j为计数器
	while (p && j < i) // 顺指针向后查找,直到p指向第i个元素或p为空
	{
		p = p->next;
		j++;
	}
	if (!p || j > i) return ERROR; // 第i个元素不存在
	e = p->data; // 取第i个元素
	return OK;
}// GetElem_L
```

> 上述算法的基本操作是：比较 $i$ 与 $j$ 的值并后移指针，因此，**时间复杂度为 $O(n)$ **。

@算法 2-9 ：单链表的插入操作：

```c
// 算法2.9 单链表的插入操作
Status ListInsert_L(LinkList &L, int i, ElemType e)
{
	// 在带头结点的单链线性表L中第i个位置之前插入元素e
	// i的合法值为 1 <= i <= ListLength(L)+1
	LNode *p = L; // 初始化,p指向头结点,j为计数器
	int j = 0;
	while (p && j < i - 1) // 寻找第i-1个结点
	{
		p = p->next;
		++j;
	}
	if (!p || j > i - 1) return ERROR; // i小于1或者大于表长加1
	
    LNode *s = (LNode *)malloc(sizeof(LNode)); // 生成新结点
	s->data = e; // 插入L中
	s->next = p->next;
	p->next = s;
	return OK;
}// ListInsert_L
```

@算法 2-10 ：单链表的删除操作：

```c
// 算法2.10 单链表的删除操作
Status ListDelete_L(LinkList& L, int i, ElemType& e)
{
	// 在带头结点的单链线性表L中,删除第i个元素,并由e返回其值
	// i的合法值为 1 <= i <= ListLength(L)
	LNode *p = L; // 初始化,p指向头结点,j为计数器
	int j = 0;
	while (p->next && j < i - 1) // 寻找第i个结点,并令p指向其前趋
	{
		p = p->next;
		++j;
	}
	if (!(p->next) || j > i - 1) return ERROR; // 删除位置不合理
	LNode *q = p->next; // 删除并释放结点
	p->next = q->next;
	e = q->data;
	free(q);
	return OK;
}// ListDelete_L
```

> 在插入或者删除结点时，必须先找到对应的结点位置。**时间复杂度为 $O(n)$ **。

## 3.2 循环链表

**循环链表**是一种链表数据结构，与普通链表的不同之处在于**它的最后一个节点指向链表的第一个节点**。

- 优点：可以轻松地实现循环遍历操作；
- 缺点：比普通链表的操作要稍微复杂一些；
- 另外，循环链表也需要注意避免出现死循环的情况。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/2_线性表.md/循环链表.svg" alt="循环链表.svg" style="zoom: 100%">

循环链表的操作和线性链表基本一致，差别仅在于**算法中的循环条件不是 `p == NULL` 或者是 `P->next == NULL` ，而是是否等于头结点指针**。

## 3.3 双向链表

前面讨论的结点中只有一个**直接后记**的指针域，因此，从某个节点出发，只能顺指针往后巡查其它节点。为克服单链表这种单向性的缺点，可利用**双向链表**。

**双向链表**：在指针域使用两个指针，分别指向该元素结点的**直接前驱**和**直接后继**，而数据域不发生任何改变，这样的链表称为**双向链表**。

**双向链表的数据结构**如下：

```c
// ---------- 双向链表 ----------
typedef struct DuLNode
{
	ElemType data;
	struct DuLNode *prior; // 直接前驱指针
	struct DuLNode *next; // 直接后继指针
} DuLNode, *DuLinkList;
```

> 双向链表也可以有循环链表。

三种链表的优缺点：

- 单项链表和循环链表：只能进行**单向的遍历访问**，如果链表的长度很大，可能会遍历整个链表
- 双向链表：能够双向的进行遍历，不仅能知道**直接后继**，也能知道**直接前驱**。
- 双向链表：会**额外增加一部分内存**，以便于存放**指向直接前驱的指针**。

> 由于链表在空间的合理利用上，以及插入、删除时不需要移动等的优点，因此，在很多场合下，**链表是线性表的首选存储结构**。
>
> 然而，也存在着某些基本操作不如顺序存储结构的缺点。

# 四、一元多项式的表示及相加

**符号多项式的操作，已经成为表处理的典型应用**。在数学上，一个一元多项式 $\displaystyle P_{n} (x)$ 可按升幂写成：

$$
\displaystyle P_{n} (x) = p_{0} x^{0} +p_{1} x^{1} +p_{2} x^{2} +\cdots +p_{n} x^{n}
$$

它是由 $n+1$ 个系数唯一确定。因此在计算机里，它可以用一个线性表 $P$ 来表示：

$$
\displaystyle P_{n} = (p_{0}, p_{1},p_{2},\cdots ,p_{n})
$$

假设 $\displaystyle Q_{m} (x)$ 是一元 $m$ 次多项式，同样可用线性表 $Q$ 表示：

$$
\displaystyle Q_{n} = (q_{0}, q_{1},q_{2},\cdots ,q_{n})
$$

了不失一般性，设 $\displaystyle m< n$ ，则两个多项式相加的结果为可用线性表 $R$ 表示：

$$
\displaystyle \displaystyle R_{n} = (p_{0}+q_{0}, p_{01}+q_{01},p_{2}+q_{2},\cdots ,p_{m}+q_{m},p_{m+1},p_{m+2},\cdots ,p_{n})
$$

显然，我们可以对 $P,Q,R$ 采用顺序存储结构，使得多项式相加的算法定义的十分简单。然而，在通常的应用中，**多项式的次数可能很高且变化很大**，使得顺序存储结构的最大长度很难确定。例如下面形式：

$$
\displaystyle S(x) = 1+3x^{10000} +2x^{20000}
$$

如果用上述的线性表来表示，就要用一长度为 20001 的线性表，表中仅有三个非零元素，这种对存储空间的浪费时应当避免的。

因此，**使用链表只存储非零的幂项元素，链表结点的数据域包含两个元素，当前的系数以及幂指数**。

**运算规则如下**：假设指针 `qa` 和指针 `qb` 分别指向多项式 $A$ 和多项式 $B$ 中当前比较的某个结点，比较结点中的指数项，有三种情况：

1. 指针 `qa` 所指结点的指数值 < 指针 `qb` 所指结点的指数值，则应摘取 `qa` 指针所指结点插入到“**和多项式**”链表中去；
2. 指针 `qa` 所指结点的指数值 > 指针 `qb` 所指结点的指数值，则应摘取 `qb` 指针所指结点插入到“**和多项式**”链表中去；
3. 指针 `qa` 所指结点的指数值 = 指针 `qb` 所指结点的指数值，则将两个结点中的系数相加：
   - 若和数不为零，则修改 `qa` 所指结点的系数值，同时释放 `qb` 所指结点；
   - 反之，释放 `qa` 和 `qb` 所指结点；

**注意事项**：

1. 多项式的第一项元素的系数大于零，不需要添加 `+` ；
2. 多项式系数为 0 的项，不需要存储；
3. 多项式系数为 1 的项，不需要打印数字 `1` 。

@算法 2-22 ：建立多项式的数据结构模型：

```c
// ---------- 多项式相加 ----------
// 这是书本上的多项式相加的方法
typedef struct Node
{
	int coef; // 系数
	int exp;  // 指数
	struct Node* next;
} Node;

// 系数-指数
int LA[][2] = { {7, 0}, {3, 1}, {9, 8}, {5, 17} };
int LB[][2] = { {8, 1}, {22, 7}, {-9, 8}, {3, 16}, {5, 17}, {6, 18} };
//然后构造一个将多项式元素的数组转化为链表的方法。代码如下：
Node* changeToList(int data[][2], int row, int list)
{
	Node* head = (Node*)malloc(sizeof(Node)); // 创建头结点
	head->coef = 0;
	head->exp = -1;
	head->next = NULL;
	Node* current = head; // 当前结点
	for (int i = 0; i < row; i++)
	{
		Node* tmp = (Node*)malloc(sizeof(Node));
		tmp->coef = data[i][0];
		tmp->exp = data[i][1];
		tmp->next = NULL;
		current->next = tmp;
		current = current->next;
	}
	return head;
}
// 接着构造一个将链表打印成多项式的方法。代码如下：
void printNodeList(Node* head)
{
	Node* current = head->next;
	printf("多项式为: ");
	if (current == NULL)
	{
		printf("NULL");
	}
	else
	{
		printf("P(x)= ");
		switch (current->exp)
		{
		case 0:
		{
			printf("%d", current->coef);
			break;
		}
		case 1:
		{
			printf("%d*X", current->coef);
			break;
		}
		default:
		{
			printf("%d*X^%d", current->coef, current->exp);
			break;
		}
		}
		current = current->next;
	}
	while (current != NULL)
	{
		printf("+%d*X^%d", current->coef, current->exp);
		current = current->next;
	}
}
// 接着构造一个将两个多项式相加的方法。代码如下：
int main_add()
{
	Node* result, * P, * Q, * currentResult, * currentP, * currentQ;

	result = (Node*)malloc(sizeof(Node));
	result->coef = 0;
	result->exp = -1;
	result->next = NULL;

	P = changeToList(LA, 4, 2);
	Q = changeToList(LB, 6, 2);

	currentP = P->next;
	currentQ = Q->next;
	currentResult = result;

	while (currentP != NULL && currentQ != NULL)
	{
		if (currentP->exp < currentQ->exp)
		{
			currentResult->next = currentP;
			currentP = currentP->next;

			currentResult = currentResult->next;
			currentResult->next = NULL;
		}
		else if (currentP->exp > currentQ->exp)
		{
			currentResult->next = currentQ;
			currentQ = currentQ->next;

			currentResult = currentResult->next;
			currentResult->next = NULL;
		}
		else
		{
			currentP->coef += currentQ->coef;
			if (currentP->coef != 0)
			{
				currentResult->next = currentP;
				currentP = currentP->next;

				currentResult = currentResult->next;
				currentResult->next = NULL;

				Node* tmp = currentQ = currentQ;
				currentQ = currentQ->next;
				free(tmp);
			}
			else
			{
				Node* tmp = currentP;
				currentP = currentP->next;
				free(tmp);

				tmp = currentQ;
				currentQ = currentQ->next;
				free(tmp);
			}
		}
	}
	if (currentP != NULL)
	{
		currentResult->next = currentP;
	}
	if (currentQ != NULL)
	{
		currentResult->next = currentQ;
	}
	printNodeList(result);
	return 0;
}
```
