---
title: 第四章 串【数据结构】
date: 2023-4-29 00:00:04
categories:
	- [大学学习, 考研]
	- [C语言, 数据结构]
tags: [C语言, 数据结构, 考研, 大学学习]
description: 数据结构(C语言版)学习笔记，包括线性表、栈、队列、串、树、图、查找、排序等内容。
mathjax: true
katex: true
imagehost_path: Blog/Post/01.计算机学习/02.计算机基础学习/02.数据结构/04串.md/
---

# 前言

# 一、字符串的定义

**串**（或者字符串）是由零个或者多个字符组成的有限序列，一般记为：

$$
\displaystyle s = 'a_{1} a_{2}a_{3}\cdots a_{n}'(n\ge 0)
$$

其中， `s` 是串的名，用**单引号**括起来的字符序列是串的值。 串中字符的数目 $n$ 称为串的长度。零个字符的串称为**空串**，记作 $\displaystyle \phi $ 。

串中任意个连续的字符组成的子序列称为该串的**字串**。包含字串的串相应的称为**主串**。通常称字符在序列中的序号为该字符在串中的**位置**（索引位置从 0 开始）。

由**一个**或者**多个**空格组成的串称为**空格串**。

> 当且仅当两个串的长度相等，并且各个对应位置的字符都相等，称**两个串相等**。

串的抽象数据模型如下：

```伪c
ADT String{
    数据对象: D;
    数据关系: R;
    基本操作:
    StrAssign(&T, chars); // 生成一个值等于 chars 的串 T
    StrCopy(&T, S); // 由串 S 复制得串 T
    StrEmpty(S); // 如果 S 是空串，则返回 True；否则，返回 False
    StrCompare(S, T); // 如果 S > T ，则返回值 > 0；如果 S = T ，则返回值 = 0；如果 S < T ，则返回值 < 0；
    StrLength(S); // 返回 S 的元素个数，称为串的长度
    ClearString(&S); // 将 S 清空
    Concat(&T, S1, S2); // 用 T 返回由 S1 和 S2 连接而成的新串
    SubString(&Sub, S, pos, len); // 用 Sub 返回串 S 的第 pos 个字符起，长度为 len 的字串
    Index(S, T, pos); // 如果 S 字串存在和串 T 值相同的字串，则返回它在主串 S 中第 pos 个字符之后第一次出现的位置；否则函数值为 0
    Replace(&S, T, V); // 用 V 替换主串 S 中出现的所有与 T 相等的不重叠的字串
    StrInsert(&S, pos, T); // 在串 S 的第 pos 个字符之前插入串 T
    StrDelete(&S, pos, len); // 从串 S 中删除第 pos 个字符起长度为len的子串
    Destory(&S); // 串 S 被摧毁
}
```

# 二、串的表示和实现

## 2.1 定长顺序表存储表示

类似与线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。

在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组：

```c
#define MAXSTRLEN 255                         // 用户可在255以内定义最大串长
typedef unsigned char SString[MAXSTRLEN + 1]; // 0号单元存放串的长度
```

> 串的实际长度可在这预定义长度范围内随意，超过预定义长度的串值则被舍去，称之为**“截断”**。

1. 串连接 `Concat(&T, S1, S2)` ；

   ```c
   int Concat(SString &T, SString S1, SString S2)
   {
       if (S1[0] + S2[0] <= MAXSTRLEN) // 未截断
       {
           T[1..S1 [0]] = S1[1..S1 [0]];
           T[S1[0] + 1..S1 [0] + S2[0]] = S2[1..S2 [0]];
           T[0] = S1[0] + S2[0];
           return 0;
       }
       else if (S1[0] < MAXSTRLEN) // 截断 S2
       {
           T[1..S1 [0]] = S1[1..MAXSTRLEN - S2[0]];
           T[S1[0] + 1..MAXSTRLEN] = S2[1..MAXSTRLEN];
           T[0] = MAXSTRLEN;
           return 1;
       }
       else // 截断 S1, S2
       {
           T[0..MAXSTRLEN] = S1[0..MAXSTRLEN];
           return 1;
       }
   }
   ```

2. 求字串 `SubString(&Sub, S, pos, len)`；

   ```c
   int SubString(SString &Sub, SString S, int pos, int len)
   {
       if (pos < 1 || pos > S[0] || len < 0 || len > S[0] - pos + 1)
           return -1;
       Sub[1..len] = S[pos..pos + len - 1];
       Sub[0] = len;
       return 0;
   }
   ```

## 2.2 堆分配存储表示

字符串的结构为：

```c
typedef struct HString
{
    char *ch;
    int length;
} HString;
```

## 2.3 串的块链存储表示

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/4_串.md/串的块链存储结构.svg" alt="串的块链存储结构.svg" style="zoom: 30%">

为了便于进行串的操作，当以链表储存串值时，除头指针外，还可以附设一个尾指针，指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串的存储结构为**块链结构**。

**串的块链存储结构的数据结构**如下：

```c
// 块链结点类型定义
typedef struct Chunk
{
    char chunkChars[CHUNKSIZE]; // 字符数组
    struct Chunk *next;         // 指向下一个块的指针
} Chunk;
// 串的块链结构定义
typedef struct LString
{
    Chunk *head; // 串的头指针
    Chunk *tail; // 串的尾指针
    int curlen;  // 串的当前长度
} LString;
```

**存储密度**的概念：

$$
\displaystyle {\large \mathbb{\text{存储密度} =\frac{串值所占存储位}{实际分配的存储位} } }
$$

# 三、串的模式匹配算法

## 3.1 求子串位置的定位函数

**字串的定位操作通常称作串的模式匹配，是各种串处理系统中最重要的操作之一**。定位函数的算法如下：

```c
#include "stdio.h"

#define MAXSTRLEN 255                         // 用户可在255以内定义最大串长
typedef unsigned char SString[MAXSTRLEN + 1]; // 0号单元存放串的长度

int Index(SString S, SString T, int pos);

SString str = {10, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'};

int main()
{
    int a;
    SString t = {3, 'C', 'D', 'E'};
    a = Index(str, t, 1);
    printf("%d", a);
    return 0;
    // 结果是: 3
}

int Index(SString S, SString T, int pos)
{
    int index = pos; // 主串索引从pos开始
    int i = 1;       // 模式串从 1 开始匹配
    while (index <= S[0] && i <= T[0])
    {
        // 如果字符对应相等，则前往下一个字符位置
        if (S[index] == T[i])
        {
            ++index;
            ++i;
        }
        // 如果不相等，主串回到上一次（第一次）匹配字符的下一位置，重新匹配
        // 模式串从 1 开始，重新匹配
        else
        {
            index = index - i + 2; // index = index - (i - 1) + 1;
            i = 1;
        }
    }
    if (i > T[0]) // 匹配成功
    {
        return index - T[0];
    }
    else // 匹配失败
    {
        return 0;
    }
}
```

算法的基本思想是：从主串 S 的第 pos 个字符起和模式的第一个字符比较之，若相等，则继续逐个比较后续字符；否则，从主串的下一个字符起，再重新和模式的字符比较之。依次类推，直至模式 T 中的每个字符依次和主串 S 中的一个连续的字符序列相等，则称**匹配成功**，函数值为和模式 T 中第一个字符相等的字符，在主串 S 中的序号；否则称**匹配不成功**，函数值为零。

> - **算法的时间复杂度为： $\displaystyle O(n+m)$**；
> - **算法在坏的情况下，时间复杂度为：$\displaystyle O(n \times m)$**。

## 3.2 模式匹配的改进算法（KMP 算法）

这种改进算法是 `D.E.Knuth` 与 `VRPratt` 和 `JHMorris` 同时发现的,因此人们称它为**克努特一莫里斯一普拉特操作（简称为 KMP 算法）**。此算法可以在 `O(n+m)` 的时间数量级上完成串的模式匹配操作。

其改进在于：每当一趟匹配过程中出现字符比较不等时，不需回溯 `i` 指针，而是利用已经得到的“部分匹配”的结果，将模式向右“滑动”尽可能远的一段距离后，继续进行比较。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/4_串.md/KMP算法过程举例.png" alt="KMP算法过程举例" style="zoom: 150%">

现在讨论一般情况。假设主串为 $\displaystyle 'S_{0} S_{1} S_{2} \cdots S_{n-1} '$ ，模式串为 $\displaystyle 'P_{0} P_{1} P_{2} \cdots P_{m-1} '$ 。实现改进算法需要解决下列问题：**当匹配过程产生“失配”时，模式串“向右滑行”的距离需要多远？**

> 换句话说，当主串中位置 $i$ 字符与模式中位置 $j$ 字符“失配”时，主串中位置 $i$ 字符应与模式串中那个字符在比较？

假设，当与模式串中的位置 $j$ 个字符串进行比较时，发生了 “失配”，因此，能够得到下列关系：（即前 $j$ 个字符对应相等，匹配正确）

$$
\displaystyle 'S_{i-j} S_{i-j+1} \cdots S_{i-1} '= 'P_{0} P_{1} P_{2} \cdots P_{j-1} '
$$

并且，接下来应该将模式串向右滑动一段距离，即主串位置 $i$ 的字符与模式串中 $\displaystyle 'P_{0} P_{1} P_{2} \cdots P_{j-1} '$ 子串的某个字符进行比较。因此，假设“应当”与模式串中位置 $k$ 字符进行比较（显然，$\displaystyle k<j-1$，而“**满足比较**”的前提是：模式串中前 $k$ 个字符串与主串中位置 $i$ 字符之前的 $k$ 个字符串匹配成功，即：

$$
\displaystyle 'P_{0} P_{1} P_{2} \cdots P_{j-1} '='S_{i-k} S_{i-k+1} \cdots S_{i-1} '
$$

> 简单来讲，就是模式串中前 $j$ 个字符 $\displaystyle 'P_{0} P_{1} P_{2} \cdots P_{j-1} '$ 子串中，前 $k$ 个字符的子串与后 $k$ 个字符的子串能够**匹配成功**。
>
> 并且模式串向右滑动 $j-k$ 个字符，就满足“比较”的条件。

因此，构造一个数组，存储的是模式串每一个位置如果发生“失配”后，重新与主串比较的位置，即 $k$ 。令 $\displaystyle \mathrm{text}\left [ j \right ]  =k$ ，得：

$$
\displaystyle \mathrm{next}\left [ j \right ] = \left\{\begin{matrix}-1 & & j=0\\ 0 & & j=1\\ k & & 1< j< m-1\end{matrix}\right.
$$

例如：书本 `P80` 的模式串 `abcac` 的 `next` 数组为：

| $j$ | 位置 $j$ 之前的子串 |    子串开头开始 | 子串结尾开始   | $\displaystyle \mathrm{next}\left [ j \right ]$ |
| :-: | :-----------------: | --------------: | :------------- | ----------------------------------------------- |
|  0  |         空          |              空 | 空             | -1                                              |
|  1  |          a          |                 |                | 0                                               |
|  2  |         ab          |               a | b              | 0                                               |
|  3  |         abc         |           a, ab | bc, c          | 0                                               |
|  4  |        abca         | **a**, ab, abc, | bca, ca, **a** | 1                                               |

再举个 `ABAABCAC` 的例子：

| $j$ | 位置 $j$ 之前的子串 |                        子串开头开始 | 子串结尾开始                        | $\displaystyle \mathrm{next}\left [ j \right ]$ |
| :-: | :-----------------: | ----------------------------------: | :---------------------------------- | :---------------------------------------------: |
|  0  |         空          |                                  空 | 空                                  |                       -1                        |
|  1  |          A          |                                     |                                     |                        0                        |
|  2  |         AB          |                                   A | B                                   |                        0                        |
|  3  |         ABA         |                           **A**, AB | BA, **A**                           |                        1                        |
|  4  |        ABAA         |                      **A**, AB, ABA | BAA, AA, **A**                      |                        1                        |
|  5  |        ABAAB        |                A, **AB**, ABA, ABAA | BAAB, AAB, **AB**, B                |                        2                        |
|  6  |       ABAABC        |             A, AB, ABA, ABAA, ABAAB | BAABC, AABC, ABC, BC, C             |                        0                        |
|  7  |       ABAABCA       | **A**, AB, ABA, ABAA, ABAAB, ABAABC | BAABCA, AABCA, ABCA, BCA, CA, **A** |                        1                        |
