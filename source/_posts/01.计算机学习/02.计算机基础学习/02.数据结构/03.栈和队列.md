---
title: 第三章 栈和队列【数据结构】
date: 2023-4-29 00:00:03
categories:
	- [大学学习, 考研]
	- [C语言, 数据结构]
tags: [C语言, 数据结构, 考研, 大学学习]
description: 数据结构(C语言版)学习笔记，包括线性表、栈、队列、串、树、图、查找、排序等内容。
mathjax: true
katex: true
imagehost_path: Blog/Post/01.计算机学习/02.计算机基础学习/02.数据结构/03.栈和队列.md/
---

# 前言

# 一、栈

## 1.1 栈的定义

**栈**（Stack）是一种特殊的线性表，**它只能在表的一端进行插入和删除操作**，这一端被称为**栈顶（Top）**，另一端被称为**栈底（Bottom）**。栈的特点是“**先进后出**”（Last In First Out，LIFO），即**最后插入的元素最先被删除，而最先插入的元素最后被删除**。

> 象一下生活中的**羽毛球筒**，就是先放进去的在底部，最后才能拿出来；后放进去的在顶部，最先拿出来。

栈的抽象数据类型中包含一下方法：

1. `InitStack( &S )` ：构造一个空栈；
2. `DestoryStack( &S )` ：将栈 S 销毁；
3. `ClearStack( &S )` ：将栈 S 清空；
4. `StackEmpty( S )` ：如栈 S 为空，则返回 TURE；反之，则返回 FALSER；
5. `StackLength( S )` ：返回栈 S 的元素个数，即栈的长度；
6. `GetTop( S, &e )` ：返回栈顶的元素到 e
7. `Push( &S, e)` ：插入元素 e 为新的栈顶
8. `Pop( &S, &e)` ：删除 S 的栈顶元素，并用 e 返回其值
9. `StackTraverse( S, visit())` ：从栈底到栈顶依次对 S 的每个数据元素调用函数 `visit()` 。一旦`visit()` 失败，则操作失败。

## 1.2 栈的表示和实现

栈也有两种存储表示方法。

- 顺序栈，即栈的顺序存储结构，是利用一组地址连续的存储单元，依次存放自栈底到栈顶的数据元素，同时附设指针 `top` 指示栈顶的元素在顺序表中的元素位置。

   由于栈在使用过程中，所需要的最大空间的大小难以估计，因此，一般来说，在初始化设空栈时，不应限定栈的最大容量。一个合理的做法是：

  1. 先给栈分配一个基本容量；
  2. 在应用过程中，当栈的空间不够使用时再逐段扩大。

   **顺序栈的数据模型**如下：

  ```c
  #define STACK_INIT_SIZE = 100; // 存储空间初始分配量
  #define STACKINCREMENT = 10; // 存储空间分配增量，每一次扩充栈，都是以 10 个元素为单位
  // 数据域
  typedef struct
  {
      SElemType* base; // 栈底指针
      SElemType* top; // 栈顶指针
      int stacksize; // 栈的元素个数
  } SqStack;
  ```

   上面的**顺序栈**有以下关系：

  1. 当 `base == NULL` 时，栈不存在；
  2. 当 `base != NULL && base == top` 时，栈为空，此时`stacksize == 1` ；
  3. 指针 `top` 永远指向**栈顶的下一个元素位置**，其指向的位置随栈的变化而变化；
  4. 指针 `base` 永远指向栈底的位置，并且不会改变；

- 链栈，采用链式结构实现栈的表示和实现。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/栈顶指针和栈中元素之间的关系.svg" alt="栈顶指针和栈中元素之间的关系.svg" style="zoom: 100%">

# 二、栈的应用

## 2.1 数制转换

二进制、八进制、十六进制，这种进制都是 2 的倍数，因此在转换之间很简单。日常生活中，使用较多的是十进制，但是计算机常用的是二进制、十六进制，因此，**十进制数与其他进制数的转换是计算机实现计算的基本问题**。

其解决方法有很多，下面是一个简单的方法： $\displaystyle (1348)_{10} = (2504)_{8} $

$$
\begin{align}1348{\div} 8 &=168\cdots \cdots 4\\ 168{\div} 8 &=21\cdots \cdots 0\\ 21{\div} 8 &=2\cdots \cdots 5\\ 2{\div} 8 &=0\cdots \cdots 2\\ \end{align}
$$

就是不断用正数结果除以 8（对应的进制数），然后根据运算的先后顺序，从后往前输出对应的**余数**。

@算法 3-1 ：栈的应用：进制转换：

```c
// 算法 3-1 ：栈的应用——进制转换：十进制数 n 转换为 d 进制数
void conversion()
{
	SqStack s;
	int N;
	SElemType e;
	InitStack(&s); // 初始化空栈 s
	scanf("%d", &N); // 输入一个十进制数 N
	while (N)
	{
		Push(&s, N % 8); // N 除以 8 的余数进栈
		N = N / 8; // N 除以 8 的商作为新的 N
	}
	while (!StackEmpty(s))
	{
		Pop(&s, &e); // 弹出栈顶元素
		printf("%d", e); // 打印栈顶元素
	}
	printf("\n");
}
```

## 2.2 括号匹配

对于一个含有 `()` 、 `[]` 、 `{}` 的行运算表达式，由于添加了括号，会改变运算的顺序。

**括号匹配**：运算表达式中，括号都是成对出现的，并且允许嵌套。那么，针对嵌套的括号，当匹配到做括号时，就把它入栈，匹配到对应的右括号时，就出栈。

> 在算法中，每读入一个括号，如果是左括号就入栈；如果是右括号，则将栈顶元素出栈，并且比较二者的括号类型，括号类型不一致就是不合法的情况。

## 2.3 行编辑程序

当存在程序跳转语句的时候，就需要把当前指令地址进行入栈处理；当跳转语句结束后，就把栈中的指令地址弹出，使其能够**继续执行原来的逻辑顺序**。

假设用户输入的是：

```txt
whli##ilr#e(s# *s)
```

其中， `#` 代表删除键，那么最终结果为：

```txt
while( *s)
```

## 2.4 迷宫求解

求迷宫中一条从入口到出口的路径算法，可简单描述如下：

```伪c
do{
    若: 当前位置可通,
    则{
        将当前位置插入栈顶,
        若: 当前位置是出口位置, 则: 结束;
        否则: 切换当前位置的东邻方块为新的当前位置
    }
    否则{
        若: 栈不空，且栈顶位置尚有其他方向未经探索,
        	则: 设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一相邻快;
        若: 栈不空，但是栈顶位置的四周均不可通,
        	则{
                删除栈顶位置;
                若: 栈不空，则重新测试新的栈顶位置,
                	直至找到一个可通的相邻快或者出栈至栈空
            }
    }
}while(栈不为空)
```

## 2.5 表达式求值

要对一个算术表达式求值，首先要了解算术四则运算的规则。即：

1. 先乘除，后加减；
2. 从左到右；
3. 先括号内，在括号外；

> 任何一个表达式都是由**操作数**、**运算符**和**界限符**组成的，称之为**单词**。

为了实现优先算法，可以使用两个工作栈。一个称作 `OPTR` ，用以寄存运算符；另外一个称作 `OPND` ，用于寄存操作数或原运算结果。算法的基本思想是：

1. 首先，置操作数栈为空，表达式起始符 `#` ；
2. 依次读入表达式中的每个字符，
   1. 如果是操作数，则进 `OPND` 栈；
   2. 如果是运算符，则和 `OPTR` 栈的栈顶运算符比较优先权后，做出相应的操作；
3. 直至整个表达式求值完毕。

@算法 3-4 ：表达式求值（由书本的代码改进而来）

```c
OperandType EvaluateExpression()
{
    InitStack(OPTR);    Push(OPTR,'#');
    InitStack(OPND);
    C = getchar(); // 依次读取表达式的各各字符
    // 如果 C == '#' && GetTop(OPTR) == '#' 满足，就说明表达式的左右都已到达界限，该表达式解析完毕
    while( !(C == '#' && GetTop(OPTR) == '#'))
    {
        if(C == 数字)
        {
            Push(OPND, C);
            C = getchar();
        }
        else
        {
            switch(比较: GetTop(OPTR) 和 C )
            {
                case '<' : //  新的运算符优先级高，因此栈中的运算先不处理；但是无法知道后续运算的优先级，因此暂时将当前的运算符入栈
                    Push(OPTR, C);
                    C = getchar(); break;
                case '=' : // 要么匹配括号，要么表达式结束
                    Pop(OPTR, C);
                    C = getchar(); break;
                case '>' : // 新的运算符优先级低，就需要处理栈中高优先级的运算
                    Pop(OPTR, theta);
                    Pop(OPND, a);    Pop(OPND, b);
                    result = Operate(a, theta, b)
                    Push(OPND, result); break
            }
        }
    }
    return GetTop(OPND);
}
```

# 三、栈与递归的实现

栈还有一个重要应用是在程序设计语言上实现递归。一个直接调用自己或通过一系列的调用语句间接调用自己的函数，称作**递归函数**。

> 递归函数在实际中，应当避免使用，因为递归会占用大量的栈内存，使用不当会导致**爆栈**。

递归是程序设计中一个强有力的工具。其一、有很多数学函数是递归定义的，如阶乘函数：

$$
\displaystyle \mathrm{Fact}(n) \left\{\begin{matrix} 1 & n=0\\ n \cdot \mathrm{Fact}(n) & n> 0\end{matrix}\right.
$$

其二，有的数据结构，如二叉树、广义表等，由于结构本身固有的递归特性；其三，还有一类问题本身没有明显的递归结构，但是用递归求解比迭代求解更简单，如八皇后问题、`Hanoi` 塔问题等。

---

例题 3-2（ $n$ 阶 `Hanoi` 塔问题）：假设有 3 个分别命名为 X、Y 和 Z 的塔座，在塔座 X 上插有 n 个直径大小各不相同、依小到大编号为 $\displaystyle 1,2,\cdots ,n$ 的圆盘。现要求将 X 轴上的 n 个圆盘移至塔座 Z 上，并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：

- 每次只能移动一个圆盘；
- 圆盘可以插在 X、Y 和 Z 中的任一塔座上；
- 任何时刻都不能将一个较大的圆盘压在较小的圆盘之上；

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/汉诺塔实物模型.webp" alt="汉诺塔实物模型" style="zoom: 100%">

@算法 3-5 ：汉诺塔问题的递归步骤：

```c
// 汉诺塔问题。将n个盘子从A柱子移动到C柱子，其中B柱子作为辅助柱子
void Hanoi(int n, char Source, char Transfer, char Target)
{
    if (n == 1)
    {
        move(1, Source, Target)
    }
    else
    {
        Hanoi(n - 1, Source, Target, Transfer);
        move(n, Source, Target);
        Hanoi(n - 1, Transfer, Source, Target);
    }
}
void move(int n, char Source, char Target)
{
    printf("%c -> %c\n", Source, Target);
}
```

# 四、队列

## 4.1 队列的定义

和**栈**相反，**队列**是一种**先进后出**的线性表（`FIFO`），它只允许在表的一端进行插入，而在另一端删除元素。允许插入的一段叫做**队尾**，允许删除的一点则称为**队头**。

> 队列在程序设计中也经常出现。一个最经典的例子就是操作系统的**作业排队**。

队列的抽象数据类型中包含一下方法：

1. `InitQueue( &Q )` ：构造一个队列；
2. `DestoryQueue( &S )` ：将队列 S 销毁；
3. `ClearQueue( &S )` ：将队列 S 清空；
4. `QueueEmpty( S )` ：如队列 S 为空，则返回 TURE；反之，则返回 FALSER；
5. `QueuekLength( S )` ：返回队列 S 的元素个数，即队列的长度；
6. `GetHead( S, &e )` ：返回队头的元素给 e
7. `EnQueue( &S, e)` ：插入元素 e 为新的队尾元素
8. `DeQueue( &S, &e)` ：删除 S 的队头元素，并用 e 返回其值
9. `QueueTraverse( S, visit())` ：从栈底到栈顶依次对 S 的每个数据元素调用函数 `visit()` 。一旦`visit()` 失败，则操作失败。

**双端队列**是限定插入和删除操作在表的两端进行的线性表。尽管双端队列看起来似乎比栈和队列更灵活，但是实际上在应用程序中远不及栈和队列，故仅作了解即可。

## 4.2 链队列

用链表表示的队列简称**链队列**。**一个链队列，显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定**。

如下图所示：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/单链队列.svg" alt="单链队列.svg" style="zoom: 40%">

并且，当 `Q.front == Q.rear` 时，队列为空，如下如所示：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/单链空队列.svg" alt="单链空队列.svg" style="zoom: 100%">

---

**单链队列的数据结构**如下：

```c
// 构造队列元素结点的结构体
typedef struct QNode
{
    QElemType dataElem; // 队列中的数据元素
    struct QNode *next; // 指向队列中下一元素的指针
} QNode, *QueuePtr;

// 构造队列的队头和队尾的结构体
typedef struct LinkQueue
{
    QNode *frontPtr; // 队头指针
    QNode *rearPtr;  // 队尾指针
} LinkQueue;


/* ======================== 基本操作 =============================== */
int EnQueue(LinkQueue &Q, QElemType e)
{
    QNode *newNode = (QNode *)malloc(sizeof(QNode));
    if (!newNode)
        exit(-1);
    newNode->dataElem = e;
    newNode->next = NULL;
    Q.rearPtr->next = newNode;
    Q.rearPtr = newNode;
    return 0;
}
int DeQueue(LinkQueue &Q, QElemType &e)
{
    if (Q.frontPtr == Q.rearPtr)
        return -1;
    QNode *p = Q.frontPtr->next;
    e = p->dataElem;
    Q.frontPtr->next = p->next;
    if (Q.rearPtr == p)
        Q.rearPtr = Q.frontPtr;
    free(p);
    return 0;
}
```

## 4.3 循环队列

在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放队列从头到尾的元素之外，尚需附设两个指针 `front` 和 `rear` 分别知识队列头元素及队列尾元素的位置。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/队列的顺序存储结构.svg" alt="队列的顺序存储结构.svg" style="zoom: 100%">

假设当前为队列分配的最大空间为 6 ，则当队列处于**上图最后一个状态**时，不能再继续插入新的队尾元素，否则会出现数组越界而导致程序代码被破坏。

> 从上述分析可见，在 C 语言中，不能用动态分配的一维数组，来实现循环队列。如果用户的应用程序中设有循环队列，**则必须为它设定一个最大队列长度**，如果用户无法估计的最大程度，则宜采用链队列。

**循环队列**：一种巧妙的方法是，**将顺序队列臆造**成一个环状的空间。

**循环队列的数据结构**如下：

```c
#define MAXQSIZE 100 // 最大队列长度
// 循环队列的顺序存储结构
typedef struct
{
    QElemType *base; // 初始化的动态分配存储空间
    int front;       // 队列头指针，若队列不空，指向队列头元素
    int rear;        // 队列尾指针，若队列不空，指向队列尾元素的下一个位置
} SqQueue;

/* ------------ 循环队列的基本操作的算法描述 -------------- */

// 初始化一个空队列Q
int InitQueue(SqQueue Q)
{
    Q.base = (QElemType *)malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q.base)
        exit(-1);
    Q.front = Q.rear = 0;
    return 1;
}
// 获取队列长度
int QueueLength(SqQueue Q)
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}
void EnQueue(SqQueue Q, QElemType e)
{
    if ((Q.rear + 1) % MAXQSIZE == Q.front) // 队列满
        return;
    Q.base[Q.rear] = e;
    Q.rear = (Q.rear + 1) % MAXQSIZE;
}
void DeQueue(SqQueue Q, QElemType *e)
{
    if (Q.front == Q.rear) // 队列空
        return;
    *e = Q.base[Q.front];
    Q.front = (Q.front + 1) % MAXQSIZE;
}
```
