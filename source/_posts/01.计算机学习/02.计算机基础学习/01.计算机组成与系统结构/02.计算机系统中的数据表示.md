---
title: 第二章 计算机系统中的数据表示【计算机组成与系统结构】
date: 2023-9-5:00:00:02
categories:
  - [大学学习, 考研]
  - [计算机学习，计算机组成，计算机系统结构]
tags: [计算机学习, 大学学习, 考研, 计算机组成, 计算机系统结构]
description: 了解计算机体系结构和基本工作原理。
mathjax: true
katex: true
image_path: 计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/
---

# 前言

# 一、概述

## 1.1 数的进制及转换

常见的进位计数制有：**二进制**、**八进制**、**十进制**和**十六进制**。

1. 十进制：**十进制数的后面常用字母 D 表示**；
2. 二进制：**二进制数的后面常用字母 B 标记**；
3. 八进制：**八进制的后面常用字母 O 标记**；
4. 十六进制：**十六进制数的后面常用 H 标记**，也可以在数前面加前缀 “0x” 。

**任何一种进位计数制表示的数都可以写成按权展开的多项式之和**，即：
$$
\displaystyle N_{r} =\sum D_{i} \times r^{i}
$$
其中， $\displaystyle D_{i}$ 为该数制采用的基本数码， $\displaystyle r^{i} $ 是权， $r$ 是基数。

数值数据是表示数量多少和数值大小的数据，即在数轴上能找到其对应点的数据。各种数值数据在计算机中表示的形式称为**机器数**。机器数对应的实际数值称为数的**真值**。

---

十进制数转换成二进制之间的方法：

1. 十进制转换成二进制
2. 二进制转换成十进制

由于二进制数转换成十进制数，以及二进制、八进制、十六进制之间的转换过于简单，这里不做赘述。

## 1.2 无符号数与有符号数的定义

## 1.2 无符号数和有符号数的定义

|   类型   | 说明                                                         |
| :------: | ------------------------------------------------------------ |
| 无符号数 | 没有**正负号**的数，**数中的每一位均用来表示数值**。         |
| 有符号数 | 在数值位前面添加一位**符号位**，并且规定 0 为正号，1 为负号。 |

## 1.3 定点数与浮点数的定义

1. 定点数：

    在机器数表示中，约定小数点的位置固定不变，则称为**定点数**。包含：定整数（纯整数）和定点小数（纯小数）。

    ![定点数的结构示意图.svg](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/定点数的结构示意图.svg)

2. 浮点数：

    既可以是纯整数，也可以是纯小数，还可以是同时含有整数和小数的数据，其**小数点的位置是不固定**的，故称**浮点数**。基数为 2 的浮点数 $F$ 的表示为
    $$
    \displaystyle F = M\times 2^{E}
    $$
    其中，**$M$ 称为尾数， $E$ 称为阶码**。显然，**尾数的位数决定了浮点数的精度，阶码的大小决定了浮点数的大小**。

    ![浮点数的编码格式之一](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/1_绪论.md/浮点数的编码格式之一.svg)

# 二、定点数

## 2.1 原码

原码是机器数中最简单的一种表示形式，其符号位为 “0” 表示正数，符号位为 “1” 表示负数，**数值位即真值的绝对值**。

### 2.1.1 整数的原码

若整数用 $n$ 位二进制表示，则整数的原码的定义为：
$$
\displaystyle \left [  X \right ] _{\text{原码} } = \left\{\begin{matrix} X && 0\le X\le 2^{n-1} -1\\   && \\ 2^{n-1} -X &&-(2^{n-1} -1)\le X\le 0\end{matrix}\right.
$$


原码可用定义表示，也可用**符号位后面紧跟数的绝对值表示**，符号位总是在最高位。原码又称作**带符号的绝对值表示**，即在符号的后面跟着的就是该数据的绝对值。

**正数的原码就是其本身的二进制表示，并且在最高位添加一位符号位0**；**负数的原码是其本身绝对值的二进制表示，并且在最高位添加一位符号位 1** 。

### 2.1.2 小数的原码

若小数用 $n$ 位二进制表示，则小数的原码的定义为：
$$
\displaystyle \left [  X \right ] _{\text{原码} } = \left\{\begin{matrix} X && 0\le X\le 1-2^{-(n-1)} \\   && \\ 1 -X &&-(1-2^{-(n-1)} )\le X\le 0\end{matrix}\right.
$$
*值得注意的是，在计算机中小数点是隐含的，是不用出现的，上面编码中出现小数点是为了强调小数点的位置。在本书各章节中，所有编码中若出现小数点，其作用与此处相同，都仅仅是为了提示*。

> 小数的原码：“小数点”之后的部分，就是**小数绝对值的二进制表示**，而“小数点”之前是符号位：“0” -> 正数；“1” -> 负数。

### 2.1.3 原码的特点

1. **数值原码表示方法简单直观，但是加减运算很麻烦**；
2. **对于数值 “0” ，原码的表示方法不唯一**。 $\displaystyle \left [  0 \right ] _{\text{原码} } =0000,0000=1000,0000$ 。
3.  $n$ 位原码表示的范围：
    1. 纯整数： $\displaystyle -(2^{n-1} -1)\to (2^{n-1} -1)$ ；
    2. 纯小数： $\displaystyle -(1-2^{-(n-1)})\to (1-2^{-(n-1)})$ 。

## 2.2 补码

### 2.2.1 补数的概念*

在日常生活中，常会遇到补数的概念。例如，当前时钟指针指示在 “6” 点，欲使它指示 “3” 点，既可按顺时针方向将分针转 “9” 圈，也可按逆时针方向将分针转 3 圈，其结果是一致的。由于时钟的时针转一圈能指示 “12” 个小时，因此时钟指针两个方向转动产生的效果在数学上，称为**模 12 运算**，写作 `mod 12`。

将补数的概念用到计算机中，便出现了补码机器数。

### 2.2.2 补码的定义

1. 整数补码

    如果整数用 $n$ 位二进制表示，则整数的补码的定义为：
    $$
    \displaystyle \left [ X \right ] _{\text{补码} } =\left\{\begin{matrix} X && 0\le X\le 2^{n-1}-1 \\  && \\ 2^{n} +X && -2^{n-1}\le X\le -1\end{matrix}\right.
    $$

    - 对正数来说，补码与原码的定义完全一样；
    - 对负数而言，补码与原码是不同的：
        - 负数的**绝对值**用原码表示，然后包括符号位在内各位取反，再在最低位加 “1” ；
        - 负数用原码表示，然后**不包括符号位各位取反，再在最低位加 1** 。
        - 负数的**绝对值**用原码表示，然后从右往左搜索第一个 “1” ，第一个 “1” 及其右边保持不变，左边全部按位取反；

2. 小数补码

    如果小数用 $n$ 位二进制表示，则小数的补码的定义为：
    $$
    \displaystyle \left [ X \right ] _{\text{补码} } =\left\{\begin{matrix} X && 0\le X\le 1-2^{-(n-1)}  \\  && \\ 2 +X && -1\le X\le -2^{-(n-1)} \end{matrix}\right.
    $$
    对于负数纯小数，构成补码表示所采用的方法与整数一样。

### 2.2.3 补码的特点🦋

1.  $n$ 位补码表示的整数数值范围： $\displaystyle -2^{n-1}\to 2^{n-1}-1  $ ，小数数值范围： $\displaystyle -1\to 1-2^{-(n-1)} $ ；

2. **“0” 的表示是唯一的**。

3. **变形码**。

    前面的纯小数的补码定义，是按照**模2**的形式；当**模数为4**时，可形成**双符号位补码**。即：
    $$
    \begin{align}\displaystyle \text{非负数} &= 00.x_{1}  x_{2} \cdots x_{n} \\\displaystyle \text{负数} &= 11.x_{1}  x_{2} \cdots x_{n} \end{align}
    $$

4. **求补运算**。

    许多处理器中设置有求补指令，**其功能是对操作数取负数（即正数变负数，负数变正数）**。

5. **简化加减法**。

    **补码的加法运算规则**：
    $$
    \displaystyle \left [ X+Y \right ] _{\text{补码} } = \left [ X \right ] _{\text{补码} }  +\left [ Y \right ] _{\text{补码} }
    $$
    并且减法运算也可以用加法实现，即：
    $$
    \displaystyle \left [ \left [ X\right ] _{\text{补码} }  \right ] _{\text{求补} } = \left [ -X \right ] _{\text{补码} }
    $$
    这样，在运算器中就可以不设置**减法器**，从而简化了运算器的结构。

6. **算术或逻辑左移**

    对补码表示的数值做算术右移一位（即编码各位依次向右移动一位，最低位移出，最高位保持原符号不变）

> 对于 8 位二进制补码来说，其编码从 `0000,0000` 到 `1111,1111` ，其对应的真值为 `0，1，2，..., 127, -128, -127,..., -1` 。



## 2.3 反码*

**反码通常用作来作为原码求补码或者补码求原码的中间过渡**。

### 2.3.1 反码的定义

1. 整数反码的定义为：
    $$
    \displaystyle \left [ X \right ] _{\text{反码} } =\left\{\begin{matrix} X && 0\le X\le 2^{n-1}-1 \\  && \\ (2^{n}-1)+X && -(2^{n-1}-1)\le X\le 0\end{matrix}\right.
    $$

    1. 正整数的反码表示与原码及补码相同。
    2. 对于一个负数，
        - 可直接利上式来获得；
        - 或者，将负数绝对值相同的正数原码（包括符号位）各位取反获得；
        - 或者，利用该负数的原码**保持符号位不变**，其余各位取反来获得；

2. 小数反码的定义：
    $$
    \displaystyle \left [ X \right ] _{\text{反码} } =\left\{\begin{matrix} X && 0\le X\le 1-2^{-(n-1)}  \\  && \\ (2-2^{-(n-1)})+X && -(1-2^{-(n-1)} )\le  X\le 0\end{matrix}\right.
    $$

### 2.3.2 反码的特点

1. **“0” 的表示不唯一**。
2. 负数反码与补码的关系。
3.  $n$ 位反码表示的整数数值范围： $\displaystyle -(2^{n-1}-1)\to (2^{n-1}-1)  $ ，小数数值范围： $\displaystyle -(1-2^{-(n-1)})\to (1-2^{-(n-1)}) $ 。



## 2.4 移码

### 2.4.1 移码的由来*

*当真值用补码表示时，由于符号位和数值部分一起编码，与习惯上的表示法不同，因此人们很难从补码的形式上直接判断其真值的大小*。

*例如：十进制数`X=+31`，对应的二进制数为`+11111`，若用8位表示，则`[X]=00011111`；十进制数`X=-31`，对应的二进制数为`-11111`，若用8位表示，则`[X]补=11100001` 。在原来补码表示的编码基础上再加上一个偏移量，就构成了新的编码，即移码。*

### 2.4.2 移码的定义

由于移码多用于浮点数中表示阶码，均为整数，因此这里只介绍定点整数的移码表示。当用包括符号位在内的 $n$ 位字长时，整数移码的定义为：
$$
\begin{array}{c}\displaystyle \left [ X \right ] _{\text{移码} } = 2^{n-1}+X && (-2^{n-1} \le X\le 2^{n-1})\end{array}
$$
要获得整数的移码表示，可以利用定义计算，也可以**先求出该数的补码后将符号位取反**。

### 2.4.3 移码的特点

1. 移码就是在其真值上加一个常数 $\displaystyle 2^{n-1}$ 。

2. **真值 “0” 的表示方法唯一**。

3. 移码与补码的关系：

    移码符号位取反补码[�]移码⟷符号位取反[�]补码

4. 移码码值的大小反映了数值的大小，正数移码的码值一定大于负数移码的码值。

> 对于 8 位二进制**移码**来说，其编码从 `0000,0000` 到 `1111,1111` ，其对应的真值为 `-128, -127, ..., -1, 0，1，2，..., 127` 。

## 2.5 不同编码的比较

不同编码的总结：(以8位有符号数为例)

|                     |               原码                |         补码         |               反码                |         移码         |
| :-----------------: | :-------------------------------: | :------------------: | :-------------------------------: | :------------------: |
|       0的表示       | 不唯一<br/>(0000,0000和1000,0000) | 唯一<br/>(0000,0000) | 不唯一<br/>(0000,0000和1000,0000) | 唯一<br/>(1000,0000) |
| 0000,0000表示的元素 |                +0                 |          0           |                +0                 |         -256         |
|      0111,1111      |                255                |         255          |                255                |          -1          |
|      1000,0000      |                -0                 |         -256         |               -255                |          0           |
|      1111,1111      |               -255                |          -1          |                -0                 |         255          |

# 三、浮点数

## 3.1 浮点数的表示方法

例如，二进制 $\displaystyle F=11.0101$ ，使用浮点数可以表示为以下不同的形态：
$$
\displaystyle F=11.0101 = 0.110101\times 2^{010} =1.10101\times 2^{001}
$$
其中，尾数与阶码均用**二进制**表示，**基数用十进制表示**。

### 3.1.1 浮点数的编码

浮点数的编码规则如下：

1. 尾数 $M$ 必须为小数，用 $n+1$ 位有符号定点小数表示；
2. **阶码 $E$ 必须为整数**，用 $k+1$ 位有符号定点整数表示。
3. 因此，**浮点数编码位数为 $\displaystyle m = (n+1)+(k+1) = n+k+2$**。

浮点数的编码格式不止一种。下面是其中一种常用的编码格式：

![浮点数的编码格式_2](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/浮点数的编码格式_2.svg)

需要强调的是：

1. **阶码是整数**，其**位数决定浮点数的数值范围**，也就决定了数据的大小。**阶符决定阶码的正负**。
2. **尾数是小数**，其**位数决定浮点数的精度**。
3. **尾数的符号表示浮点数的正负**。

### 3.1.2 非规格化浮点数

当对尾数 $M$ 只要求是小数而无其他限制时，此时的浮点数被称为**非规格化浮点数**。

| 阶码和尾数 |         最小值          |          最大值           |
| :--------: | :---------------------: | :-----------------------: |
|    阶码    | $\displaystyle -2^{k} $ | $\displaystyle 2^{k} -1$  |
| 尾数（负） |   $\displaystyle -1$    | $\displaystyle -2^{-n} $  |
| 尾数（正） | $\displaystyle 2^{-n} $ | $\displaystyle 1-2^{-n} $ |



因为非规格化浮点数的尾数可以为“0”，也就是非规格化浮点数可以为“0”，因此非规格化浮点数范围为：

![非规格化浮点数的数值范围](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/非规格化浮点数的数值范围.png)

### 3.1.3 规格化浮点数

规格化浮点数，就是将尾数的绝对值限定在规定的数值范围内，即 $\displaystyle \frac{1}{2} \le \left | M \right | < 1$ 。如果尾数用**补码**表示，那么，则当 $\displaystyle M\ge 0$ 时，规格化尾数的形式必须为：
$$
\displaystyle \left [ X \right ] _{\text{补码} } = 0.1x_{2} x_{3} \cdots x_{n}
$$
其中， “X” 是任意二进制值。当 $\displaystyle M< 0$ 时，规格化尾数的形式必须为：
$$
\displaystyle \left [ X \right ] _{\text{补码} } = 1.0x_{2} x_{3} \cdots x_{n}
$$
**根据规格化浮点数的定义，可以得到规格化尾数的数值范围**：

|   尾数   |          最小数值           |                最大数值                 |
| :------: | :-------------------------: | :-------------------------------------: |
| 尾数负值 |     $\displaystyle -1$      | $\displaystyle -(\frac{1}{2} +2^{-n} )$ |
| 尾数正值 | $\displaystyle \frac{1}{2}$ |       $\displaystyle (1-2^{-n} )$       |

> 一旦浮点数的位数确定后，不同的阶码和尾数位数划分，将直接影响浮点数的表示范围和精度，所以需要合理分配阶码和尾数的位数。利用数值的浮点数表示，可实现用有限字长的二进制编码表示更大的数值范围。

### 3.1.4 规格化处理

 浮点数在运算前和运算后，若其尾数不是规格化数，就要通过修改阶码，并同时左右移动尾数使其变成规格化数。将非规格化数转换成规格化数的过程叫作**规格化**。

当尾数 $M$ 用二进制补码编码，规格化时，尾数左移 “1” 位，阶码减 “1” ，这种规格化叫作**向左规格化**，简称**左规**；尾数右移 “1” 位，阶码加 “1” ，这种规格化叫作**向右规格化**，简称**右规**。

### 3.1.5 定点数和浮点数的对比

1. 当浮点计算机和定点计算机中数据的位数相同时，浮点数的表示范围比定点数大得多；
2. 当浮点数为规格化数时，其精度比相同位数的定点数高；
3. **浮点运算步骤比定点运算步骤多，运算速度比定点低，运算电路比定点复杂**；
4. 在溢出的判断方法上，浮点数对规格化数的阶码进行判断，而定点数对数值本身进行判断。

## 3.2 IEEE754标准🥩🥩

|               参 数               |             单精度浮点数              |              双精度浮点数               |             双精度扩展浮点数              |
| :-------------------------------: | :-----------------------------------: | :-------------------------------------: | :---------------------------------------: |
|          浮点数长度/bit           |                  32                   |                   64                    |                    80                     |
|  尾数长度 $\displaystyle p$/bit   |                  23                   |                   52                    |                    64                     |
|             符号位 s              |                   1                   |                    1                    |                     1                     |
|         指数 e 的长度/bit         |                   8                   |                   11                    |                    15                     |
| 最大指数 $\displaystyle E_{max} $ |                 +127                  |                 +1,023                  |                  +16,383                  |
| 最小指数 $\displaystyle E_{min} $ |               **-126**                |                 -1,022                  |                  -16,382                  |
|            指数偏移量             |               **+127**                |                 +1,023                  |                  +16,383                  |
|         可表示的实数范围          | $\displaystyle 10^{-38}\to 10^{+38} $ | $\displaystyle 10^{-308}\to 10^{+308} $ | $\displaystyle 10^{-4932}\to 10^{+4932} $ |

### 3.2.1 单精度浮点数

IEEE754 标准规定，单精度浮点数的真值一般表示为：
$$
\displaystyle N = (-1)^{s} \times 2^{e-127} \times 1.f
$$
其**编码格式由三个字段构成**：数符 $s$ 为 1 位，阶码编码 $e$ 为8位（含1位阶符），尾数编码 $f$ 为 23 位。

![IEEE754单精度浮点数的编码格式](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/IEEE754单精度浮点数的编码格式.svg)

需要注意的是：

1. **阶码采用移码**，但单精度浮点数来说，移码的偏移量不是 $\displaystyle 2^{7} =128$ ，而是 $\displaystyle 2^{7}-1 =127$ ，这是因为 IEEE754 将移码编码的“**全 0**” 和“**全 1**” 作为了特殊标识；
2. 浮点数是规格化数，为了能够更多地表示尾数的有效数位，规定尾数真值的整数部分必须为 “1” ，尾数编码时整数 “1” 隐去，小数部分 $f$ 用**原码**表示。

| 单精度格式位模式                                         | IEEE浮点数的值                                               |
| :------------------------------------------------------- | :----------------------------------------------------------- |
| $\displaystyle 0< e< 255$                                | $\displaystyle N = (-1)^{s} \times 2^{e-127} \times 1.f\quad (\text{正规数} )$ |
| $\displaystyle e=0,f\ne 0(f\text{中至少有一位不等于0} )$ | $\displaystyle N = (-1)^{s} \times 2^{-126} \times 0.f\quad (\text{次规数} )$ |
| $\displaystyle e=0,f=0(f\text{所有位都等于0} )$          | $\displaystyle N = (-1)^{s} \quad (\text{有符号的零} )$      |
| $\displaystyle s=0,e=255,f=0$                            | $\displaystyle +INF$ 正无穷大                                |
| $\displaystyle s=1,e=255,f=0$                            | $\displaystyle -INF$ 负无穷大                                |
| $\displaystyle s=u,e=255,f\ne 0$                         | $\displaystyle NaN$ 非数值                                   |

### 3.2.2 双精度浮点数

对双精度浮点数的说明：

1. 阶码真值 $E$ 的取值范围为 −1022 ——> +1023 ，将其偏移 +1023 ，即得编码 $e$ ，编码值为 +1 ——> +2046 ;

2. 双精度浮点规格化数表示为
    $$
    \displaystyle N = (-1)^{s} \times 2^{e-127} \times 1.f
    $$

3. 所能表示的规格化数范围：

    1. 正数为：；
    2. 负数为：；

4. 当 $e=0$ 或 $e=2047$ 时，在 `IEEE754` 标准中表示特殊的数。

# 四、BCD码🍉🍉

**计算机中，采用 4 位二进制编码来表示 1 位十进制数，这种编码称为 BCD 码**。但是，4 位二进制有 16 中编码，而十进制数有 10 个数字符。因此，**BCD 码有多种形式，使用最多的就是 8421 码**。

| 8421BCD码 | 十进制数 |
| :-------: | :------: |
|   0000    |    0     |
|   0001    |    1     |
|   0010    |    2     |
|   0011    |    3     |
|   0100    |    4     |
|   0101    |    5     |
|   0110    |    6     |
|   0111    |    7     |
|   1000    |    8     |
|   1001    |    9     |

# 五、非数值数据

现代计算机，不仅要处理数值领域的问题，而且还要处理大量的非数值领域问题。

## 5.1 ASCII 码

目前，国际上普遍采用的一种字符系统是 **ASCII 码**。包含 10 个十进制数码，26 个英文字母的大小写，一定数量的专用符号及控制命令等 128 个元素，用 **7 位二进制编码表示**。如果加一个奇偶校验位，则共 8 位，用**一字节**表示。

| 校验位 | 高3位 | 高3位 | 高3位 | 低四位 | 低四位 | 低四位 | 低四位 |
| :----: | :---: | :---: | :---: | :----: | :----: | :----: | :----: |
|   D7   |  D6   |  D5   |  D4   |   D3   |   D2   |   D1   |   D0   |

**ASCII 编码表**

|      | 000  | 001  | 010  |  011  |  100  | 101  |  110  | 111  |      |
| :--: | :--: | :--: | :--: | :---: | :---: | :--: | :---: | :--: | ---- |
| 0000 | NUL  | DLE  |  SP  | **0** |   @   |  P   |   `   |  p   |      |
| 0001 | SOH  | DC1  |  !   |   1   | **A** |  Q   | **a** |  q   |      |
| 0010 | STX  | DC2  |  “   |   2   |   B   |  R   |   b   |  r   |      |
| 0011 | ETX  | DC3  |  #   |   3   |   C   |  S   |   c   |  s   |      |
| 0100 | EOT  | DC4  |  $   |   4   |   D   |  T   |   d   |  t   |      |
| 0101 | ENQ  | NAK  |  %   |   5   |   E   |  U   |   e   |  u   |      |
| 0110 | ACK  | SYN  |  &   |   6   |   F   |  V   |   f   |  v   |      |
| 0111 | BEL  | ETB  |  ‘   |   7   |   G   |  W   |   g   |  w   |      |
| 1000 |  BS  | CAN  |  (   |   8   |   H   |  X   |   h   |  x   |      |
| 1001 |  HT  |  EM  |  )   |   9   |   I   |  Y   |   i   |  y   |      |
| 1010 |  LF  | SUB  |  *   |   :   |   J   |  Z   |   j   |  z   |      |
| 1011 |  VT  | ESC  |  +   |   ;   |   K   |  [   |   k   |  {   |      |
| 1100 |  FF  |  FS  |  ,   |   <   |   L   |  \   |   l   |  \   |      |
| 1101 |  CR  |  GS  |  -   |   =   |   M   |  ]   |   m   |  }   |      |
| 1110 |  SO  |  RS  |  .   |   >   |   N   |  ^   |   n   |  ~   |      |
| 1111 |  SI  |  US  |  /   |   ?   |   O   |  _   |   o   | DEL  |      |

**字符串**是指连续的一串字符。通常方式下，它们占用主存中连续的多个字节单元，每个字节单元存储一个字符。

当**主存字**由“2”个或“4”个字节组成时，在同一个主存字中，既可按从低位字节向高位字节的顺序存放字符串内容，也可按从高位字节向低位字节的顺序存放字符串内容。这两种存放方式都是常用方式。

## 5.2 汉字编码

| 序号 |     名称      |    年份    |  字符数   |               字节编码               | 内容                                                         |
| :--: | :-----------: | :--------: | :-------: | :----------------------------------: | ------------------------------------------------------------ |
|  1   |  GB 2312-80   |   1980年   |   7445    |              两字节编码              | 常用汉字3755个，次常用汉字3008个，共6763个汉字；以及俄文字母、日语假名、拉丁字母、希腊字母、汉语拼音、一般符号、数字等共682个非汉字符号，加在一起共7445个字符。 |
|  2   |      GBK      | 1995年12月 | 21003+883 |              两字节编码              | 收录汉字21003个，符号883个，并提供1894个造字码位，简、繁体字融于一库。 |
|  3   | GB 18030—2005 |   2005年   |  70244+   | 变长，采用单字节、双字节、四字节编码 | 收录汉字 70244 个，同时还收录了藏文、蒙古文、维吾尔文等主要的少数民族文字 |

为了使汉字信息交换有一个通用的标准，1980 年我国制定了国家标准 **GB 2312—80**：《信息交换用汉字编码字符集基本集》。在该标准中，挑选了常用汉字 3755 个，次常用汉字 3008 个，共 6763 个汉字，以及俄文字母、日语假名、拉丁字母、希腊字母、汉语拼音、一般符号、数字等共 682 个非汉字符号，加在一起共 7445 个字符，以两字节编码。**GB 2312**也收录了英文字母和数字等符号，并且**仍然以两字节编码**，于是 GB 2312 中的英文字母和数字等就成了我们平常所说的**全角符号**，而 ASCII 码的符号就叫作**半角符号**。

1995年12月我国发布了中文编码扩展国家标准 **GBK**，完全兼容 GB 2312-80，并且支持国际标准 ISO10646-1 中的全部中日韩汉字，全部字符可以一一映射到 Unicode 2.0 。GBK 是双字节编码，共收录汉字 21003 个，符号 883 个，并提供 1894 个造字码位，简、繁体字融于一库。

2000 年我国发布了**GB18030—2000**：《信息技术信息交换用汉字编码字符集基本集的扩充》，之后又于 2005 年发布了修订版 GB18030—2005 ：《信息技术中文编码字符集》。 GB 18030与 GBK 、GB2312 完全兼容，编码是变长的，采用单字节、双字节、四字节编码。 GB 18030—2005 收录了 Unicode 中的全部汉字，共收录汉字 70244 个，同时还收录了藏文、蒙古文、维吾尔文等主要的少数民族文字，为推动少数民族的信息化奠定了基础。

## 5.3 UniCode与UTF-8

为了统一表示世界各国的文字，1993年国际标准化组织公布了国际标准 `ISO/IEC 10646`，简称 `UCS` 。这一标准为包括汉字在内的各种正在使用的文字规定了统一的编码方案，因此又称为 Unicode。

**Unicode 的基本思路是给每一个字符和符号分配一个永久的、唯一的16位值，称为码点(Code Point)**。

*Unicode 支持的字符足够多了，但在发明之后的初期难以推广使用。原因在于 Unicode 用两个或者三个字节表示一个字符，而 ASCII 码用一个字节表示一个字符，对于 连续的两个字节或三个字节，计算机如何知道这是一个Unicode 字符，还是两个或三个 ASCII 字符?此外，对于英文字母构成的文件来说，用 Unicode 表示时，每个字母要用两 个或者三个字节表示(虽然前面的一个或两个字节都为0)，这样文件尺寸会增大为两倍或者三倍，是一种浪费*。

*为此又设计出了 Unicode 字符集的编码方案，如 UTF-8、UCS-2、UTF-16、UCS-4 和UTF-32, 其中最常用的是UTF-8*。

**UTF-8 以“8”位一个字节为单位，是一种可变长度的编码**。它将 Unicode 的码点编码为1～4个字，其编码方案如下：

| 字符码点范围      | 位数 | 字节1     | 字节2     | 字节3     | 字节4     |
| ----------------- | :--: | --------- | --------- | --------- | --------- |
| U+0000～U+007F    |  7   | 0XXX,XXXX |           |           |           |
| U+0080～U+07FF    |  11  | 110X,XXXX | 10XX,XXXX |           |           |
| U+0800～U+FFFF    |  16  | 1110,XXXX | 10XX,XXXX | 10XX,XXXX |           |
| U+10000～U+10FFFF |  21  | 1111,0XXX | 10XX,XXXX | 10XX,XXXX | 10XX,XXXX |

UTF-8 的优点在于：**编码 0～127 分配给了ASCII 码，并且用一个字节表示**，因此纯 ASCI 码的字符串也是 UTF-8 的合法字符串，两者一致，这样原先以 ASCII 码存储的文件或处理 ASCI 码的程序，不用改动即可兼容UTF-8；

UTF-8 编码中的第一个字节指明了这个字符一共有几个字节。

- 若第一个字节最高位是 “0”，则该字符只有一个字节；
- 若第一个字节最高位是 “1”，则有几个连续 “1” 就表明该字符有几个字节。

后面的字节都以 “10” 开头， 这样在传输或存储中出错时，很容易跳过出错字节，直接找到下一个字符的起始字节，即**拥有自同步能力**。当前， UTF-8 在互联网上被广泛使用。

# 六、检错与纠错

## 6.1 码距与校验位位数

假设数据有 $n$ 位，**为了具备检错或纠错能力，必须增添 $k$ 位校验位**，则数据加校验位一共有 $m=n+k$ 位，称为 **$m$ 位码字**。

任意两个 $m$ 位的码字，其对应位不同的数目，称为**这两个码字的海明码距**。计算公式为：
$$
\displaystyle d = \left | X-Y \right | =\sum_{i=1}^{m}X_{i} \oplus  Y_{i} 
$$
**对于 $n$ 位数据，所有的 $\displaystyle 2^{n} $ 个编码都是合法编码。而增加 $k$ 位校验位变成 $m=n+k$ 位的码字后，在 $\displaystyle 2^{n} $ 个码字中，仍然只有 $\displaystyle 2^{n} $ 个码字是合法的。在这 $\displaystyle 2^{n} $ 个合法码字之间，两两码字之间海明码距的最小值 $\displaystyle d_{\mathrm{min} } $ ，称为这种编码的海明码距**。

**编码的检错与纠错能力取决于其海明码距 $\displaystyle d_{\mathrm{min} } $ **：

- 如果要检测 $r$ 位错，则编码的码距 $d$ 至少应为 $r+1$ ，使得一个合法码字的 $r$ 位出错时不会成为另一个合法码字。
- 要纠正 $r$ 位错，则编码的码距 $d$ 至少应为 $2r+1$ ，使得一个合法码字 $r$ 位出错时，得到的新码字与原合法码字的**码距**(大小为r)，一定比它与其他合法码字间的**码距**（大于等于 $r+1$ ）要小。因此，只要选取与该错误码字码距最小的合法码字作为正确的码字，就实现了纠错。

满足一位纠错能力的条件：
$$
\displaystyle 2^{k} \ge n+k+1
$$
**数据长度与校验位位数的关系**：

|    n    | $\displaystyle k_{min} $ |
| :-----: | :----------------------: |
|    1    |            2             |
|  2～4   |            3             |
|  5～11  |            4             |
| 12～26  |            5             |
| 27～57  |            6             |
| 58～120 |            7             |

## 6.2 奇偶校验码

### 6.2.1 奇校验


$\displaystyle n$ 位的数据 $\displaystyle X=x_{0} x_{1} x_{2} \cdots x_{n-1} $ ，在最高位添加一位奇校验位 $\displaystyle c$ ，则完整的**码字**为 $\displaystyle X{}' =cx_{0} x_{1} x_{2} \cdots x_{n-1} $ 。奇校验定义为：
$$
\displaystyle c\oplus x_{0} \oplus x_{1} \oplus x_{2}\oplus  \cdots \oplus x_{n-1} =0
$$

> 之所以称为奇校验，是因为必须保证数据（包括奇校验位在内）的 $n+1$ 位中“1”的个数为奇数。

### 6.2.2 偶检验

偶校验的概念与奇校验是一样的，就是加上偶校验后，必须保证数据（包括偶校验位在内）的 $n+1$ 位中“1”的个数为偶数，即必须保证：
$$
\displaystyle c\oplus x_{0} \oplus x_{1} \oplus x_{2}\oplus  \cdots \oplus x_{n-1} =1
$$

## 6.3 海明校验码🌋🌋

### 6.3.1 海明码的编码

假设，有效信息为 16 位数据，用 $\displaystyle D_{15} \gets D_{0} $ ，表示由高到低的各位。若要纠正 1 位错误，需要在有效信息中添加 5 个校验位 $\displaystyle H_{4} \gets H_{0} $ 。 **此时海明码的码长为**： $\displaystyle m=21$ 。

| 位置 |          校验          |          数据           | $\displaystyle P_{0} /H_{0} $ | $\displaystyle P_{1} /H_{1} $ | $\displaystyle P_{2} /H_{2} $ | $\displaystyle P_{3} /H_{3} $ | $\displaystyle P_{4} /H_{4} $ |
| :--: | :--------------------: | :---------------------: | :---------------------------: | :---------------------------: | :---------------------------: | :---------------------------: | :---------------------------: |
|  1   | $\displaystyle H_{0} $ |                         |               ✅               |                               |                               |                               |                               |
|  2   | $\displaystyle H_{1} $ |                         |                               |               ☑️               |                               |                               |                               |
|  3   |                        | $\displaystyle D_{0} $  |               ✅               |               ☑️               |                               |                               |                               |
|  4   | $\displaystyle H_{2} $ |                         |                               |                               |               ✅               |                               |                               |
|  5   |                        | $\displaystyle D_{1} $  |               ✅               |                               |               ✅               |                               |                               |
|  6   |                        | $\displaystyle D_{2} $  |                               |               ☑️               |               ✅               |                               |                               |
|  7   |                        | $\displaystyle D_{3} $  |               ✅               |               ☑️               |               ✅               |                               |                               |
|  8   | $\displaystyle H_{3} $ |                         |                               |                               |                               |               ☑️               |                               |
|  9   |                        | $\displaystyle D_{4} $  |               ✅               |                               |                               |               ☑️               |                               |
|  10  |                        | $\displaystyle D_{5} $  |                               |               ☑️               |                               |               ☑️               |                               |
|  11  |                        | $\displaystyle D_{6} $  |               ✅               |               ☑️               |                               |               ☑️               |                               |
|  12  |                        | $\displaystyle D_{7} $  |                               |                               |               ✅               |               ☑️               |                               |
|  13  |                        | $\displaystyle D_{8} $  |               ✅               |                               |               ✅               |               ☑️               |                               |
|  14  |                        | $\displaystyle D_{9} $  |                               |               ☑️               |               ✅               |               ☑️               |                               |
|  15  |                        | $\displaystyle D_{10} $ |               ✅               |               ☑️               |               ✅               |               ☑️               |                               |
|  16  | $\displaystyle H_{4} $ |                         |                               |                               |                               |                               |               ✅               |
|  17  |                        | $\displaystyle D_{11} $ |               ✅               |                               |                               |                               |               ✅               |
|  18  |                        | $\displaystyle D_{12} $ |                               |               ☑️               |                               |                               |               ✅               |
|  19  |                        | $\displaystyle D_{13} $ |               ✅               |               ☑️               |                               |                               |               ✅               |
|  20  |                        | $\displaystyle D_{14} $ |                               |                               |               ✅               |                               |               ✅               |
|  21  |                        | $\displaystyle D_{15} $ |               ✅               |                               |               ✅               |                               |               ✅               |

### 6.3.2 海明码的校验

1. 构建生成方程；

    根据上述内容进行构建。

2. 构成海明码；

3. 构建校验方程：**当获得一个海明码时，使用校验方程来判断该编码的正确性**。

    1. 如果读取或接收的海明码正确，则**各校验方程的计算结果应为全“0”**；
    2. 若计算结果不为全“0”，则 $\displaystyle P_{4} P_{3} P_{2} P_{1} P_{0} $ 的**编码值的无符号真值**，就是海明码出错位的位置编号。

### 6.3.3 海明码的纠错

根据校验方程即可直接确定海明码是否有错或者出错位置编号。知道出错位置，对该位求反，就实现了纠错。所以海明码也被称作**纠错码**，**具有纠正一位错误的能力**。

### 6.3.4 单纠错双检错码

**观察海明码的生成方程可以发现，每一个数据位至少出现在两个生成方程中，即被两个校验位校验**。因此当一个数据位变化时，至少有两个校验位也随之变化，这意味着两个合法码字之间的码距至少为3。

实际上，当 $\displaystyle n=8,k=4$ 时，海明码的码距就是3，**它可以纠正1位错误，或者发现2位错误而不纠正**。那么同时纠正1位错误，以及发现2位错误呢，就需要进一步扩大码距。

方案是：增加一个所有数据位异或得到的校验位（即偶校验）。如果该校验位校验错误，表示可能有1位错误（实际上说明有奇数位错误）；进一步根据 $\displaystyle P_{3} P_{2} P_{1} P_{0} $ ，具体确定错误位的位置，并纠错。反之，如果该校验位校验正确，且 $\displaystyle P_{3} P_{2} P_{1} P_{0} $ 不是全零，则表示有2位错误（实际上为偶数位错误），只给出校验错误信息，不纠错，这就是半导体存储器中常用的**单纠错双检错(Single-Error- Correcting, Double-Error-Detecting, SEC-DED)码**。

## 6.4 循环冗余校验码

**循环冗余校验(Cyclic Redundancy Check, CRC)码**可以发现并纠正信息在存储或传送过程中出现的错误。

### 6.4.1 “模2”运算

- 模2加法：按位加，不考虑进位。

    0+0=0，0+1=1，1+0=1，1+1=0

- 模 2 减法：按位减，不考虑借位。

     0-0=0，0-1=1，1-0=1，1-1=0

> 模2减法与模2加法运算结果相同，因此可用模2加法代替模2减法。

- 模2乘法：按模2加求部分积之和，不考虑进位。
- 模2除法：按模2减求部分余数，不借位，每求一位商应使部分余数减少一位。求商的规则是：余数首位为“1”商取“1”，余数首位为“0”商取“0”。当余数位数小于除数位数时，即为最后的余数。
    1. 如果被除数的首位为 “1”，那么商的第一位为 “1”；如果被除数的首位为 “0”，那么商的第一位为 “0”；
    2. 被除数与除数进行**模2减法**（相减时，高位对齐，即左对齐，除数低位补 “0”），得到余数；
    3. 余数舍去首位（最高位）；如果余数的新首位为 “1”，那么商的第一位为 “1”；如果余数的新首位为 “0”，那么商的第二位为 “0”；
    4. 余数与除数进行**模2减法**（相减时，高位对齐，即左对齐，除数低位补“0”），得到余数；
    5. 重复（3）到（5）；
    6. 如果余数舍去首位后的位数小于除数，那么运算结束，最后剩余的余数就是最终的余数；

### 6.4.2 CRC 码的编码

设 $n$ 位数据为 $\displaystyle D_{n-1}\sim D_{0}  $ ， $k+1$ 位生成码为 $\displaystyle G_{k}\sim G_{0}  $ ，则构成的**CRC码**的码长为 $m=n+k$ ，其中包含 $k$ 位校验位。

1. 二进制数据用多项式表示。

    将 $n$ 位数据用多项式 $\displaystyle M(x)$ 表示为：
    $$
    \displaystyle M(x) = D_{n-1} x^{n-1} +D_{n-2} x^{n-2} +\dots +D_{0} x^{0} 
    $$
     $k+1$ 位生成码用多项式 $\displaystyle G(x)$ 表示为：
    $$
    \displaystyle G(x)=G_{k} x^{k} +G_{k-1} x^{k-1} +\cdots +G_{0} x^{0}
    $$

2. 数据做左移 $k$ 位操作。

    数据左移 $k$ 位，相当于多项式 $\displaystyle M(x)$ 做乘以 $\displaystyle x^{k} $ 的操作，即得 $\displaystyle M(x)\cdot x^{k} $ ，其 $n+k$ 位的二进制编码如下图所示

3. 求余数。

    用 $\displaystyle M(x)\cdot x^{k} $ 对生成多项式 $\displaystyle G(x)$ 作**模2除法**，求余数多项式 $\displaystyle R(x)$ ，即
    $$
    \displaystyle \frac{M(x)\cdot x^{k} }{G(x)} = Q(x)+\frac{R(x)}{G(x)}  
    $$
    其中， $Q(x)$ 为商的多项式，余数 $R(x)$ 的二进制编码为 $k$ 位。

    > 在此强调，除法过程必须按照**模2运算**规则计算。

4. 构成**CRC码**。

    将余数作为校验位，用（2）中获得的待编信息码的多项式 $\displaystyle M(x)\cdot x^{k} $ 与余数 $R(x)$ 作“模2加法”，构成**CRC码**多项式 $\displaystyle C(x)$ ：
    $$
    \displaystyle C(x) = M(x)\cdot x^{k} +R(x) = Q(x)\cdot G(x)
    $$
    **CRC码**的编码格式如图所示：

    ![CRC码的编码格式](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/2/CRC码的编码格式.png)

所以，**CRC码**是用多项式 $\displaystyle M(x)\cdot x^{k} $ 除以生成多项式 $\displaystyle G(x)$ （即生成校验位的多项式）所得余数作为校验位的。为了得到 $k$ 位余数（校验位），生成码必须是 $k+1$ 位的。

### 6.4.4 CRC码的校验

根据前面知识可得：
$$
\displaystyle C(x) = M(x)\cdot x^{k} +R(x) = Q(x)\cdot G(x)
$$
也即“CRC码”是一个可被生成码除尽的数码。如果CRC码在存储或传输过程中不出错，则 $\displaystyle C(x)$ 除以 $\displaystyle G(x) $ 的余数必为“0”。如果CRC码出错，则余数不为“0”，利用余数编码与错误位的对应关系（需要在设计CRC码时确定），就可以指出哪一位出错。

### 6.4.5 CRC码的纠错

1. 方法一：如果已设计好余数和出错位的对应关系，则通过查表的方法即可确定CRC码的出错位，对出错位求反即可纠正。

2. 方法二：如果CRC码有一位出错，则用 $\displaystyle G(x) $ 做“模2除法”，将得到一个不为0的余数。如果对余数补0继续除下去，将发现各次所得余数将出现循环。

    比如“位置1”出错，其余数为“001”；补0后再除，第二次余数为“010”；以后依次为100、011、......反复循环，这就是**循环码**的由来。

    这个特点正好用来纠错，即当出现不为零的余数后，

    - 一方面对余数补0，继续做模2除法，
    - 另一方面将被检测的CRC码字**循环左移**。当出现余数为 101 （最高出错位对应的余数）时，出错位也移到了位置7（最高位）。可通过异或门将它纠正后，再在下一次移位时送回位。