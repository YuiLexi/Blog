---
title: C语言基础
date: 2023-4-26 00:00:01
categories:
  - [C语言]
tags: [C语言基础,程序设计,编程语言,嵌入式,指针,数据结构,算法,数据分析]
description: 涵盖了C语言的基础知识，包括C语言的基本语法、指针、数据结构、算法等。

imghost_path: Blog/Post/01.计算机学习/01.计算机语言学习/02.C/01.C语言基础语法.md/

swiper_index: 9997
---



# 第一章 认识 C 语言

# 前言

# 第一章 认识 C 语言

C 语言是一种通用的、面向过程式的计算机程序设计语言。

## 1.1 C 语言的历史

C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。

在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&R 标准。

UNIX 操作系统，C 编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。

- 易于学习。
- 结构化语言。
- 它产生高效率的程序。
- 它可以处理底层的活动。
- 它可以在多种计算机平台上编译。

## 1.2 C 语言的作用

语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：

- 操作系统
- 语言编译器
- 汇编器
- 文本编辑器
- 打印机
- 网络驱动器
- 现代程序
- 数据库
- 语言解释器
- 实体工具

## 1.3 环境设置

如果您想要设置 C 语言环境，您需要确保电脑上有以下两款可用的软件：文本编辑器和 C 编译器。

## 1.4 算法

程序 = 数据结构 + 算法

# 第二章 C 语言基础

## 2.1 C 语言程序结构

一个完整的 C 语言代码文件，至少包含两部分：头文件和主函数。

```C
#include<stido.h>
int Main()
{
    printf("Hello , world!");	
    return 0;
}
```

- 头文件：里面定义了 C 语言常用的常量，以及一些函数
- 主函数：是 C 语言代码文件的入口，主程序所运行的源文件必须包含主函数

例如，下面完整代码：

```C
//预处理命令，（1）导入头文件；（2）宏定义；
#include<stdio.h>
#include"XXX.h"
#define datetype int

//全局变量区

//主函数
int main()
{
    return 0;
}
//自定义函数区
void Add(int a,int b)
{
    return 0;
}
```

## 2.2 注释

在代码中添加的标注行文字，从而帮助程序员更好的阅读代码。注释的内容将被编译器忽略，并不会在执行结果种体现出来。

在 C 语言中，主要有两种注释方式：单行注释和多行注释。

1. 单行注释

   语法如下：

   ```C
   //我是注释君
   ```

   

2. 多行注释

   语法如下：

   ```C
   /*
   	我是注释
   */
   ```

   在限定符之间的所有内容均是注释。

## 2.3 头文件和宏定义

### 2.3.1 头文件

头文件是扩展名为 **.h** 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。

在程序中要使用头文件，需要使用 C 预处理指令 **#include** 来引用它。前面我们已经看过 **stdio.h** 头文件，它是编译器自带的头文件。

引用头文件有两种方式：

```C
#including<file>
#include "file"
```

上述两种引用头文件的方式用法不同。

- 使用 <> ：程序会从标准头文件目录中，搜索对应的头文件。因此，一般引用系统头文件，采用这种方式
- 使用引号：程序先从当前目录中，搜索对应的头文件。因此，自定义的头文件会采用这种方式。

### 2.3.2 宏定义

宏定义又称为宏替换、宏代换，简称“宏”，是 C 提供的三种预处理功能的其中一种。其主要目的是为程序员在编程时提供一定的方便，并能在一定程度上提高程序的运行效率。

 \#define 命令是 C 语言中的一个宏定义命令，它用来讲一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。该命令有两种格式：一种是简单的宏定义（不带参数的宏定义），另一种是带参数的宏定义。

 基本语法如下：

```C
#define <宏名/标识符> <字符串>

#define <宏名>(<参数表>) <字符串>
```

 无参的宏定义：

- 宏名一般用大写，宏定义末尾**不加分号**
- 可以用 #undef 命令终止宏定义的作用域
- 宏定义可以嵌套，<内容>中永远不要包含宏
- 宏替换在编译前进行，不分配内存，变量定义分配内存，函数调用在编译后程序运行时进行，并且分配内存
- 预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查
- 使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义

 有参的宏定义：

- 实参如果是表达式容易出问题
- 宏名和参数的括号间不能有空格
- 宏替换之作替换不做计算，不做表达式求解
- 宏的哑实结合不存在类型，也没有类型转换
- 宏展开不占用运行时间，只占用编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）

## 2.4 关键字和标识符

### 2.4.1 关键字

关键字是 C 语言中已经被赋予特定含义的一些单词，开发程序时，不可以把这些保留字作为变量、函数、类、模块和其他对象的名称来使用。

|  关键字  | 说明                                                          |  关键字  | 说明                                       |
| :------: | :------------------------------------------------------------ | :------: | :----------------------------------------- |
|   auto   | 声明自动变量                                                  |   int    | 声明整型变量或函数                         |
|  break   | 跳出当前循环                                                  |   long   | 声明长整型变量或函数返回值类型             |
|   case   | 开关语句分支                                                  | register | 声明寄存器变量                             |
|   char   | 声明字符型变量或函数返回值类型                                |  return  | 子程序返回语句（可以带参数，也可不带参数） |
|  const   | 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 |  short   | 声明短整型变量或函数                       |
| continue | 结束当前循环，开始下一轮循环                                  |  signed  | 声明有符号类型变量或函数                   |
| default  | 开关语句中的"其它"分支                                        |  sizeof  | 计算数据类型或变量长度（即所占字节数）     |
|    do    | 循环语句的循环体                                              |  static  | 声明静态变量                               |
|  double  | 声明双精度浮点型变量或函数返回值类型                          |  struct  | 声明结构体类型                             |
|   else   | 条件语句否定分支（与 if 连用）                                |  switch  | 用于开关语句                               |
|   enum   | 声明枚举类型                                                  | typedef  | 用以给数据类型取别名                       |
|  extern  | 声明变量或函数是在其它文件或本文件的其他位置定义              | unsigned | 声明无符号类型变量或函数                   |
|  float   | 声明浮点型变量或函数返回值类型                                |  union   | 声明共用体类型                             |
|   for    | 一种循环语句                                                  |   void   | 声明函数无返回值或无参数，声明无类型指针   |
|   goto   | 无条件跳转语句                                                | volatile | 说明变量在程序执行中可被隐含地改变         |
|    if    | 条件语句                                                      |  while   | 循环语句的循环条件                         |

C99 新增关键字：

| \_Bool | \_Complex | \_Imaginary | inline | restrict |
| ------ | --------- | ----------- | ------ | -------- |

C11 新增关键字：

| \_Alignas       | \_Alignof      | \_Atomic | \_Generic | \_Noreturn |
| --------------- | -------------- | -------- | --------- | ---------- |
| \_Static_assert | \_Thread_local |          |           |            |

### 2.4.2 标识符

标识符：标识符简单理解为一个名字

 C 语言的标识符命名规则如下：

- 由字母、下划线和数字组成，并且不能以数字开
- 不能使用关键字

## 2.5 基础数据类型

在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。

C 中的类型可分为以下几种：

| 序号 |     类型     |
| :--: | :----------: |
|  1   | 基本数据类型 |
|  2   |   枚举类型   |
|  3   |  void 类型   |
|  4   |   派生类型   |

### 2.5.1 整型

下表列出了关于标准整数类型的存储大小和值范围的细节：

|      类型      |  存储大小   |                        值范围                        |
| :------------: | :---------: | :--------------------------------------------------: |
|      char      |   1 字节    |               -128 到 127 或 0 到 255                |
| unsigned char  |   1 字节    |                       0 到 255                       |
|  signed char   |   1 字节    |                     -128 到 127                      |
|      int       | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
|  unsigned int  | 2 或 4 字节 |          0 到 65,535 或 0 到 4,294,967,295           |
|     short      |   2 字节    |                  -32,768 到 32,767                   |
| unsigned short |   2 字节    |                     0 到 65,535                      |
|      long      |   4 字节    |           -2,147,483,648 到 2,147,483,647            |
| unsigned long  |   4 字节    |                  0 到 4,294,967,295                  |

> 注意：各种类型的存储大小与系统位数有关，但目前通用的以 64 位系统为主。

为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 **sizeof** 运算符。语法如下：

```C
#pragma warning(disable:4996)
#include <stdio.h>
int main() {
	int a;
	printf("%d", sizeof(int));

	return 0;
}
```

### 2.5.2 浮点型

下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：

|    类型     | 存储大小 |         值范围         |    精度     |
| :---------: | :------: | :--------------------: | :---------: |
|    float    |  4 字节  |   1.2E-38 到 3.4E+38   | 6 位有效位  |
|   double    |  8 字节  |  2.3E-308 到 1.7E+308  | 15 位有效位 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位有效位 |

### 2.5.3 类型转换

类型转换是将一个数据类型的值转换为另一种数据类型的值。C 语言中有两种类型转换：

- **隐式类型转换：**隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型

  ```C
  int i = 10;
  float f = 3.14;
  double d = i + f; // 隐式将int类型转换为double类型
  ```

- **显式类型转换：**显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。

  ```C
  double d = 3.14159;
  int i = (int)d; // 显式将double类型转换为int类型
  ```

## 2.6 运算符

运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。

### 2.6.1 算术运算符

下表显示了 C 语言支持的所有算术运算符。假设变量 **A** 的值为 10，变量 **B** 的值为 20，则：

| 运算符 | 描述                             | 实例              |
| :----- | :------------------------------- | :---------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30   |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10  |
| \*     | 把两个操作数相乘                 | A \* B 将得到 200 |
| /      | 分子除以分母                     | B / A 将得到 2    |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0    |
| ++     | 自增运算符，整数值增加 1         | A++ 将得到 11     |
| --     | 自减运算符，整数值减少 1         | A-- 将得到 9      |

### 2.6.2 关系运算符

下表显示了 C 语言支持的所有关系运算符。假设变量 **A** 的值为 10，变量 **B** 的值为 20，则：

| 运算符 | 描述                                                           | 实例            |
| :----- | :------------------------------------------------------------- | :-------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。               | (A == B) 为假。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。             | (A != B) 为真。 |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。       | (A > B) 为假。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。       | (A < B) 为真。  |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。 |

### 2.6.3 逻辑运算符

下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 **A** 的值为 1，变量 **B** 的值为 0，则：

| 运算符 | 描述                                                                               | 实例              |
| :----: | :--------------------------------------------------------------------------------- | :---------------- |
|   &&   | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。                               | (A && B) 为假。   |
| &#124; | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。                     | (A&#124;B) 为真。 |
|   !    | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。  |

### 2.6.4 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p   | q   | p & q | p&#124;q |     |
| :-- | :-- | :---- | :------- | :-- |
| 0   | 0   | 0     | 0        | 0   |
| 0   | 1   | 0     | 1        | 1   |
| 1   | 1   | 1     | 1        | 0   |
| 1   | 0   | 0     | 1        | 1   |

| 运算符  | 描述                                   | 实例                                                             |
| :-----: | :------------------------------------- | :--------------------------------------------------------------- |
|    &    | 按位与操作，按二进制位进行"与"运算。   | (A & B) 将得到 12，即为 0000 1100                                |
| $\vert$ | 按位或运算符，按二进制位进行"或"运算。 | (A$\vert$B) 将得到 61，即为 0011 1101                            |
|    ^    | 异或运算符，按二进制位进行"异或"运算。 | (A ^ B) 将得到 49，即为 0011 0001                                |
|    ~    | 取反运算符，按二进制位进行"取反"运算。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
|   <<    | 二进制左移运算符。                     | A << 2 将得到 240，即为 1111 0000                                |
|   >>    | 二进制右移运算符。                     | A >> 2 将得到 15，即为 0000 1111                                 |

### 1.6.5 赋值运算符

下表列出了 C 语言支持的赋值运算符：

| 运算符  | 描述                                                             | 实例                               |
| :------ | :--------------------------------------------------------------- | :--------------------------------- |
| =       | 简单的赋值运算符，把右边操作数的值赋给左边操作数                 | C = A + B 将把 A + B 的值赋给 C    |
| +=      | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A            |
| -=      | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A            |
| \*=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C _= A 相当于 C = C _ A            |
| /=      | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A            |
| %=      | 求模且赋值运算符，求两个操作数的模赋值给左边操作数               | C %= A 相当于 C = C % A            |
| <<=     | 左移且赋值运算符                                                 | C <<= 2 等同于 C = C << 2          |
| >>=     | 右移且赋值运算符                                                 | C >>= 2 等同于 C = C >> 2          |
| &=      | 按位与且赋值运算符                                               | C &= 2 等同于 C = C & 2            |
| ^=      | 按位异或且赋值运算符                                             | C ^= 2 等同于 C = C ^ 2            |
| &#124;= | 按位或且赋值运算符                                               | C &#124;= 2 等同于 C = C $\vert$ 2 |

### 1.6.6 杂项运算符

下表列出了 C 语言支持的其他一些重要的运算符，包括 **sizeof** 和 **? :**。

|  运算符  | 描述             | 实例                                 |
| :------: | :--------------- | :----------------------------------- |
| sizeof() | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。  |
|    &     | 返回变量的地址。 | &a; 将给出变量的实际地址。           |
|    \*    | 指向一个变量。   | \*a; 将指向一个变量。                |
|   ? :    | 条件表达式       | 如果条件为真 ? 则值为 X : 否则值为 Y |

### 1.6.7 运算优先级

下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。

| 类别       | 运算符                                  | 结合性   |
| :--------- | :-------------------------------------- | :------- |
| 后缀       | () [] -> . ++ - -                       | 从左到右 |
| 一元       | + - ! ~ ++ - - (type) \* & sizeof       | 从右到左 |
| 乘除       | \* / %                                  | 从左到右 |
| 加减       | + -                                     | 从左到右 |
| 移位       | << >>                                   | 从左到右 |
| 关系       | < <= > >=                               | 从左到右 |
| 相等       | == !=                                   | 从左到右 |
| 位与 AND   | &                                       | 从左到右 |
| 位异或 XOR | ^                                       | 从左到右 |
| 位或 OR    | &#124;                                  | 从左到右 |
| 逻辑与 AND | &&                                      | 从左到右 |
| 逻辑或 OR  | &#124;&#124;                            | 从左到右 |
| 条件       | ?:                                      | 从右到左 |
| 赋值       | = += -= \*= /= %= >>= <<= &= ^= &#124;= | 从右到左 |
| 逗号       | ,                                       | 从左到右 |

## 1.7 变量与常量

变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。

### 1.7.1 变量定义

变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：

```
type variable_list;
```

### 1.7.2 变量声明

变量的声明有两种情况：

1. 需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
2. 不需要建立存储空间的，通过使用 extern 关键字声明变量名而不定义它。
3. 除非有 extern 关键字，否则都是变量的定义。

```
extern int i; //声明，不是定义
int i; //声明，也是定义
```

### 1.7.3 常量

在 C 中，有两种简单的定义常量的方式：

1. 使用 **#define** 预处理器。
2. 使用 **const** 关键字。

下面是使用 #define 预处理器定义常量的形式：

```
#define identifier value
```

您可以使用 **const** 前缀声明指定类型的常量，如下所示：

```
const type variable = value;
```

## 1.8 输入和输出

当我们提到**输入**时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。

当我们提到**输出**时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。

### 1.8.1 scanf() 和 printf() 函数

`int scanf(const char \*format, ...) `函数从标准输入流 `stdin` 读取输入，并根据提供的 `format` 来浏览输入。

`int printf(const char \*format, ...)` 函数把输出写入到标准输出流 `stdout` ，并根据提供的格式产生输出。

`format` 可以是一个简单的常量字符串，但是您可以分别指定 `%s、%d、%c、%f `等来输出或读取字符串、整数、字符或浮点数。

例如：

```C
#pragma warning(disable:4996)
#include <stdio.h>
int main()
{
	char str[100];
	int i;
	printf("请输入值：");
	scanf("%s %d", str, &i);
	printf("\nYou entered: %s %d ", str, i);
	printf("\n");

	return 0;
}
```

### 1.8.2 getchar() 和 putchar() 函数

**`int getchar(void)`** 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

**`int putchar(int c)`** 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

### 1.8.3 gets() 和 puts() 函数

**`char \*gets(char \*s)`** 函数从 **`stdin`** 读取一行到 **s** 所指向的缓冲区，直到一个终止符或 EOF。

**`int puts(const char \*s)`** 函数把字符串 s 和一个尾随的换行符写入到 **`stdout`**。

# 第三章 流程控制语句

## 3.1 顺序结构

## 3.2 选择结构

选择结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。

### 3.2.1 if 语句

单个 if 的语句，当表达式 1 为真时，执行代码块 1。基本语法如下：

```C
if(表达式1)
{
    代码块1;
}
```

if…else 语句：当表达式 1 为真时，执行代码块 1；反之，执行代码块 2。基本语法如下：

```C
if(表达式1)
{
    代码块1;
}
else
{
    代码块2;
}
```

> 循环之间可以相互嵌套

### 3.2.2 switch 语句

基本语法如下：

```C
switch(value)
{
        case'A':a = 0;
        case'B':a = 1;
}
```

当传入的值 value 为 A 时，“a = 0”代码，其余同理。

### 3.2.3 三元运算符

```C
a>b? max = a: max = b;//如果a>b为真，则执行max = a;反之，则执行max = b;
```

## 3.3 循环结构

### 3.3.1 while 循环

基本语法如下：

```C
while(循环条件)
{
    xxx;
    循环体
}
```

### 3.3.2 do-while 循环

基本语法如下：

```C
do{
    循环体
}
while (循环条件);
```

与 while 的区别是，该循环是：先执行，后判断；而 while 是：先判断，后执行。

### 3.3.3 for 循环

基本语法如下：

```C
for(i = 1;i < 10;i++)
{
    循环体;
}
```

### 3.3.4 循环控制语句

| 控制语句                                                                       | 描述                                                                               |
| :----------------------------------------------------------------------------- | :--------------------------------------------------------------------------------- |
| [break 语句](https://www.runoob.com/cprogramming/c-break-statement.html)       | 终止**循环**或 **switch** 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。 |
| [continue 语句](https://www.runoob.com/cprogramming/c-continue-statement.html) | 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。                         |
| [goto 语句](https://www.runoob.com/cprogramming/c-goto-statement.html)         | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。                       |

# 第四章 复杂数据类型

## 4.1 数组

C 语言支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

数组中的元素的地址是连续的。

### 4.1.1 声明数组

在 C 中要声明一个数组，需要指定元素的类型和元素的数量。基本语法如下：

```C
//类型名 变量名[常量表达式]
int num[10];
```

- 定义数组时，需指明数组长度
- 中括号 [ ] 里为常量，不能为变量

### 4.1.2 初始化数组

在声明时进行初始化。基本语法如下：

```C
//全部赋值
int num[4] = {1,2,3,4}

//也可以部分赋值，未赋值的默认为0
int num[10] = {1,2,3,4}
```

还可以对数组中的单个元素进行赋值。例如;

```C
int num[10];
num[6] = 12;
```

### 4.1.3 访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```C
//数组名[下标]
//下标的范围0-max
num[0];
num[10];
```

### 4.1.4 二维数组

```C
//类型名 变量名[常量表达式][常量表达式]
int num[5][5];

//数组名[下标][下标]
//下标的范围0-max
num[0][0];
num[10][10];

int number[3][4] = {
    {1,2,3,4}
    {12,32,23,321}
    {23,1,23,32}
}

int number[3][4] = {1,23,2,321,23,23,32,12,31,32,3,24}
```

## 4.2 字符数组-字符串

在 C 语言中，**字符串**实际上是使用空字符 **\0** 结尾的一维字符数组。因此，**\0** 是用于标记字符串的结束。

![C/C++ 中的字符串表示](https://raw.githubusercontent.com/YuiLexi/Imageshack/main/E-books/Programming/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E6%A8%A1%E5%9E%8B.png)

### 4.2.1 字符数组的声明和初始化

语法如下：

```C
char str[6] = {'H','e','l','l','o','!'}

//或者
char str[] = "Hello!"
```

### 4.2.2 字符数组的输出

使用 printf() 函数，对字符数组进行输出。语法如下：

```C
char c[] = {"China"};
printf("%s\n",c);
```

说明：

- 输出的字符中不包含结束符'\0'
- 如果数组长度大于字符串的实际长度，也只输出遇到'\0'
- 如果一个字符数组中包含一个以上的'\0'，则遇到第一个时输出就结束
- 可以用**scanf_s**输入一个字符串

### 4.2.2 操作字符数组

C 中有大量操作字符串的函数：

| 序号 | 函数 & 目的                                                                                              |
| :--- | :------------------------------------------------------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。                                                          |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。                                                   |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                                                                   |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。                           |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。                         |

## 4.3 结构体

**结构**是 C 编程中一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。

### 4.3.1 结构体的定义

结构体定义由关键字 struct 和结构体名组成，结构体名可以根据需要自行定义。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```C
struct tag {
    member-list
    member-list
    member-list
    ...
} variable-list ;
/*
Struct 结构体名
{
	结构体成员列表;
}
*/
```

### 4.3.2 结构体变量初始化

和其它类型变量一样，对结构体变量可以在定义时指定初始值。例如，代码如下：

```C
#include <stdio.h>

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book = {"C 语言", "RUNOOB", "编程语言", 123456};

int main()
{
    printf("title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n", book.title, book.author, book.subject, book.book_id);
}
```

### 4.3.3 访问结构体成员

为了访问结构的成员，我们使用**成员访问运算符（.）**。您可以使用 **struct** 关键字来定义结构类型的变量。下面的实例演示了结构的用法：

```C
//定义结构体
struct Student
{
    int num;
    float f;
    char c;
    char str[];
}Tom = {9,10.56,'c',"Tom"}
struct Student *pt;
pt = &Tom
//方法一：结构体变量名.结构体成员
Tom.str;
//方法二：（*结构体指针变量).结构体成员
(*pt).str;
//方法三：结构体指针变量->结构体成员
pt->str
```

### 4.3.4 结构作为函数参数

您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：

## 4.4 共用体

**共用体**是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。

### 4.4.1 定义共用体

基本语法如下：

```C
union tag
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];
```

### 4.4.2 访问共用体成员

基本语法如下：

```C
name.element
```

### 4.4.3 共用体类型的特点

1. 同一段内存能存放不不同类型成员，但是在每一瞬间只能存放某一种类型成员
2. 可以进行初始化，但是初始化表中只能有一个常量
3. 共用体变量起作用的成员是最后一次被赋值的成员，每一次赋值后，原有变量存储单元中的值就被取代
4. 共用体变量的地址和它各成员的地址都是同一地址
5. 不能对共用体变量名赋值也不能引用变量名来获取一个值
6. C99 允许共用体变量作为函数参数

## 4.5 枚举

# 第五章 函数

函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

## 5.1 函数的使用

### 5.1.1 定义函数

C 语言中的函数定义的一般形式如下：

```C
return_type function_name( parameter list )
{
   body of the function
}
/*
类型名 函数名(参数)
{
	函数体
	返回值
}
*/
```

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

### 5.1.2 函数声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数声明包括以下几个部分：

```C
return_type function_name( parameter list );
```

针对上面定义的函数 max()，以下是函数声明：

```C
int max(int num1, int num2);
```

在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

```C
int max(int, int);
```

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

### 5.1.3 调用函数

基本语法如下：

```C
函数名(参数列表);
```

## 5.2 参数传递

- 形式参数：定义函数时括号里面的参数
- 实际参数：调用函数时括号里面的参数

### 5.2.1 传值调用

该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。

默认情况下，C 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。

### 5.2.2 引用调用

通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

## 5.3 函数的递归

在调用函数的过程中又出现**直接或间接调用该函数本身**，称为<font color='red'>函数的递归</font>。

```c
int name(int x)
{
    int y,z;
    z = name(y);
    return z;
}
```

例如，打印任意乘法表。具体代码如下：

```C
#pragma warning(disable:4996)
#include <stdio.h>

int main()
{
	void chengfabiao(int n);
	int number;
	printf("请输入要打印的乘法表的阶数：\n");
	scanf("%d", &number);
	chengfabiao(number);

	return 0;
}

void chengfabiao(int n)
{
	int i;
	if (n == 0)
		return;
	chengfabiao(n - 1);
	for (i = 1; i < n + 1; i++)
	{
		printf("%d X %d = %d ,  ", n, i, n * i);
	}
	printf("\n");
	return;
}
```

# 第六章 指针

正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 **&** 运算符访问的地址，它表示了在内存中的一个地址。

**指针也就是内存地址，指针变量是用来存放内存地址的变量**。

## 6.1 指针变量

### 6.1.1 指针变量的定义

基本语法如下：

```C
type *var_name;
```

### 6.1.2 指针的使用

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 **\*** 来返回位于操作数所指定地址的变量的值。例如，下面代码;

```C
#pragma warning(disable:4996)
#include <stdio.h>
int main()
{
	int a = 10;//定义整型变量 a
	int* ap;//定义整型指针变量 ap
	ap = &a;//让指针 ap 指向 a

	printf("a的地址是：%d\n", &a);
	printf("a的地址是：%d\n", ap);
	printf("a的值是：%d\n", a);
	printf("a的值是：%d\n", *ap);

	return 0;
}
```

## 6.2 NULL 指针

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为**空**指针。

NULL 指针是一个定义在标准库中的值为零的常量。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

## 6.3 指针详解

### 6.3.1 指针的算数运算

指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、- 。

假设 **ptr** 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

```C
ptr++;
```

在执行完上述的运算之后，**ptr** 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 **ptr** 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。

我们概括一下：

- 指针的每一次递增，它其实会指向下一个元素的存储单元。
- 指针的每一次递减，它都会指向前一个元素的存储单元。
- 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。

### 6.3.2 指针数组

### 6.3.3 多重指针

## 6.4 通过指针引用数组

### 6.4.1 数组元素的指针

**所谓数组元素的指针就是数组元素的地址**。

引用数组元素可以用下标法，也可用指针法。使用指针法能使目标程序质量高（占内存少，运算快）

```c
p = &a[0];
p = a;
```

注意：数组名不代表整个数组，只代表数组首元素的我地址。

### 6.4.2 在引用数组元素时的指针运算

在指针以指向一个数组元素时，可以对指针进行一下运算：

- p + 1;
- p - 1;
- p++,++p;
- p--,--p;

### 6.4.3 指针引用数组元素

1. 下标法

   ```C
   int a[10] = {0,1,2,3,4,5,6,7,8,9};

   int b;

   b = a[4];//b == 5
   ```

2. 指针法

   ```C
   int a[10] = {0,1,2,3,4,5,6,7,8,9};
   
   int *p;
   int b;
   
   p = &a[0];//或者 p=a; 将数组a的初地址赋给p指针
   b = *(p+4);//b==5
   ```

# 第七章 动态内存和链表

## 7.1 建立动态内存的方式

### 7.1.1 开辟动态存储区 malloc() 函数

基本语法如下：

```C
void *malloc(unsigned int size);
```

- 在内存的动态存储区中分配一个长度为 size 的连续空间。
- 函数返回值为内存第一个字节的地址
- 未能成功执行（例如：内存空间不足），则返回 NULL

### 7.1.2 开辟动态存储区 calloc() 函数

基本语法如下：

```C
void *calloc(unsigned int n,unsigned int size);
```

- 在内存的动态存储区中分配 n 个长度为 size 的连续空间。
- 函数返回值为内存第一个字节的地址
- 未能成功执行（例如：内存空间不足），则返回 NULL

### 7.1.3 重新分配动态存储区 realloc() 函数

基本语法如下：

```c
void *realloc(void *p,unsigned int size);
```

- 能够重新分配 malloc 或 calloc 函数开辟的动态空间
- realloch 函数将 p 所指向的动态空间的大小改变为 size 。
- p 的值不变
- 未能成功执行，则返回 NULL

### 7.1.4 释放动态存储区 free() 函数

基本语法如下：

```C
void free（void *p;
```

## 7.2 链表

### 7.2.1 静态链表

建立简单的静态链表。具体代码如下：

```C
#include <stdio.h>
#define maxSize 6
typedef struct {
    int data;
    int cur;
}component;
//将结构体数组中所有分量链接到备用链表中
void reserveArr(component *array);
//初始化静态链表
int initArr(component *array);
//输出函数
void displayArr(component * array, int body);
//从备用链表上摘下空闲节点的函数
int mallocArr(component * array);
int main() {
    component array[maxSize];
    int body = initArr(array);
    printf("静态链表为：\n");
    displayArr(array, body);
    return 0;
}
//创建备用链表
void reserveArr(component *array) {
    int i = 0;
    for (i = 0; i < maxSize; i++) {
        array[i].cur = i + 1;//将每个数组分量链接到一起
        array[i].data = 0;
    }
    array[maxSize - 1].cur = 0;//链表最后一个结点的游标值为0
}
//提取分配空间
int mallocArr(component * array) {
    //若备用链表非空，则返回分配的结点下标，否则返回 0（当分配最后一个结点时，该结点的游标值为 0）
    int i = array[0].cur;
    if (array[0].cur) {
        array[0].cur = array[i].cur;
    }
    return i;
}
//初始化静态链表
int initArr(component *array) {
    int tempBody = 0, body = 0;
    int i = 0;
    reserveArr(array);
    body = mallocArr(array);
    //建立首元结点
    array[body].data = 1;
    array[body].cur = 0;
    //声明一个变量，把它当指针使，指向链表的最后的一个结点，当前和首元结点重合
    tempBody = body;
    for (i = 2; i < 4; i++) {
        int j = mallocArr(array); //从备用链表中拿出空闲的分量
        array[j].data = i;      //初始化新得到的空间结点
        array[tempBody].cur = j; //将新得到的结点链接到数据链表的尾部
        tempBody = j;             //将指向链表最后一个结点的指针后移
    }
    array[tempBody].cur = 0;//新的链表最后一个结点的指针设置为0
    return body;
}
void displayArr(component * array, int body) {
    int tempBody = body;//tempBody准备做遍历使用
    while (array[tempBody].cur) {
        printf("%d,%d\n", array[tempBody].data, array[tempBody].cur);
        tempBody = array[tempBody].cur;
    }
    printf("%d,%d\n", array[tempBody].data, array[tempBody].cur);
}
```

### 7.2.2 动态链表

具体代码如下：

```C
#pragma warning(disable:4996)
#include<stdio.h>
#include<malloc.h>

typedef struct Books
{
	int id;
	struct Books* Bp;
}Books;

int main()
{
	Books* init(int n);
	void print(Books * fbp);
	Books* p;
	p = init(10);
	print(p);
}

/// <summary>
/// 生成对应结点数链表
/// </summary>
/// <param name="n">链表的结点数</param>
/// <returns>返回表头指针</returns>
Books* init(int n)
{
	Books* fBp = NULL;
	Books* tmp = NULL;
	int a;
	fBp = (Books*)malloc(sizeof(Books));

	tmp = fBp;
	for (a = 0; a < n; a++)
	{
		(*tmp).id = a;
		(*tmp).Bp = (Books*)malloc(sizeof(Books));
		tmp = (*tmp).Bp;
		(*tmp).Bp = NULL;
	}
	return fBp;
}

/// <summary>
/// 将链表的内容输出出来（正序和倒序）
/// </summary>
/// <param name="fbp">指向表头的指针</param>
void print(Books* fbp)
{
	if ((*fbp).Bp == NULL)
		return;
	printf("%d\n", (*fbp).id);
	print((*fbp).Bp);
	//printf("%d\n", (*fbp).id);
}
```

# 第八章 对文件的输入输出

## 8.1 C 文件的有关知识

### 8.1.1 什么是文件

程序文件

数据文件

### 8.1.2 文件类型指针

```c
FILE f1;
FILE * f1;
```

## 8.2 打开与关闭文件

| mode |                                                                        含义                                                                         |
| :--: | :-------------------------------------------------------------------------------------------------------------------------------------------------: |
|  r   |                                                         以只读方式打开文件，该文件必须存在                                                          |
|  r+  |                                                        以可读写方式打开文件，该文件必须存在                                                         |
| rb+  |                                                         读写打开一个二进制文件，允许读数据                                                          |
| rw+  |                                                          读写打开一个文本文件，允许读和写                                                           |
|  w   |                               打开只写文件，若文件存在则文件长度清为 0，即该文件内容会消失。若文件不存在则建立该文件                                |
|  w+  |                              打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件                               |
|  a   |       以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留（EOF 符保留）        |
|  a+  | 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留（原来的 EOF 符不保留） |
|  wb  |                                                     只写打开或新建一个二进制文件；只允许写数据                                                      |
| wb+  |                                                      读写打开或建立一个二进制文件，允许读和写                                                       |
| ab+  |                                                  读写打开一个二进制文件，允许读或在文件末追加数据                                                   |

### 8.2.1 用 fopen 函数打开数据文件

```c
fopen("文件名","操作文件方式");
```

### 8.2.2 用 fclose 函数关闭数据文件

```c
fclose(文件指针);
```

## 8.3 顺序读写数据文件

### 8.3.1 向文件读写字符

|  函数   |   调用形式   |                 功能                 |                                返回值                                 |
| :-----: | :----------: | :----------------------------------: | :-------------------------------------------------------------------: |
| getc()  |   getc(fp)   | 从 fp 所指向的输入文件中读取一个字符 |          返回值是读取的字符，如果发生错误则返回**EOF = -1**           |
| fputc() | fputc(ch,fp) |  字符 ch 写入到 fp 所指向的输出流中  | 如果写入成功，它会返回写入的字符，如果发生错误，则会返回 **EOF = -1** |

### 8.3.2 向文件读写字符串

|  函数   |    调用形式    |                  功能                   |                            返回值                            |
| :-----: | :------------: | :-------------------------------------: | :----------------------------------------------------------: |
| gets()  | gets(str,n,fp) | 从 fp 所指向的输入流中读取 n - 1 个字符 |         返回值是地址 str，如果发生错误则返回**NULL**         |
| fputs() | fputs(str,fp)  | 字符串 **s** 写入到 fp 所指向的输出流中 | 如果写入成功，它会返回 0，如果发生错误，则会返回 **非 0 值** |
