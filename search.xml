<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lua基础语法</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/05.Lua/01.Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/05.Lua/01.Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1><h1 id="二、Lua基础"><a href="#二、Lua基础" class="headerlink" title="二、Lua基础"></a>二、Lua基础</h1><h2 id="2-1-第一个Lua程序"><a href="#2-1-第一个Lua程序" class="headerlink" title="2.1 第一个Lua程序"></a>2.1 第一个Lua程序</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：在 <code>Lua</code> 语法中，语句的结尾可以添加 “;”，也可以选择不添加 “;”，但是习惯上不添加 “;”。</p></blockquote><h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h2><p>俗话说的好：我讨厌两种人，一是不写注释的人；二是让我写注释的人。尽管如此，良好的注释习惯不仅能提升代码的美观度和可读性，而且便于后期迭代修改。因此，养成写注释的好习惯是写代码的第一步。</p><p>基本上所有的计算机语言都有注释，而在 <code>Lua</code> 语言中，支持的注释类型有两种，分别是：</p><ol><li><p>单行注释</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********单行注释**********&quot;</span>)</span><br><span class="line"><span class="comment">-- 我是单行注释</span></span><br></pre></td></tr></table></figure><p> 这里是两个短横线 “-”。</p></li><li><p>多行注释</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********多行注释**********&quot;</span>)</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">我是多行注释</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">我是多行注释</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line">   <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">我是多行注释</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-基础变量类型"><a href="#2-3-基础变量类型" class="headerlink" title="2.3 基础变量类型"></a>2.3 基础变量类型</h2><p>在 <code>Lua</code> 语言中，所有的变量类型总结起来一共有 8 种，分别是：</p><div class="table-container"><table><thead><tr><th style="text-align:center">nil</th><th style="text-align:center">number</th><th style="text-align:center">string</th><th style="text-align:center">boolean</th><th style="text-align:center">table</th><th style="text-align:center">function</th><th style="text-align:center">userdata</th><th style="text-align:center">thread</th></tr></thead><tbody><tr><td style="text-align:center">表示NULL</td><td style="text-align:center">表示数字，包含整数和浮点数</td><td style="text-align:center">表示字符串</td><td style="text-align:center">表示布尔类型</td><td style="text-align:center">表类型</td><td style="text-align:center">函数类型</td><td style="text-align:center">数据结构</td><td style="text-align:center">协同程序</td></tr></tbody></table></div><p>本节中，主要讲解前四种基础变量类型，而后四种的复杂变量类型放在以后的小节中。</p><p>首先，在 <code>Lua</code> 语言中，声明变量是不需要指明其类型的，系统能够自动推断出变量的类型，属于<strong>弱语言</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. nil变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********nil变量**********&quot;</span>)</span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的值:&quot;</span>, a, <span class="string">&quot;    a的类型:&quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. number变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********number变量**********&quot;</span>)</span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;num的值:&quot;</span>, num, <span class="string">&quot;    num的类型:&quot;</span>, <span class="built_in">type</span>(num))</span><br><span class="line">number = <span class="number">73.123123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;number的值:&quot;</span>, number, <span class="string">&quot;    number的类型:&quot;</span>, <span class="built_in">type</span>(number))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. string变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********string变量**********&quot;</span>)</span><br><span class="line">str = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str的值:&quot;</span>, str, <span class="string">&quot;    str的类型:&quot;</span>, <span class="built_in">type</span>(str))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. boolean变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********boolean变量**********&quot;</span>)</span><br><span class="line">bool = <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bool的值:&quot;</span>, bool, <span class="string">&quot;    bool的类型:&quot;</span>, <span class="built_in">type</span>(bool))</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们能得到：</p><ol><li><p>变量的类型是根据其赋值所决定的；</p><p> 疑问：如果一个没有赋值的变量，那么它的类型是什么呢？</p><p> 答案：</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;变量 “ABCD” 的类型是&quot;</span>, <span class="built_in">type</span>(ABCD))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[结果为:</span></span><br><span class="line"><span class="comment">变量 “ABCD” 的类型是nil</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p> 由此可见，使用为定义的变量时，系统并不会报错，并且未定义的变量的类型为 <code>nil</code> 。</p></li><li><p>同一变量名可以进行多次赋值，并且取最后赋的值。</p><p> 疑问：如果我将一个变量赋<strong>不同类型的变量</strong>，是否可取？结果又会是什么呢？</p><p> 答案：</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********变量的多次赋值**********&quot;</span>)</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的值:&quot;</span>, a, <span class="string">&quot;    a的类型:&quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line">a = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的值:&quot;</span>, a, <span class="string">&quot;    a的类型:&quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********变量的多次赋值**********</span></span><br><span class="line"><span class="comment">a的值:10    a的类型:number</span></span><br><span class="line"><span class="comment">a的值:Hello, World!    a的类型:string</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>Tip：在 <code>Lua</code> 语言中，可以使用 <code>type(..)</code> 函数来获取变量类型，其返回值是一个字符串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********type()**********&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********type()**********</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="2-4-字符串"><a href="#2-4-字符串" class="headerlink" title="2.4 字符串"></a>2.4 字符串</h2><p>在 <code>Lua</code> 语言中，针对字符的变量类型只有字符串 <code>string</code> ，没有字符 <code>char</code> 。</p><p><strong>对于字符串的表示，既可以使用双引号，也可以使用单引号</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********字符串的声明**********&quot;</span>)</span><br><span class="line">str = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">str2 = <span class="string">&#x27;你好&#x27;</span></span><br></pre></td></tr></table></figure><p>对于字符串来讲，我们使用字符串，不仅会要学会创建字符串，而且还必须学会如可操作字符串，例如：获取字符串长度、拼接字符串、大小写转换、查找、截取、重复、替换等。</p><p>首先，给出字符串多行打印的方法，并且 <code>Lua</code> 语言中，<strong>字符串支持转义字符</strong>；而字符串类型的转换，是通过函数 <code>tostring(..)</code> 来完成的。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********多行打印**********&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12345\n67890\n&quot;</span>)</span><br><span class="line">str3 = <span class="string">[[</span></span><br><span class="line"><span class="string">我是</span></span><br><span class="line"><span class="string">多行打印</span></span><br><span class="line"><span class="string">!!!!</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********多行打印**********</span></span><br><span class="line"><span class="comment">12345</span></span><br><span class="line"><span class="comment">67890</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我是</span></span><br><span class="line"><span class="comment">多行打印</span></span><br><span class="line"><span class="comment">!!!!</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********字符串的转换**********&quot;</span>)</span><br><span class="line">str4 = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str4的值:&quot;</span>, str4, <span class="string">&quot;    str4的类型:&quot;</span>, <span class="built_in">type</span>(str4))</span><br><span class="line">str4 = <span class="built_in">tonumber</span>(str4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str4的值:&quot;</span>, str4, <span class="string">&quot;    str4的类型:&quot;</span>, <span class="built_in">type</span>(str4))</span><br><span class="line">str4 = <span class="built_in">tostring</span>(str4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str4的值:&quot;</span>, str4, <span class="string">&quot;    str4的类型:&quot;</span>, <span class="built_in">type</span>(str4))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********字符串的转换**********</span></span><br><span class="line"><span class="comment">str4的值:123    str4的类型:string</span></span><br><span class="line"><span class="comment">str4的值:123    str4的类型:number</span></span><br><span class="line"><span class="comment">str4的值:123    str4的类型:string</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p>对于如何获取字符串的长度，通过 <code>#</code> 符号来进行操作的，其使用方法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********字符串的长度**********&quot;</span>)</span><br><span class="line">str5 = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str5的长度:&quot;</span>, #str5)</span><br><span class="line">str6 = <span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str6的长度:&quot;</span>, #str6)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(#str6))</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********字符串的长度**********</span></span><br><span class="line"><span class="comment">str5的长度:13</span></span><br><span class="line"><span class="comment">str6的长度:6</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在 <code>Lua</code> 语言中，通过 <code>#</code> 获取字符串的长度，并不是字符数，而是返回的字节数（汉字占三个字节）。</p></blockquote><p>字符串的拼接：使用 <code>..</code> 操作符。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********字符串的连接**********&quot;</span>)</span><br><span class="line">str7 = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str8 = <span class="string">&quot;World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str7 .. str8)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********字符串的连接**********</span></span><br><span class="line"><span class="comment">Hello, World!</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p>还可以使用模式匹配的方式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********模式匹配**********&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;我已经使用了 %d 天的Lua&quot;</span>, <span class="number">7</span>))</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********模式匹配**********</span></span><br><span class="line"><span class="comment">我已经使用了 7 天的Lua</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p>而对于字符串的其余操作，其用法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********字符串的操作**********&quot;</span>)</span><br><span class="line">str9 = <span class="string">&quot;abcDEFghabc&quot;</span></span><br><span class="line"><span class="comment">-- 1. 小写转大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(str9))</span><br><span class="line"><span class="comment">-- 2. 大写转小写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">lower</span>(str9))</span><br><span class="line"><span class="comment">-- 3. 反转</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">reverse</span>(str9))</span><br><span class="line"><span class="comment">-- 4. 查找</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str9, <span class="string">&quot;abc&quot;</span>))</span><br><span class="line"><span class="comment">-- 5. 截取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(str9, <span class="number">4</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment">-- 6. 替换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(str9, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;***&quot;</span>))</span><br><span class="line"><span class="comment">-- 7. 重复</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">rep</span>(str9, <span class="number">3</span>))</span><br><span class="line"><span class="comment">-- 8. 匹配</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(str9, <span class="string">&quot;DEF&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********字符串的操作**********</span></span><br><span class="line"><span class="comment">ABCDEFGHABC</span></span><br><span class="line"><span class="comment">abcdefghabc</span></span><br><span class="line"><span class="comment">cbahgFEDcba</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">DEF</span></span><br><span class="line"><span class="comment">***DEFgh***2</span></span><br><span class="line"><span class="comment">abcDEFghabcabcDEFghabcabcDEFghabc</span></span><br><span class="line"><span class="comment">DEF</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p>函数 <code>find()</code> 返回值有两个，表明查找到两处，位置分别是 1 和 3；函数 <code>gsub()</code> 最后输出一个数字，表明替换的次数。</p><blockquote><p>注意：在 <code>Lua</code> 语言中，字符串的索引是从 “1” 开始的，这一点需要和替他语言进行区分。在后面的学习中，其实发现，涉及到索引的，默认都是从 “1” 开始，而不是从 “0” 开始。</p></blockquote><h2 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h2><p>在 <code>Lua</code> 语言中，运算符的种类分为三种：<strong>算术运算符</strong>、<strong>条件运算符</strong>和<strong>逻辑运算符</strong>。</p><ol><li><p>算术运算符：<code>+  -  *  /  %  ^</code> （加、减、乘、除、取余、幂）；</p><blockquote><p><strong>在 <code>Lua</code> 语言中，没有自增自减运算符（<code>++ --</code>），同时也没有复合运算符（<code>+= -= *= /= %=</code>）</strong>。</p></blockquote><p> <code>string</code> 与 <code>number</code> 类型运算时，如果 <code>string</code> 可以被转换成 <code>number</code> ，那么会得到 <code>number</code> 类型的结果。</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********算术运算符**********&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12.3&quot;</span> + <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12.3&quot;</span> - <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12.3&quot;</span> * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12.3&quot;</span> / <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12.3&quot;</span> % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">结果为:</span></span><br><span class="line"><span class="comment">**********算术运算符**********</span></span><br><span class="line"><span class="comment">14.3</span></span><br><span class="line"><span class="comment">10.3</span></span><br><span class="line"><span class="comment">24.6</span></span><br><span class="line"><span class="comment">6.15</span></span><br><span class="line"><span class="comment">0.3</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>条件(关系)运算符：<code>&gt;  &lt;  &gt;=  &lt;=  ==  ~=</code> （大于、小于、大于等于、小于等于、等于、不等于）</p></li><li><p>逻辑运算符：<code>and  or  not</code> （与、或、非）。</p><p> 在 <code>Lua</code> 语言中，“与” 和 “或” 都遵循逻辑电路的 “短路” 原则。</p></li></ol><blockquote><p>在 <code>Lua</code> 语言中，<strong>不支持位运算符和三目运算符</strong>。</p></blockquote><h1 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h1><h2 id="3-1-条件分支语句"><a href="#3-1-条件分支语句" class="headerlink" title="3.1 条件分支语句"></a>3.1 条件分支语句</h2><p>在 <code>Lua</code> 语言中，基本的 <code>if</code> 语句如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [条件表达式] <span class="keyword">then</span></span><br><span class="line">    [分支]</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    [分支]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a大于5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a小于5&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[结果为:</span></span><br><span class="line"><span class="comment">a大于5</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p>多分支语句：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a大于5&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a &lt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a小于5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a等于5&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[结果为:</span></span><br><span class="line"><span class="comment">a大于5</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>在<code>Lua</code>语法中，没有<code>switch</code>语法</strong>。</p></blockquote><h2 id="3-2-循环语句"><a href="#3-2-循环语句" class="headerlink" title="3.2 循环语句"></a>3.2 循环语句</h2><ol><li><p><code>while</code>循环</p><p> 基本语法格式如下：</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [条件表达式] <span class="keyword">do</span></span><br><span class="line">    [循环体]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>“<code>do-while</code>“ <code>repeat</code>循环</p><p> 基本语法格式如下：</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    [循环体]</span><br><span class="line"><span class="keyword">until</span> [结束条件判断表达式]</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>for</code>循环</p><p> 基本语法格式如下：</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = [初值], [目标值(不包含)], [step] <span class="keyword">do</span></span><br><span class="line">    [循环体]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>在<code>Lua</code>语言中，<code>for</code>循环会自行累计计数，不需要手动著名<code>i = i + 1</code>；</li><li><code>step</code>是步长，也就是每一次迭代，<code>i</code>变换的量，<strong>默认是 “1”</strong>；</li><li>初值和目标值是左开右闭（区间）范围，也就是相当于 “初值 &lt;= X &lt; 目标值”。</li></ul></li></ol><h1 id="四、函数💲"><a href="#四、函数💲" class="headerlink" title="四、函数💲"></a>四、函数💲</h1><h2 id="4-1-函数的定义"><a href="#4-1-函数的定义" class="headerlink" title="4.1 函数的定义"></a>4.1 函数的定义</h2><p>在<code>Lua</code>语言中，函数的表示方式有两种，分别是：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span><span class="params">()</span></span></span><br><span class="line">    [函数体]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Name()</span><br><span class="line"></span><br><span class="line">Name = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    [函数体]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Name()</span><br></pre></td></tr></table></figure><blockquote><p>Tips：在前面的学习中提到过函数<code>function</code>也是一种特殊的变量，而第二种表示方式就类似于变量的定义。</p><p>注意：在<code>Lua</code>语言中，由于是解释型语言，系统逐行进行执行的，因此<strong>不能将函数的执行放在函数的定义之前</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这样的代码会报错</span></span><br><span class="line">Name()</span><br><span class="line">Name = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m a function&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></blockquote><p>对于含有参数的函数，在定义的时候不需要指明参数的类型，因此，在函数处理的时候，就要做好应对多种数据类型的准备，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">F1 = <span class="function"><span class="keyword">function</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你输入的是：&quot;</span>, a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">F1(<span class="literal">nil</span>)</span><br><span class="line">F1(<span class="number">1</span>)</span><br><span class="line">F1(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">F1(<span class="literal">true</span>)</span><br><span class="line">F1()</span><br><span class="line">F1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[结果为:</span></span><br><span class="line"><span class="comment">你输入的是：nil</span></span><br><span class="line"><span class="comment">你输入的是：1</span></span><br><span class="line"><span class="comment">你输入的是：Hello, World!</span></span><br><span class="line"><span class="comment">你输入的是：true</span></span><br><span class="line"><span class="comment">你输入的是：nil</span></span><br><span class="line"><span class="comment">你输入的是：1</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>当执行有参的函数时，如果输入零个参数，那么会按照<code>nil</code>对每个参数进行处理；如果输入的参数多于定义的参数，那么会默认忽略多余的参数</strong>。</p></blockquote><p>对于有返回值的参数，在函数体内部使用<code>return</code>语句，并且<strong>可以有多返回值</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********函数的返回值**********&quot;</span>)</span><br><span class="line">F2 = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(F2(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">F3 = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a, b, a + b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a, b, c = F3(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><p>对于多返回值，可以声明多个变量来接收，如果接收者多于返回者，那么多余的接收者为<code>nil</code>；如果接收者小于返回者，那么多余的返回者丢弃。</p><blockquote><p>在<code>Lua</code>语言中，如果中间某个返回值不想要，可以使用弃元<code>_</code>（单下划线），作为接收的占位符。</p></blockquote><h2 id="4-2-函数的重载"><a href="#4-2-函数的重载" class="headerlink" title="4.2 函数的重载"></a>4.2 函数的重载</h2><p>先回答一下什么是函数额重载：函数名相同，但是函数的参数不同，称为<strong>函数的重载</strong>。</p><p>在<code>Lua</code>语言中，不支持函数的重载，执行函数时，会默认调取最后一次赋值的函数变量。</p><h2 id="4-3-变长参数"><a href="#4-3-变长参数" class="headerlink" title="4.3 变长参数"></a>4.3 变长参数</h2><p>在<code>Lua</code>语言中，如果希望函数传入多个参数，但是参数的个数不确定，可以使用变长参数，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********函数的可变参数**********&quot;</span>)</span><br><span class="line">F4 = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span> &#123; ... &#125; <span class="keyword">do</span></span><br><span class="line">        sum = sum + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(F4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(F4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment">--[[结果为:</span></span><br><span class="line"><span class="comment">**********函数的可变参数**********</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">55</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p>在上面代码中，定义函数的参数时，使用<code>...</code>（三个点）表示参数，那么在执行函数的时候，就能传入多个参数。这些传入函数的参数，是通过转换成表<code>table</code>类型的变量来操作的，对于表<code>table</code>的相关知识，在后续的章节中，会进行细致的讲解。</p><h2 id="4-4-函数的嵌套-闭包"><a href="#4-4-函数的嵌套-闭包" class="headerlink" title="4.4 函数的嵌套(闭包)"></a>4.4 函数的嵌套(闭包)</h2><h1 id="五、复杂数据结构——表"><a href="#五、复杂数据结构——表" class="headerlink" title="五、复杂数据结构——表"></a>五、复杂数据结构——表</h1>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Unity3D基础 </category>
          
          <category> Lua </category>
          
          <category> Lua基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 离散数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录【离散数学】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/04.%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/08.%E9%99%84%E5%BD%95.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/04.%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/08.%E9%99%84%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、命题与逻辑"><a href="#一、命题与逻辑" class="headerlink" title="一、命题与逻辑"></a>一、命题与逻辑</h1><h2 id="3-1-常见命题等价公式："><a href="#3-1-常见命题等价公式：" class="headerlink" title="3.1 常见命题等价公式："></a>3.1 常见命题等价公式：</h2><div style="text-align:center;">表1.3.3</div><div class="table-container"><table><thead><tr><th style="text-align:center">定律</th><th style="text-align:center">定律描述</th><th style="text-align:center">定律代号</th></tr></thead><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">$\neg \neg P\Longleftrightarrow P$</td><td style="text-align:center">$E_{1}$</td></tr><tr><td style="text-align:center">等幂律</td><td style="text-align:center">$P\wedge P\Longleftrightarrow P$</td><td style="text-align:center">$E_{2}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\vee P\Longleftrightarrow P$</td><td style="text-align:center">$E_{3}$</td></tr><tr><td style="text-align:center">交换律</td><td style="text-align:center">$P\wedge Q\Longleftrightarrow Q\wedge P$</td><td style="text-align:center">$E_{4}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\vee Q\Longleftrightarrow Q\vee P$</td><td style="text-align:center">$E_{5}$</td></tr><tr><td style="text-align:center">结合律</td><td style="text-align:center">$P\wedge (Q\wedge R)\Longleftrightarrow (P\wedge Q)\wedge R$</td><td style="text-align:center">$E_{6}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\vee (Q\vee R)\Longleftrightarrow (P\vee Q)\vee R$</td><td style="text-align:center">$E_{7}$</td></tr><tr><td style="text-align:center">分配律</td><td style="text-align:center">$P\wedge (Q\vee R)\Longleftrightarrow (P\wedge Q)\vee (P\wedge R)$</td><td style="text-align:center">$E_{8}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\vee (Q\wedge R)\Longleftrightarrow (P\vee Q)\wedge (P\vee R)$</td><td style="text-align:center">$E_{9}$</td></tr><tr><td style="text-align:center"><strong>德·摩根定律</strong></td><td style="text-align:center"><strong>$\neg (P\wedge Q)\Longleftrightarrow \neg P\vee \neg Q$</strong></td><td style="text-align:center">$E_{10}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>$\neg (P\vee Q)\Longleftrightarrow \neg P\wedge \neg Q$</strong></td><td style="text-align:center">$E_{11}$</td></tr><tr><td style="text-align:center">吸收率</td><td style="text-align:center">$P\wedge (P\vee Q)\Longleftrightarrow P$</td><td style="text-align:center">$E_{12}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\vee (P\wedge Q)\Longleftrightarrow P$</td><td style="text-align:center">$E_{13}$</td></tr><tr><td style="text-align:center">蕴含率</td><td style="text-align:center">$P\longrightarrow Q\Longleftrightarrow \neg P\vee Q$</td><td style="text-align:center">$E_{14}$</td></tr><tr><td style="text-align:center">双条件定律</td><td style="text-align:center">$P\longleftrightarrow Q\Longleftrightarrow (P\longrightarrow Q)\wedge (Q\longrightarrow P)$</td><td style="text-align:center">$E_{15}$</td></tr><tr><td style="text-align:center"><strong>零率</strong></td><td style="text-align:center">$P\wedge F\Longleftrightarrow F$</td><td style="text-align:center">$E_{16}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\vee T\Longleftrightarrow T$</td><td style="text-align:center">$E_{17}$</td></tr><tr><td style="text-align:center">同一律</td><td style="text-align:center">$P\wedge T\Longleftrightarrow P$</td><td style="text-align:center">$E_{18}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\vee F\Longleftrightarrow P$</td><td style="text-align:center">$E_{19}$</td></tr><tr><td style="text-align:center">矛盾律</td><td style="text-align:center">$P\wedge \neg P\Longleftrightarrow F$</td><td style="text-align:center">$E_{20}$</td></tr><tr><td style="text-align:center"><strong>排中律</strong></td><td style="text-align:center"><strong>$P\vee \neg P\Longleftrightarrow T$</strong></td><td style="text-align:center">$E_{21}$</td></tr><tr><td style="text-align:center">输出律</td><td style="text-align:center">$(P\wedge Q)\longrightarrow R\Longleftrightarrow P\longrightarrow (Q\longrightarrow R)$</td><td style="text-align:center">$E_{22}$</td></tr><tr><td style="text-align:center">归谬律</td><td style="text-align:center">$(P\longrightarrow Q)\wedge (P\longrightarrow \neg Q)\Longleftrightarrow \neg P$</td><td style="text-align:center">$E_{23}$</td></tr><tr><td style="text-align:center">逆反律</td><td style="text-align:center">$P\longrightarrow Q\Longleftrightarrow \neg Q\longrightarrow \neg P$</td><td style="text-align:center">$E_{24}$</td></tr></tbody></table></div><h2 id="3-2-蕴含"><a href="#3-2-蕴含" class="headerlink" title="3.2 蕴含"></a>3.2 蕴含</h2><p>常见的蕴含公式</p><div style="text-align:center;">表1.3.7</div><div class="table-container"><table><thead><tr><th style="text-align:center">定律</th><th style="text-align:center">定律描述</th><th style="text-align:center">定律代号</th></tr></thead><tbody><tr><td style="text-align:center">直推式</td><td style="text-align:center">$P\Longrightarrow P$</td><td style="text-align:center">$I_{1} $</td></tr><tr><td style="text-align:center">化简式</td><td style="text-align:center">$P\wedge Q\Longrightarrow P$</td><td style="text-align:center">$I_{2} $</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\wedge Q\Longrightarrow Q$</td><td style="text-align:center">$I_{3} $</td></tr><tr><td style="text-align:center">附加式</td><td style="text-align:center">$P\Longrightarrow P\vee Q$</td><td style="text-align:center">$I_{4} $</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$Q\Longrightarrow P\vee Q$</td><td style="text-align:center">$I_{5} $</td></tr><tr><td style="text-align:center">变形附加式</td><td style="text-align:center">$\neg P\Longrightarrow P\longrightarrow Q$</td><td style="text-align:center">$I_{6} $</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$Q\Longrightarrow P\longrightarrow Q$</td><td style="text-align:center">$I_{7} $</td></tr><tr><td style="text-align:center">变形附加式</td><td style="text-align:center">$\neg (P\longrightarrow Q)\Longrightarrow P$</td><td style="text-align:center">$I_{8} $</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$\neg (P\longrightarrow Q)\Longrightarrow \neg Q$</td><td style="text-align:center">$I_{9} $</td></tr><tr><td style="text-align:center">假言推理</td><td style="text-align:center">$P\wedge (P\longrightarrow Q)\Longrightarrow  Q$</td><td style="text-align:center">$I_{10} $</td></tr><tr><td style="text-align:center">拒取式</td><td style="text-align:center">$\neg Q\wedge (P\longrightarrow Q)\Longrightarrow \neg P$</td><td style="text-align:center">$I_{11} $</td></tr><tr><td style="text-align:center">析取三段论</td><td style="text-align:center">$\neg P\wedge (P\vee Q)\Longrightarrow Q$</td><td style="text-align:center">$I_{12} $</td></tr><tr><td style="text-align:center">前提三段论</td><td style="text-align:center">$(P\longrightarrow Q)\wedge (Q\longrightarrow R)\Longrightarrow P\longrightarrow R$</td><td style="text-align:center">$I_{13} $</td></tr><tr><td style="text-align:center">构造性二难推理</td><td style="text-align:center">$(P\vee Q)\wedge (P\longrightarrow R)\wedge (Q\longrightarrow S)\Longrightarrow R\vee S$</td><td style="text-align:center">$I_{14} $</td></tr><tr><td style="text-align:center">破坏性二难推理</td><td style="text-align:center">$(\neg R\vee \neg S)\wedge (P\longrightarrow R)\wedge (Q\longrightarrow S)\Longrightarrow \neg P\vee \neg Q$</td><td style="text-align:center">$I_{15} $</td></tr><tr><td style="text-align:center">合取二难推理</td><td style="text-align:center">$(P\wedge Q)\wedge (P\longrightarrow R)\wedge (Q\longrightarrow S)\Longrightarrow R\wedge S$</td><td style="text-align:center">$I_{16} $</td></tr><tr><td style="text-align:center">逆条件附加</td><td style="text-align:center">$(P\longrightarrow Q)\Longrightarrow (Q\longrightarrow R)\longrightarrow (P\longrightarrow R)$</td><td style="text-align:center">$I_{17} $</td></tr><tr><td style="text-align:center">条件归并</td><td style="text-align:center">$(P\longrightarrow Q)\wedge (R\longrightarrow S)\Longrightarrow (P\wedge R)\longrightarrow (Q\wedge S)$</td><td style="text-align:center">$I_{18} $</td></tr><tr><td style="text-align:center">双条件三段论</td><td style="text-align:center">$(P\longleftrightarrow Q)\wedge (Q\longleftrightarrow R)\Longrightarrow P\longleftrightarrow R$</td><td style="text-align:center">$I_{19} $</td></tr><tr><td style="text-align:center">前后件附加</td><td style="text-align:center">$P\longrightarrow Q\Longrightarrow (P\vee R)\longrightarrow (Q\vee R)$</td><td style="text-align:center">$I_{20} $</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$P\longrightarrow Q\Longrightarrow (P\wedge R)\longrightarrow (Q\wedge R)$</td><td style="text-align:center">$I_{21} $</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 离散数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 谓词逻辑【离散数学】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/04.%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/02.%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/04.%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/02.%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>命题逻辑能够对自然语言中的逻辑思维进行精确的形式化描述，并且对一些比较复杂的逻辑推理能够用形式化的方法进行证明。但是，由于命题逻辑以原子命题为演算的基本单位，对简单命题不再进行分解，无法分析命题的内部结构及命题之间的内在联系，导致命题逻辑在表示和推理方面存在局限性。</p><h1 id="一、谓词和量词"><a href="#一、谓词和量词" class="headerlink" title="一、谓词和量词"></a>一、谓词和量词</h1><h2 id="1-1-谓词"><a href="#1-1-谓词" class="headerlink" title="1.1 谓词"></a>1.1 谓词</h2><p><strong>定义2.1.1</strong>：刻画单个个体的特性或者多个个体间关系的模式称为谓词(predicate)。</p><p>用于表示具体或特定个体的符号称做<strong>个体常元</strong>，常用 $\displaystyle a,b,c,\cdots $ 表示。用于表示任意个体的变量称做<strong>个体变元</strong>，常用 $\displaystyle x,y,z,\cdots $​ 表示。个体变元的取值范围称为该变元的论<strong>域(domainofdiscourse)或个体域</strong>，是一个集合，通常采用大写字母表示。</p><ul><li><p>一元谓词。</p><p>  例如：小明是学生。（小明是个体常元）</p></li><li><p>二元谓词。</p><p>  例如：2整除6.（“2” 和 “6” 是个体常元）</p></li><li><p>$n$ 元谓词。</p></li></ul><p>谓词就可以简单地描述为是由一个谓词符和若干具有有固定次序的个体常元或变元组成的表达式。带有 $n$ ( $n&gt;0$ )个个体的谓词称为 $n$ 元谓词。设有谓词 $P(x_{1},x_{2},\cdots ,x_{n})$ ，也称作 $n$ 元命题函数。</p><p>从谓词的定义来看，谓词 $P(x_{1},x_{2},\cdots ,x_{n})$ 仅仅是一个函数，因此它没有真假值。</p><h2 id="1-2-量词"><a href="#1-2-量词" class="headerlink" title="1.2 量词"></a>1.2 量词</h2><blockquote><p>使用谓词还不能很好地表达日常生活中的所有命题，如“所有的人都要呼吸”、“有些有理数是自然数”等。为了刻画这类<strong>表示全称判断或特称判断</strong>的命题,需要引人量词(quantifier)。</p></blockquote><ol><li><p>全称量词 $\forall $​ ：</p><p>  $\forall x$ 表示“对于所有的 $x$ ”、“对于任一 $x$ ”或者“对于每一个 $x$ ”。例如： $\displaystyle \forall xP(x)$ 表示“对于所有的 $x$ 均有 $P(x)$ ”。 </p></li><li><p>存在量词 $\exists $​ ：</p><p>  $\exists  x$ 表示“存在某个 $x$ ”或者“至少有一个 $x$ ”。例如： $\displaystyle \exists  xP(x)$ 表示“存在 $x$ 有 $P(x)$​ ”。 </p></li></ol><p>事实上，不同个体变元可以采用完全不同的论域，但不同变元一起讨论时用不同的论域会带来不便，于是引人一个统一的个体论域————<strong>全总个体域</strong>，它包括所有个体变元所能代表的所有可能的个体。以后除非特别说明，否则论域都默认是全总个体域。此时，对个体变元的变化范围，可以用特性谓词来加以限制。</p><p>例如：人都是要死的。$P(x)$：$x$ 是人； $G(x)$： $x$ 会死。</p><ul><li>论域“全人类”： $\displaystyle (\forall x)G(x)$​ ；</li><li>论域“全总个体域”： $\displaystyle (\forall x)(H(x)\wedge G(x))$ 。</li></ul><h1 id="二、谓词公式"><a href="#二、谓词公式" class="headerlink" title="二、谓词公式"></a>二、谓词公式</h1><h1 id="三、谓词演算的永真公式"><a href="#三、谓词演算的永真公式" class="headerlink" title="三、谓词演算的永真公式"></a>三、谓词演算的永真公式</h1><h1 id="四、谓词逻辑的推理理论"><a href="#四、谓词逻辑的推理理论" class="headerlink" title="四、谓词逻辑的推理理论"></a>四、谓词逻辑的推理理论</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 离散数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 命题与逻辑【离散数学】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/04.%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/01.%E5%91%BD%E9%A2%98%E4%B8%8E%E9%80%BB%E8%BE%91.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/04.%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/01.%E5%91%BD%E9%A2%98%E4%B8%8E%E9%80%BB%E8%BE%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>1898 年德国数学家弗雷德在《算术基本规律》一书中，介绍了命题逻辑，标志着符号逻辑系统的诞生。</p><p>数理逻辑：数学的一个分支。它是用数学的方法研究逻辑或形式逻辑的学科。所谓数学方法是指采用数学的一般方法，包括使用符号和公式，使用己有的数学成果和方法，特别是使用形式的公理方法。数理逻辑又称为“符号逻辑”。</p><h1 id="一、命题与联结词"><a href="#一、命题与联结词" class="headerlink" title="一、命题与联结词"></a>一、命题与联结词</h1><h2 id="1-1-命题"><a href="#1-1-命题" class="headerlink" title="1.1 命题"></a>1.1 命题</h2><p>命题逻辑主要研究<strong>前提</strong>和<strong>结论</strong>之间的逻辑关系。</p><p><strong>定义1.1.1：一个具有真或假，但是不能两者都是的断言称为命题</strong>（具有唯一真值的陈述句）。</p><p>命题必须满足以下两个条件：</p><ol><li>命题是表达判断的陈述句。（不能是疑问句、祈使句、感叹句和<strong>悖论</strong>）</li><li>命题具有确定的真假值。</li></ol><p>命题“真”时，用大写字母 “T” 表示，或者使用数字 “1” 表示；命题 “假” 时，用大写字母 “F” 表示，或者使用数字 “0” 表示。</p><p><strong>原子命题</strong>：如果一个陈述句不能再分成更简单的语句，那么由它构成的命题称为<strong>原子命题</strong>。</p><p><strong>复合命题</strong>：由原子命题、联结词和圆括号组成的命题</p><h2 id="1-2-联结词"><a href="#1-2-联结词" class="headerlink" title="1.2 联结词"></a>1.2 联结词</h2><p>在代数中，使用 “+”、“-” 等运算符连接数字得到表达式，同样，在数理逻辑中，也存在运算符，称为<strong>逻辑连接词</strong>。</p><ol><li><p><strong>否定联结词</strong>：也成为<strong>“非”运算</strong>，一元运算符</p><p> <strong>定义1.1.2 设 $P$ 是命题， $P$ 的否定是一个复合否定，记作 $\neg P$ ，称为“非$P$”。符号 $\neg$ 用于表示否定联结词</strong>。</p><p> 真值表如下：</p><p> | $P$  | $\neg P$ |<br> | :—: | :———: |<br> |  0   |    1     |<br> |  1   |    0     |</p></li></ol><ol><li><p><strong>合取联结词</strong></p><p> <strong>定义1.1.3 如果 $P$ 和 $Q$ 是命题，那么“ $P$ 并且 $Q$”是一个复合命题，记作 $P\wedge Q$ 称为  $P$ 和 $Q$ 的合取。符号 $\wedge$ 用于表示合取联结词</strong>。</p><p> 真值表如下：</p><p> | $P$  | $Q$  | $P\wedge Q$ |<br> | :—: | :—: | :————-: |<br> |  0   |  0   |      0      |<br> |  0   |  1   |      0      |<br> |  1   |  0   |      0      |<br> |  1   |  1   |      1      |</p><blockquote><p>在数理逻辑中，任意两个命题都能进行合取运算，一旦这两个命题的真值确定后，合取的真值就随之确定。</p></blockquote></li><li><p><strong>析取联结词</strong></p><p> <strong>定义1.1.4 如果 $P$ 和 $Q$ 是命题，那么“ $P$ 或 $Q$”是一个复合命题，记作 $P\vee Q$ 称为  $P$ 和 $Q$ 的析取。符号 $\vee$ 用于表示合取联结词</strong>。</p><p> 真值表如下：</p><p> | $P$  | $Q$  | $P\vee Q$ |<br> | :—: | :—: | :———-: |<br> |  0   |  0   |     0     |<br> |  0   |  1   |     1     |<br> |  1   |  0   |     1     |<br> |  1   |  1   |     1     |</p><blockquote><p>与合取类似，析取也可以联结两个没有内在联系的命题。</p></blockquote></li><li><p>条件联结词</p><p> <strong>定义1.1.5 如果 $P$ 和 $Q$ 是命题，那么“如果 $P$ ，那么 $Q$ ”是一个复合命题，记作 $P\to Q$ 称为 $P$ 和 $Q$ 的条件命题</strong>。称 $P$ 为<strong>假设或者前件、条件</strong>，称 $Q$ 为<strong>结论或者后件</strong>。</p><p> 真值表如下：</p><p> | $P$  | $Q$  | $P\to Q$ |<br> | :—: | :—: | :———: |<br> |  0   |  0   |    1     |<br> |  0   |  1   |    1     |<br> |  1   |  0   |    0     |<br> |  1   |  1   |    1     |</p><p> “如果P，那么Q”、“P仅当Q”、“Q每当P”、“P是Q的充分条件”、“Q是P的必要条件”</p><p> 给定的条件命题 $P\to Q$ ，把 $Q\to P$ 、$\neg P\to \neg Q$ 、$\neg Q\to \neg P$ 分别称作命题的<strong>逆命题</strong>、<strong>否命题</strong>和<strong>逆否命题</strong>。</p></li><li><p>双条件联结词</p><p> <strong>定义1.1.6 如果 $P$ 和 $Q$ 是命题，那么“$P$ 当且仅当 $Q$”是一个复合命题，记作 $P\longleftrightarrow Q$ 称作 $P$ 和 $Q$ 的双条件命题</strong>。</p><p> 真值表如下：</p><p> | $P$  | $Q$  | $P\longleftrightarrow Q$ |<br> | :—: | :—: | :———————————: |<br> |  0   |  0   |            1             |<br> |  0   |  1   |            0             |<br> |  1   |  0   |            0             |<br> |  1   |  1   |            1             |</p></li></ol><h1 id="二、命题公式"><a href="#二、命题公式" class="headerlink" title="二、命题公式"></a>二、命题公式</h1><h2 id="2-1-命题公式及其符号化"><a href="#2-1-命题公式及其符号化" class="headerlink" title="2.1 命题公式及其符号化"></a>2.1 命题公式及其符号化</h2><p><strong>定义1.2.1 用于代表取值为真(T、1)或假(F、0)之一的变量，称为命题变元，通常用大写 字母或者带下标或者带上标的大写字母表示</strong>。</p><p><strong>定义1.2.2 命题合式公式，简称命题公式</strong>：</p><ol><li>（基础）命题常元或者命题变元；</li><li>（归纳）如果 $A$ 与 $B$ 是命题公式，那么 $\displaystyle \neg A$ 、$\displaystyle A\wedge B$、$\displaystyle A\vee  B$、$\displaystyle A\longrightarrow B$、$\displaystyle A\longleftrightarrow  B$ 是命题公式；</li><li>（极小性）只有有限次的应用（1）和（2）生成的表达式才是命题合式公式。</li></ol><p><strong>定义1.2.3 如果 $B$ 是命题公式 $A$ 的一个连续段，并且 $B$ 也是命题公式，则称 $B$ 是 $A$ 的一个子公式</strong>。</p><p>例如： $P$ 是 $\displaystyle \neg P$ 的子公式。</p><p>命题联结词的运算优先级为：</p><script type="math/tex; mode=display">\neg\quad  \wedge \quad \vee \quad \longrightarrow \quad \longleftrightarrow</script><p><strong>定义1.2.4 把一个用自然语言叙述的命题写成与之内涵相同的命题公式的形式，称为命题的符号化</strong>。</p><h2 id="2-2-命题公式的赋值"><a href="#2-2-命题公式的赋值" class="headerlink" title="2.2 命题公式的赋值"></a>2.2 命题公式的赋值</h2><p>命题公式的真值取决于所含命题变元的真值。</p><p><strong>定义1.2.5 设 $\displaystyle p_{1} ,p_{2} ,\dots ,p_{n} $ 是命题公式的变元，如果给 $\displaystyle p_{1} ,p_{2} ,\dots ,p_{n} $ 指定一组真值，则称为对命题公式 $A$ 的赋值（指派或者解释）</strong>。</p><p>对于含有 $n$ 个命题变元的命题公式，有 $\displaystyle 2^{n} $ 种情况，可以采用真值表的形式：</p><ol><li>将公式中的 $n$ 个命题变元按照字典升序或者降序排列（例如：$A,B,C,D,\cdots$​）；</li><li>对 $\displaystyle 2^{n} $ 个不同的赋值，按其对应的 $n$ 位二进制数从小到大或者从大到小排列；</li><li>如果公式比较复杂，可以从内层向外层先列出各子公式的真值，最后列出所求公式的真值。</li></ol><p><strong>定义1.2.6 给定一个命题公式，如果在任何赋值下，它的真值都为 $T$ ，则称该命题公式为<u>重言式或者永真式</u></strong>。</p><p><strong>定义1.2.7 给定一个命题公式，如果在任何赋值下，它的真值都为 $F$ ，则称该命题公式为<u>矛盾式或者永假式</strong>。</p><p><strong>定义1.2.8 给定一个命题公式，如果它既不是永真式，也不是永假式，成该命题为偶然式</strong>。</p><h1 id="三、逻辑等价与蕴含"><a href="#三、逻辑等价与蕴含" class="headerlink" title="三、逻辑等价与蕴含"></a>三、逻辑等价与蕴含</h1><h2 id="3-1-等价"><a href="#3-1-等价" class="headerlink" title="3.1 等价"></a>3.1 等价</h2><p><strong>定义1.3.1 给定两个命题公式 $A$ 和 $B$ ，设 $\displaystyle p_{1} ,p_{2} ,\dots ,p_{n} $ 为所有出现在 $A$ 和 $B$ 中的命题变元，但是 $\displaystyle P_{i} $ 不一定在 $A$ 和 $B$ 中同时出现。如果对 $\displaystyle p_{1} ,p_{2} ,\dots ,p_{n} $ 的任一赋值， $A$ 和 $B$ 的真值都相同，则称 $A$ 和 $B$ 逻辑<u>等价</u>，记作 $\displaystyle A\Longleftrightarrow B$ ，读作 “ $A$ 等价于 $B$​​ ”</strong>。</p><hr><p>基本等价关系：</p><div class="table-container"><table><thead><tr><th style="text-align:center">定律</th><th style="text-align:center">定律描述</th><th style="text-align:center">定律代号</th></tr></thead><tbody><tr><td style="text-align:center">对合律</td><td style="text-align:center">$\neg \neg A\Longleftrightarrow A$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">等幂律</td><td style="text-align:center">$\displaystyle P\wedge P\Longleftrightarrow P$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$\displaystyle P\vee P\Longleftrightarrow P$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">交换律</td><td style="text-align:center">$\displaystyle P\wedge Q\Longleftrightarrow Q\wedge P$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$\displaystyle P\vee Q\Longleftrightarrow Q\vee P$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">结合律</td><td style="text-align:center">$\displaystyle P\wedge (Q\wedge R) = (P\wedge Q)\wedge R$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$\displaystyle P\vee (Q\vee R) = (P\vee Q)\vee R$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">分配律</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><hr><blockquote><p>判断两个命题公式 $A、B$ 是否等价，如果所含的命题变元较少，则采用真值表的方法；但是如果</p></blockquote><p><strong>定理1.3.1（代入规则） 设 $A、B$ 是命题公式，其中 $A$ 是重言式（永真式），$P$ 是 $A$ 中的命题变元，如果将 $A$ 中每一处出现的 $P$ 均用 $B$ 代入，则所得的命题公式 $A^{‘}$ 仍是一个重言式</strong>。</p><p><strong>定理1.3.2 设 $A、B$ 是命题公式，则 $A$ 和 $B$ 逻辑等价，当且仅当 $\displaystyle A\longleftrightarrow B$​ 是一个重言式</strong>。</p><p><strong>定理1.3.3（替换规则） 设 $A,X,Y$ 是命题公式， $X$ 是 $A$ 的子公式，且有 $\displaystyle X\Longleftrightarrow Y$。如果将 $A$ 中的 $X$ 用 $Y$ 来替换，则所得到的公式 $B$ 与 $A$ 等价，即 $\displaystyle A\Longleftrightarrow B$</strong>。</p><p><strong>定理1.3.4（传递规则） 设 $A,B,C$ 是命题公式，如果 $\displaystyle A\Longleftrightarrow B$ 且 $\displaystyle B\Longleftrightarrow C$ ，则有 $\displaystyle A\Longleftrightarrow C$</strong>。</p><h2 id="3-2-蕴含"><a href="#3-2-蕴含" class="headerlink" title="3.2 蕴含"></a>3.2 蕴含</h2><p><strong>定义1.3.2 设 $A,B$ 是命题公式，如果 $\displaystyle A\longrightarrow B$ 是一个重言式，则称 $A$ 蕴含 $B$ ，记作 $\displaystyle A\Longrightarrow  B$​</strong>。</p><p>证明 $\displaystyle A\Longrightarrow  B$ 的两种常见方法：</p><ul><li>肯定前件法：假设 $A$ 为 $T$ ，如果能够推出 $B$ 为 $T$ ，则 $\displaystyle A\Longrightarrow  B$；</li><li>否定后件法：假设 $B$ 为 $F$ ，如果能够推出 $A$ 为 $F$ ，则 $\displaystyle A\Longrightarrow  B$。</li></ul><p><strong>定理1.3.5 设 $A$ 和 $B$ 是任意的两个命题公式， $\displaystyle A\Longleftrightarrow B$ 当且仅当 $\displaystyle A\Longrightarrow B$ 且 $\displaystyle B\Longrightarrow A$​</strong>。</p><p>设 $A,B,C$ 是命题公式</p><ol><li>性质1：如果 $\displaystyle A\Longrightarrow B$ 并且 $A$ 是重言式，则 $B$ 也是重言式；</li><li>性质2：如果 $\displaystyle A\Longrightarrow B$ 并且 $\displaystyle B\Longrightarrow C$ ，则 $\displaystyle A\Longrightarrow C$ ，即蕴含关系是传递的；</li><li>性质3：如果 $\displaystyle A\Longrightarrow B$ 并且 $\displaystyle A\Longrightarrow C$ ，则 $\displaystyle A\Longrightarrow B\wedge C$ ；</li><li>性质4：如果 $\displaystyle A\Longrightarrow C$ 并且 $\displaystyle B\Longrightarrow C$ ，则 $\displaystyle A\vee B\Longrightarrow C$ 。</li></ol><h1 id="四、联结词的完备集"><a href="#四、联结词的完备集" class="headerlink" title="四、联结词的完备集"></a>四、联结词的完备集</h1><p>条件否定：</p><script type="math/tex; mode=display">\displaystyle P\xi Q\neg (P\longrightarrow Q)</script><p>异或（不可兼得）：</p><script type="math/tex; mode=display">\displaystyle P\oplus Q \Longleftrightarrow \neg (P\longleftrightarrow Q)\Longleftrightarrow(P\wedge \neg Q)\vee (\neg P\wedge Q)</script><p>或非：</p><script type="math/tex; mode=display">\displaystyle P\downarrow Q\Longleftrightarrow \neg (P\wedge Q)</script><p>与非：</p><script type="math/tex; mode=display">\displaystyle P\uparrow Q\Longleftrightarrow \neg (P\wedge Q)</script><p>对于二元运算，有两个命题变元参与玉奴三，共有 4 种赋值，则有 16 种可能的运算结果：</p><div class="table-container"><table><thead><tr><th style="text-align:center">P</th><th style="text-align:center">Q</th><th style="text-align:center">F1</th><th style="text-align:center">F2</th><th style="text-align:center">F3</th><th style="text-align:center">F4</th><th style="text-align:center">F5</th><th style="text-align:center">F6</th><th style="text-align:center">F7</th><th style="text-align:center">F8</th><th style="text-align:center">F9</th><th style="text-align:center">F10</th><th style="text-align:center">F11</th><th style="text-align:center">F12</th><th style="text-align:center">F13</th><th style="text-align:center">F14</th><th style="text-align:center">F15</th><th style="text-align:center">F16</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">永假式</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">永真式</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><p><strong>定义1.4.1 给定一个联结词集合，如果所有的命题公式都能用其中的联结词等价表示出来,则称该联结词集合为全功能联结词集合，或称该联结词集合是功能完备的(functionally complete)</strong>。</p><p><strong>定义1.4.2 一个联结词集合是全功能的,并且去掉其中任意一个联结词后均不是全功能的，则称其为<u>极小全功能联结词集合</u></strong>。</p><h1 id="五、对偶式"><a href="#五、对偶式" class="headerlink" title="五、对偶式"></a>五、对偶式</h1><p><strong>定义1.5.1 设有命题公式 $A$ ，其中仅含有联结词 $\neg $ 、$\vee $ 和 $\wedge $ ，如果将 $A$ 中的 $\vee $ 换成 $\wedge $ ， $\wedge $ 换成 $\vee $ ，常元 F 和 T 也互相替换，所得公式记做 $\displaystyle A^{\star }$，则称 $\displaystyle A^{\star }$ 为 $A$ 的对偶(dual)公式。显然， $A$ 也是 $\displaystyle A^{\star }$ 的对偶公式，即对偶是相互的,即 $\displaystyle (A^{\star })^{\star } $​ </strong>。</p><p><strong>定理1.5.1</strong>：设 $A$ 和 $\displaystyle A^{\star }$ 是对偶式，其中仅含有联结词 $\neg $ 、$\vee $ 和 $\wedge $ ，$\displaystyle P_{1} ,P_{2},\dots ,P_{n}$ 是出现在 $A$ 和 $\displaystyle A^{\star }$ 中所有命题变元，于是有：</p><script type="math/tex; mode=display">\begin{align}\displaystyle &\neg A(\displaystyle P_{1} ,P_{2},\dots ,P_{n})\Longleftrightarrow  A^{\star } (\displaystyle \neg P_{1} ,\neg P_{2},\dots ,\neg P_{n})\\\displaystyle &A(\displaystyle \neg P_{1} ,\neg P_{2},\dots ,\neg P_{n})\Longleftrightarrow  \neg A^{\star } (\displaystyle P_{1} ,P_{2},\dots ,P_{n})\\\end{align}</script><p><strong>定理1.5.2</strong>：设 $A$ 和 $B$ 是命题公式， $\displaystyle P_{1} ,P_{2},\dots ,P_{n}$ 是出现在 $A$ 和 $B$ 中的命题变元，则有：</p><ol><li>如果 $A\Longleftrightarrow B$ ，则 $A^{\star } \Longleftrightarrow B^{\star } $ ；</li><li>如果 $A\Longrightarrow B$ ，则 $A^{\star }\Longrightarrow B^{\star } $​ 。</li></ol><h1 id="六、范式"><a href="#六、范式" class="headerlink" title="六、范式"></a>六、范式</h1><h2 id="6-1-析取范式和合取范式"><a href="#6-1-析取范式和合取范式" class="headerlink" title="6.1 析取范式和合取范式"></a>6.1 析取范式和合取范式</h2><p><strong>定义1.6.1</strong>：仅由若干命题变元和若干命题变元之否定通过联结词 $\vee $​​ 构成的命题公式，称为<strong>析取式</strong>。</p><p><strong>定义1.6.2</strong>：仅由若干命题变元和若干命题变元之否定通过联结词 $\wedge $​​ 构成的命题公式，称为<strong>合取式</strong>。</p><p><strong>定义1.6.3</strong>：一个命题公式称为析取范式，当且仅当它具有如下形式：</p><script type="math/tex; mode=display">A_{1}\vee  A_{2}\vee \cdots A_{b}</script><p>其中， $\displaystyle A_{1} ,A_{2},\dots ,A_{n}$​ 是合取式。</p><p><strong>定义1.6.4</strong>：一个命题公式称为合取范式，当且仅当它具有如下形式：</p><script type="math/tex; mode=display">A_{1}\wedge A_{2}\wedge \cdots \wedge A_{b}</script><p>其中， $\displaystyle A_{1} ,A_{2},\dots ,A_{n}$​ 是析取式。</p><p><strong>定理（范式存在定理）</strong>：任意命题公式都存在玉器等值的析取范式和合取范式</p><p>对于任何一个命题公式，都可以求得它的析取范式或者合取范式，步骤如下：</p><ol><li>将公式中的联结词都归约成 $\neg $ 、$\vee $ 和 $\wedge $；</li><li>利用<strong>德·摩根定律</strong>将否定联结词 $\neg $ 直接移到各命题变元之前；</li><li>利用分配律、结合律将公式归约成合取范式或者析取范式。</li></ol><h2 id="6-2-主析取范式"><a href="#6-2-主析取范式" class="headerlink" title="6.2 主析取范式"></a>6.2 主析取范式</h2><blockquote><p>一个命题公式的合取范式或析取范式是存在的，但并不一定是唯一的，为了使任意一个命题公式都能转化成唯一的标准形式，引入主范式的概念。</p></blockquote><p><strong>定义1.6.5</strong>：一个含 $n$ 个命题变元的合取式，如果其中每个变元与其否定<strong>不同时存</strong>在，但两者之一<strong>必须出现且仅出现一次</strong>，则称该合取式为<strong>布尔合取或者极小项(minterm)</strong>。</p><p> $n$ 个命题变元 $P_{1} ,P_{2} ,\cdots ,P_{n} $ 构成的极小项具有如下性质：</p><ol><li><p>每一个极小项当<strong>其真值指派与编码相同</strong>时，其真值为 $T$ ，在其余 $\displaystyle 2^{n} -1$ 种赋值下其真值均为 $F$ ；</p></li><li><p>任意两个不同极小项的合取式永假，即</p><script type="math/tex; mode=display"> \displaystyle m_{i} \wedge m_{j} \Longleftrightarrow F</script></li><li><p>所有极小项的析取式永真，记为</p><script type="math/tex; mode=display"> \displaystyle \sum_{i=0}^{2^{n}-1 } m_{i} \Longleftrightarrow m_{0} \vee m_{1} \vee \cdots \vee m_{2^{n} -1} \Longleftrightarrow T</script></li></ol><p><strong>定义1.6.6</strong>：设 $P_{1} ,P_{2} ,\cdots ,P_{n} $ 是命题公式 $A$ 中包含的所有命题变元，若由 $P_{1} ,P_{2} ,\cdots ,P_{n} $ 的<strong>若干极小项析取</strong>所构成的析取范式与 $A$ 等价，则称该析取范式为 <strong>$A$​ 的主析取范式(principle disjunctive normal form)</strong>。</p><p><em>对于一个给定的命题公式，可以用构造真值表的方法求得它的主析取范式</em>。</p><blockquote><p>将一个极小项用二进制表示，用其真直指派作为 “0/1” 值，按照当前的形式进行编码赋值。例如： $\displaystyle \neg P\wedge Q\wedge \neg R$ 对应的编码为：<code>010</code> 。</p></blockquote><p><strong>定理1.6.1</strong>：在一个命题公式 $A$ 的真值表中，使 $A$ 的真值为 $T$ 的所有赋值所对应的极小项构成的析取范式，即为 $A$ 的主析取范式。</p><p>任何一个命题公式都可以求得它的析取范式，而析取范式可转化为主析取范式，步骤如下：</p><ol><li>将原命题公式转化为析取范式；</li><li>将每个合取式等价变换为若干极小项的析取（<strong>对每个合取式填补没有出现的变元，如缺 $P$ 和 $\displaystyle \neg P$ ，则合取 $\displaystyle \neg P\vee P$ ，再应用分配律展开</strong>）；</li><li>重复的极小项只保留一个。</li></ol><p>例如：求命题公式 $\displaystyle \neg P\wedge (Q\longrightarrow R)$ 的主析取范式：</p><script type="math/tex; mode=display">\begin{align}\text{解：}\quad &\\&\neg P\wedge (Q\longrightarrow R)\\\Longleftrightarrow &\neg P\wedge (\neg Q\vee R)\\\Longleftrightarrow &(\neg P\wedge \neg Q)\vee (\neg P\wedge R)\\\Longleftrightarrow &(\neg P\wedge \neg Q\wedge {\color{Red} (\neg R\vee R}) )\vee (\neg P\wedge {\color{Red} (\neg Q\vee Q)} \wedge R)\\\Longleftrightarrow &(\neg P\wedge \neg Q\wedge \neg R)\vee \underline{(\neg P\wedge \neg Q\wedge R )} \vee \underline{(\neg P\wedge  \neg Q\wedge R)} \vee (\neg P\wedge  Q\wedge R)\\\Longleftrightarrow &(\neg P\wedge \neg Q\wedge \neg R)\vee (\neg P\wedge  \neg Q\wedge R)\vee (\neg P\wedge  Q\wedge R)\\\Longleftrightarrow & m_{000} \vee m_{001}\vee m_{011}\\\Longleftrightarrow &\displaystyle \sum (0,1,3)\end{align}</script><h2 id="6-3-主合取范式"><a href="#6-3-主合取范式" class="headerlink" title="6.3 主合取范式"></a>6.3 主合取范式</h2><blockquote><p>与主析取范式相对应的还有主合取范式。下面介绍主合取范式的相关概念以及求一个命题公式的主合取范式的方法。</p></blockquote><p><strong>定义1.6.7</strong> 一个含 $n$ 个命题变元的析取式，如果其中每个变元与其否定<strong>不同时存</strong>在，但两者之一<strong>必须出现且仅出现一次</strong>，则称该析取式为<strong>布尔析取或者极大项(minterm)</strong>。</p><p> $n$ 个命题变元 $P_{1} ,P_{2} ,\cdots ,P_{n} $ 构成的<strong>极大项</strong>具有如下性质：</p><ol><li><p>每一个极大项当<strong>其真值指派与编码相同</strong>时，其真值为 $F$ ，在其余 $\displaystyle 2^{n} -1$ 种赋值下其真值均为 $T$ ；</p></li><li><p>任意两个不同极大项的析取式永真，即</p><script type="math/tex; mode=display"> \displaystyle M_{i} \vee  M_{j} \Longleftrightarrow T</script></li><li><p>所有极大项的合取式永假，记为</p><script type="math/tex; mode=display"> \displaystyle \prod _{i=0}^{2^{n}-1 } M_{i} \Longleftrightarrow M_{0} \wedge M_{1} \wedge \cdots\wedge M_{2^{n} -1} \Longleftrightarrow F</script></li></ol><p><strong>定义1.6.8</strong>：设 $P_{1} ,P_{2} ,\cdots ,P_{n} $ 是命题公式 $A$ 中包含的所有命题变元，若由 $P_{1} ,P_{2} ,\cdots ,P_{n} $ 的<strong>若干极大项析取</strong>所构成的合取范式与 $A$ 等价，则称该合取范式为 <strong>$A$​ 的主合取范式(principle disjunctive normal form)</strong>。</p><p><em>对于一个给定的命题公式，可以用构造真值表的方法求得它的主合取范式</em>。</p><p><strong>定理1.6.2</strong>：在一个命题公式 $A$ 的真值表中，使 $A$ 的真值为 $F$ 的所有赋值所对应的极大项构成的合取范式，即为 $A$ 的主析取范式。</p><p>任何一个命题公式都可以求得它的合取范式，而合取范式可转化为主合取范式，步骤如下：</p><ol><li>将原命题公式转化为合取范式；</li><li>将每个合取式等价变换为若干极大项的合取（<strong>对每个析取式填补没有出现的变元，如缺 $P$ 和 $\displaystyle \neg P$ ，则析取 $\displaystyle \neg P\wedge P$ ，再应用分配律展开</strong>）；</li><li>重复的极大项只保留一个。</li></ol><p><strong>定理1.6.3</strong>：已知由 $n$ 个不同命题变元构成的命题公式 $A$ 的主析取范式为 $\displaystyle \sum (i_{1}, i_{2},\cdots ,i_{k})$ ，其主合取范式为 $\displaystyle \prod (j_{1}, j_{2},\cdots ,j_{t})$ ，则有：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \left \{ i_{1}, i_{2},\cdots ,i_{k} \right \} \cup \left \{ j_{1}, j_{2},\cdots ,j_{t} \right \}={0,1,2,\cdots ,2^{n}-1 } \\\displaystyle \left \{ i_{1}, i_{2},\cdots ,i_{k} \right \} \cap \left \{ j_{1}, j_{2},\cdots ,j_{t} \right \}=\emptyset \\\end{align}</script><blockquote><p>上述定理表明，对对于一个命题变元的主析取范式与主合取范式所对应的真值指派集，在全集里面是<strong>互补的</strong>。</p></blockquote><h1 id="七、命题逻辑的推理理论"><a href="#七、命题逻辑的推理理论" class="headerlink" title="七、命题逻辑的推理理论"></a>七、命题逻辑的推理理论</h1><blockquote><p>在现实生活和科学研究活动中，经常要进行推理，即从某些假设(hypothesis)或前提(premises)出发，使用一些公认的规则和已知的公理、定理、推论等进行逻辑推演，从而形成结论(conclusion)。其中有一些推理，只需要分析前提和它们之间的联结词，就可以直接得到相关结论。但是在大多数情况下，结论需要复杂的推演过程才能得到。</p></blockquote><p><strong>定义1.7.1</strong>：设 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ ， $C$ 是命题公式，若 $\displaystyle H_{1}\wedge H_{2} \wedge \cdots \wedge H_{n} \Longrightarrow C$ ，则称 $C$ 是一组前提 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ 的有效结论(valid conclusion)，或者称 $C$ 可由前提 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ 逻辑推出。从前提 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $​ 推出结论的过程，称为<strong>推理(reasoning)、论证(argument)或证明(proof)</strong>。</p><p><strong>等价公式</strong>和<strong>蕴含公式</strong>都可以作为推理规则使用。另外，在推理过程中还有两条常用的重要推理规则：</p><ul><li><strong>P规则</strong>:在推导过程中，前提可以在任何步骤引入；</li><li><strong>T规则</strong>:在推导过程中，如果由已经推出的一个或多个公式蕴含S,则公式S可以引人到推导过程中。判别结论是否有效有各种不同的方法。下面介绍几种常用的证明方法。</li></ul><p><strong>方法1</strong>：无义证明法。如果能够证明 P 恒为<strong>假</strong>，则有 $P\longrightarrow Q$ <strong>恒为真</strong>，即 $P\Longrightarrow Q$ 。</p><p><strong>方法2</strong>：平凡证明法。如果能够证明 Q 恒为<strong>真</strong>，则有 $P\longrightarrow Q$ <strong>恒为真</strong>，即 $P\Longrightarrow Q$ 。</p><p><strong>方法3</strong>：直接证明法。直接证明法就是从一组前提出发，利用公认的推理规则(等价公式、蕴含公式、P规则、T规则)，逻辑演绎得到有效结论。</p><p><strong>方法4</strong>：归谬法。（反证法）</p><p><strong>定义1.7.2</strong>：设 $P_{1} ,P_{2} ,\cdots ,P_{n} $ 是命题公式 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ 中的所有命题变元，如果存在 $P_{1} ,P_{2} ,\cdots ,P_{n} $ 的一种赋值,使得 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ 的真值为 <code>T</code> ，则称命题公式集合($\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $)是<strong>一致的或相容的</strong>；否则，称为<strong>不一致的或不相容的</strong>。</p><p><em>因为当( $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ )不相容时， $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ 的真值恒为 <code>F</code> ，所以这个定义的另一种等价说法是：设 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ 是公式,若存在公式R,使得H，H,,…,H„→RΛ-R,则称命题公式集合($\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $)是不一致的或不相容的，否则称为一致的或相容的</em>。</p><p><strong>定理1.7.1</strong>： $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ ， $C$ 是公式，如果存在公式 $R$ ,使得 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} \neg C\Longrightarrow R\wedge \neg R$ ，则有 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} \Longrightarrow C$ 。</p><p><strong>方法5</strong>：CP规则法。</p><p>设 $\displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} $ ， $R,C$ 是命题公式，根据输出律 $E_{22}$ 推知 $\displaystyle (H_{1}\wedge H_{2}\wedge \cdots\wedge H_{n})\longrightarrow (R\longrightarrow C)\Longleftrightarrow (H_{1}\wedge H_{2}\wedge \cdots\wedge H_{n}\wedge R)\longrightarrow C$ 。因此，如果能够证明 $\displaystyle \displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} ,R\Longrightarrow C$ ，则有 $\displaystyle \displaystyle H_{1} ,H_{2} ,\cdots ,H_{n} \Longrightarrow R\longrightarrow C$ 成立。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机学习 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 离散数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限状态机【Unity】</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/06.%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/01.%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/06.%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/01.%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是有限状态机"><a href="#什么是有限状态机" class="headerlink" title="什么是有限状态机"></a>什么是有限状态机</h1><p>有限状态机(Finite state machine)是非常重要的一个概念，是一种用来进行对象行为建模的工具，其作用主要是<strong>描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件</strong>。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。其实，有限状态机的概念和应用遍布生活中的每一个角落。</p><p>有限状态机有两个主要特征：状态是有限的，同一时刻只能存在一种状态；一般归为4个要素，即：现态、条件、动作、次态。“现态”和“条件”是原因，“动作”和“次态”是结果。详解如下：</p><ol><li><p>现态：是指当前所处的状态；</p></li><li><p>条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移；</p></li><li><p>动作：条件满足后执行的动作。</p><p> 动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态；</p></li><li><p>次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</p></li></ol><h1 id="Unity中实现FSM"><a href="#Unity中实现FSM" class="headerlink" title="Unity中实现FSM"></a>Unity中实现FSM</h1><h2 id="1-框架结构"><a href="#1-框架结构" class="headerlink" title="1 框架结构"></a>1 框架结构</h2><p><img src="https://imagehost.yuilexi.cn/Blog/Post/02.Unity游戏开发_全栈学习/06.经典功能实现/01.有限状态机.md/FSM框图.svg" alt="FSM框图"></p><h2 id="2-代码结构"><a href="#2-代码结构" class="headerlink" title="2 代码结构"></a>2 代码结构</h2><p>首先，定义一个接口：<code>IState</code>，该结构声明三个状态的基础方法：进入状态<code>OnEnterState</code>、更新状态<code>OnUpdateState</code>、退出状态<code>OnExitState</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 进入状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnterState</span>()</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 更新状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnUpdateState</span>()</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 退出状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExitState</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有状态都要继承该接口，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">State1</span> : <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnterState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 代码;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnUpdateState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 代码;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExitState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 代码;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">State2</span> : <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnterState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 代码;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnUpdateState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 代码;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExitState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 代码;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p>然后构造一个FSM的抽象父类，需要继承自<code>MonoBehaviour</code>，里面包含<strong>当前状态字段</strong>、<strong>状态切换方法</strong>，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FSM</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> IState _currentState;</span><br><span class="line">    <span class="keyword">protected</span> Dictionary&lt;T, IState&gt; _stateDic = <span class="keyword">new</span> Dictionary&lt;T, IState&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化状态机</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化状态机的状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Start</span>()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 更新状态机</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_currentState != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _currentState.OnUpdateState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 状态切换</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;stateType&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;Exception&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TransitionState</span>(<span class="params">T stateType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_currentState != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _currentState.OnExitState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _currentState = _stateDic.TryGetValue(stateType);</span><br><span class="line">        <span class="keyword">if</span> (_currentState == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;状态机中没有找到对应的状态：<span class="subst">&#123;stateType&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _currentState.OnEnterState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的FSM类使用了泛型，泛型参数是不同对象的状态枚举类型，例如：玩家有Idle、Move、Attack等状态，将这些状态定义为枚举变量，即为FSM抽象父类的泛型参数。使用抽象泛型的目的是为了，是不同的对象可以有不同的状态机来控制，不同对象的状态条件不同，但是状态的切换和更新功能是一致的，</p><p>FSM类里面有两个字段：</p><ul><li><code>_currentState</code> ：存放当前对象的当前状态；</li><li><code>_stateDic</code>：存放当前对象的所有状态类型，并且以状态枚举值作为字典的键，以状态对象作为字典的值。</li></ul><p>FSM还要构造出抽象的 <code>Awake()</code> 与 <code>Start()</code> 函数，其目的是为继承的子类去初始化状态机，特别向字典中添加所有的状态类型。</p><p>FSM里面还包括两个虚函数 <code>Update()</code> 和 <code>TransitionState(T stateType)</code> ，前者是状态更新函数，后者是状态切换函数，使用虚函数，便于子类进行多态扩展。</p><h2 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3 具体实现"></a>3 具体实现</h2><p>根据上述提供的状态接口和FSM父类，实现一个具体对象的状态：</p><p>1.玩家的状态枚举：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 玩家的状态枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> PlayerStateEnum</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>, <span class="comment">// 无状态</span></span><br><span class="line">    Idle = <span class="number">1</span>, <span class="comment">// 空闲</span></span><br><span class="line">    Move = <span class="number">2</span>, <span class="comment">// 移动状态</span></span><br><span class="line">    Attack = <span class="number">3</span>, <span class="comment">// 攻击状态</span></span><br><span class="line">    Hurt = <span class="number">4</span>, <span class="comment">// 受伤状态</span></span><br><span class="line">    Dead = <span class="number">5</span>, <span class="comment">// 死亡状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.玩家的所有状态：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 空闲状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IdleState</span> : <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PlayerFSM _fsm; <span class="comment">// 对该状态对象所在状态机对象的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdleState</span>(<span class="params">PlayerFSM fsm</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _fsm = fsm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdleState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;创建Idle状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnterState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;进入Idle状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdateState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExitState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;退出Idle状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AttackState</span> : <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PlayerFSM _fsm;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AttackState</span>(<span class="params">PlayerFSM fsm</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _fsm = fsm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnterState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;进入Attack状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdateState</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExitState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;退出Attack状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他状态......</span></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p>3.玩家的FSM</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem; <span class="comment">// 引入Unity的InputSystem命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerFSM</span> : <span class="title">FSM</span>&lt;<span class="title">PlayerStateEnum</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> PlayerProperty _playerProperty; <span class="comment">// 玩家属性</span></span><br><span class="line">    <span class="keyword">private</span> Vector2 _moveDirection; <span class="comment">// 移动方向</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 MoveDirection =&gt; _moveDirection; <span class="comment">// 移动方向</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _stateDic.Add(PlayerStateEnum.Idle, <span class="keyword">new</span> IdleState(<span class="keyword">this</span>));</span><br><span class="line">        _stateDic.Add(PlayerStateEnum.Move, <span class="keyword">new</span> MoveState(<span class="keyword">this</span>));</span><br><span class="line">        _stateDic.Add(PlayerStateEnum.Attack, <span class="keyword">new</span> AttackState(<span class="keyword">this</span>));</span><br><span class="line">        _stateDic.Add(PlayerStateEnum.Hurt, <span class="keyword">new</span> HurtState(<span class="keyword">this</span>));</span><br><span class="line">        _stateDic.Add(PlayerStateEnum.Dead, <span class="keyword">new</span> DeadState(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        TransitionState(PlayerStateEnum.Idle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 玩家移动状态切换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnMove</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _moveDirection = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line">        <span class="keyword">if</span> (context.performed)</span><br><span class="line">        &#123;</span><br><span class="line">            TransitionState(PlayerStateEnum.Move);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (context.canceled)</span><br><span class="line">        &#123;</span><br><span class="line">            TransitionState(PlayerStateEnum.Idle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAttack</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.performed)</span><br><span class="line">        &#123;</span><br><span class="line">            TransitionState(PlayerStateEnum.Attack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (context.canceled)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_moveDirection != Vector2.zero)</span><br><span class="line">            &#123;</span><br><span class="line">                TransitionState(PlayerStateEnum.Move);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                TransitionState(PlayerStateEnum.Idle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnHurt</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.performed)</span><br><span class="line">        &#123;</span><br><span class="line">            TransitionState(PlayerStateEnum.Hurt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4 扩展"></a>4 扩展</h2><p>根据上面的结构，就可以在具体的状态中，调整玩家的各项属性和行为，建议将玩家的属性和各种组件放在FSM中，便于不用的状态进行引用修改。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 经典功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> Csharp </tag>
            
            <tag> 有限状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一)DOTS基础—1. 认识DOTS</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/DOTS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/(%E4%B8%80)DOTS%E4%BB%8B%E7%BB%8D.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/DOTS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/(%E4%B8%80)DOTS%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="DOTS架构"><a href="#DOTS架构" class="headerlink" title="DOTS架构"></a>DOTS架构</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Unity中，<code>DOTS</code>代表的是”<strong>Data-Oriented Technology Stack</strong>“，官方中文名字是<strong>多线程面向数据的技术堆栈 </strong>，是一种用于游戏开发的技术堆栈。DOTS的目标是优化游戏引擎的性能，使开发者能够更好地利用现代硬件的多核处理能力和内存体系结构。</p><p>DOTS包含了一系列的工具、框架和技术，其中最重要的包括：</p><ol><li><strong>Entity Component System (ECS)</strong>：这是DOTS的核心，它是一种用于构建游戏对象和组件的新的架构。ECS将游戏对象拆分为实体（Entities）和组件（Components），并通过系统（Systems）来处理数据和逻辑。这种数据导向的方式可以更好地利用多核处理器，提高性能。</li><li><strong>Burst Compiler</strong>：Burst Compiler是一种使用LLVM从IL/.NET字节码转换为高度优化的本机代码的编译器，可以生成高度优化的本地机器码，提高代码的执行效率。它能通过编译本地代码，极大提高代码的运行效率 10-1000倍不等，当我们在加入Jobsystem进行并行计算的时候，运行效率会进一步提升。</li><li><strong>Jobs System</strong>：Jobs System允许开发者编写高性能的并行代码，能够更有效地利用多核处理器。通过JobSystem让我们需要大量计算的程序，以并行的方式，放入多个子线程中进行计算，这样能大大提升为我们的计算效率，其实也就是提升性能！</li><li>Unity Physics：Unity Physics是一个用于模拟物理行为的引擎，可以与ECS结合使用，实现高性能的物理模拟。</li><li>Unity Collections：这是一组优化过的集合类型，用于在ECS架构中存储和处理数据。</li></ol><p>DOTS的引入旨在解决传统游戏引擎在大规模游戏中性能问题的挑战，但也需要开发者学习新的编程模式和工具。虽然DOTS在性能方面有很多优势，但在选择是否使用时，开发者需要权衡其带来的学习成本和适用性。</p><p>在Unity发布的 <code>2022LTS</code> 版本中，全面支持 <code>ECS</code> 架构，并且实现对 DOTS 的支持。</p><h2 id="DOTS应用"><a href="#DOTS应用" class="headerlink" title="DOTS应用"></a>DOTS应用</h2><ul><li>具有大世界流式加载的游戏</li><li>具有复杂的大规模模拟的游戏</li><li>具有多种网络类型的多人连线游戏</li><li>具有需要客户端模拟预测的网络游戏，如射击游戏</li></ul><h1 id="ECS架构"><a href="#ECS架构" class="headerlink" title="ECS架构"></a>ECS架构</h1><h2 id="什么是ECS？"><a href="#什么是ECS？" class="headerlink" title="什么是ECS？"></a>什么是ECS？</h2><p>说起 ECS 架构（面向数据编程），就不得不提到传统的面向对象编程（Object-Oriented Programming，简称OOP）。</p><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>面向对象编程（Object-Oriented Programming，简称OOP）是一种编程范式，它的核心思想是通过将<strong>数据</strong>和<strong>操作数据的方法</strong>组合成对象，以模拟现实世界的实体和交互。OOP强调数据和方法的封装、继承和多态性，旨在提高代码的可维护性、可扩展性和重用性。</p><p><img src="https://imageshack.yuilexi.cn/(%E4%B8%80)DOTS%E5%9F%BA%E7%A1%80%E2%80%941-%E8%AE%A4%E8%AF%86DOTSOOP%E7%BB%93%E6%9E%84.svg" alt="OOP结构" style="zoom:50%" /></p><p>在Unity中，使用传统的面向对象编程技术，是依赖<strong>多重继承</strong>的方式实现的，虽然Unity中有<strong>组件系统</strong>，但是本质上，每一个对象都是<strong>数据和方法</strong>的集合体。</p><p><img src="https://imageshack.yuilexi.cn/(%E4%B8%80)DOTS%E5%9F%BA%E7%A1%80%E2%80%941-%E8%AE%A4%E8%AF%86DOTSOOP%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.svg" alt="OOP的多重继承" style="zoom:50%" /></p><blockquote><p>总结：面向数据编程，就是将<strong>数据</strong>和<strong>方法</strong>绑定在一起，形成一个集合体，称之为<strong>对象</strong>。其功能的实现通过封装、<strong>多重继承</strong>、多态的手段实现。</p></blockquote><h3 id="面向数据编程——ECS"><a href="#面向数据编程——ECS" class="headerlink" title="面向数据编程——ECS"></a>面向数据编程——ECS</h3><p>ECS即实体（Entity），组件（Component），系统（System），其中<strong>Entity，Component皆为纯数据向的类</strong>，<strong>System负责操控它们</strong>，这种模式会一定程度上优化我们的代码速度。</p><ul><li>Entities：游戏中的事物，但在ECS中它只作为一个Id，用于表示对应的对象。</li><li>Components：与Entity相关的数据，但是这些数据应该由Component本身而不是Entity来组织。（这种组织上的差异正是面向对象和面向数据的设计之间的关键差异之一）。</li><li>Systems：Systems是把Components的数据从当前状态转换为下一个状态的逻辑，但System本身应当是无状态的。例如，一个system可能会通过他们的速度乘以从前一帧到这一帧的时间间隔来更新所有的移动中的entities的位置。</li></ul><h2 id="ECS为什么快？"><a href="#ECS为什么快？" class="headerlink" title="ECS为什么快？"></a>ECS为什么快？</h2><p>首先明确几个知识点：</p><ol><li>CPU与Memory的速度发展不均衡以及带宽限制<ol><li>CPU处理数据的速度非常快，即CPU的处理速度远高于内存的读写速度，所以需要设计能跟上CPU的高速缓存区，来尽量保证CPU有事干，同时也提高了数据访问效率。</li><li>CPU自身有三级缓存，俗称高速缓存，CPU访问第一级（L1）缓存最快，容量最小，第三级（L3）缓存最慢，容量最大。</li><li>常说的内存是指CPU拿取数据的起源点，CPU访问内存所需的时钟周期，<strong>远大于</strong>访问高速缓存所需的时钟周期。</li><li>CPU操作数据会先从一，二，三级缓存中取得数据，速度非常快，尤其在一级缓存处速率基本可以满足CPU的需求（即不让CPU等待数据），但是有些情况下我们请求的数据不在这三级缓存中（即 <code>Cache Miss</code> ），就需要寻址到内存中的数据（<strong>包含这个数据的一整块数据都将被存入缓存</strong>），并且把目标数据放到高速缓存中，提高下一次的访问速度（因为这一次调用的数据块往往在不久的将来还会用到）。</li><li>因此，CPU指令跳转的次数越少，运算速度越快。最常见的例子就是在数据量小的情况下遍历数组会比遍历List快上很多，因为数组是有序的，而列表则是分散的，无序的。</li></ol></li><li>摩尔定律的延续和现代CPU工艺的设计<ol><li>越来越好的工艺</li><li>越来越多的核</li><li>分工越来越细的处理单元和存储</li><li>SIMD/SIMT</li></ol></li></ol><h3 id="ECS的数据组织与使用形式"><a href="#ECS的数据组织与使用形式" class="headerlink" title="ECS的数据组织与使用形式"></a>ECS的数据组织与使用形式</h3><p>在传统模式中，假设想要移动场景中的一个物体，那么我们会修改它的 <code>Position</code> ，但是使用的时候整个 <code>Transform</code> 都会被加到缓存当中，而 <code>Transform</code> 中有很多我们不需要的属性占用了很大的缓存空间，所以就造成了严重的内存浪费。</p><p>而ECS架构在执行逻辑时，只会操作需要操作的数据：System在操作数据的时候只会收集它关心的Component数据，CPU运行时就会将这一整块内存装入高速缓存中，这样就减少了<code>Cache Miss</code>次数，增加了缓存命中率，整体上提高了程序效率。</p><blockquote><p>ECS是数据组件化的，需要哪些数据，就声明哪些数据，不会造成上面那样严重的内存浪费！</p></blockquote><h2 id="ECS有什么优势"><a href="#ECS有什么优势" class="headerlink" title="ECS有什么优势"></a>ECS有什么优势</h2><p>对比传统的面向对象编程，ECS模式无疑更加适合现代CPU架构，因为它可以做到高效的处理数据，而不用把多余的数据字段存入宝贵的缓存，从而导致多次 <code>Cache Miss</code> 。 举个例子就是传统模式下我们操作Unity对象的Position属性，它会把GameObject所有相关数据都加入缓存，浪费了宝贵的缓存空间。 而如果在ECS模式下，将只会把Position属性集放入内存，节省了缓存空间，也一定程度上减少了Cache Miss，即常说的<code>提高缓存命中率</code>。</p><h1 id="Job-System"><a href="#Job-System" class="headerlink" title="Job System"></a>Job System</h1><h2 id="什么是Job-System？"><a href="#什么是Job-System？" class="headerlink" title="什么是Job System？"></a>什么是Job System？</h2><p>Job System （作业系统） 可以理解为多线程管理系统。通过Job System就可以编写与Unity其他部件交互的多线程代码，同时让编写正确的多线程代码变得更容易。编写多线程代码可以提供更好的性能表现。这包括极大的提升提升和手机上更久的续航。</p><p>Job System的一个非常关键的方面是它可以融入Unity内部的原生Job System。这使得用户的代码可以和Unity共享worker threads。这种合作避免了创建更多线程，因为这可能会造成对于CPU资源的争抢。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> DOTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOTS </tag>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 前导课【DOTS】</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/03.DOST%E6%A1%86%E6%9E%B6%E5%85%A8%E5%BA%94%E7%94%A8/01.%E5%89%8D%E5%AF%BC%E8%AF%BE%E3%80%90DOTS%E3%80%91.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/03.DOST%E6%A1%86%E6%9E%B6%E5%85%A8%E5%BA%94%E7%94%A8/01.%E5%89%8D%E5%AF%BC%E8%AF%BE%E3%80%90DOTS%E3%80%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="前导课"><a href="#前导课" class="headerlink" title="前导课"></a>前导课</h1><h1 id="一、什么是DOTS"><a href="#一、什么是DOTS" class="headerlink" title="一、什么是DOTS"></a>一、什么是DOTS</h1><p>DOTS的全称是<code>Data-Oriented-Tech-Stack</code>，官方的中文释义为：多线程式数据导向型技术堆栈。从名字就能得到两个关键性信息：多线程和面向数据。对于多线程，想必已经耳熟能详，这是现代多核CPU架构的结果；但是，什么是面向数据？（🤔一头雾水🤔），它和面向对象又有什么区别呢？</p><h2 id="1-1-DOTS的组成部分"><a href="#1-1-DOTS的组成部分" class="headerlink" title="1.1 DOTS的组成部分"></a>1.1 DOTS的组成部分</h2><p>DOTS并不是一个独立的框架，在Unity中，DOTS是由一下几个核心组件构成的，分别是：</p><ol><li>ECS架构：全称是<strong>Entity-Component-System</strong>，是一个代码框架，只需遵循该框架代码的编写方式，即可写出高性能的代码<br> 1. </li><li>Job System</li><li>Burst编译器</li></ol><h2 id="1-2-ECS概要"><a href="#1-2-ECS概要" class="headerlink" title="1.2 ECS概要"></a>1.2 ECS概要</h2><h2 id="1-3-Jobs概要"><a href="#1-3-Jobs概要" class="headerlink" title="1.3 Jobs概要"></a>1.3 Jobs概要</h2><h2 id="1-4-Burst概要"><a href="#1-4-Burst概要" class="headerlink" title="1.4 Burst概要"></a>1.4 Burst概要</h2><h1 id="二、DOTS的优点"><a href="#二、DOTS的优点" class="headerlink" title="二、DOTS的优点"></a>二、DOTS的优点</h1><h1 id="三、如何学习和使用DOTS"><a href="#三、如何学习和使用DOTS" class="headerlink" title="三、如何学习和使用DOTS"></a>三、如何学习和使用DOTS</h1>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> DOTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> DOTS </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust基础语法</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/01.Rust/01.Rust%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/01.Rust/01.Rust%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
          <category> Rust基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> Web开发 </tag>
            
            <tag> 操作系统开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 存储系统【计算机组成与系统结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/04.%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/04.%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="一、存储系统概述"><a href="#一、存储系统概述" class="headerlink" title="一、存储系统概述"></a>一、存储系统概述</h1><h2 id="1-1-存储系统的层次结构"><a href="#1-1-存储系统的层次结构" class="headerlink" title="1.1 存储系统的层次结构"></a>1.1 存储系统的层次结构</h2><p>计算机中包括各种存储器：<strong>CPU内部的通用寄存器组</strong>、一级Cache、 二级Cache、三级Cache、主存储器（简称主存）、联机（在线）磁盘存储器以及脱机（离线）的磁带、光盘存储器等。</p><p><strong>将上述两种或两种以上的存储器用硬件、软件或硬件和软件连接在 一 起，并对它们进行管理，就构成了存储系统</strong>。</p><p><img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/4/存储系统的结构层次.png" alt="存储系统的结构层次"></p><p><strong>层次结构中，越是靠近上层，其速度越快、容量越小，而单位存储容量的价格也越高</strong>。</p><p><em>这种层次结构使计算机的存取速度接近CPU的速度，使程序员所使用的主存容量接近联机外存的容量，使整个存储系统的单位存储容量价格接近联机外存的价格</em>。</p><h2 id="1-2-存储器的分类"><a href="#1-2-存储器的分类" class="headerlink" title="1.2 存储器的分类"></a>1.2 存储器的分类</h2><ol><li><p>按存储信息的“介质”分类</p><p> 半导体存储器、磁盘（磁带）存储器、光盘存储器等。</p></li><li><p>按在计算机中的“用途”分类</p><ul><li>主存储器：存放当前正要执行或刚执行的“程序”和“数据”；</li><li>高速缓冲存储器Cache：存放正在执行的程序或正在使用的数据、<strong>用以克服主存储器速度太慢</strong>；</li><li>内存：存储器和Cache统称为内部存储器；</li><li>控制存储器：CPU内部存放“微程序”；</li><li>外存：用来存放当前暂不使用的大量信息的存储器。</li></ul></li><li><p>按存放信息的“易失（挥发）性”分类</p><ul><li>当存储器断电后，有些存储器所存信息会随之丢失，这类存储器所存信息是易失的、 可挥发的；</li><li>在断电后所存信息不会丢失，当再次加电后它所存储的信息依然存在。</li></ul></li><li><p>按“存取方式”分类</p><ul><li>随机存取存储器（RAM）：存储器的存取时间与存储单元的物理地址无关；</li><li>顺序读写存储器：存取只能按顺序进行；</li></ul></li><li><p>按存储器的“读写功能”分类</p><ul><li>读写存储器：既能读出又能写入的存储器</li><li>只读存储器（ROM）：只能读出的存储器</li></ul></li></ol><h2 id="1-3-存储器的性能指标"><a href="#1-3-存储器的性能指标" class="headerlink" title="1.3 存储器的性能指标"></a>1.3 存储器的性能指标</h2><ol><li><p>存储容量</p><p> 存储容量指的是存储器所能存储的二进制信息的总位数，其表示方式一般为</p><script type="math/tex; mode=display"> \displaystyle \text{容量} =\text{单元数} \times  \text{每单元位数}</script><p> 例如，某计算机主存容量为 <code>1024M×8 bit(即1024MB)</code> 。</p></li><li><p>存储器速度</p><ol><li><strong>存取时间又称访问时间</strong>：对存储器中某一个存储单元的数据进行一次存（取）所需要的时间；</li><li><strong>存取周期</strong>：连续对存储器进行存（取）时，完成一次存（取）所需要的时间；</li><li><p><strong>存储器带宽(Memory Bandwidth)</strong>：单位时间里存储器可以读出（或写入）的字节数；</p><blockquote><p><strong>一般是存取周期大于存取时间</strong>。因为在连续存取存储器时，对下一个存储单元操作前，每读出（或写入）一个存储单元需要一定的稳定时间。</p></blockquote></li></ol></li><li><p>可靠性</p><p> 可维修部件的可靠性用<strong>平均故障间隔时间</strong>(Mean Time Between Maintenance,MTBF)来描述，而不可维修部件的可靠性用<strong>平均无故障时间或平均故障前时间</strong>(Mean Time To Failure, MTTF) 来描述。</p></li><li><p>功耗</p><p> 功耗在电池供电的系统中是非常重要的指标。使用功耗低的存储器构成存储系统，不仅可以降低对电源容量的要求，而且还可以提高存储系统的可靠性。</p></li><li><p>价格</p><p> 构成存储系统时，在满足上述指标要求的情况下，应尽量降低存储器的价格。通常是 以每千字节(KB) 或每兆字节(MB) 的价格来衡量存储器的成本。随着技术的发展，存储器 的价格已大大降低。</p></li></ol><p>除上述指标外，还有体积、重量、封装方式、工作电压、环境条件等指标。<strong>总之，大容量、高速度、高可靠性、低功耗、低成本是各类存储器追求的目标</strong>。</p><h1 id="二、主存储器"><a href="#二、主存储器" class="headerlink" title="二、主存储器"></a>二、主存储器</h1><h1 id="三、高速缓冲存储器"><a href="#三、高速缓冲存储器" class="headerlink" title="三、高速缓冲存储器"></a>三、高速缓冲存储器</h1><h1 id="四、虚拟存储器"><a href="#四、虚拟存储器" class="headerlink" title="四、虚拟存储器"></a>四、虚拟存储器</h1><h1 id="五、外部存储器（辅助存储器）"><a href="#五、外部存储器（辅助存储器）" class="headerlink" title="五、外部存储器（辅助存储器）"></a>五、外部存储器（辅助存储器）</h1>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 考研 </category>
          
          <category> 计算机学习，计算机组成，计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计算机学习 </tag>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 运算方法与运算器【计算机组成与系统结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/03.%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/03.%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="一、定点数运算"><a href="#一、定点数运算" class="headerlink" title="一、定点数运算"></a>一、定点数运算</h1><h2 id="1-1-加法运算"><a href="#1-1-加法运算" class="headerlink" title="1.1 加法运算"></a>1.1 加法运算</h2><p>有符号定点数的编码可以用<strong>原码</strong>、<strong>反码</strong>、<strong>补码</strong>、<strong>移码</strong>等形式表示。实际中用得最多、最普遍的是<strong>补码</strong>。<strong>补码加减运算过程中，参加运算的操作数及运算结果均用补码表示</strong>。</p><h3 id="1-1-1-补码加减法"><a href="#1-1-1-补码加减法" class="headerlink" title="1.1.1 补码加减法"></a>1.1.1 补码加减法</h3><p>补码加法的运算法则为：</p><script type="math/tex; mode=display">\displaystyle \left [ X +  Y\right ] _{\text{补码} } =\left [ X \right ] _{\text{补码} } +\left [ Y \right ] _{\text{补码} }</script><p><strong>两数和的补码就等于两数补码之和</strong>。</p><blockquote><p>在数值的补码表示法中，<strong>对一个正数求补：对该数包括符号位在内的各位取反再加1，即可得到该数的负数</strong>；若对该负数再求补，则又可得到原来的正数。</p><p>补码减法的运算法则为：</p><script type="math/tex; mode=display">\displaystyle\left [  \left [ X \right ] _{\text{补码} }  \right ] _{\text{求补} }= \left [ -X \right ] _{\text{补码} }</script></blockquote><p>综上所述，补码加减运算的规则是：</p><ol><li>参加运算的操作数用补码表示；</li><li>符号位参加运算；</li><li>若相加，则两个数的补码直接相加；若相减，则将减数连同符号位一起取反加1后，与被减数相加；</li><li>运算结果为补码表示。</li></ol><h3 id="1-1-2-溢出判断"><a href="#1-1-2-溢出判断" class="headerlink" title="1.1.2 溢出判断"></a>1.1.2 溢出判断</h3><p>溢出的概念：<strong>运算结果超出规定的数值范围，而造成错误的现象称为溢出</strong>。发生溢出时，运算结果一定是错误的，所以必须采取措施防止溢出。</p><blockquote><p>只有当同号相加或者异号相减时，运算结果才有可能溢出。</p></blockquote><p><strong>溢出的判定</strong>😨😨😨😨</p><ol><li><p><strong>双符号位（变形码）判决法</strong>（双符号位）</p><p> 如果运算结果的两符号分别用 $\displaystyle S_{2} S_{1} $ 表示，则溢出的标志 $\displaystyle OF$ 的逻辑表达式为：</p><script type="math/tex; mode=display"> \displaystyle OF= S_{2} \oplus S_{1}</script><p> 当 $\displaystyle OF=0$ ，未发生溢出；当 $\displaystyle OF=1$ ，发生溢出。</p></li><li><p><strong>进位判决法</strong>（单符号位）</p><p> 如果 $\displaystyle C_{n-1} $ 表示最高数值为产生的进位， $\displaystyle C_{n} $ 表示符号产生的进位（即进位标志 $\displaystyle CF $），则溢出的标志 $\displaystyle OF$ 的逻辑表达式为：</p><script type="math/tex; mode=display"> \displaystyle OF = C_{n-1} \oplus C_{n}</script></li><li><p>根据运算结果的符号位和进位标志判别</p><p> <strong>该方法适用于两个同号数求和或异号数求差时判别溢出</strong>。溢出的标志 $\displaystyle OF$ 的逻辑表达式为：</p><script type="math/tex; mode=display"> \displaystyle OF = SF\oplus CF</script></li><li><p>根据运算前后的符号位进行判别</p></li></ol><h3 id="1-1-3-一位全加器"><a href="#1-1-3-一位全加器" class="headerlink" title="1.1.3 一位全加器"></a>1.1.3 一位全加器</h3><p>设一位全加器的输入分别为 $\displaystyle X_{i} $ 和 $\displaystyle Y_{i} $ ，低位进位为 $\displaystyle C_{i} $ ，全加器的结果为 $\displaystyle Z_{i} $ ，向高位进位为 $\displaystyle C_{i+1} $ ，则实现一位全加器的逻辑表达式为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle &Z_{i} = X_{i} \oplus Y_{i} \oplus C_{i} \\\displaystyle &C_{i+1} = (X_{i} Y_{i} ) + (X_{i} +Y_{i} )C_{i} = (X_{i} Y_{i} ) + (X_{i} \oplus Y_{i} )C_{i} \end{align}</script><p><img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/一位全加器逻辑电路及其框图.svg" alt="一位全加器逻辑电路及其框图"></p><h3 id="1-1-4-n位全加器"><a href="#1-1-4-n位全加器" class="headerlink" title="1.1.4 n位全加器"></a>1.1.4 n位全加器</h3><ol><li><p><strong>行波进位加法器</strong>💤💤</p><p> 将 $n$ 个“一位全加器”串接在一起，构成 $n$ 位二进制数加法器。进位的产生是由三级门形成的，<strong>因为任何一级门均有延时，所以生成进位是需要花时间的</strong>。</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/行波进位加法器.png" alt="行波进位加法器)"></p><p> 行波进位加法器:</p><ul><li><p>加法器的“进位”逐位产生。<strong>高位运算必须等待低位运算产生进位后，方能进行计算</strong>。</p></li><li><p>加法器的“和”逐位产生<strong>。</strong></p><p>  如果一位全加器的延时是 $\displaystyle \Delta t$ ，那么完成 $n$ 位加法需要的时间为 $\displaystyle n\Delta t$ 。<strong>显然，行波进位加法器的速度是难以令人满意的</strong>。</p></li><li><p>利用“异或门”实现了溢出判别逻辑。</p></li></ul></li><li><p>并/先行进位加法器（CLA）：同时生成所有低位向高位的进位。</p><p> 在加法运算之前，将各位全加器所需要的进位并行生成，以此加快加法运算速度。</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/并行进位加法器.png" alt="并行进位加法器"></p><p> 并行进位加法器：</p><ul><li><strong>如果一位全加器的延时是 $\displaystyle \Delta t$ ，并行进位产生电路的延时是 $\displaystyle \tau $ ，那么，完成 $n$ 位加法仅需要 $\displaystyle \Delta t+\tau $ 时间</strong>。</li><li>随着位数的增加，电路会越来越复杂。（因此，在设计加法器时，会将多位加法器分组。）</li></ul></li><li><p>组内并行<u>组间串行</u>进位加法器，又称为<strong>单级先行进位</strong>。</p><p> 组间进位是串行的，即每个组的进位输入是相邻低位组的进位输出，而每个组的进位输出是相邻高位组的进位输入。<strong>串行进位链的总延迟时间与分组数目成正比</strong>。</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/组内并行组间串行进位加法器.png" alt="组内并行组间串行进位加法器"></p></li><li><p>组内并行<u>组间并行</u>进位加法器，又称为<strong>多级先行进位加法器</strong>。</p><p> 这种加法器利用每组的 G+3 和 P4s 信号再次组成先行进位链，即构成组内先行进位，组间也为先行进位的进位逻辑。</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/组内并行组间并行进位加法器.png" alt="组内并行组间并行进位加法器"></p></li><li><p>加法/减法器</p><p> 利用异或门和控制信号 $\displaystyle M$ 可实现减法运算。</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/行波进位的n位加减法器.png" alt="行波进位的n位加减法器"></p></li></ol><ul><li>当 $\displaystyle M=0$ 时，异或门输出 $\displaystyle Y$ ，实现加法 $\displaystyle X+Y$ 的功能；</li><li>当 $\displaystyle M=0$ 时，异或门输出 $\displaystyle \overline{Y} $ ，$\displaystyle \overline{Y} $ 与最低进位 $\displaystyle C_{0} =M=1$ 相加，实现减数求补，然后与 $\displaystyle X$ 做加法，从而实现减法 $\displaystyle X-Y$ 的功能。</li></ul><h3 id="1-1-5-BCD-加法器"><a href="#1-1-5-BCD-加法器" class="headerlink" title="1.1.5 BCD 加法器"></a>1.1.5 BCD 加法器</h3><p>“8421BCD”码的对照表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">BCD</th><th style="text-align:center">十进制</th><th style="text-align:center">BCD</th><th style="text-align:center">十进制</th></tr></thead><tbody><tr><td style="text-align:center">0000</td><td style="text-align:center">0</td><td style="text-align:center">1000</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">1</td><td style="text-align:center">1001</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">0010</td><td style="text-align:center">2</td><td style="text-align:center"><strong>1010</strong></td><td style="text-align:center"><strong>10</strong></td></tr><tr><td style="text-align:center">0011</td><td style="text-align:center">3</td><td style="text-align:center"><strong>1011</strong></td><td style="text-align:center"><strong>11</strong></td></tr><tr><td style="text-align:center">0100</td><td style="text-align:center">4</td><td style="text-align:center"><strong>1100</strong></td><td style="text-align:center"><strong>12</strong></td></tr><tr><td style="text-align:center">0101</td><td style="text-align:center">5</td><td style="text-align:center"><strong>1101</strong></td><td style="text-align:center"><strong>13</strong></td></tr><tr><td style="text-align:center">0110</td><td style="text-align:center">6</td><td style="text-align:center"><strong>1110</strong></td><td style="text-align:center"><strong>14</strong></td></tr><tr><td style="text-align:center">0111</td><td style="text-align:center">7</td><td style="text-align:center"><strong>1111</strong></td><td style="text-align:center"><strong>15</strong></td></tr></tbody></table></div><ol><li><p>“8421BCD码”的使用方式</p><ol><li>压缩BCD数：用一个字节（8位二进制数）表示2位BCD数，即高4位表示1位BCD数，低4位表示1位BCD数。</li><li>非压缩BCD数：用一个字节表示1位BCD数，即高4位为0，低4位为1位BCD数。</li></ol></li><li><p>加法运算</p><p> 十进制数用8421BCD码编码后，其形式是一个二进制数，因此可以用 $n$ 位加法器进行加法运算，但其运算结果需要校正。</p></li><li><p>校正：（对于一个字节的压缩BCD数加法进行校正的法则）</p><ul><li>运算中<strong>低4位相加结果大于9</strong>或者<strong>有bit3向bit4的进位</strong>，则结果加 <code>06H</code> ；</li><li>运算中<strong>高四位相加的结果大于9</strong>或<strong>有bit7向更高位的进位</strong>，则结果加 <code>60H</code> ，同时进位为“1”，且将其看作相加结果的最高位；</li><li>若高四位和低四位均不满足上述条件，则无须校正。</li></ul></li><li><p>BCD码加法器</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/BCD码加法电路.png" alt="BCD码加法电路"></p><p> 将 $n$ 个一位 BCD 码加法器进位链串接起来，即可构成“ $n$ 位行波进位BCD加法器”。</p></li></ol><h3 id="1-1-6-移码加减法"><a href="#1-1-6-移码加减法" class="headerlink" title="1.1.6 移码加减法"></a>1.1.6 移码加减法</h3><ol><li><p>运算规则：</p><ol><li>两运算数据为移码编码；</li><li>对两个移码求和/差；</li><li><p>对结果进行修正：<strong>将结果符号取反，即得到正确结果</strong>。</p><blockquote><p> 根据该规则，将前述的 $n$ 位加/减法运算器结果输出端的最高位（即符号位）加一个反相器，即可构成移码加/减法运算器。</p></blockquote></li></ol></li><li><p>移码运算注意的问题</p><ol><li><p>对移码运算的结果需要加以修正。</p><p> $n$ 位数的修正量为 $\displaystyle 2^{n-1} $ ，即对结果的符号位取反后，才是移码形式的正确结果；</p></li><li><p>移码表示中，0有唯一的编码，为 <code>1000 …00</code> 。当编码出现 <code>000 …00</code> 时，表示十进制数 $\displaystyle -2^{n-1} $ 。</p><p> 该编码若出现在“IEEE754”格式的浮点数阶码中，则<strong>表示浮点数出现下溢，此时浮点数按机器零处理</strong>。</p></li></ol></li></ol><h2 id="1-2-乘法运算"><a href="#1-2-乘法运算" class="headerlink" title="1.2 乘法运算"></a>1.2 乘法运算</h2><ol><li><strong>乘法运算可以用软件来实现</strong>，若CPU硬件结构简单，则这<strong>种做法实现乘法所用的时间较长，速度很慢</strong>。</li><li>在ALU等硬件的基础上，增加一些硬件构成乘法器。硬件复杂，但速度比较快。</li><li><strong>速度最快的是全部由硬件实现的阵列乘法器，其硬件更加复杂</strong>。</li></ol><h3 id="1-2-1-原码乘法运算"><a href="#1-2-1-原码乘法运算" class="headerlink" title="1.2.1 原码乘法运算"></a>1.2.1 原码乘法运算</h3><ol><li><p>原码一位乘法规则：</p><ol><li><p>乘积的符号为：“被乘数的符号位”与“乘数的符号位”相异或</p></li><li><p>乘积的数值为“被乘数的数值”与“乘数的数值”之积；</p></li><li><p>乘积的原码</p><script type="math/tex; mode=display"> \displaystyle \left [ Z \right ] _{\text{原码} } = \left [ X\times Y \right ] _{\text{原码} } = (x_{0} \oplus y_{0} )(\left | X \right |\times \left | Y \right |  )</script></li></ol></li><li><p>原码一位乘法的实现思路</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/原码一位乘法的实现思路.png" alt="原码一位乘法的实现思路"></p><p> 在CPU中，一个ALU一次只能完成两个数的相加，上述求和要通过3～4次相加才能获得结果，其中每次相加的结果称为部分积。</p></li><li><p>原码一位乘法的算法流程图：</p><ul><li>寄存器 $\displaystyle D$ ：初始化为“0”；运算中存放“部分积的高位”；运算结束存放“数值乘积的高位”。</li><li>寄存器 $\displaystyle A$ ：初始化“存放乘数”；运算中与寄存器 $\displaystyle D$ 一起右移，接受来自 $\displaystyle D$ 的位数据；运算结束存放数值乘积的低位。</li><li><p>寄存器 $B$ ：一直存放被乘数。</p><p><img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/源码一位乘法的算法流程.png" alt="源码一位乘法的算法流程"></p></li></ul></li><li><p>原码一位乘法器的框图：</p><p> <img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/原码一位乘法器的框图.png" alt="原码一位乘法器的框图"></p></li></ol><h3 id="1-2-2-补码乘法运算"><a href="#1-2-2-补码乘法运算" class="headerlink" title="1.2.2 补码乘法运算"></a>1.2.2 补码乘法运算</h3><p><strong>计算机中经常采用补码表示数据</strong>，较多计算机采取补码进行乘法运算。<strong>一种经典的补码乘法算法为“布斯法”，补码一位乘法的一种，是由布斯(Booth)夫妇提出的</strong>。</p><p>设被乘数 $\displaystyle X$ 与乘数 $\displaystyle Y$ 均用补码表示的纯小数，分别为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \left [ X \right ] _{\text{补码} } &=X_{0} .X_{-1} X_{-2} \cdots X_{-(n-1)} \\\displaystyle \left [ Y \right ] _{\text{补码} } &=Y_{0} .Y_{-1} Y_{-2} \cdots Y_{-(n-1)} \\\end{align}</script><p>布斯法补码一位乘法的公式为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \left [ X\times Y \right ] _{\text{补码} }  = \left [ X\right ] _{\text{补码} } \times[ &(Y_{-1} -Y_{0} )\times 2^{0} +(Y_{-2} -Y_{-1} )\times 2^{-1} +\cdots +\\&(Y_{-(n-1)} -Y_{-(n-2)} )\times 2^{-(n-2)} +({\color{Red} 0}  -Y_{-(n-1)} )\times 2^{-(n-1)}] \end{align}</script><div class="table-container"><table><thead><tr><th style="text-align:center">$\displaystyle Y_{i} $</th><th style="text-align:center">$\displaystyle Y_{i-1} $</th><th style="text-align:center">$\displaystyle Y_{i-1}-Y_{i} $</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">+0；$\displaystyle DA$右移一位</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">$\displaystyle +\left [ X \right ] _{\text{补码} } $；$\displaystyle DA$右移一位</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">-1</td><td style="text-align:center">$\displaystyle +\left [ -X \right ] _{\text{补码} } $；$\displaystyle DA$右移一位</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">+0；$\displaystyle DA$右移一位</td></tr></tbody></table></div><p><strong>布斯算法描述</strong>：</p><ol><li>乘数与被乘数均用补码表示，符号位参加运算；</li><li>乘数最低位后增加一个附加位（用 $\displaystyle A_{-1} $ 表示），初始值为 0 ；</li><li>从附加位开始，根据上表完成各位的操作。</li></ol><p>实现布斯算法的流程图如下：</p><p><img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/布斯算法流程图png" alt="布斯算法流程图"></p><p>不死算法乘法器的硬件框图：</p><p><img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/布斯算法乘法器的硬件框图.png" alt="布斯算法乘法器的硬件框图"></p><h3 id="1-2-3-阵列乘法器"><a href="#1-2-3-阵列乘法器" class="headerlink" title="1.2.3 阵列乘法器"></a>1.2.3 阵列乘法器</h3><p>上述乘法运算，是利用简单的硬件进行多次加法和多次移位来实现乘法的。显然，这样难以获得高的运算速度。为了提高运算速度，可以采取类似人工手算的方法。</p><p>设二进制数 $\displaystyle X=X_{3} X_{2}X_{1}X_{0}$ 和 $\displaystyle Y=Y_{3} Y_{2}Y_{1}Y_{0}$ 。计算 $\displaystyle Z=X\times Y$ ，列式如下：</p><p><img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/乘法手算单元.png" alt="乘法手算单元"></p><p>每一对相与求和操作可以用基本乘加单元电路来实现。 如下图：</p><p><img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/基本乘加单元电路.png" alt="基本乘加单元电路"></p><p>利用手算算式的结构及乘加单元电路，可以方便地实现无符号数阵列乘法器。利用无符号数阵列乘法器完成原码的数值相乘，再加入一个完成符号运算的异或门，就构成了“原码阵列乘法器”。</p><p><a href="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/无符号数阵列乘法器.png"><img src="https://imageshack.yuilexi.cn/University/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/3/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%98%B5%E5%88%97%E4%B9%98%E6%B3%95%E5%99%A8.png" alt="无符号数阵列乘法器"></a></p><p><strong>补码的阵列乘法器</strong>：在无符号数阵列乘法器的基础上，很容易实现补码阵列乘法器。其基本思路是：<strong>先求被乘数与乘数的绝对值（无符号数），然后进行无符号数阵列乘法，最后根据被乘数与乘数的符号决定最终乘积的符号</strong>。</p><p><a href="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/求补电路.png"><img src="https://imageshack.yuilexi.cn/University/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/3/%E6%B1%82%E8%A1%A5%E7%94%B5%E8%B7%AF.png" alt="求补电路"></a></p><p><strong>适于流水线工作的阵列乘法器</strong>：上述阵列乘法器的最大缺点是，每一步部分积的计算都是用串行进位加法器来实现的，因此即使采用硬件电路，其运算速度仍然很慢，令乘法器的使用者无法接受。</p><h2 id="1-3-除法运算"><a href="#1-3-除法运算" class="headerlink" title="1.3 除法运算"></a>1.3 除法运算</h2><h3 id="1-3-1-原码除法运算"><a href="#1-3-1-原码除法运算" class="headerlink" title="1.3.1 原码除法运算"></a>1.3.1 原码除法运算</h3><p>原码除法运算规则：</p><ol><li><p>除数不能为零。</p><ul><li>对于定点纯小数，被除数 &lt; 除数；</li><li>对于定点纯整数，被除数 &gt; 除数；</li></ul></li><li><p>分别处理<strong>商符</strong>和<strong>商值</strong>。</p><p> 商符等于被除数的符号与除数的符号相异或；商值等于被除数的数值除以除数的数值；</p></li><li><p>将商符与商值拼接在一起即可得到商的原码。</p></li><li><p>除法是通过<strong>逐次减除数</strong>来实现的，也就是被除数（或余数）每次减去“右移一位”的除数，以此来决定商值。</p></li><li><p>在手算过程中，人通过眼睛和大脑来判断被除数或余数是否够减除数，以决定商是 “0” 还是 “1” 。<strong>而在CPU中，必须完成相减操作方能判断余数是否够减。当发现不够减时，由于余数已经减掉了除数，因此必须在下一步操作之前恢复余数。这就是“恢复余数法”</strong>。</p></li></ol><p>恢复余数法：</p><ol><li>被除数左移一位，减除数，若够减 ，上商为 “1” ；若不够减，上商为 “0”，同时加除数——<strong>恢复余数</strong>；</li><li>余数左移一位，减除数，若够减，上商为 “1” ；若不够减，上商为“0”，同时加除数——<strong>恢复余数</strong>；</li><li>重复此过程，直到除尽或精度达到要求为止。</li></ol><p><strong>恢复余数法的最大缺点</strong>：在运算位数相同的情况下，不同的被除数和除数在运算中何时需恢复余数不相同，运算时间不一致，实现起来不便于控制。</p><p>因此，恢复余数法在计算机中并不常用，由此法演变出了另一种更有效的计算方法：<strong>加减交替法</strong>。</p><p>加减交替法：</p><ol><li><p>加减交替算法可描述如下：①若余数 $\displaystyle R\ge 0$ ，则商上“1”，余数左移一位，减除数；②若余数 $\displaystyle R &lt; 0$ ，则商上“0”，余数左移一位，加除数。</p></li><li><p>加减交替除法器硬件电路</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/加减交替除法器硬件电路.png" alt="加减交替除法器硬件电路"></p></li></ol><h1 id="二、逻辑与移位运算"><a href="#二、逻辑与移位运算" class="headerlink" title="二、逻辑与移位运算"></a>二、逻辑与移位运算</h1><p>除了加减乘除四则运算外，目前的运算器还包括“逻辑与移位运算”。</p><h2 id="2-1-逻辑运算"><a href="#2-1-逻辑运算" class="headerlink" title="2.1 逻辑运算"></a>2.1 逻辑运算</h2><p>基本的逻辑运算包括“与<strong>、</strong>或、非、异或”等运算。计算机以“1”和“0”分别表示逻辑数据的真和假两个状态。此时 $n$ 个 0 和 1 的数字组合不是算术数字，而是没有符号位的逻辑数据。 </p><p>逻辑运算按位进行操作，各位之间互不影响，<strong>运算结果没有进位、借位、溢出等问题</strong>。</p><h3 id="2-1-1-基本逻辑运算"><a href="#2-1-1-基本逻辑运算" class="headerlink" title="2.1.1 基本逻辑运算"></a>2.1.1 基本逻辑运算</h3><div class="table-container"><table><thead><tr><th style="text-align:center">$\displaystyle X$</th><th style="text-align:center">$\displaystyle Y$</th><th style="text-align:center">$\displaystyle XY$</th><th style="text-align:center">$\displaystyle X+Y$</th><th style="text-align:center">$\displaystyle X\oplus Y$</th><th style="text-align:center">$\displaystyle \overline{X}$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table></div><ol><li>逻辑与(AND) 运算：也称为<strong>逻辑乘运算</strong>，是指对两个操作数进行按位相与，用符号 ∧ 或 ⋅ 来表示；</li><li>逻辑或(OR) 运算：也称为<strong>逻辑加运算</strong>，是指对两个操作数进行按位相或，用符号 ∨ 或 + 来表示；</li><li>逻辑异或(XOR) 运算：也称为<strong>按位加</strong>，是指按位求两个数模 2 相加的和，用符号 ⊕ 表示；</li><li>逻辑非(NOT) 运算：也称为<strong>求反</strong>，是指对数据位进行取反操作， 1 和 0 分别转换为 0 和 1 。</li></ol><h3 id="2-1-2-逻辑运算部件"><a href="#2-1-2-逻辑运算部件" class="headerlink" title="2.1.2 逻辑运算部件"></a>2.1.2 逻辑运算部件</h3><p><img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/逻辑运算部件.svg" alt="逻辑运算部件"></p><h2 id="2-2-移位运算"><a href="#2-2-移位运算" class="headerlink" title="2.2 移位运算"></a>2.2 移位运算</h2><p>对于无限长度二进制数，左移或者右移 $\displaystyle n$ 位相当于该数乘以或者除以 $\displaystyle 2^{n} $ 。</p><p>由于计算的机器数字长是固定的，因此当机器数左移或右移 $\displaystyle n$ 位时，必然会使数据的低位或者高位出现 $\displaystyle n$ 个空位。<strong>空位填写“0”还是“1”，取决于机器数采用的是“无符号数”还是“有符号数”</strong>。</p><p><img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/移位运算执行过程.png" alt="移位运算执行过程"></p><h3 id="2-2-1-逻辑移位"><a href="#2-2-1-逻辑移位" class="headerlink" title="2.2.1 逻辑移位"></a>2.2.1 逻辑移位</h3><p>逻辑移位包括<strong>逻辑左移</strong>和<strong>逻辑右移</strong>两种操作。逻辑移位的操作数被认为是无符号数或逻辑数据，不存在符号问题，所有数据位都参与移位运算。</p><ol><li>逻辑左移（SHL）：操作数的<strong>最高位向左移出</strong>，存入状态寄存器的进位标志位 CF ，其他位依次向左移位，<strong>最低位补“0”</strong>；</li><li>逻辑右移（SHR）：操作数的<strong>最低位向左移出</strong>，存入状态寄存器的进位标志位 CF ，其他位依次向右移位，<strong>最高位补“0”</strong>。</li></ol><h3 id="2-2-2-算术移位"><a href="#2-2-2-算术移位" class="headerlink" title="2.2.2 算术移位"></a>2.2.2 算术移位</h3><p><strong>算术移位是指将操作数据当作有符号数进行运算，在算术移位过程中必须保持移位前后的符号位不变</strong>。</p><ol><li>算术左移（SAL）：数值位与逻辑左移操作方法相同。其原码、补码和反码与真值相等，<strong>在不超出编码表示范围的前提下，算术左移1位等于对操作数做乘2运算</strong>；</li><li>算术右移（SAR）：数值位与逻辑左移操作方法相同，<strong>最高位用符号位填入</strong>。对于补码而言，算术右移1位等于对操作数作除2运算。</li></ol><h3 id="2-2-3-循环移位"><a href="#2-2-3-循环移位" class="headerlink" title="2.2.3 循环移位"></a>2.2.3 循环移位</h3><p>循环移位是指将数据的首尾相连进行移位，在整个移位过程中，数据各位信息没有丢失，可用于多字节数据的高低字节交换等操作。</p><p>根据进位是否参与循环，循环移位可分为<strong>不带进位循环移位</strong>和<strong>带进位循环移位</strong>：</p><ul><li>不带进位循环左移（ROL）：数据各位依次向左移位，<strong>移出的最高位移入空出的最低位</strong>，同时存入 CF 标志位；</li><li>不带进位循环右移（ROR）：数据各位依次向右移位，<strong>移出的最低位移入空出的最高位</strong>，同时存入 CF 标志位；</li><li>带进位循环左移（RCL）：数据各位依次向左移位，移出的最高位移入 CF 标志位，同时原 CF 标志位的内容移入空出的最低位；</li><li>带进位循环右移（RCR）：数据各位依次向右移位，移出的最低位移入 CF 标志位，同时原 CF 标志位的内容移入空出的最高位。</li></ul><h3 id="2-3-4-移位运算部件"><a href="#2-3-4-移位运算部件" class="headerlink" title="2.3.4 移位运算部件"></a>2.3.4 移位运算部件</h3><p>上述 8 种（实质为 7 种）移位运算的功能实现电路，其中<strong>核心器件为 16 个 D 触发器构成的 16 位移位寄存器</strong>（通过增加 D 触发器的数目，可以扩充移位寄存器的位数）。通过与或逻辑电路控制 D 触发器的输人端 D 移位寄存器可实现所期望的移位操作。</p><p><img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/移位运算功能的移位寄存器.png" alt="移位运算功能的移位寄存器"></p><h1 id="三、浮点数运算"><a href="#三、浮点数运算" class="headerlink" title="三、浮点数运算"></a>三、浮点数运算</h1><h2 id="3-1-浮点数加减运算"><a href="#3-1-浮点数加减运算" class="headerlink" title="3.1 浮点数加减运算"></a>3.1 浮点数加减运算</h2><p>设两个规格化浮点数 $\displaystyle X = M_{x} \times 2^{E_{x} } $ 和 $\displaystyle Y = M_{y} \times 2^{E_{y} } $ 。</p><h3 id="3-1-1-对阶"><a href="#3-1-1-对阶" class="headerlink" title="3.1.1 对阶"></a>3.1.1 对阶</h3><p>一般情况下，两浮点数的阶码不会相同。也就是说，两数的小数点没有对齐。</p><p>和我们所熟悉的十进制小数加减一样，在进行浮点数加减运算前需将小数点对齐，这称为<strong>对阶</strong>。只有当两数的阶码相同时才能进行尾数的加减运算。 对<strong>阶的原则是小阶对大阶，也就是将小阶码浮点数的阶码变成大阶码浮点数的阶码</strong>。</p><p>具体做法是：小阶码每增加 “1” ，该浮点数的尾数右移一位，直到小阶码增大到与大阶码相同。<em>这样在对阶时丢失的是尾数的低位，造成的误差很小。若是大阶对小阶，将丢失尾数的高位，从而导致错误的结果</em>。</p><h2 id="3-2-浮点数乘除运算"><a href="#3-2-浮点数乘除运算" class="headerlink" title="3.2 浮点数乘除运算"></a>3.2 浮点数乘除运算</h2><h2 id="3-3-浮点数运算实现方法"><a href="#3-3-浮点数运算实现方法" class="headerlink" title="3.3 浮点数运算实现方法"></a>3.3 浮点数运算实现方法</h2><h1 id="四、运算器基本结构"><a href="#四、运算器基本结构" class="headerlink" title="四、运算器基本结构"></a>四、运算器基本结构</h1><h2 id="4-1-三种基本结构"><a href="#4-1-三种基本结构" class="headerlink" title="4.1 三种基本结构"></a>4.1 三种基本结构</h2><h2 id="4-2-运算器实例"><a href="#4-2-运算器实例" class="headerlink" title="4.2 运算器实例"></a>4.2 运算器实例</h2>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 考研 </category>
          
          <category> 计算机学习，计算机组成，计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计算机学习 </tag>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 计算机系统中的数据表示【计算机组成与系统结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-数的进制及转换"><a href="#1-1-数的进制及转换" class="headerlink" title="1.1 数的进制及转换"></a>1.1 数的进制及转换</h2><p>常见的进位计数制有：<strong>二进制</strong>、<strong>八进制</strong>、<strong>十进制</strong>和<strong>十六进制</strong>。</p><ol><li>十进制：<strong>十进制数的后面常用字母 D 表示</strong>；</li><li>二进制：<strong>二进制数的后面常用字母 B 标记</strong>；</li><li>八进制：<strong>八进制的后面常用字母 O 标记</strong>；</li><li>十六进制：<strong>十六进制数的后面常用 H 标记</strong>，也可以在数前面加前缀 “0x” 。</li></ol><p><strong>任何一种进位计数制表示的数都可以写成按权展开的多项式之和</strong>，即：</p><script type="math/tex; mode=display">\displaystyle N_{r} =\sum D_{i} \times r^{i}</script><p>其中， $\displaystyle D_{i}$ 为该数制采用的基本数码， $\displaystyle r^{i} $ 是权， $r$ 是基数。</p><p>数值数据是表示数量多少和数值大小的数据，即在数轴上能找到其对应点的数据。各种数值数据在计算机中表示的形式称为<strong>机器数</strong>。机器数对应的实际数值称为数的<strong>真值</strong>。</p><hr><p>十进制数转换成二进制之间的方法：</p><ol><li>十进制转换成二进制</li><li>二进制转换成十进制</li></ol><p>由于二进制数转换成十进制数，以及二进制、八进制、十六进制之间的转换过于简单，这里不做赘述。</p><h2 id="1-2-无符号数与有符号数的定义"><a href="#1-2-无符号数与有符号数的定义" class="headerlink" title="1.2 无符号数与有符号数的定义"></a>1.2 无符号数与有符号数的定义</h2><h2 id="1-2-无符号数和有符号数的定义"><a href="#1-2-无符号数和有符号数的定义" class="headerlink" title="1.2 无符号数和有符号数的定义"></a>1.2 无符号数和有符号数的定义</h2><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">无符号数</td><td>没有<strong>正负号</strong>的数，<strong>数中的每一位均用来表示数值</strong>。</td></tr><tr><td style="text-align:center">有符号数</td><td>在数值位前面添加一位<strong>符号位</strong>，并且规定 0 为正号，1 为负号。</td></tr></tbody></table></div><h2 id="1-3-定点数与浮点数的定义"><a href="#1-3-定点数与浮点数的定义" class="headerlink" title="1.3 定点数与浮点数的定义"></a>1.3 定点数与浮点数的定义</h2><ol><li><p>定点数：</p><p> 在机器数表示中，约定小数点的位置固定不变，则称为<strong>定点数</strong>。包含：定整数（纯整数）和定点小数（纯小数）。</p><p> <img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/定点数的结构示意图.svg" alt="定点数的结构示意图.svg"></p></li><li><p>浮点数：</p><p> 既可以是纯整数，也可以是纯小数，还可以是同时含有整数和小数的数据，其<strong>小数点的位置是不固定</strong>的，故称<strong>浮点数</strong>。基数为 2 的浮点数 $F$ 的表示为</p><script type="math/tex; mode=display"> \displaystyle F = M\times 2^{E}</script><p> 其中，<strong>$M$ 称为尾数， $E$ 称为阶码</strong>。显然，<strong>尾数的位数决定了浮点数的精度，阶码的大小决定了浮点数的大小</strong>。</p><p> <img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/1_绪论.md/浮点数的编码格式之一.svg" alt="浮点数的编码格式之一"></p></li></ol><h1 id="二、定点数"><a href="#二、定点数" class="headerlink" title="二、定点数"></a>二、定点数</h1><h2 id="2-1-原码"><a href="#2-1-原码" class="headerlink" title="2.1 原码"></a>2.1 原码</h2><p>原码是机器数中最简单的一种表示形式，其符号位为 “0” 表示正数，符号位为 “1” 表示负数，<strong>数值位即真值的绝对值</strong>。</p><h3 id="2-1-1-整数的原码"><a href="#2-1-1-整数的原码" class="headerlink" title="2.1.1 整数的原码"></a>2.1.1 整数的原码</h3><p>若整数用 $n$ 位二进制表示，则整数的原码的定义为：</p><script type="math/tex; mode=display">\displaystyle \left [  X \right ] _{\text{原码} } = \left\{\begin{matrix} X && 0\le X\le 2^{n-1} -1\\   && \\ 2^{n-1} -X &&-(2^{n-1} -1)\le X\le 0\end{matrix}\right.</script><p>原码可用定义表示，也可用<strong>符号位后面紧跟数的绝对值表示</strong>，符号位总是在最高位。原码又称作<strong>带符号的绝对值表示</strong>，即在符号的后面跟着的就是该数据的绝对值。</p><p><strong>正数的原码就是其本身的二进制表示，并且在最高位添加一位符号位0</strong>；<strong>负数的原码是其本身绝对值的二进制表示，并且在最高位添加一位符号位 1</strong> 。</p><h3 id="2-1-2-小数的原码"><a href="#2-1-2-小数的原码" class="headerlink" title="2.1.2 小数的原码"></a>2.1.2 小数的原码</h3><p>若小数用 $n$ 位二进制表示，则小数的原码的定义为：</p><script type="math/tex; mode=display">\displaystyle \left [  X \right ] _{\text{原码} } = \left\{\begin{matrix} X && 0\le X\le 1-2^{-(n-1)} \\   && \\ 1 -X &&-(1-2^{-(n-1)} )\le X\le 0\end{matrix}\right.</script><p><em>值得注意的是，在计算机中小数点是隐含的，是不用出现的，上面编码中出现小数点是为了强调小数点的位置。在本书各章节中，所有编码中若出现小数点，其作用与此处相同，都仅仅是为了提示</em>。</p><blockquote><p>小数的原码：“小数点”之后的部分，就是<strong>小数绝对值的二进制表示</strong>，而“小数点”之前是符号位：“0” -&gt; 正数；“1” -&gt; 负数。</p></blockquote><h3 id="2-1-3-原码的特点"><a href="#2-1-3-原码的特点" class="headerlink" title="2.1.3 原码的特点"></a>2.1.3 原码的特点</h3><ol><li><strong>数值原码表示方法简单直观，但是加减运算很麻烦</strong>；</li><li><strong>对于数值 “0” ，原码的表示方法不唯一</strong>。 $\displaystyle \left [  0 \right ] _{\text{原码} } =0000,0000=1000,0000$ 。</li><li>$n$ 位原码表示的范围：<ol><li>纯整数： $\displaystyle -(2^{n-1} -1)\to (2^{n-1} -1)$ ；</li><li>纯小数： $\displaystyle -(1-2^{-(n-1)})\to (1-2^{-(n-1)})$ 。</li></ol></li></ol><h2 id="2-2-补码"><a href="#2-2-补码" class="headerlink" title="2.2 补码"></a>2.2 补码</h2><h3 id="2-2-1-补数的概念"><a href="#2-2-1-补数的概念" class="headerlink" title="2.2.1 补数的概念*"></a>2.2.1 补数的概念*</h3><p>在日常生活中，常会遇到补数的概念。例如，当前时钟指针指示在 “6” 点，欲使它指示 “3” 点，既可按顺时针方向将分针转 “9” 圈，也可按逆时针方向将分针转 3 圈，其结果是一致的。由于时钟的时针转一圈能指示 “12” 个小时，因此时钟指针两个方向转动产生的效果在数学上，称为<strong>模 12 运算</strong>，写作 <code>mod 12</code>。</p><p>将补数的概念用到计算机中，便出现了补码机器数。</p><h3 id="2-2-2-补码的定义"><a href="#2-2-2-补码的定义" class="headerlink" title="2.2.2 补码的定义"></a>2.2.2 补码的定义</h3><ol><li><p>整数补码</p><p> 如果整数用 $n$ 位二进制表示，则整数的补码的定义为：</p><script type="math/tex; mode=display"> \displaystyle \left [ X \right ] _{\text{补码} } =\left\{\begin{matrix} X && 0\le X\le 2^{n-1}-1 \\  && \\ 2^{n} +X && -2^{n-1}\le X\le -1\end{matrix}\right.</script><ul><li>对正数来说，补码与原码的定义完全一样；</li><li>对负数而言，补码与原码是不同的：<ul><li>负数的<strong>绝对值</strong>用原码表示，然后包括符号位在内各位取反，再在最低位加 “1” ；</li><li>负数用原码表示，然后<strong>不包括符号位各位取反，再在最低位加 1</strong> 。</li><li>负数的<strong>绝对值</strong>用原码表示，然后从右往左搜索第一个 “1” ，第一个 “1” 及其右边保持不变，左边全部按位取反；</li></ul></li></ul></li><li><p>小数补码</p><p> 如果小数用 $n$ 位二进制表示，则小数的补码的定义为：</p><script type="math/tex; mode=display"> \displaystyle \left [ X \right ] _{\text{补码} } =\left\{\begin{matrix} X && 0\le X\le 1-2^{-(n-1)}  \\  && \\ 2 +X && -1\le X\le -2^{-(n-1)} \end{matrix}\right.</script><p> 对于负数纯小数，构成补码表示所采用的方法与整数一样。</p></li></ol><h3 id="2-2-3-补码的特点🦋"><a href="#2-2-3-补码的特点🦋" class="headerlink" title="2.2.3 补码的特点🦋"></a>2.2.3 补码的特点🦋</h3><ol><li><p>$n$ 位补码表示的整数数值范围： $\displaystyle -2^{n-1}\to 2^{n-1}-1  $ ，小数数值范围： $\displaystyle -1\to 1-2^{-(n-1)} $ ；</p></li><li><p><strong>“0” 的表示是唯一的</strong>。</p></li><li><p><strong>变形码</strong>。</p><p> 前面的纯小数的补码定义，是按照<strong>模2</strong>的形式；当<strong>模数为4</strong>时，可形成<strong>双符号位补码</strong>。即：</p><script type="math/tex; mode=display"> \begin{align}\displaystyle \text{非负数} &= 00.x_{1}  x_{2} \cdots x_{n} \\\displaystyle \text{负数} &= 11.x_{1}  x_{2} \cdots x_{n} \end{align}</script></li><li><p><strong>求补运算</strong>。</p><p> 许多处理器中设置有求补指令，<strong>其功能是对操作数取负数（即正数变负数，负数变正数）</strong>。</p></li><li><p><strong>简化加减法</strong>。</p><p> <strong>补码的加法运算规则</strong>：</p><script type="math/tex; mode=display"> \displaystyle \left [ X+Y \right ] _{\text{补码} } = \left [ X \right ] _{\text{补码} }  +\left [ Y \right ] _{\text{补码} }</script><p> 并且减法运算也可以用加法实现，即：</p><script type="math/tex; mode=display"> \displaystyle \left [ \left [ X\right ] _{\text{补码} }  \right ] _{\text{求补} } = \left [ -X \right ] _{\text{补码} }</script><p> 这样，在运算器中就可以不设置<strong>减法器</strong>，从而简化了运算器的结构。</p></li><li><p><strong>算术或逻辑左移</strong></p><p> 对补码表示的数值做算术右移一位（即编码各位依次向右移动一位，最低位移出，最高位保持原符号不变）</p></li></ol><blockquote><p>对于 8 位二进制补码来说，其编码从 <code>0000,0000</code> 到 <code>1111,1111</code> ，其对应的真值为 <code>0，1，2，..., 127, -128, -127,..., -1</code> 。</p></blockquote><h2 id="2-3-反码"><a href="#2-3-反码" class="headerlink" title="2.3 反码*"></a>2.3 反码*</h2><p><strong>反码通常用作来作为原码求补码或者补码求原码的中间过渡</strong>。</p><h3 id="2-3-1-反码的定义"><a href="#2-3-1-反码的定义" class="headerlink" title="2.3.1 反码的定义"></a>2.3.1 反码的定义</h3><ol><li><p>整数反码的定义为：</p><script type="math/tex; mode=display"> \displaystyle \left [ X \right ] _{\text{反码} } =\left\{\begin{matrix} X && 0\le X\le 2^{n-1}-1 \\  && \\ (2^{n}-1)+X && -(2^{n-1}-1)\le X\le 0\end{matrix}\right.</script><ol><li>正整数的反码表示与原码及补码相同。</li><li>对于一个负数，<ul><li>可直接利上式来获得；</li><li>或者，将负数绝对值相同的正数原码（包括符号位）各位取反获得；</li><li>或者，利用该负数的原码<strong>保持符号位不变</strong>，其余各位取反来获得；</li></ul></li></ol></li><li><p>小数反码的定义：</p><script type="math/tex; mode=display"> \displaystyle \left [ X \right ] _{\text{反码} } =\left\{\begin{matrix} X && 0\le X\le 1-2^{-(n-1)}  \\  && \\ (2-2^{-(n-1)})+X && -(1-2^{-(n-1)} )\le  X\le 0\end{matrix}\right.</script></li></ol><h3 id="2-3-2-反码的特点"><a href="#2-3-2-反码的特点" class="headerlink" title="2.3.2 反码的特点"></a>2.3.2 反码的特点</h3><ol><li><strong>“0” 的表示不唯一</strong>。</li><li>负数反码与补码的关系。</li><li>$n$ 位反码表示的整数数值范围： $\displaystyle -(2^{n-1}-1)\to (2^{n-1}-1)  $ ，小数数值范围： $\displaystyle -(1-2^{-(n-1)})\to (1-2^{-(n-1)}) $ 。</li></ol><h2 id="2-4-移码"><a href="#2-4-移码" class="headerlink" title="2.4 移码"></a>2.4 移码</h2><h3 id="2-4-1-移码的由来"><a href="#2-4-1-移码的由来" class="headerlink" title="2.4.1 移码的由来*"></a>2.4.1 移码的由来*</h3><p><em>当真值用补码表示时，由于符号位和数值部分一起编码，与习惯上的表示法不同，因此人们很难从补码的形式上直接判断其真值的大小</em>。</p><p><em>例如：十进制数<code>X=+31</code>，对应的二进制数为<code>+11111</code>，若用8位表示，则<code>[X]=00011111</code>；十进制数<code>X=-31</code>，对应的二进制数为<code>-11111</code>，若用8位表示，则<code>[X]补=11100001</code> 。在原来补码表示的编码基础上再加上一个偏移量，就构成了新的编码，即移码。</em></p><h3 id="2-4-2-移码的定义"><a href="#2-4-2-移码的定义" class="headerlink" title="2.4.2 移码的定义"></a>2.4.2 移码的定义</h3><p>由于移码多用于浮点数中表示阶码，均为整数，因此这里只介绍定点整数的移码表示。当用包括符号位在内的 $n$ 位字长时，整数移码的定义为：</p><script type="math/tex; mode=display">\begin{array}{c}\displaystyle \left [ X \right ] _{\text{移码} } = 2^{n-1}+X && (-2^{n-1} \le X\le 2^{n-1})\end{array}</script><p>要获得整数的移码表示，可以利用定义计算，也可以<strong>先求出该数的补码后将符号位取反</strong>。</p><h3 id="2-4-3-移码的特点"><a href="#2-4-3-移码的特点" class="headerlink" title="2.4.3 移码的特点"></a>2.4.3 移码的特点</h3><ol><li><p>移码就是在其真值上加一个常数 $\displaystyle 2^{n-1}$ 。</p></li><li><p><strong>真值 “0” 的表示方法唯一</strong>。</p></li><li><p>移码与补码的关系：</p><p> 移码符号位取反补码[�]移码⟷符号位取反[�]补码</p></li><li><p>移码码值的大小反映了数值的大小，正数移码的码值一定大于负数移码的码值。</p></li></ol><blockquote><p>对于 8 位二进制<strong>移码</strong>来说，其编码从 <code>0000,0000</code> 到 <code>1111,1111</code> ，其对应的真值为 <code>-128, -127, ..., -1, 0，1，2，..., 127</code> 。</p></blockquote><h2 id="2-5-不同编码的比较"><a href="#2-5-不同编码的比较" class="headerlink" title="2.5 不同编码的比较"></a>2.5 不同编码的比较</h2><p>不同编码的总结：(以8位有符号数为例)</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">原码</th><th style="text-align:center">补码</th><th style="text-align:center">反码</th><th style="text-align:center">移码</th></tr></thead><tbody><tr><td style="text-align:center">0的表示</td><td style="text-align:center">不唯一<br/>(0000,0000和1000,0000)</td><td style="text-align:center">唯一<br/>(0000,0000)</td><td style="text-align:center">不唯一<br/>(0000,0000和1000,0000)</td><td style="text-align:center">唯一<br/>(1000,0000)</td></tr><tr><td style="text-align:center">0000,0000表示的元素</td><td style="text-align:center">+0</td><td style="text-align:center">0</td><td style="text-align:center">+0</td><td style="text-align:center">-256</td></tr><tr><td style="text-align:center">0111,1111</td><td style="text-align:center">255</td><td style="text-align:center">255</td><td style="text-align:center">255</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">1000,0000</td><td style="text-align:center">-0</td><td style="text-align:center">-256</td><td style="text-align:center">-255</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1111,1111</td><td style="text-align:center">-255</td><td style="text-align:center">-1</td><td style="text-align:center">-0</td><td style="text-align:center">255</td></tr></tbody></table></div><h1 id="三、浮点数"><a href="#三、浮点数" class="headerlink" title="三、浮点数"></a>三、浮点数</h1><h2 id="3-1-浮点数的表示方法"><a href="#3-1-浮点数的表示方法" class="headerlink" title="3.1 浮点数的表示方法"></a>3.1 浮点数的表示方法</h2><p>例如，二进制 $\displaystyle F=11.0101$ ，使用浮点数可以表示为以下不同的形态：</p><script type="math/tex; mode=display">\displaystyle F=11.0101 = 0.110101\times 2^{010} =1.10101\times 2^{001}</script><p>其中，尾数与阶码均用<strong>二进制</strong>表示，<strong>基数用十进制表示</strong>。</p><h3 id="3-1-1-浮点数的编码"><a href="#3-1-1-浮点数的编码" class="headerlink" title="3.1.1 浮点数的编码"></a>3.1.1 浮点数的编码</h3><p>浮点数的编码规则如下：</p><ol><li>尾数 $M$ 必须为小数，用 $n+1$ 位有符号定点小数表示；</li><li><strong>阶码 $E$ 必须为整数</strong>，用 $k+1$ 位有符号定点整数表示。</li><li>因此，<strong>浮点数编码位数为 $\displaystyle m = (n+1)+(k+1) = n+k+2$</strong>。</li></ol><p>浮点数的编码格式不止一种。下面是其中一种常用的编码格式：</p><p><img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/浮点数的编码格式_2.svg" alt="浮点数的编码格式_2"></p><p>需要强调的是：</p><ol><li><strong>阶码是整数</strong>，其<strong>位数决定浮点数的数值范围</strong>，也就决定了数据的大小。<strong>阶符决定阶码的正负</strong>。</li><li><strong>尾数是小数</strong>，其<strong>位数决定浮点数的精度</strong>。</li><li><strong>尾数的符号表示浮点数的正负</strong>。</li></ol><h3 id="3-1-2-非规格化浮点数"><a href="#3-1-2-非规格化浮点数" class="headerlink" title="3.1.2 非规格化浮点数"></a>3.1.2 非规格化浮点数</h3><p>当对尾数 $M$ 只要求是小数而无其他限制时，此时的浮点数被称为<strong>非规格化浮点数</strong>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">阶码和尾数</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">阶码</td><td style="text-align:center">$\displaystyle -2^{k} $</td><td style="text-align:center">$\displaystyle 2^{k} -1$</td></tr><tr><td style="text-align:center">尾数（负）</td><td style="text-align:center">$\displaystyle -1$</td><td style="text-align:center">$\displaystyle -2^{-n} $</td></tr><tr><td style="text-align:center">尾数（正）</td><td style="text-align:center">$\displaystyle 2^{-n} $</td><td style="text-align:center">$\displaystyle 1-2^{-n} $</td></tr></tbody></table></div><p>因为非规格化浮点数的尾数可以为“0”，也就是非规格化浮点数可以为“0”，因此非规格化浮点数范围为：</p><p><img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/非规格化浮点数的数值范围.png" alt="非规格化浮点数的数值范围"></p><h3 id="3-1-3-规格化浮点数"><a href="#3-1-3-规格化浮点数" class="headerlink" title="3.1.3 规格化浮点数"></a>3.1.3 规格化浮点数</h3><p>规格化浮点数，就是将尾数的绝对值限定在规定的数值范围内，即 $\displaystyle \frac{1}{2} \le \left | M \right | &lt; 1$ 。如果尾数用<strong>补码</strong>表示，那么，则当 $\displaystyle M\ge 0$ 时，规格化尾数的形式必须为：</p><script type="math/tex; mode=display">\displaystyle \left [ X \right ] _{\text{补码} } = 0.1x_{2} x_{3} \cdots x_{n}</script><p>其中， “X” 是任意二进制值。当 $\displaystyle M&lt; 0$ 时，规格化尾数的形式必须为：</p><script type="math/tex; mode=display">\displaystyle \left [ X \right ] _{\text{补码} } = 1.0x_{2} x_{3} \cdots x_{n}</script><p><strong>根据规格化浮点数的定义，可以得到规格化尾数的数值范围</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">尾数</th><th style="text-align:center">最小数值</th><th style="text-align:center">最大数值</th></tr></thead><tbody><tr><td style="text-align:center">尾数负值</td><td style="text-align:center">$\displaystyle -1$</td><td style="text-align:center">$\displaystyle -(\frac{1}{2} +2^{-n} )$</td></tr><tr><td style="text-align:center">尾数正值</td><td style="text-align:center">$\displaystyle \frac{1}{2}$</td><td style="text-align:center">$\displaystyle (1-2^{-n} )$</td></tr></tbody></table></div><blockquote><p>一旦浮点数的位数确定后，不同的阶码和尾数位数划分，将直接影响浮点数的表示范围和精度，所以需要合理分配阶码和尾数的位数。利用数值的浮点数表示，可实现用有限字长的二进制编码表示更大的数值范围。</p></blockquote><h3 id="3-1-4-规格化处理"><a href="#3-1-4-规格化处理" class="headerlink" title="3.1.4 规格化处理"></a>3.1.4 规格化处理</h3><p> 浮点数在运算前和运算后，若其尾数不是规格化数，就要通过修改阶码，并同时左右移动尾数使其变成规格化数。将非规格化数转换成规格化数的过程叫作<strong>规格化</strong>。</p><p>当尾数 $M$ 用二进制补码编码，规格化时，尾数左移 “1” 位，阶码减 “1” ，这种规格化叫作<strong>向左规格化</strong>，简称<strong>左规</strong>；尾数右移 “1” 位，阶码加 “1” ，这种规格化叫作<strong>向右规格化</strong>，简称<strong>右规</strong>。</p><h3 id="3-1-5-定点数和浮点数的对比"><a href="#3-1-5-定点数和浮点数的对比" class="headerlink" title="3.1.5 定点数和浮点数的对比"></a>3.1.5 定点数和浮点数的对比</h3><ol><li>当浮点计算机和定点计算机中数据的位数相同时，浮点数的表示范围比定点数大得多；</li><li>当浮点数为规格化数时，其精度比相同位数的定点数高；</li><li><strong>浮点运算步骤比定点运算步骤多，运算速度比定点低，运算电路比定点复杂</strong>；</li><li>在溢出的判断方法上，浮点数对规格化数的阶码进行判断，而定点数对数值本身进行判断。</li></ol><h2 id="3-2-IEEE754标准🥩🥩"><a href="#3-2-IEEE754标准🥩🥩" class="headerlink" title="3.2 IEEE754标准🥩🥩"></a>3.2 IEEE754标准🥩🥩</h2><div class="table-container"><table><thead><tr><th style="text-align:center">参 数</th><th style="text-align:center">单精度浮点数</th><th style="text-align:center">双精度浮点数</th><th style="text-align:center">双精度扩展浮点数</th></tr></thead><tbody><tr><td style="text-align:center">浮点数长度/bit</td><td style="text-align:center">32</td><td style="text-align:center">64</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">尾数长度 $\displaystyle p$/bit</td><td style="text-align:center">23</td><td style="text-align:center">52</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">符号位 s</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">指数 e 的长度/bit</td><td style="text-align:center">8</td><td style="text-align:center">11</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">最大指数 $\displaystyle E_{max} $</td><td style="text-align:center">+127</td><td style="text-align:center">+1,023</td><td style="text-align:center">+16,383</td></tr><tr><td style="text-align:center">最小指数 $\displaystyle E_{min} $</td><td style="text-align:center"><strong>-126</strong></td><td style="text-align:center">-1,022</td><td style="text-align:center">-16,382</td></tr><tr><td style="text-align:center">指数偏移量</td><td style="text-align:center"><strong>+127</strong></td><td style="text-align:center">+1,023</td><td style="text-align:center">+16,383</td></tr><tr><td style="text-align:center">可表示的实数范围</td><td style="text-align:center">$\displaystyle 10^{-38}\to 10^{+38} $</td><td style="text-align:center">$\displaystyle 10^{-308}\to 10^{+308} $</td><td style="text-align:center">$\displaystyle 10^{-4932}\to 10^{+4932} $</td></tr></tbody></table></div><h3 id="3-2-1-单精度浮点数"><a href="#3-2-1-单精度浮点数" class="headerlink" title="3.2.1 单精度浮点数"></a>3.2.1 单精度浮点数</h3><p>IEEE754 标准规定，单精度浮点数的真值一般表示为：</p><script type="math/tex; mode=display">\displaystyle N = (-1)^{s} \times 2^{e-127} \times 1.f</script><p>其<strong>编码格式由三个字段构成</strong>：数符 $s$ 为 1 位，阶码编码 $e$ 为8位（含1位阶符），尾数编码 $f$ 为 23 位。</p><p><img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/2_计算机系统中的数据表示.md/IEEE754单精度浮点数的编码格式.svg" alt="IEEE754单精度浮点数的编码格式"></p><p>需要注意的是：</p><ol><li><strong>阶码采用移码</strong>，但单精度浮点数来说，移码的偏移量不是 $\displaystyle 2^{7} =128$ ，而是 $\displaystyle 2^{7}-1 =127$ ，这是因为 IEEE754 将移码编码的“<strong>全 0</strong>” 和“<strong>全 1</strong>” 作为了特殊标识；</li><li>浮点数是规格化数，为了能够更多地表示尾数的有效数位，规定尾数真值的整数部分必须为 “1” ，尾数编码时整数 “1” 隐去，小数部分 $f$ 用<strong>原码</strong>表示。</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">单精度格式位模式</th><th style="text-align:left">IEEE浮点数的值</th></tr></thead><tbody><tr><td style="text-align:left">$\displaystyle 0&lt; e&lt; 255$</td><td style="text-align:left">$\displaystyle N = (-1)^{s} \times 2^{e-127} \times 1.f\quad (\text{正规数} )$</td></tr><tr><td style="text-align:left">$\displaystyle e=0,f\ne 0(f\text{中至少有一位不等于0} )$</td><td style="text-align:left">$\displaystyle N = (-1)^{s} \times 2^{-126} \times 0.f\quad (\text{次规数} )$</td></tr><tr><td style="text-align:left">$\displaystyle e=0,f=0(f\text{所有位都等于0} )$</td><td style="text-align:left">$\displaystyle N = (-1)^{s} \quad (\text{有符号的零} )$</td></tr><tr><td style="text-align:left">$\displaystyle s=0,e=255,f=0$</td><td style="text-align:left">$\displaystyle +INF$ 正无穷大</td></tr><tr><td style="text-align:left">$\displaystyle s=1,e=255,f=0$</td><td style="text-align:left">$\displaystyle -INF$ 负无穷大</td></tr><tr><td style="text-align:left">$\displaystyle s=u,e=255,f\ne 0$</td><td style="text-align:left">$\displaystyle NaN$ 非数值</td></tr></tbody></table></div><h3 id="3-2-2-双精度浮点数"><a href="#3-2-2-双精度浮点数" class="headerlink" title="3.2.2 双精度浮点数"></a>3.2.2 双精度浮点数</h3><p>对双精度浮点数的说明：</p><ol><li><p>阶码真值 $E$ 的取值范围为 −1022 ——&gt; +1023 ，将其偏移 +1023 ，即得编码 $e$ ，编码值为 +1 ——&gt; +2046 ;</p></li><li><p>双精度浮点规格化数表示为</p><script type="math/tex; mode=display"> \displaystyle N = (-1)^{s} \times 2^{e-127} \times 1.f</script></li><li><p>所能表示的规格化数范围：</p><ol><li>正数为：；</li><li>负数为：；</li></ol></li><li><p>当 $e=0$ 或 $e=2047$ 时，在 <code>IEEE754</code> 标准中表示特殊的数。</p></li></ol><h1 id="四、BCD码🍉🍉"><a href="#四、BCD码🍉🍉" class="headerlink" title="四、BCD码🍉🍉"></a>四、BCD码🍉🍉</h1><p><strong>计算机中，采用 4 位二进制编码来表示 1 位十进制数，这种编码称为 BCD 码</strong>。但是，4 位二进制有 16 中编码，而十进制数有 10 个数字符。因此，<strong>BCD 码有多种形式，使用最多的就是 8421 码</strong>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">8421BCD码</th><th style="text-align:center">十进制数</th></tr></thead><tbody><tr><td style="text-align:center">0000</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0010</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">0011</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">0100</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">0101</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">0110</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">0111</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">1000</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">1001</td><td style="text-align:center">9</td></tr></tbody></table></div><h1 id="五、非数值数据"><a href="#五、非数值数据" class="headerlink" title="五、非数值数据"></a>五、非数值数据</h1><p>现代计算机，不仅要处理数值领域的问题，而且还要处理大量的非数值领域问题。</p><h2 id="5-1-ASCII-码"><a href="#5-1-ASCII-码" class="headerlink" title="5.1 ASCII 码"></a>5.1 ASCII 码</h2><p>目前，国际上普遍采用的一种字符系统是 <strong>ASCII 码</strong>。包含 10 个十进制数码，26 个英文字母的大小写，一定数量的专用符号及控制命令等 128 个元素，用 <strong>7 位二进制编码表示</strong>。如果加一个奇偶校验位，则共 8 位，用<strong>一字节</strong>表示。</p><div class="table-container"><table><thead><tr><th style="text-align:center">校验位</th><th style="text-align:center">高3位</th><th style="text-align:center">高3位</th><th style="text-align:center">高3位</th><th style="text-align:center">低四位</th><th style="text-align:center">低四位</th><th style="text-align:center">低四位</th><th style="text-align:center">低四位</th></tr></thead><tbody><tr><td style="text-align:center">D7</td><td style="text-align:center">D6</td><td style="text-align:center">D5</td><td style="text-align:center">D4</td><td style="text-align:center">D3</td><td style="text-align:center">D2</td><td style="text-align:center">D1</td><td style="text-align:center">D0</td></tr></tbody></table></div><p><strong>ASCII 编码表</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">000</th><th style="text-align:center">001</th><th style="text-align:center">010</th><th style="text-align:center">011</th><th style="text-align:center">100</th><th style="text-align:center">101</th><th style="text-align:center">110</th><th style="text-align:center">111</th><th></th></tr></thead><tbody><tr><td style="text-align:center">0000</td><td style="text-align:center">NUL</td><td style="text-align:center">DLE</td><td style="text-align:center">SP</td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">@</td><td style="text-align:center">P</td><td style="text-align:center">`</td><td style="text-align:center">p</td><td></td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">SOH</td><td style="text-align:center">DC1</td><td style="text-align:center">!</td><td style="text-align:center">1</td><td style="text-align:center"><strong>A</strong></td><td style="text-align:center">Q</td><td style="text-align:center"><strong>a</strong></td><td style="text-align:center">q</td><td></td></tr><tr><td style="text-align:center">0010</td><td style="text-align:center">STX</td><td style="text-align:center">DC2</td><td style="text-align:center">“</td><td style="text-align:center">2</td><td style="text-align:center">B</td><td style="text-align:center">R</td><td style="text-align:center">b</td><td style="text-align:center">r</td><td></td></tr><tr><td style="text-align:center">0011</td><td style="text-align:center">ETX</td><td style="text-align:center">DC3</td><td style="text-align:center">#</td><td style="text-align:center">3</td><td style="text-align:center">C</td><td style="text-align:center">S</td><td style="text-align:center">c</td><td style="text-align:center">s</td><td></td></tr><tr><td style="text-align:center">0100</td><td style="text-align:center">EOT</td><td style="text-align:center">DC4</td><td style="text-align:center">$</td><td style="text-align:center">4</td><td style="text-align:center">D</td><td style="text-align:center">T</td><td style="text-align:center">d</td><td style="text-align:center">t</td><td></td></tr><tr><td style="text-align:center">0101</td><td style="text-align:center">ENQ</td><td style="text-align:center">NAK</td><td style="text-align:center">%</td><td style="text-align:center">5</td><td style="text-align:center">E</td><td style="text-align:center">U</td><td style="text-align:center">e</td><td style="text-align:center">u</td><td></td></tr><tr><td style="text-align:center">0110</td><td style="text-align:center">ACK</td><td style="text-align:center">SYN</td><td style="text-align:center">&amp;</td><td style="text-align:center">6</td><td style="text-align:center">F</td><td style="text-align:center">V</td><td style="text-align:center">f</td><td style="text-align:center">v</td><td></td></tr><tr><td style="text-align:center">0111</td><td style="text-align:center">BEL</td><td style="text-align:center">ETB</td><td style="text-align:center">‘</td><td style="text-align:center">7</td><td style="text-align:center">G</td><td style="text-align:center">W</td><td style="text-align:center">g</td><td style="text-align:center">w</td><td></td></tr><tr><td style="text-align:center">1000</td><td style="text-align:center">BS</td><td style="text-align:center">CAN</td><td style="text-align:center">(</td><td style="text-align:center">8</td><td style="text-align:center">H</td><td style="text-align:center">X</td><td style="text-align:center">h</td><td style="text-align:center">x</td><td></td></tr><tr><td style="text-align:center">1001</td><td style="text-align:center">HT</td><td style="text-align:center">EM</td><td style="text-align:center">)</td><td style="text-align:center">9</td><td style="text-align:center">I</td><td style="text-align:center">Y</td><td style="text-align:center">i</td><td style="text-align:center">y</td><td></td></tr><tr><td style="text-align:center">1010</td><td style="text-align:center">LF</td><td style="text-align:center">SUB</td><td style="text-align:center">*</td><td style="text-align:center">:</td><td style="text-align:center">J</td><td style="text-align:center">Z</td><td style="text-align:center">j</td><td style="text-align:center">z</td><td></td></tr><tr><td style="text-align:center">1011</td><td style="text-align:center">VT</td><td style="text-align:center">ESC</td><td style="text-align:center">+</td><td style="text-align:center">;</td><td style="text-align:center">K</td><td style="text-align:center">[</td><td style="text-align:center">k</td><td style="text-align:center">{</td><td></td></tr><tr><td style="text-align:center">1100</td><td style="text-align:center">FF</td><td style="text-align:center">FS</td><td style="text-align:center">,</td><td style="text-align:center">&lt;</td><td style="text-align:center">L</td><td style="text-align:center">\</td><td style="text-align:center">l</td><td style="text-align:center">\</td><td></td></tr><tr><td style="text-align:center">1101</td><td style="text-align:center">CR</td><td style="text-align:center">GS</td><td style="text-align:center">-</td><td style="text-align:center">=</td><td style="text-align:center">M</td><td style="text-align:center">]</td><td style="text-align:center">m</td><td style="text-align:center">}</td><td></td></tr><tr><td style="text-align:center">1110</td><td style="text-align:center">SO</td><td style="text-align:center">RS</td><td style="text-align:center">.</td><td style="text-align:center">&gt;</td><td style="text-align:center">N</td><td style="text-align:center">^</td><td style="text-align:center">n</td><td style="text-align:center">~</td><td></td></tr><tr><td style="text-align:center">1111</td><td style="text-align:center">SI</td><td style="text-align:center">US</td><td style="text-align:center">/</td><td style="text-align:center">?</td><td style="text-align:center">O</td><td style="text-align:center">_</td><td style="text-align:center">o</td><td style="text-align:center">DEL</td></tr></tbody></table></div><p><strong>字符串</strong>是指连续的一串字符。通常方式下，它们占用主存中连续的多个字节单元，每个字节单元存储一个字符。</p><p>当<strong>主存字</strong>由“2”个或“4”个字节组成时，在同一个主存字中，既可按从低位字节向高位字节的顺序存放字符串内容，也可按从高位字节向低位字节的顺序存放字符串内容。这两种存放方式都是常用方式。</p><h2 id="5-2-汉字编码"><a href="#5-2-汉字编码" class="headerlink" title="5.2 汉字编码"></a>5.2 汉字编码</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">名称</th><th style="text-align:center">年份</th><th style="text-align:center">字符数</th><th style="text-align:center">字节编码</th><th>内容</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">GB 2312-80</td><td style="text-align:center">1980年</td><td style="text-align:center">7445</td><td style="text-align:center">两字节编码</td><td>常用汉字3755个，次常用汉字3008个，共6763个汉字；以及俄文字母、日语假名、拉丁字母、希腊字母、汉语拼音、一般符号、数字等共682个非汉字符号，加在一起共7445个字符。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">GBK</td><td style="text-align:center">1995年12月</td><td style="text-align:center">21003+883</td><td style="text-align:center">两字节编码</td><td>收录汉字21003个，符号883个，并提供1894个造字码位，简、繁体字融于一库。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">GB 18030—2005</td><td style="text-align:center">2005年</td><td style="text-align:center">70244+</td><td style="text-align:center">变长，采用单字节、双字节、四字节编码</td><td>收录汉字 70244 个，同时还收录了藏文、蒙古文、维吾尔文等主要的少数民族文字</td></tr></tbody></table></div><p>为了使汉字信息交换有一个通用的标准，1980 年我国制定了国家标准 <strong>GB 2312—80</strong>：《信息交换用汉字编码字符集基本集》。在该标准中，挑选了常用汉字 3755 个，次常用汉字 3008 个，共 6763 个汉字，以及俄文字母、日语假名、拉丁字母、希腊字母、汉语拼音、一般符号、数字等共 682 个非汉字符号，加在一起共 7445 个字符，以两字节编码。<strong>GB 2312</strong>也收录了英文字母和数字等符号，并且<strong>仍然以两字节编码</strong>，于是 GB 2312 中的英文字母和数字等就成了我们平常所说的<strong>全角符号</strong>，而 ASCII 码的符号就叫作<strong>半角符号</strong>。</p><p>1995年12月我国发布了中文编码扩展国家标准 <strong>GBK</strong>，完全兼容 GB 2312-80，并且支持国际标准 ISO10646-1 中的全部中日韩汉字，全部字符可以一一映射到 Unicode 2.0 。GBK 是双字节编码，共收录汉字 21003 个，符号 883 个，并提供 1894 个造字码位，简、繁体字融于一库。</p><p>2000 年我国发布了<strong>GB18030—2000</strong>：《信息技术信息交换用汉字编码字符集基本集的扩充》，之后又于 2005 年发布了修订版 GB18030—2005 ：《信息技术中文编码字符集》。 GB 18030与 GBK 、GB2312 完全兼容，编码是变长的，采用单字节、双字节、四字节编码。 GB 18030—2005 收录了 Unicode 中的全部汉字，共收录汉字 70244 个，同时还收录了藏文、蒙古文、维吾尔文等主要的少数民族文字，为推动少数民族的信息化奠定了基础。</p><h2 id="5-3-UniCode与UTF-8"><a href="#5-3-UniCode与UTF-8" class="headerlink" title="5.3 UniCode与UTF-8"></a>5.3 UniCode与UTF-8</h2><p>为了统一表示世界各国的文字，1993年国际标准化组织公布了国际标准 <code>ISO/IEC 10646</code>，简称 <code>UCS</code> 。这一标准为包括汉字在内的各种正在使用的文字规定了统一的编码方案，因此又称为 Unicode。</p><p><strong>Unicode 的基本思路是给每一个字符和符号分配一个永久的、唯一的16位值，称为码点(Code Point)</strong>。</p><p><em>Unicode 支持的字符足够多了，但在发明之后的初期难以推广使用。原因在于 Unicode 用两个或者三个字节表示一个字符，而 ASCII 码用一个字节表示一个字符，对于 连续的两个字节或三个字节，计算机如何知道这是一个Unicode 字符，还是两个或三个 ASCII 字符?此外，对于英文字母构成的文件来说，用 Unicode 表示时，每个字母要用两 个或者三个字节表示(虽然前面的一个或两个字节都为0)，这样文件尺寸会增大为两倍或者三倍，是一种浪费</em>。</p><p><em>为此又设计出了 Unicode 字符集的编码方案，如 UTF-8、UCS-2、UTF-16、UCS-4 和UTF-32, 其中最常用的是UTF-8</em>。</p><p><strong>UTF-8 以“8”位一个字节为单位，是一种可变长度的编码</strong>。它将 Unicode 的码点编码为1～4个字，其编码方案如下：</p><div class="table-container"><table><thead><tr><th>字符码点范围</th><th style="text-align:center">位数</th><th>字节1</th><th>字节2</th><th>字节3</th><th>字节4</th></tr></thead><tbody><tr><td>U+0000～U+007F</td><td style="text-align:center">7</td><td>0XXX,XXXX</td><td></td><td></td><td></td></tr><tr><td>U+0080～U+07FF</td><td style="text-align:center">11</td><td>110X,XXXX</td><td>10XX,XXXX</td><td></td><td></td></tr><tr><td>U+0800～U+FFFF</td><td style="text-align:center">16</td><td>1110,XXXX</td><td>10XX,XXXX</td><td>10XX,XXXX</td><td></td></tr><tr><td>U+10000～U+10FFFF</td><td style="text-align:center">21</td><td>1111,0XXX</td><td>10XX,XXXX</td><td>10XX,XXXX</td><td>10XX,XXXX</td></tr></tbody></table></div><p>UTF-8 的优点在于：<strong>编码 0～127 分配给了ASCII 码，并且用一个字节表示</strong>，因此纯 ASCI 码的字符串也是 UTF-8 的合法字符串，两者一致，这样原先以 ASCII 码存储的文件或处理 ASCI 码的程序，不用改动即可兼容UTF-8；</p><p>UTF-8 编码中的第一个字节指明了这个字符一共有几个字节。</p><ul><li>若第一个字节最高位是 “0”，则该字符只有一个字节；</li><li>若第一个字节最高位是 “1”，则有几个连续 “1” 就表明该字符有几个字节。</li></ul><p>后面的字节都以 “10” 开头， 这样在传输或存储中出错时，很容易跳过出错字节，直接找到下一个字符的起始字节，即<strong>拥有自同步能力</strong>。当前， UTF-8 在互联网上被广泛使用。</p><h1 id="六、检错与纠错"><a href="#六、检错与纠错" class="headerlink" title="六、检错与纠错"></a>六、检错与纠错</h1><h2 id="6-1-码距与校验位位数"><a href="#6-1-码距与校验位位数" class="headerlink" title="6.1 码距与校验位位数"></a>6.1 码距与校验位位数</h2><p>假设数据有 $n$ 位，<strong>为了具备检错或纠错能力，必须增添 $k$ 位校验位</strong>，则数据加校验位一共有 $m=n+k$ 位，称为 <strong>$m$ 位码字</strong>。</p><p>任意两个 $m$ 位的码字，其对应位不同的数目，称为<strong>这两个码字的海明码距</strong>。计算公式为：</p><script type="math/tex; mode=display">\displaystyle d = \left | X-Y \right | =\sum_{i=1}^{m}X_{i} \oplus  Y_{i}</script><p><strong>对于 $n$ 位数据，所有的 $\displaystyle 2^{n} $ 个编码都是合法编码。而增加 $k$ 位校验位变成 $m=n+k$ 位的码字后，在 $\displaystyle 2^{n} $ 个码字中，仍然只有 $\displaystyle 2^{n} $ 个码字是合法的。在这 $\displaystyle 2^{n} $ 个合法码字之间，两两码字之间海明码距的最小值 $\displaystyle d_{\mathrm{min} } $ ，称为这种编码的海明码距</strong>。</p><p><strong>编码的检错与纠错能力取决于其海明码距 $\displaystyle d_{\mathrm{min} } $ </strong>：</p><ul><li>如果要检测 $r$ 位错，则编码的码距 $d$ 至少应为 $r+1$ ，使得一个合法码字的 $r$ 位出错时不会成为另一个合法码字。</li><li>要纠正 $r$ 位错，则编码的码距 $d$ 至少应为 $2r+1$ ，使得一个合法码字 $r$ 位出错时，得到的新码字与原合法码字的<strong>码距</strong>(大小为r)，一定比它与其他合法码字间的<strong>码距</strong>（大于等于 $r+1$ ）要小。因此，只要选取与该错误码字码距最小的合法码字作为正确的码字，就实现了纠错。</li></ul><p>满足一位纠错能力的条件：</p><script type="math/tex; mode=display">\displaystyle 2^{k} \ge n+k+1</script><p><strong>数据长度与校验位位数的关系</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">n</th><th style="text-align:center">$\displaystyle k_{min} $</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2～4</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">5～11</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">12～26</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">27～57</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">58～120</td><td style="text-align:center">7</td></tr></tbody></table></div><h2 id="6-2-奇偶校验码"><a href="#6-2-奇偶校验码" class="headerlink" title="6.2 奇偶校验码"></a>6.2 奇偶校验码</h2><h3 id="6-2-1-奇校验"><a href="#6-2-1-奇校验" class="headerlink" title="6.2.1 奇校验"></a>6.2.1 奇校验</h3><p>$\displaystyle n$ 位的数据 $\displaystyle X=x_{0} x_{1} x_{2} \cdots x_{n-1} $ ，在最高位添加一位奇校验位 $\displaystyle c$ ，则完整的<strong>码字</strong>为 $\displaystyle X{}’ =cx_{0} x_{1} x_{2} \cdots x_{n-1} $ 。奇校验定义为：</p><script type="math/tex; mode=display">\displaystyle c\oplus x_{0} \oplus x_{1} \oplus x_{2}\oplus  \cdots \oplus x_{n-1} =0</script><blockquote><p>之所以称为奇校验，是因为必须保证数据（包括奇校验位在内）的 $n+1$ 位中“1”的个数为奇数。</p></blockquote><h3 id="6-2-2-偶检验"><a href="#6-2-2-偶检验" class="headerlink" title="6.2.2 偶检验"></a>6.2.2 偶检验</h3><p>偶校验的概念与奇校验是一样的，就是加上偶校验后，必须保证数据（包括偶校验位在内）的 $n+1$ 位中“1”的个数为偶数，即必须保证：</p><script type="math/tex; mode=display">\displaystyle c\oplus x_{0} \oplus x_{1} \oplus x_{2}\oplus  \cdots \oplus x_{n-1} =1</script><h2 id="6-3-海明校验码🌋🌋"><a href="#6-3-海明校验码🌋🌋" class="headerlink" title="6.3 海明校验码🌋🌋"></a>6.3 海明校验码🌋🌋</h2><h3 id="6-3-1-海明码的编码"><a href="#6-3-1-海明码的编码" class="headerlink" title="6.3.1 海明码的编码"></a>6.3.1 海明码的编码</h3><p>假设，有效信息为 16 位数据，用 $\displaystyle D_{15} \gets D_{0} $ ，表示由高到低的各位。若要纠正 1 位错误，需要在有效信息中添加 5 个校验位 $\displaystyle H_{4} \gets H_{0} $ 。 <strong>此时海明码的码长为</strong>： $\displaystyle m=21$ 。</p><div class="table-container"><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">校验</th><th style="text-align:center">数据</th><th style="text-align:center">$\displaystyle P_{0} /H_{0} $</th><th style="text-align:center">$\displaystyle P_{1} /H_{1} $</th><th style="text-align:center">$\displaystyle P_{2} /H_{2} $</th><th style="text-align:center">$\displaystyle P_{3} /H_{3} $</th><th style="text-align:center">$\displaystyle P_{4} /H_{4} $</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$\displaystyle H_{0} $</td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$\displaystyle H_{1} $</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{0} $</td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$\displaystyle H_{2} $</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{1} $</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{2} $</td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{3} $</td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">$\displaystyle H_{3} $</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{4} $</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{5} $</td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{6} $</td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">12</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{7} $</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">13</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{8} $</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">14</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{9} $</td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{10} $</td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">$\displaystyle H_{4} $</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{11} $</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{12} $</td><td style="text-align:center"></td><td style="text-align:center">☑️</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{13} $</td><td style="text-align:center">✅</td><td style="text-align:center">☑️</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{14} $</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center"></td><td style="text-align:center">$\displaystyle D_{15} $</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center">✅</td></tr></tbody></table></div><h3 id="6-3-2-海明码的校验"><a href="#6-3-2-海明码的校验" class="headerlink" title="6.3.2 海明码的校验"></a>6.3.2 海明码的校验</h3><ol><li><p>构建生成方程；</p><p> 根据上述内容进行构建。</p></li><li><p>构成海明码；</p></li><li><p>构建校验方程：<strong>当获得一个海明码时，使用校验方程来判断该编码的正确性</strong>。</p><ol><li>如果读取或接收的海明码正确，则<strong>各校验方程的计算结果应为全“0”</strong>；</li><li>若计算结果不为全“0”，则 $\displaystyle P_{4} P_{3} P_{2} P_{1} P_{0} $ 的<strong>编码值的无符号真值</strong>，就是海明码出错位的位置编号。</li></ol></li></ol><h3 id="6-3-3-海明码的纠错"><a href="#6-3-3-海明码的纠错" class="headerlink" title="6.3.3 海明码的纠错"></a>6.3.3 海明码的纠错</h3><p>根据校验方程即可直接确定海明码是否有错或者出错位置编号。知道出错位置，对该位求反，就实现了纠错。所以海明码也被称作<strong>纠错码</strong>，<strong>具有纠正一位错误的能力</strong>。</p><h3 id="6-3-4-单纠错双检错码"><a href="#6-3-4-单纠错双检错码" class="headerlink" title="6.3.4 单纠错双检错码"></a>6.3.4 单纠错双检错码</h3><p><strong>观察海明码的生成方程可以发现，每一个数据位至少出现在两个生成方程中，即被两个校验位校验</strong>。因此当一个数据位变化时，至少有两个校验位也随之变化，这意味着两个合法码字之间的码距至少为3。</p><p>实际上，当 $\displaystyle n=8,k=4$ 时，海明码的码距就是3，<strong>它可以纠正1位错误，或者发现2位错误而不纠正</strong>。那么同时纠正1位错误，以及发现2位错误呢，就需要进一步扩大码距。</p><p>方案是：增加一个所有数据位异或得到的校验位（即偶校验）。如果该校验位校验错误，表示可能有1位错误（实际上说明有奇数位错误）；进一步根据 $\displaystyle P_{3} P_{2} P_{1} P_{0} $ ，具体确定错误位的位置，并纠错。反之，如果该校验位校验正确，且 $\displaystyle P_{3} P_{2} P_{1} P_{0} $ 不是全零，则表示有2位错误（实际上为偶数位错误），只给出校验错误信息，不纠错，这就是半导体存储器中常用的<strong>单纠错双检错(Single-Error- Correcting, Double-Error-Detecting, SEC-DED)码</strong>。</p><h2 id="6-4-循环冗余校验码"><a href="#6-4-循环冗余校验码" class="headerlink" title="6.4 循环冗余校验码"></a>6.4 循环冗余校验码</h2><p><strong>循环冗余校验(Cyclic Redundancy Check, CRC)码</strong>可以发现并纠正信息在存储或传送过程中出现的错误。</p><h3 id="6-4-1-“模2”运算"><a href="#6-4-1-“模2”运算" class="headerlink" title="6.4.1 “模2”运算"></a>6.4.1 “模2”运算</h3><ul><li><p>模2加法：按位加，不考虑进位。</p><p>  0+0=0，0+1=1，1+0=1，1+1=0</p></li><li><p>模 2 减法：按位减，不考虑借位。</p><p>   0-0=0，0-1=1，1-0=1，1-1=0</p></li></ul><blockquote><p>模2减法与模2加法运算结果相同，因此可用模2加法代替模2减法。</p></blockquote><ul><li>模2乘法：按模2加求部分积之和，不考虑进位。</li><li>模2除法：按模2减求部分余数，不借位，每求一位商应使部分余数减少一位。求商的规则是：余数首位为“1”商取“1”，余数首位为“0”商取“0”。当余数位数小于除数位数时，即为最后的余数。<ol><li>如果被除数的首位为 “1”，那么商的第一位为 “1”；如果被除数的首位为 “0”，那么商的第一位为 “0”；</li><li>被除数与除数进行<strong>模2减法</strong>（相减时，高位对齐，即左对齐，除数低位补 “0”），得到余数；</li><li>余数舍去首位（最高位）；如果余数的新首位为 “1”，那么商的第一位为 “1”；如果余数的新首位为 “0”，那么商的第二位为 “0”；</li><li>余数与除数进行<strong>模2减法</strong>（相减时，高位对齐，即左对齐，除数低位补“0”），得到余数；</li><li>重复（3）到（5）；</li><li>如果余数舍去首位后的位数小于除数，那么运算结束，最后剩余的余数就是最终的余数；</li></ol></li></ul><h3 id="6-4-2-CRC-码的编码"><a href="#6-4-2-CRC-码的编码" class="headerlink" title="6.4.2 CRC 码的编码"></a>6.4.2 CRC 码的编码</h3><p>设 $n$ 位数据为 $\displaystyle D_{n-1}\sim D_{0}  $ ， $k+1$ 位生成码为 $\displaystyle G_{k}\sim G_{0}  $ ，则构成的<strong>CRC码</strong>的码长为 $m=n+k$ ，其中包含 $k$ 位校验位。</p><ol><li><p>二进制数据用多项式表示。</p><p> 将 $n$ 位数据用多项式 $\displaystyle M(x)$ 表示为：</p><script type="math/tex; mode=display"> \displaystyle M(x) = D_{n-1} x^{n-1} +D_{n-2} x^{n-2} +\dots +D_{0} x^{0}</script><p>  $k+1$ 位生成码用多项式 $\displaystyle G(x)$ 表示为：</p><script type="math/tex; mode=display"> \displaystyle G(x)=G_{k} x^{k} +G_{k-1} x^{k-1} +\cdots +G_{0} x^{0}</script></li><li><p>数据做左移 $k$ 位操作。</p><p> 数据左移 $k$ 位，相当于多项式 $\displaystyle M(x)$ 做乘以 $\displaystyle x^{k} $ 的操作，即得 $\displaystyle M(x)\cdot x^{k} $ ，其 $n+k$ 位的二进制编码如下图所示</p></li><li><p>求余数。</p><p> 用 $\displaystyle M(x)\cdot x^{k} $ 对生成多项式 $\displaystyle G(x)$ 作<strong>模2除法</strong>，求余数多项式 $\displaystyle R(x)$ ，即</p><script type="math/tex; mode=display"> \displaystyle \frac{M(x)\cdot x^{k} }{G(x)} = Q(x)+\frac{R(x)}{G(x)}</script><p> 其中， $Q(x)$ 为商的多项式，余数 $R(x)$ 的二进制编码为 $k$ 位。</p><blockquote><p>在此强调，除法过程必须按照<strong>模2运算</strong>规则计算。</p></blockquote></li><li><p>构成<strong>CRC码</strong>。</p><p> 将余数作为校验位，用（2）中获得的待编信息码的多项式 $\displaystyle M(x)\cdot x^{k} $ 与余数 $R(x)$ 作“模2加法”，构成<strong>CRC码</strong>多项式 $\displaystyle C(x)$ ：</p><script type="math/tex; mode=display"> \displaystyle C(x) = M(x)\cdot x^{k} +R(x) = Q(x)\cdot G(x)</script><p> <strong>CRC码</strong>的编码格式如图所示：</p><p> <img src="https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/2/CRC码的编码格式.png" alt="CRC码的编码格式"></p></li></ol><p>所以，<strong>CRC码</strong>是用多项式 $\displaystyle M(x)\cdot x^{k} $ 除以生成多项式 $\displaystyle G(x)$ （即生成校验位的多项式）所得余数作为校验位的。为了得到 $k$ 位余数（校验位），生成码必须是 $k+1$ 位的。</p><h3 id="6-4-4-CRC码的校验"><a href="#6-4-4-CRC码的校验" class="headerlink" title="6.4.4 CRC码的校验"></a>6.4.4 CRC码的校验</h3><p>根据前面知识可得：</p><script type="math/tex; mode=display">\displaystyle C(x) = M(x)\cdot x^{k} +R(x) = Q(x)\cdot G(x)</script><p>也即“CRC码”是一个可被生成码除尽的数码。如果CRC码在存储或传输过程中不出错，则 $\displaystyle C(x)$ 除以 $\displaystyle G(x) $ 的余数必为“0”。如果CRC码出错，则余数不为“0”，利用余数编码与错误位的对应关系（需要在设计CRC码时确定），就可以指出哪一位出错。</p><h3 id="6-4-5-CRC码的纠错"><a href="#6-4-5-CRC码的纠错" class="headerlink" title="6.4.5 CRC码的纠错"></a>6.4.5 CRC码的纠错</h3><ol><li><p>方法一：如果已设计好余数和出错位的对应关系，则通过查表的方法即可确定CRC码的出错位，对出错位求反即可纠正。</p></li><li><p>方法二：如果CRC码有一位出错，则用 $\displaystyle G(x) $ 做“模2除法”，将得到一个不为0的余数。如果对余数补0继续除下去，将发现各次所得余数将出现循环。</p><p> 比如“位置1”出错，其余数为“001”；补0后再除，第二次余数为“010”；以后依次为100、011、……反复循环，这就是<strong>循环码</strong>的由来。</p><p> 这个特点正好用来纠错，即当出现不为零的余数后，</p><ul><li>一方面对余数补0，继续做模2除法，</li><li>另一方面将被检测的CRC码字<strong>循环左移</strong>。当出现余数为 101 （最高出错位对应的余数）时，出错位也移到了位置7（最高位）。可通过异或门将它纠正后，再在下一次移位时送回位。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 考研 </category>
          
          <category> 计算机学习，计算机组成，计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计算机学习 </tag>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 绪论【计算机组成与系统结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/01.%E7%BB%AA%E8%AE%BA.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/01.%E7%BB%AA%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="文章导航"><a href="#文章导航" class="headerlink" title="文章导航"></a>文章导航</h2><blockquote><p>计算机组成与系统结构：</p><ol><li><a href="./01.绪论.md">第一章 绪论【计算机组成与系统结构】</a></li><li></li></ol></blockquote><h1 id="一、计算机的发展历史"><a href="#一、计算机的发展历史" class="headerlink" title="一、计算机的发展历史"></a>一、计算机的发展历史</h1><h2 id="1-1-发展历史"><a href="#1-1-发展历史" class="headerlink" title="1.1 发展历史"></a>1.1 发展历史</h2><p>电子数字计算机的发展根据所使用的电子元器件划分为如下几个阶段：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">时间</th><th style="text-align:center">类型</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1946—1957</td><td style="text-align:center">电子管计算机</td><td style="text-align:center">由<strong>电磁继电器</strong>、<strong>电子管</strong>等器件构成的</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1958—1964</td><td style="text-align:center">晶体管计算机</td><td style="text-align:center">由<strong>晶体管</strong>、<strong>磁芯存储器</strong>等构成；软件上采用监控程序对计算机进行管理，并且<strong>开始使用高级语言</strong></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1965—1971</td><td style="text-align:center">中小规模集成电路计算机</td><td style="text-align:center">由中小规模的<strong>集成电路芯片</strong>、<strong>多层印刷电路板</strong>以及<strong>磁芯存储器</strong>等结构</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1972—2010</td><td style="text-align:center">大规模和超大规模集成电路计算机</td><td style="text-align:center">大规模和超大规模集成电路计算机</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">2010—至今</td><td style="text-align:center">巨大规模集成电路</td><td style="text-align:center">【NULL】</td></tr></tbody></table></div><h2 id="1-2-摩尔定律"><a href="#1-2-摩尔定律" class="headerlink" title="1.2 摩尔定律"></a>1.2 摩尔定律</h2><p>1965年4月，摩尔在《电子学》杂志上的文章中讲述：如何将50个晶体管集成在一块芯片上，并且预言：到1975年，就可以将6.5万只这样的元件密植在一块芯片上，支撑高度复杂的集成电路。</p><p>文章的核心思想：预测集成电路芯片内可集成的晶体管数量差不多每年可增加一倍，在后来的技术发展过程中证明是正确的，并被称为<strong>摩尔定律</strong>。</p><p>现在人们根据几十年走过的技术历程将莫俄日的那个率描述为：<strong>集成电路芯片的集成度每18个月翻一番</strong>。</p><blockquote><p>后来摩尔与其他人共同成立了英特尔（Intel）公司。</p></blockquote><p><strong>摩尔定律的影响</strong>体现在如下几个方面：</p><ol><li>更低的成本（更低的单位价格，更高的性能）；</li><li>更高的集成度；</li><li>更小的尺寸；</li><li>更低的功耗；</li><li>更好的可靠性。</li></ol><h1 id="二、计算机的基本组成"><a href="#二、计算机的基本组成" class="headerlink" title="二、计算机的基本组成"></a>二、计算机的基本组成</h1><p>计算机由<strong>硬件</strong>和<strong>软件</strong>两大部分组成，其基本功能为<strong>控制</strong>、<strong>运算</strong>、<strong>存储</strong>和<strong>控制</strong>。</p><h2 id="2-1-硬件系统"><a href="#2-1-硬件系统" class="headerlink" title="2.1 硬件系统"></a>2.1 硬件系统</h2><h3 id="2-1-1-硬件组成"><a href="#2-1-1-硬件组成" class="headerlink" title="2.1.1 硬件组成"></a>2.1.1 硬件组成</h3><p>⚡⚡早期的计算机由<strong>运算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入设备</strong>、<strong>输出设备</strong>这五大部件构成：</p><p><img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/1_绪论.md/冯·诺依曼结构.svg" alt="冯·诺依曼结构"></p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">部件名称</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">运算器</td><td>实现<strong>算术运算</strong>和<strong>逻辑运算</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">控制器</td><td>根据指令，产生相应的控制信号，并且控制其他部件</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">存储器</td><td>存放<strong>数据</strong>和<strong>程序（指令）</strong></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">输入设备</td><td>将外部信息输入到计算机中</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">输出设备</td><td>接收计算机的处理结果，并做出显示、存储等操作</td></tr></tbody></table></div><h3 id="2-1-2-冯·诺依曼计算机的特点"><a href="#2-1-2-冯·诺依曼计算机的特点" class="headerlink" title="2.1.2 冯·诺依曼计算机的特点"></a>2.1.2 冯·诺依曼计算机的特点</h3><p>👑👑冯·诺依曼计算机的特点：</p><ol><li>计算机由<strong>运算器（ALU）</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入设备</strong>、<strong>输出设备</strong>这五大部件构成。</li><li><strong>指令和数据以二进制形式表示，以同等地位存放在存储器中，并且按照地址访问</strong>。</li><li><strong>指令由操作码可地址码组成</strong>。</li><li>将计算机要处理的问题用指令编写成<strong>程序</strong>（程序化问题解决方案）。</li><li>指令逐条（顺序）从存储器中取出并且执行（指令的顺序执行性）。</li><li>特定情况下，跳转类指令可改变指令的执行顺序（指令的可跳转性）。</li><li>早期的冯·诺依曼计算机<strong>以运算器为中心</strong>，输入/输出设备通过运算器与存储器传送数据。</li></ol><h3 id="2-1-3-计算机硬件结构的发展"><a href="#2-1-3-计算机硬件结构的发展" class="headerlink" title="2.1.3 计算机硬件结构的发展"></a>2.1.3 计算机硬件结构的发展</h3><ol><li><p>不断扩充硬件及功能：增加了更多的通用寄存器、多种寻址方式，支持<strong>浮点数据类型</strong>、<strong>中断</strong>和<strong>异步 I/O 结构</strong>。</p></li><li><p>存储器分层：<strong>引入高速缓存（<code>Cache</code>）</strong>、虚拟存储器等。</p></li><li><p><strong>总线结构</strong>：通过总线连接计算机系统中的各个模块。<strong>总线信号根据传输的信息类型，分为地址线、控制线、数据线</strong>。</p><ol><li>地址线：用来选择要访问的存储单元或I/O 接口；</li><li>控制线：用来传输相应的读写控制信号；</li><li><p>数据线：用来传输数据。</p><blockquote><p>总线大大简化了计算机系统各模块之间的连接，增强了计算机系统硬件的扩展能力。</p></blockquote></li></ol></li></ol><p><img src="https://imageshack.yuilexi.cn/University/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/1/%E7%8E%B0%E4%BB%A3%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%93%E6%A1%86%E5%9B%BE.png" alt=""></p><h2 id="2-2-软件系统"><a href="#2-2-软件系统" class="headerlink" title="2.2 软件系统"></a>2.2 软件系统</h2><p>在计算机系统中，各种软件相互配合，支持计算机有条不紊地工作，这一系列软件就构成了计算机的软件系统。软件系统一般包括两大部分：<strong>系统软件</strong>和<strong>应用软件</strong>。</p><ol><li><p>系统软件</p><ol><li><strong>操作系统</strong>：包括五大功能：<strong>处理器管理、存储管理、文件管理、设备管理和作业管理</strong>。</li><li>语言处理程序;</li><li>各种服务支持软件;</li></ol></li><li><p>应用软件：<strong>应用软件是指用户在各自的应用中，为解决自己的任务而编写的程序</strong>。</p><p> 例如，应用软件包括用于办公自动化、视频编辑、图形图像处理、科学计算、信息管理、过程控制、武器装备等方面的软件。</p></li></ol><h2 id="2-3-指令集体系结构（ISA）"><a href="#2-3-指令集体系结构（ISA）" class="headerlink" title="2.3 指令集体系结构（ISA）"></a>2.3 指令集体系结构（ISA）</h2><p><strong>计算机系统的底层逻辑只能识别机器语言，也就是存储在主存中的指令</strong>。 <code>CPU</code> 从主存中取指令，执行指令，<strong>每条指令可实现计算机系统内最基本的操作</strong>，比如基本的算术运算（加、减）、逻辑运算（与、或、异或、移位）、数据传送（装载、存储）、跳转（条件转移、无条件转移），<strong>这些指令被编码为一个字或多个字节组成的二进制格式</strong>。</p><h3 id="2-3-1-指令集体系结构的概述"><a href="#2-3-1-指令集体系结构的概述" class="headerlink" title="2.3.1 指令集体系结构的概述"></a>2.3.1 指令集体系结构的概述</h3><p>处理器支持的指令和指令的字节级编码成为<strong>指令集体系结构</strong>。 <code>ISA</code> 是软件和硬件的分界面：软件是由<code>ISA</code> 规定的“指令”组成的，指令通过二进制编码规定其功能、源操作数和目的操作数的位置等信息。</p><p><code>ISA</code> 不仅要规定指令集，还要定义任何系统程序员需要了解的硬件信息。 <code>ISA</code> 需要规定计算机程序员可见的所有组件及操作，包括：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th>内容</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">指令集</td><td>指令格式；数据类型；寻址方式</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">软件可见的处理器状态</td><td><strong>寄存器的个数、名称、长度和用途</strong>；指令执行过程中的控制方式。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">存储模型</td><td>主存组织；字节次序；存储保护；虚拟存储器的管理方式；输入/输出接口的访问与管理方式。</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">系统模型</td><td>处理器状态；特权级别；中断和异常的处理方式。</td></tr></tbody></table></div><h3 id="2-3-2-典型的ISA"><a href="#2-3-2-典型的ISA" class="headerlink" title="2.3.2 典型的ISA"></a>2.3.2 典型的ISA</h3><h3 id="1-2-3-2-典型的-ISA"><a href="#1-2-3-2-典型的-ISA" class="headerlink" title="1.2.3.2 典型的 ISA"></a>1.2.3.2 典型的 ISA</h3><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">名称</th><th style="text-align:left">诞生</th><th>特点</th><th>应用</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">x86</td><td style="text-align:left">Intel公司推出于，1978年首次用于8086处理器。</td><td>个人计算机的标准处理器架构，成为桌面计算机和高性能计算领域最成功的 <code>ISA</code> 。</td><td>目前，绝大多数个人计算机、工作站、服务器、超级计算机使用的都是兼容x86 指令集体系结构的处理器。可运行于 x86 处理器的操作系统主要有 Microsoft Windows 和 Linux 系列，以及Apple 公司的 macOS。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">ARM</td><td style="text-align:left">【NULL】</td><td>将低功耗、低成本的优先级排在高性能之前，主要面向嵌入式应用。</td><td>可运行于 ARM 处理器的操作系统主要有 Linux、Google 的 Android 和 Apple 的 iOS。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">POWER</td><td style="text-align:left">IBM 公司设计开发，最早于1990年推出。</td><td>性能卓越</td><td>【NULL】</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">MIPS</td><td style="text-align:left">【NULL】</td><td>无内部互锁流水线微处理器，一款经典的精简指令集架构</td><td>MIPS 的高端处理器主要用于 SGI 公司的高性能工作站、服务 器和超级计算机系统；而 MIPS 的低功耗处理器被广泛用于路由器、游戏机、激光打印机等嵌入式设备中。可运行于 SPARC 处理器的操作系统主要是 Sun/Oracle 的 Solaris(基于 UNIX)。另外， NeXTSTEP、 Linux 、FreeBSD、OpenBSD 及 NetBSD 操作系统也提供了SPARC 版本</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">SPARC</td><td style="text-align:left">【NULL】</td><td>面向高性能服务器，具有非常高的性能；但是芯片面积、功耗太大，不适用于个人计算机和嵌入式领域。</td><td>可运行于 SPARC 处理器的操作系统主要是 Sun/Oracle 的 Solaris(基于 UNIX)。另外， NeXTSTEP、 Linux 、FreeBSD、OpenBSD 及 NetBSD 操作系统也提供了SPARC 版本。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RISC-V</td><td style="text-align:left">袖珍的、开源的 ISA，于2011年推出</td><td>简洁，低成本，高性能（或低功耗），架构和具体实现分离，并预留一定的扩展空间。</td><td>【NULL】</td></tr></tbody></table></div><h1 id="三、计算机的层次概念"><a href="#三、计算机的层次概念" class="headerlink" title="三、计算机的层次概念"></a>三、计算机的层次概念</h1><h2 id="3-1-计算机系统的层次结构"><a href="#3-1-计算机系统的层次结构" class="headerlink" title="3.1 计算机系统的层次结构"></a>3.1 计算机系统的层次结构</h2><p><img src="https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/1_绪论.md/计算机系统的层次结构.svg" alt="计算机系统的层次结构"></p><ol><li>第一级：<strong>硬件逻辑层</strong>。</li><li>第二级：<strong>机器语言层</strong>。该层的主要设计工作是计算机体系结构设计，包括指令系统设计，所以该层也成为<strong>指令集体系结构层</strong>。<strong>无论用什么语言编写的程序，最终都必须编译为机器语言程序。而机器语言是面向具体硬件物理计算机的，不同的计算机其机器语言也不相同</strong>。</li><li>第三级：<strong>操作系统层</strong>。操作系统的功能是对整个系统的硬件、软件资源进行有效管理：在设计计算机时必须考虑要尽可能多地对操作系统给予支持。</li><li>第四级：<strong>汇编语言层</strong>。汇编语言层涉及的指令系统是面向特定处理器的，不同处理器的指令系统是不一样的。</li><li><strong>第五级</strong>：<strong>高级语言层</strong>。此层上的用户为高级语言程序设计者。高级语言程序由<strong>编译程序</strong>转换成计算机可执行的机器语言（二进制代码），再由计算机执行</li><li>第六级：<strong>应用语言层</strong>。在此层可设计更适合于应用的、更接近自然语言的编程语言，使应用者在虚拟计算机上工作，完全不依赖计算机硬件系统。</li></ol><h2 id="3-2-计算机体系结构、组成与实现"><a href="#3-2-计算机体系结构、组成与实现" class="headerlink" title="3.2 计算机体系结构、组成与实现"></a>3.2 计算机体系结构、组成与实现</h2><p><strong>计算机体系结构</strong>、<strong>计算机组成</strong>与<strong>计算机实现</strong>三者有密切的关系，但又各不相同，且具有不同的概念。</p><h3 id="3-2-1-计算机体系结构"><a href="#3-2-1-计算机体系结构" class="headerlink" title="3.2.1 计算机体系结构"></a>3.2.1 计算机体系结构</h3><p><strong>计算机体系结构</strong>是程序员所看到的计算机系统的属性，即概念性结构及功能特性。不同层次上的程序员所看到的计算机。</p><p>在定义计算机体系结构的年代里，计算机的属性、概念性结构及功能特性主要是指低层的硬件。今天的计算机体系结构所指的计算机的属性主要 包括：数据的表示形式；寻址方式；内部寄存器组；指令集；中断系统；处理器工作状态及其切换；存储系统结构；输入/输出结构；信息保护及特权；高性能设计等。</p><h3 id="3-2-2-计算机组成"><a href="#3-2-2-计算机组成" class="headerlink" title="3.2.2 计算机组成"></a>3.2.2 计算机组成</h3><p><strong>计算机组成</strong>也被称为计算机组织，<strong>是计算机系统的逻辑实现，包括最底层内部算法、 数据流、控制流的逻辑实现</strong>。计算机组成的设 计主要包括：数据通路的宽度（带宽）；专用部件（如乘除法专用部件、浮点运算专用部件）的设置；各功能部件的并行程度；控制器的组成方法；存储器使用的技术；缓冲与排队技术的应用；预估、预判方法；高可靠性技术等。</p><h3 id="1-3-2-3-计算机实现"><a href="#1-3-2-3-计算机实现" class="headerlink" title="1.3.2.3 计算机实现"></a>1.3.2.3 计算机实现</h3><p>计算机实现就是指<strong>计算机组成的物理实现</strong>。 在上述计算机体系结构及计算机组成的基础上，利用具体的物理器件，根据计算机组成的逻辑设计，即可实现物理计算机。</p><blockquote><p>综上可以看到，计算机体系结构、计算机组成与计算机实现三者在概念上是不同层次的，但是它们的联系是十分紧密的。</p><p>体系结构决定了计算机的总体属性，组成是体现这些属性的逻辑设计，而实现则是用物理器件来实现逻辑设计。<strong>相同的体系结构可以有不同的组成，相同的组成可以有不同的实现</strong>。</p></blockquote><h1 id="四、计算机分类及性能描述"><a href="#四、计算机分类及性能描述" class="headerlink" title="四、计算机分类及性能描述"></a>四、计算机分类及性能描述</h1><h2 id="4-1-计算机分类"><a href="#4-1-计算机分类" class="headerlink" title="4.1 计算机分类"></a>4.1 计算机分类</h2><h3 id="4-1-1-按用途分类"><a href="#4-1-1-按用途分类" class="headerlink" title="4.1.1 按用途分类"></a>4.1.1 按用途分类</h3><ol><li>通用计算机：<ol><li>个人计算机；</li><li>服务器；</li><li>超级计算机。</li></ol></li><li>嵌入式计算机；</li></ol><h3 id="4-2-2-Flynn-分类法🐲"><a href="#4-2-2-Flynn-分类法🐲" class="headerlink" title="4.2.2 Flynn 分类法🐲"></a>4.2.2 Flynn 分类法🐲</h3><p>在程序执行中，存在三种信息流：</p><ol><li>指令流（IS）：机器执行的指令序列，它由<strong>存储器</strong>流入<strong>控制单元(CU)</strong>；</li><li>数据流（DS）：指令流所使用的数据，包括输入数据、中间数据和结果。数据在<strong>处理单元(PU)</strong>中进行处理；</li><li>控制流（CS）：指令流进入 CU ，由 CU 产生一系列控制流（信号），在控制流的控制下完成指令的功能。</li></ol><p>按照 <strong>Flynn</strong> 分类法，可以将计算机分为四类：（相当重要 🐲🐲🐲🐲🐲🐲🐲）</p><ol><li><strong>单指令流单数据流</strong>；</li><li><strong>单指令流多数据流</strong>；</li><li><strong>多指令流单数据流</strong>；（无计算机实例）</li><li><strong>多指令流多数据流</strong>。</li></ol><h2 id="4-2-计算机系统的性能描述"><a href="#4-2-计算机系统的性能描述" class="headerlink" title="4.2 计算机系统的性能描述"></a>4.2 计算机系统的性能描述</h2><p>计算机系统的性能计算：</p><ol><li><p><strong>执行时间（响应时间）</strong>：一个任务从开始到完成所有的时间，或者计算机完成一个任务所有的总时间。</p></li><li><p><strong>吞吐量</strong>：在给定的时间内（并行）完成的总任务数。</p></li><li><p>计算机的性能计算：</p><script type="math/tex; mode=display"> \displaystyle \text{性能}P = \frac{1}{\text{执行时间}T }</script><p> 也能得到：</p><script type="math/tex; mode=display"> \displaystyle \text{性能}P = \frac{\text{完成任务总数} } {\text{完成任务所需要的时间} }  = \text{吞吐率}</script></li></ol><pre><code>&gt; 即**计算机的性能**与其**吞吐率**成正比。</code></pre><h2 id="4-3-Amdahl-定律"><a href="#4-3-Amdahl-定律" class="headerlink" title="4.3 Amdahl 定律"></a>4.3 Amdahl 定律</h2><p><strong><code>Amdahl</code>定律</strong>的内容是：计算机系统中，某一部件采用更快的执行方式后，整个系统性能的提高于与<strong>这种执行方式的使用频率</strong>或<strong>占中执行时间的比例</strong>有关。</p><p><code>Amdahl</code>定律给出加速比的定义：</p><script type="math/tex; mode=display">\displaystyle {\color{Blue} \text{加速比} =\frac{\text{改进后的系统性能} }{\text{改进前的系统性能} } =\frac{\text{改进后的系统总执行时间} }{\text{改进前的系统总执行时间} } }</script><p><strong>计算机的加速比取决于下面两个因素</strong>：</p><ol><li>可改进部分在原系统中执行时间中所占的比例，成为<strong>可改进比例</strong>，记作 $\displaystyle f_{e} $ ；</li><li>可改进部分改进后，性能提升的程度：通常用<strong>部件加速比 $\displaystyle r_{e} $ 来表示</strong>。</li></ol><p>假设改进前系统总执行时间为 $\displaystyle T_{0} $ ，可以得出改进后的系统总执行时间 $\displaystyle T_{n} $ 为</p><script type="math/tex; mode=display">\displaystyle T_{n}  = T_{0}(1-f_{e} +\frac{f_{e} }{r_{e} } )</script><p>如果用加速比 $\displaystyle S_{p} $ 表示，那么可以表示为：</p><script type="math/tex; mode=display">\displaystyle {\color{Red} {\large S_{p}  = \frac{1}{1-f_{e} +\frac{f_{e} }{r_{e} }  } } }</script>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 考研 </category>
          
          <category> 计算机学习，计算机组成，计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计算机学习 </tag>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio Code显示Unity依赖项</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E7%BC%96%E8%BE%91%E5%99%A8/VSCode%E6%98%BE%E7%A4%BA%E4%BE%9D%E8%B5%96%E9%A1%B9.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E7%BC%96%E8%BE%91%E5%99%A8/VSCode%E6%98%BE%E7%A4%BA%E4%BE%9D%E8%B5%96%E9%A1%B9.html</url>
      
        <content type="html"><![CDATA[<p>使用<strong>Visual Studio Code</strong>来作为Unity的脚本编辑器时，可以极大的提升开发效率。但是，有时我们希望查看依赖库中的函数，经常定位不进去，报无法导航到插入点下面的符号。</p><p>这是因为，<strong>VS Code</strong>的工程代码没有把依赖库的代码导入进来，所以定位不到函数所在的位置。</p><p>解决办法：<code>Edit-&gt; Preferences-&gt;External Tools</code>，把<code>Registry packages</code>勾选上，然后点击<code>Regenerate project files</code>。就会把我们从<code>Pakage manager</code>安装的代码都导入<strong>VS Code</strong>了。如果你的依赖库有从其他途径导入的，你要相应的勾选上选项。</p><p><img src="https://imageshack.yuilexi.cn/Unity3D/%E7%BC%96%E8%BE%91%E5%99%A8/VisualStudioCode%E6%98%BE%E7%A4%BAUnity%E4%BE%9D%E8%B5%96%E9%A1%B9/%E4%BE%9D%E8%B5%96%E9%A1%B9%E8%AE%BE%E7%BD%AE.png" alt="依赖项设置" style="zoom:50%" /></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> 编辑器 </tag>
            
            <tag> Visual Studio Code </tag>
            
            <tag> 依赖项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 概率论的基本概念【概率论与数理统计】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/1_%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/1_%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-概率论的基本概念【概率论与数理统计】"><a href="#第一章-概率论的基本概念【概率论与数理统计】" class="headerlink" title="第一章 概率论的基本概念【概率论与数理统计】"></a>第一章 概率论的基本概念【概率论与数理统计】</h1><h1 id="一、随机实验"><a href="#一、随机实验" class="headerlink" title="一、随机实验"></a>一、随机实验</h1><h2 id="1-1-随机试验与随机事件"><a href="#1-1-随机试验与随机事件" class="headerlink" title="1.1 随机试验与随机事件"></a>1.1 随机试验与随机事件</h2><p><strong>定义（<font color="red">试验</font>）</strong>：观察、测量、实验等。</p><p><strong>随机试验</strong>：三个要求</p><ol><li>在相同的条件下，可以重复进行试验；</li><li>试验所有的可能结果不唯一；</li><li>无法预测每一次试验的确切结果。</li></ol><ul><li><strong>事件</strong>：在进行随机试验时，每发生一次结果，就是一次事件。</li><li><strong>随机事件</strong>：随机发生的事件。</li><li><strong>基本事件</strong>：相对于试验目的，事件不能再分（或者不必再分）的事件，称为<strong>基本事件</strong>。</li><li><strong>复合事件</strong>：有基本事件复合而成。</li><li><strong>必然事件</strong>：一定发生的事件。</li><li><strong>不可能事件</strong>：一定不会发生的事件。</li><li><strong>样本空间</strong>：所有基本事件的<strong>集合</strong>，记作 $\Omega $ 。<ul><li>例如：抛一次硬币的样本空间是 $\Omega =\left \{ \text{正面},\text{反面} \right \} $ 。</li></ul></li><li><strong>样本点</strong>：样本空间中的元素，也就是基本事件，记作 $\omega $ 。</li></ul><h2 id="1-2-事件之间的关系"><a href="#1-2-事件之间的关系" class="headerlink" title="1.2 事件之间的关系"></a>1.2 事件之间的关系</h2><p>事件之间的关系有如下类型：</p><ol><li><p>包含：事件 $A$ 包含于事件 $B$ （或者事件 $B$ 包含事件 $A$ ），即 $A\subseteq B(B\supseteq A)$ 。</p><ul><li>注意，这种情况下的等价关系是：$x\in A\Longrightarrow x\in B $ ；</li><li><p>$\phi \subseteq A\subseteq \Omega $ 。</p><p><img src="https://imageshack.yuilexi.cn/University/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AE%8B%E6%B5%A9%E7%89%88/%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB.svg" alt="事件的包含关系" style="zoom:50%" /></p></li></ul></li><li><p>真包含：事件 $A$ 真包含于事件 $B$ （或者事件 $B$ 真包含事件 $A$ ），即 $A\subset  B(B\supset  A)$ 。</p><ul><li>注意，这种情况下的等价关系是： $x\in A\Longrightarrow x\in B \wedge B\ne A$</li></ul></li><li><p>并集（和）：事件 $A,B$ 中，至少有一个发生，记作 $A\cup B( \quad \mathrm{or}\quad A+B)$ 。</p><ul><li>$A\cup A=A,\quad A\cup \phi =A,\quad A\cup \Omega =\Omega ,\quad A\subseteq (A\cup B)$ 。</li></ul></li><li><p>交集（积）：事件 $A,B$ 同时发生，记作 $A\cap B,\quad AB$ ；</p><ul><li>$AB\subseteq A,\quad AA=A,\quad A\phi =\phi ,\quad A\Omega =A$ 。</li></ul></li><li><p>差集（差）：事件 $A$ 发生的同时事件 $B$ 不发生，记作 $A\cap \overline{B}, \quad A-B$</p></li><li><p>互不相容事件：$AB=\phi $</p></li></ol><p><img src="https://imageshack.yuilexi.cn/University/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AE%8B%E6%B5%A9%E7%89%88/%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%BA%8B%E4%BB%B6.svg" alt="互不相容事件" style="zoom:50%" /></p><ol><li><p>对立事件： 如果 $A=\Omega -B$ ，那么称事件 $A,B$ 互为对立事件，记作 $A=\overline{B} $</p><ul><li>对立事件的一个前提是：不互相容。与不互相容不同的是，<strong>对立事件的并集一定是样本空间</strong>，即 $AB=\phi\quad\wedge\quad A\cup B=\Omega $ ，二互不相容事件只是 $AB=\phi $ 。</li><li>$\overline{\overline{A} } =A,\quad A-B =A-AB=A\overline{B} $ 。</li></ul></li><li><p><strong><font name="完备事件组">完备事件组</font></strong>： $A_{1},A_{2},\cdots ,A_{n} $ 两两之间<strong>互不相容</strong>，且 $\bigcup_{i=1}^{n}A_{i}=\Omega $ （即所有事件相加等于样本空间）。</p></li></ol><blockquote><p>上述定义的关系可以扩展至无限可列个。</p><p><strong>定义（无限可列个）</strong>：按照某种规律，能够排成一个序列。</p></blockquote><h2 id="1-3-运算律"><a href="#1-3-运算律" class="headerlink" title="1.3 运算律"></a>1.3 运算律</h2><ul><li>交换律： $A\cup B=B\cup A,\quad A\cap B=B\cap A$ ；</li><li>结合律： $(A\cup B)\cup C=A\cup (B\cup C),\quad (A\cap  B)\cap C=A\cap (B\cap C)$ ；</li><li>分配律： $(A\cup B)\cap C = (A\cap  C)\cup (A\cap  B),\quad (A\cap B)\cup C = (A\cup  C)\cap (A\cup  B)$ ；</li><li>对偶律： $\overline{A\cup B} =\overline{A} \cap \overline{B},\quad \overline{A\cap B} =\overline{A} \cup \overline{B}$</li></ul><h1 id="二、事件的概率"><a href="#二、事件的概率" class="headerlink" title="二、事件的概率"></a>二、事件的概率</h1><h2 id="2-1-初等描述"><a href="#2-1-初等描述" class="headerlink" title="2.1 初等描述"></a>2.1 初等描述</h2><p><strong>概率</strong>：进行 $n$ 次同样的随机试验，事件 $A$ 发生的次数为 $m$ 次，那么称事件 $A$ 发生的概率为 $\displaystyle P(A)=\frac{m}{n} $ 。概率是描述事件发生的可能性大小的数学量。</p><p><strong>性质</strong>：</p><ol><li>$P(\Omega )=1$ ；</li><li>$P(\phi )=0$ 。</li></ol><h2 id="2-2-古典概型"><a href="#2-2-古典概型" class="headerlink" title="2.2 古典概型"></a>2.2 古典概型</h2><p>满足古典概型的条件：</p><ol><li>有限个样本点；</li><li>等可能性</li></ol><p>古典概型的概率公式：</p><script type="math/tex; mode=display">P(A)=\frac{A\text{中的样本点} }{\Omega \text{中样本点总数} } =\frac{A\text{中包含的基本事件数}}{\text{基本事件的总数} }</script><hr><div>    <p align="center">排列组合</p></div><p><strong>加法原理</strong>：实现某个事件有 $n$ 种方法，这些方法就是加法计算</p><p><strong>乘法原理</strong>：实现耨个时间有 $n$ 个步骤，每一个步骤有若干方法，那么计算就是乘法计算。</p><p><strong>排列</strong>：</p><ol><li><p>不重复排列：从 $n$ 个不同的元素中，<strong>依次</strong>取出 $m$ 个不同的（不放回），那么所有的可能性是</p><script type="math/tex; mode=display"> P_{m}^{n} =n(n-1)(n-2)\cdots (n-m)=\frac{n!}{(n-m)!}</script></li><li><p>全排列：$P_{n}^{n} =n!$ 。</p></li><li><p><strong>特别地， $0!=1$ </strong>。</p></li><li><p><strong>重复排列</strong>：从 $n$ 个不同的元素中，<strong>依次</strong>取出 $m$ 个（放回），那么所有的可能性是</p><script type="math/tex; mode=display"> n^{m}</script></li></ol><p><strong>组合</strong>：</p><ol><li><p>从 $n$ 个不同的元素中，取出 $m$ 个不同的元素，并且不关心拿出的顺序，那么所有的可能性是</p><script type="math/tex; mode=display"> C_{n} ^{m} =\frac{P_{n} ^{m}  }{m!} =\frac{n!}{m!(n-m)!}</script></li><li><p>$C_{n} ^{m}=C_{n} ^{n-m}$ 。</p></li><li><p>$C_{n} ^{0}=C_{n} ^{n}=1$ 。</p></li></ol><h2 id="2-3-几何概型"><a href="#2-3-几何概型" class="headerlink" title="2.3 几何概型"></a>2.3 几何概型</h2><p>几何概率模型，主要是针对以长度、面积、体积作为样本空间的随机试验模型。</p><blockquote><p>解决对应的几何概率，只要是求得其<strong>占比</strong>，长度、面积、体积的比。</p></blockquote><h2 id="2-4-频率和概率"><a href="#2-4-频率和概率" class="headerlink" title="2.4 频率和概率"></a>2.4 频率和概率</h2><p><strong>定义（频数和频率）</strong>：进行 $n$ 次同样的随机试验，事件 $A$ 发生的次数为 $m$ 次，那么称 $m$ 是<strong>频数</strong>， $\displaystyle\frac{m}{n} $ 称为频率，记作 $\displaystyle \omega_{n} =\frac{m}{n} $ 。</p><p><strong>性质</strong>：</p><ol><li>非负性：$ 0\le \omega_{n}\le 1$ ；</li><li>规范性：$\omega_{n}(\phi )=0,\quad \omega_{n}(\Omega )=1$ ；</li><li>可加性： $A_{1},A_{2},\cdots ,A_{m}$ 互不相容，那么 $\omega _{n}( A_{1}+A_{2}+\cdots +A_{m})=\omega _{n} ( A_{1})+\cdots +  \omega _{n} ( A_{m})$ 。</li></ol><h2 id="2-5-公理化"><a href="#2-5-公理化" class="headerlink" title="2.5 公理化"></a>2.5 公理化</h2><p>描述古典、几何、统计的相关性质：</p><ol><li>非负性</li><li>规范性</li><li>可加性</li></ol><p><strong>公理</strong>：</p><ol><li>非负性： $0\le P(A) \le 1$ ；</li><li>规范性： $P(\Omega ) =1$ ；</li><li>完全可加性：已知 $A_{1} ,A_{2},\cdots$ 互不相容，那么 $P(A_{1}+A_{2}+\cdots ) =P(A_{1})+P(A_{2})+\cdots $ 。</li></ol><p><strong>性质 1</strong>：$P(\phi )=0$ 。</p><p><strong>性质 2（有限可加性）</strong>：已知 $A_{1} ,A_{2},\cdots ,A_{n}$ 互不相容，那么 $P(A_{1}+A_{2}+\cdots A_{n}) =P(A_{1})+P(A_{2})+\cdots +P(A_{n})$ 。</p><p><strong>性质 3</strong>： $P(A)=1-P(\overline{A} ),\quad P(A)+P(\overline{A} )=1$ 。</p><p><strong>性质 4</strong>：</p><ul><li>$P(A-B)=P(A)-P(AB)$ ；</li><li>如果 $B\subseteq A$ ，那么 $P(A-B)=P(A)-P(B)$ ，且 $P(B)\le P(A)$ 。</li></ul><p><strong>性质 5⭐⭐⭐⭐⭐【极其重要】</strong>： $P(A+B)=P(A)+P(B)-P(AB)$ 。</p><ul><li>拓展： $P(A+B+C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$ 。</li></ul><p><strong>性质 6</strong>： $A$ 是不可能事件，那么 $P(A)=0$ （逆命题不成立）</p><h1 id="三、条件概率"><a href="#三、条件概率" class="headerlink" title="三、条件概率"></a>三、条件概率</h1><p><strong>定义（<font name="条件概率" color="red">条件概率</font>）</strong>： $\Omega $ 是样本空间，设 $A,B$ 是两个事件，且 $P(B)\ge 0$ ，那么，在事件 $B$ 已经发生的条件下， $A$ 发生的概率，称为<strong>条件概率</strong>，记作 $P(A|B)$ 。</p><ul><li>$P(A)$ 是无条件事件 $A$ 发生的概率</li><li>$P(A|B)$ 是条件概率。</li></ul><ol><li>$\displaystyle P(A|B)=\frac{n_{AB} }{n_{B} } $ ；</li><li>$\displaystyle P(A|B)=\frac{P(AB)}{P(B)} $ 。</li></ol><blockquote><p>条件概率相当于改变了样本空间。</p></blockquote><p><strong>推广</strong>：</p><ul><li>$P(AB)=P(A)P(B|A)=P(B)P(A|B)$ </li></ul><h1 id="四、三大概率公式"><a href="#四、三大概率公式" class="headerlink" title="四、三大概率公式"></a>四、三大概率公式</h1><h2 id="4-1-乘法公式"><a href="#4-1-乘法公式" class="headerlink" title="4.1 乘法公式"></a>4.1 乘法公式</h2><p>由上一节的<a href="#条件概率">条件概率</a>可得：</p><script type="math/tex; mode=display">\begin{align}P(A|B) & = \frac{P(AB)}{P(B)} \\P(B|A) & = \frac{P(AB)}{P(A)}\end{align}</script><p>那么，整理可以得到：</p><script type="math/tex; mode=display">\begin{align}P(AB)&=P(A)P(B|A) \\P(AB)&=P(B)P(A|B)\end{align}</script><p><strong>推广</strong>：</p><ul><li>$P(A_{1}A_{2}\cdots A_{n} )=P(A_{1})P(A_{2} |A_{1})P(A_{3}|A_{1}A_{2})\cdots P(A_{n}|A_{1}\cdots A_{n-1} )$ </li></ul><h2 id="4-2-全概率公式"><a href="#4-2-全概率公式" class="headerlink" title="4.2 全概率公式"></a>4.2 全概率公式</h2><p><strong>定理</strong>：已知 $A_{1},A_{2},\cdots ,A_{n}$ 是 $E$ 的<a href="#完备事件组">完备事件组</a>，且事件 $B$ 的概率是 $P(B)$ ，那么</p><script type="math/tex; mode=display">P(B)=\sum_{i=1}^{n} P(A_{i} )P(B|A_{i})</script><p><img src="https://imageshack.yuilexi.cn/University/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AE%8B%E6%B5%A9%E7%89%88/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F.png" alt="全概率公式" style="zoom:50%" /></p><p>全概率公式的意义：</p><ul><li>将复杂的事件 $B$ 分成较简单的事件 $A_{i}B$ ，然后再结合加法公式和乘法公式计算出 $A$ 的概率。</li><li>事件 $B$ 的发生可能有各种因素 $A_{i}$ 引起的，如果事件 $B$ 的发生原因 $A_{i}$ 有关，那么 $A$ 发生的一个概率就是 $P(B)=P(A_{i} )P(B|A_{i})$ ，每一个原因都可能导致 $B$ 发生，<strong>故 $B$ 发生的概率是全部引起 $B$ 发生概率的总和，即全概率公式</strong>。</li></ul><h2 id="4-3-贝叶斯公式"><a href="#4-3-贝叶斯公式" class="headerlink" title="4.3 贝叶斯公式"></a>4.3 贝叶斯公式</h2><p>如果<strong>全概率公式</strong>是已知原因求结果，那么<strong>贝叶斯公式</strong>就是已知结果求结果。</p><p><strong>定理</strong> $A_{1},A_{2},\cdots ,A_{n}$ 是一组完备事件组，事件 $B$ 发生的概率是 $P(B)$ ，且事件 $A_{i}$ 发生的概率是 $P(A_{i})\ge 0$ ，那么</p><script type="math/tex; mode=display">P(A_{k}|B)=\frac{P(A_{k})P(B|A_{k} )}{\displaystyle \sum_{i=1}^{n}P(A_{i})P(B|A_{i} )} =\frac{P(A_{k}B)}{P(B)}</script><p>并且称 $P(A_{i})$ 为<strong>先验概率</strong>， $P(A_{i} |B)$ 为<strong>后验概率</strong>。</p><h1 id="五、事件的独立性"><a href="#五、事件的独立性" class="headerlink" title="五、事件的独立性"></a>五、事件的独立性</h1><h2 id="5-1-独立事件"><a href="#5-1-独立事件" class="headerlink" title="5.1 独立事件"></a>5.1 独立事件</h2><p><strong>定义（<font color="red">事件的独立性</font>）</strong>：事件 $A$ 发生的概率不受事件 $B$ 发生与否的影响，即</p><script type="math/tex; mode=display">P(A|B)=P(A)</script><p><strong>定理</strong>：已知 $P(A)\ge 0,P(B)\ge 0$ ，那么 $A,B$ 相互独立 $\Longleftrightarrow $  $P(AB)=P(A)P(B)$ 。</p><p><strong>定义（事件的独立-第二定义）</strong>：事件 $A,B$ 满足 $P(AB)=P(A)P(B)$ ，那么称事件 $A,B$ 独立。</p><p><strong>定理</strong>：</p><ol><li>如果事件 $A,B$ 相互独立，那么 $A,B$ 、 $A,\overline{B} $ 、 $\overline{A} ,B$ 也是相互独立的。</li><li>$P(A)=1\text{或者} P(A)=0$ ，那么事件 $A$ 与任意事件独立。</li></ol><p><strong>独立与互不相容</strong>：</p><ul><li>互不相容考虑的是事件<strong>是否能同时发生</strong>。A和B互不相容的意思是A发生B就不可能发生。B发生A就不可能发生，也就是说A和B不能同时发生。即 $AB = \phi $ 。</li><li>独立考虑的是两个事件的关联性，<strong>一个事件的发生能否影响另一个事件</strong>。A和B独立的意思就是，A发生和B发生没有关系，A发生不会影响B发生，A和B也可能同时发生，不过A和B互不影响。即 $P(AB)=P(A)P(B)$ 。</li><li>当 $P(A)&gt; 0,P(B)&gt; 0$ ，那么<strong>独立与互不相容不能同时成立</strong>。</li></ul><h2 id="5-2-伯努利模型"><a href="#5-2-伯努利模型" class="headerlink" title="5.2 伯努利模型"></a>5.2 伯努利模型</h2><p><strong>定义（独立试验序列）</strong>： $E_{1},E_{2} ,\cdots ,E_{n} $ 相互独立，称为<strong>独立试验序列</strong>。</p><p><strong>定义（ $n$ 重独立试验）</strong>：相同的试验进行 $n$ 次。</p><p><strong>定义（伯努利试验）</strong>：在一次试验中，只会出现两种结果，那么这种试验称为<strong>伯努利试验</strong>。</p><p><strong>定义（ $n$ 重伯努利试验）</strong>：对伯努利试验进行 $n$ 次。</p><p><strong>定理</strong>：在一次伯努利试验，事件 $A$ 发生的概率是 $p$ ，那么不发生的概率就是 $1-p$ ；在 $n$ 重伯努利试验中 $A$ 发生 $k$ 次的概率是：</p><script type="math/tex; mode=display">P_{k}(n)=C_{n}^{k} p^{k} (1-p)^{n-k} =C_{n}^{k} p^{k} q^{n-k}(q=1-p)</script><p>并且称上式为<strong>二项概率公式</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 概率论与数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 多维随机变量及其分布【概率论与数理统计】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/3_%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/3_%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-多维随机变量及其分布【概率论与数理统计】"><a href="#第三章-多维随机变量及其分布【概率论与数理统计】" class="headerlink" title="第三章 多维随机变量及其分布【概率论与数理统计】"></a>第三章 多维随机变量及其分布【概率论与数理统计】</h1><h1 id="一、二维随机变量及其分布"><a href="#一、二维随机变量及其分布" class="headerlink" title="一、二维随机变量及其分布"></a>一、二维随机变量及其分布</h1><h2 id="1-1-二维随机变量"><a href="#1-1-二维随机变量" class="headerlink" title="1.1 二维随机变量"></a>1.1 二维随机变量</h2><p>设 $E$ 是一次试验， $\Omega $ 是样本空间， $X,Y$ 是 $\Omega $ 的两个随机变量，那么分布函数</p><script type="math/tex; mode=display">F(x,y) = P\left \{ X\le x,Y\le y \right \}</script><p>为 $X,Y$ 的<strong>联合分布函数</strong>。</p><p><strong>性质</strong>：</p><ol><li>$F(x,y)$ 是一个不减函数；</li><li>$F(-\infty,y)=0,F(x,-\infty)=0$ ；</li><li>$F(-\infty,-\infty)=0,F(\infty,\infty)=1$ ；</li><li>$F(x,y)$ 分别关于 $x$ 和 $y$ 右连续；</li><li>$P\left \{ x_{1}&lt; X\le x_{2},y_{1}&lt; Y\le y_{2} \right \}=F(x_{2},y_{2}) -F(x_{2},y_{1})-F(x_{1},y_{2})+F(x_{1},y_{1})$ 。</li></ol><h2 id="1-2-边缘分布"><a href="#1-2-边缘分布" class="headerlink" title="1.2 边缘分布"></a>1.2 边缘分布</h2><p><strong>定义</strong>： $X,Y$ 的<strong>联合分布函数</strong>的分布函数为 $F(x,y)$ ，那么关于 $X$ 的边缘分布函数为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle F_{X}(x) & = P\left \{ X\le x \right \}  = F(x,+\infty )\\&=\int_{-\infty }^{x} \int_{-\infty }^{+\infty}f(t,y)\mathrm{d}y\mathrm{d}t\end{align}</script><p> 关于 $Y$ 的边缘分布函数为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle F_{Y}(y) & = P\left \{ Y\le y \right \}  = F(+\infty,y )\\&=\int_{-\infty }^{y} \int_{-\infty }^{+\infty}f(x,t)\mathrm{d}x\mathrm{d}t\end{align}</script><h1 id="二、二维离散型的联合概率分布及边缘分布"><a href="#二、二维离散型的联合概率分布及边缘分布" class="headerlink" title="二、二维离散型的联合概率分布及边缘分布"></a>二、二维离散型的联合概率分布及边缘分布</h1><h2 id="2-1-联合分布表"><a href="#2-1-联合分布表" class="headerlink" title="2.1 联合分布表"></a>2.1 联合分布表</h2><p>形如：</p><div class="table-container"><table><thead><tr><th style="text-align:center">X\Y</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$0$</td><td style="text-align:center">$\displaystyle \frac{1}{2} $</td><td style="text-align:center">$\displaystyle \frac{1}{8} $</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$\displaystyle \frac{1}{8} $</td><td style="text-align:center">$\displaystyle \frac{1}{8} $</td><td style="text-align:center">$\displaystyle \frac{1}{8} $</td></tr></tbody></table></div><p><strong>性质 </strong>：</p><ol><li>$p_{ij}\ge 0$ ；</li><li>$\sum_{i,j}p_{ij}=1$ ；</li><li>$\displaystyle F(x,y) = P\left \{ X\le x,Y\le y \right \} $ ；</li></ol><h2 id="2-2-边缘分布"><a href="#2-2-边缘分布" class="headerlink" title="2.2 边缘分布"></a>2.2 边缘分布</h2><ul><li>$X$ 的边缘分布，就是将每一行求和，并且将符合要求的行相加；</li><li>$Y$ 的边缘分布，就是将每一列求和，并且将符合要求的列相加；</li></ul><h1 id="三、二位连续性的联合概率密度和边缘分布函数"><a href="#三、二位连续性的联合概率密度和边缘分布函数" class="headerlink" title="三、二位连续性的联合概率密度和边缘分布函数"></a>三、二位连续性的联合概率密度和边缘分布函数</h1><p><strong>定义</strong>：分布函数</p><script type="math/tex; mode=display">\begin{align}\displaystyle F(x,y) & = P\left \{ X\le x,Y\le y \right \} \\&=\int_{-\infty }^{x}\int_{-\infty }^{y} f(s,t)\mathrm{d}s\mathrm{d}t \end{align}</script><p>并且称 $f(x,y)$ 为联合概率密度。</p><p><strong>性质</strong>：</p><ol><li>$f(x,y)\ge 0$ ；</li><li>$\displaystyle \int_{-\infty }^{+\infty}\int_{-\infty }^{+\infty} f(x,y)\mathrm{d}x\mathrm{d}y$ ；</li><li>$\displaystyle \frac{\partial^{2}  F(x,y)}{\partial x\partial y} =f(x,y)$ ；</li></ol><p><strong>边缘分布</strong>：</p><ol><li>$\displaystyle F_{X} (x)=F(x,+\infty )=\int_{- \infty }^{x} \int_{-\infty }^{+\infty } f(t,y)\mathrm{d}t\mathrm{d}y$ ；</li><li>$\displaystyle F_{Y} (x)=F(+\infty,y)=\int_{- \infty }^{y} \int_{-\infty }^{+\infty } f(x,t)\mathrm{d}x\mathrm{d}t$ ；</li></ol><p><strong>边缘概率密度</strong>：</p><ol><li>$\displaystyle f_{X}(x) = \int_{-\infty }^{+\infty } f(x,y)\mathrm{d}y $ ；</li><li>$\displaystyle f_{Y}(y) = \int_{-\infty }^{+\infty } f(x,y)\mathrm{d}x $ 。</li></ol><blockquote><ol><li>二维正态分布的边缘分布也是正态分布；</li><li>两个边缘分布是正态分布，二维并非正态分布。</li></ol></blockquote><h1 id="四、条件分布"><a href="#四、条件分布" class="headerlink" title="四、条件分布"></a>四、条件分布</h1><p><strong>定义</strong>：在事件 $A$ 发生的条件下，即</p><script type="math/tex; mode=display">\begin{align}\displaystyle F(x|A) & = P\left \{ X\le x|A \right \} \\&=\frac{P\left \{  X\le x|A \right \} }{P\left \{ A \right \} } \end{align}</script><h3 id="3-4-1-离散型"><a href="#3-4-1-离散型" class="headerlink" title="3.4.1 离散型"></a>3.4.1 离散型</h3><p>方法：</p><ol><li>列出联合概率分布表；</li><li>计算出对应的边缘概率分布表</li><li>然后根据公式进行计算</li></ol><h3 id="3-4-2-连续性"><a href="#3-4-2-连续性" class="headerlink" title="3.4.2 连续性"></a>3.4.2 连续性</h3><p><strong>定义</strong>：已知概率密度函数为 $f(x,y)$ ，且边缘分布函数为：$f_{X}(x),f_{Y}(y)$ ，如果 $f_{Y}(y)&gt;0$ ，那么在 $Y=y$ 的条件下</p><script type="math/tex; mode=display">F(x|y)=\int_{-\infty }^{x} \frac{f(t,y)}{f_{Y}(y)}\mathrm{d}t</script><h1 id="五、随机变量的独立性"><a href="#五、随机变量的独立性" class="headerlink" title="五、随机变量的独立性"></a>五、随机变量的独立性</h1><p><strong>定义</strong>：如果满足</p><script type="math/tex; mode=display">f(x,y) = f_{X}(x)f_{Y}(y)</script><p>那么称二维随机变量 $X,Y$ 是<strong>相互独立</strong>的。</p><h3 id="3-5-1-二维离散型"><a href="#3-5-1-二维离散型" class="headerlink" title="3.5.1 二维离散型"></a>3.5.1 二维离散型</h3><p><strong>定理</strong>：如果随机变量是独立的，那么由随机变量构造的函数之间也是独立的。</p><h3 id="3-5-2-二维连续型"><a href="#3-5-2-二维连续型" class="headerlink" title="3.5.2 二维连续型"></a>3.5.2 二维连续型</h3><h1 id="六、二维随机变量函数的分布"><a href="#六、二维随机变量函数的分布" class="headerlink" title="六、二维随机变量函数的分布"></a>六、二维随机变量函数的分布</h1><h3 id="3-6-1-二维离散型"><a href="#3-6-1-二维离散型" class="headerlink" title="3.6.1 二维离散型"></a>3.6.1 二维离散型</h3>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 概率论与数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 随机变量及其分布【概率论与数理统计】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/2_%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/2_%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-随机变量及其分布【概率论与数理统计】"><a href="#第二章-随机变量及其分布【概率论与数理统计】" class="headerlink" title="第二章 随机变量及其分布【概率论与数理统计】"></a>第二章 随机变量及其分布【概率论与数理统计】</h1><h1 id="一、随机变量及其概率分布"><a href="#一、随机变量及其概率分布" class="headerlink" title="一、随机变量及其概率分布"></a>一、随机变量及其概率分布</h1><h2 id="1-1-随机变量的定义"><a href="#1-1-随机变量的定义" class="headerlink" title="1.1 随机变量的定义"></a>1.1 随机变量的定义</h2><p>随机变量表示随机试验各种结果的<strong>实值单值函数</strong>。随机事件不论与数量是否直接有关，都可以数量化，即都能用数量化的方式表达。</p><p><strong>定义（<font color="red">随机变量</font>）</strong>：定义在样本空间上 $\Omega $ 上的函数 $X=X(\omega )$ 称为随机变量。这种函数的取值是不能预先确定的，是随机的。</p><p>从随机变量数量的角度，还能将随机变量划分为<strong>离散型随机变量</strong>与<strong>连续型随机变量</strong>，前者试验结果可取的值为<strong>有限</strong>或<strong>无限可列</strong>，后者试验结果的事件域可以与某区间 $\left [ a,b \right ] $ 或者 $\left ( -\infty,+\infty  \right ) $ 构成双射。</p><h2 id="1-2-离散型随机变量及其概率分布"><a href="#1-2-离散型随机变量及其概率分布" class="headerlink" title="1.2 离散型随机变量及其概率分布"></a>1.2 离散型随机变量及其概率分布</h2><p>假设抛骰子，那么随机变量的所有可能的取值是： $1,2,3,4,5,6$ 。</p><p><strong>定义</strong>：随机变量 $X$ 的所有可能的取值 $x_{k}(k=1,2,\cdots ,)$ ，那么对应的概率就是</p><script type="math/tex; mode=display">P(X=x_{k})=p_{k}</script><p>上述概率称为<strong>概率函数或者概率分布</strong>。</p><p><strong>性质</strong>：</p><ol><li>$p_{k} \ge 0$ ；</li><li>$\sum p_{k}=1$ 。</li></ol><p>概率分布的表示方法：</p><ul><li>表格；</li><li>数据函数；</li><li>图像。</li></ul><h2 id="1-3-连续性随机变量及其概率密度函数"><a href="#1-3-连续性随机变量及其概率密度函数" class="headerlink" title="1.3 连续性随机变量及其概率密度函数"></a>1.3 连续性随机变量及其概率密度函数</h2><p>连续性的随机变量，例如：长度等，取到某点的概率为 0 ，因此，没有办法类比离散型的方法。</p><p>方法：</p><ol><li>频数直方图</li><li>频率密度直方图</li></ol><p><strong>定义</strong>：存在非负可积函数 $f(x)\ge 0$ ，且 $a\le b$ ，那么</p><script type="math/tex; mode=display">P(a\le X\le b)=\int_{a}^{b} f(x)\mathrm{d}x</script><p><strong>性质</strong>：</p><ol><li>$f(x)\ge 0$ ；</li><li>$\displaystyle \int_{-\infty }^{+\infty } f(x)\mathrm{d}x =1$ ；</li><li>连续性随机变量，取个别值的概率为 0 ，即 $\displaystyle P(X=x_{0} )=\int_{x_{0}^{-}}^{x_{0}^{+}} f(x)\mathrm{d}x $ ；</li><li>$\displaystyle P(a\le x\le b)=\int_{-\infty }^{b} f(x)\mathrm{d}x -\int_{-\infty }^{a} f(x)\mathrm{d}x=\int_{a }^{b} f(x)\mathrm{d}x  $ 。</li></ol><blockquote><ul><li>概率为 0 的事件，未必是不可能事件；</li><li>概率为 1 的事件，未必是必然事件。</li></ul></blockquote><p><strong>概率密度反映了概率的分布密度，它反映的是某一点的邻域的概率总和，侧面反映概率的分布，并且每一点的概率是 0 </strong>。</p><hr><p><strong>例题</strong>：已知 $\displaystyle f(x) = \left\{\begin{matrix} kx+1 &amp;  &amp; 0\le x \le 2\\ 0 &amp;  &amp; \text{其他} \end{matrix}\right.$ ，求 $k$ 。</p><p>解：</p><script type="math/tex; mode=display">\int_{-\infty }^{+\infty} f(x)\mathrm{d}x =\int_{0 }^{2} (kx+1)\mathrm{d}x=1</script><p> 解得：</p><script type="math/tex; mode=display">k=-\frac{1}{2}</script><h1 id="二、分布函数"><a href="#二、分布函数" class="headerlink" title="二、分布函数"></a>二、分布函数</h1><h2 id="2-1-分布函数的定义"><a href="#2-1-分布函数的定义" class="headerlink" title="2.1 分布函数的定义"></a>2.1 分布函数的定义</h2><p><strong>定义（<font color="red">分布函数</font>）</strong>：定义函数 $F(x)=P(X\le x)$ 为<strong>分布函数</strong>，其含义为 $X$ 取值不超过 $x$ 的<strong>概率</strong>。</p><ol><li>$x\in \left ( -\infty ,+\infty \right ) $ ；</li><li>$F(x)\in \left [ 0,1 \right ] $ ；</li><li>$\displaystyle F(x) = P(X\le x)=\int_{-\infty }^{x} f(t)\mathrm{d}t $ 。</li></ol><p><strong>性质 1</strong>：$F(x)\in \left [ 0,1 \right ] ,x\in \left ( -\infty ,+\infty \right )  $ 。</p><p><strong>性质 2</strong>： $F(x)$ 是一个不减函数，即 $\forall x_{1} &lt; x_{2} ,\quad F(x_{1} )\le F(x_{2} )$ 。</p><ul><li>$\displaystyle \lim_{x \to +\infty} F(x)=F(+\infty)=1$  ；</li><li>$\displaystyle \lim_{x \to -\infty} F(x)=F(-\infty)=0$ 。</li></ul><p><strong>性质 3</strong>：分布函数 $F(x)$ 是<strong>右连续的</strong>，且连续性随机变量的分布函数是<strong>连续的</strong>。</p><ul><li>证明（右连续，即 $\displaystyle \lim_{x \to a^{+} } F(x)=F(a)$ ）：</li></ul><p>公式：</p><ol><li>$P(X\le a)=F(a)$ ；</li><li>$P(X&gt; a)=1-P(X\le a)=1-F(a)$ ；</li><li>$\displaystyle P(a&lt; x\le b)=P(X\le b)-P(X\le a)=F(b)-F(a)$ ；</li><li>$\displaystyle P(X=a)=F(a)-F(a^{-} )$ ；</li><li>$\displaystyle P(a\le X\le b)=F(b)-F(a^{-} )$ ；</li><li>$\displaystyle P( X\le a)=F(a^{-} )$ ；</li><li>$\displaystyle P( X\ge  a)=1-F(a^{-} )$ 。</li></ol><h2 id="2-2-离散型随机变量的分布函数"><a href="#2-2-离散型随机变量的分布函数" class="headerlink" title="2.2 离散型随机变量的分布函数"></a>2.2 离散型随机变量的分布函数</h2><p><strong>例题</strong>： </p><div class="table-container"><table><thead><tr><th style="text-align:center">X</th><th style="text-align:center">-1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">p</td><td style="text-align:center">$\displaystyle \frac{1}{2} $</td><td style="text-align:center">$\displaystyle \frac{1}{3} $</td><td style="text-align:center">$\displaystyle \frac{1}{6} $</td></tr></tbody></table></div><p>解：</p><p>当 $\displaystyle x\in \left (- \infty ,-1 \right ) $ ， $\displaystyle F(x)=P(X\le x)=0$ ；</p><p>当 $\displaystyle x\in \left [- 1,2 \right ) $ ，$\displaystyle F(x)=P(X\le x)=\frac{1}{2} $ ；</p><p>当 $\displaystyle x\in \left [2,3 \right ) $ ， $\displaystyle F(x)=P(X\le x)=\frac{5}{6} $ ；</p><p>当 $\displaystyle x\in \left [3,+\infty  \right ) $ ， $\displaystyle F(x)=P(X\le x)=1 $ 。</p><p>所以，分布函数为：</p><script type="math/tex; mode=display">\displaystyle F(x)\left\{\begin{matrix} 0 &  & x<-1\\ \frac{1}{2}  &  & -1\le x< 2\\ \frac{5}{6}  &  & 2\le x<3\\ 1 &  &3\le x\end{matrix}\right.</script><p><img src="https://imageshack.yuilexi.cn/University/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AE%8B%E6%B5%A9%E7%89%88/%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0.png" alt="离散型随机变量的分布函数" style="zoom:50%" /></p><hr><p>由分布函数求得概率：间断点 $x_{k}$ 就是随机变量 $X$ 的所有取值。</p><h2 id="2-3-连续性随机变量的分布函数"><a href="#2-3-连续性随机变量的分布函数" class="headerlink" title="2.3 连续性随机变量的分布函数"></a>2.3 连续性随机变量的分布函数</h2><p>已知 $\displaystyle F(x) = P(X\le x)=\int_{-\infty }^{x} f(t)\mathrm{d}t $ ，可以得到：</p><script type="math/tex; mode=display">{F}' (x)=f(x)</script><h1 id="三、常见随机变量的分布"><a href="#三、常见随机变量的分布" class="headerlink" title="三、常见随机变量的分布"></a>三、常见随机变量的分布</h1><h2 id="3-1-0-1分布"><a href="#3-1-0-1分布" class="headerlink" title="3.1 0-1分布"></a>3.1 0-1分布</h2><p>形如</p><div class="table-container"><table><thead><tr><th style="text-align:center">X</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">P</td><td style="text-align:center">p</td><td style="text-align:center">1-p</td></tr></tbody></table></div><p>的分布形式，称为<strong>0-1分布</strong>。</p><p><strong>定义（<font color="red">0-1分布</font>）</strong>： $P(X=k)=p^{k} (1-p)^{1-k} \quad (k=1,2)$ 。</p><ul><li>只有两个试验结果；</li><li>试验只进行一次</li></ul><p>数学特征：</p><ul><li>期望： $\displaystyle EX=p$ ；</li><li>方差： $\displaystyle DX=2p(1-p)$ 。</li></ul><h2 id="3-2-几何分布"><a href="#3-2-几何分布" class="headerlink" title="3.2 几何分布"></a>3.2 几何分布</h2><p><strong>定义（几何分布）</strong>：在一次试验中，事件 $A$ 发生的概率是 $p$ ，那么在 $n$ 次独立重复试验中，第 $k$ 次试验中，事件 $A$ 第一次发生的概率为</p><script type="math/tex; mode=display">P(X=k)=(1-p)^{k-1} p</script><p>上述分布称为<strong>几何分布</strong>，记作 $X\sim G(p)$ 。</p><ul><li>期望： $\displaystyle E(X)=\frac{1}{p} $ ；</li><li>方差： $\displaystyle DX=\frac{1-p}{p^{2} } $ 。</li></ul><h2 id="3-3-二项分布"><a href="#3-3-二项分布" class="headerlink" title="3.3 二项分布"></a>3.3 二项分布</h2><p><strong>定义（二项分布）</strong>：在一次试验中，事件 $A$ 发生的概率是 $P(A)=p$ ，那么，在 $n$ 次独立重复实验中，事件 $A$ 发生了 $k$ 次，其发生的次数与其概率的关系为：</p><script type="math/tex; mode=display">\displaystyle P(X=k)=C_{n} ^{k} p^{k} (1-p)^{n-k} \quad (k =0, 1,2,\cdots ,n)</script><p>上述分布称为<strong>二项分布</strong>，记作 $X\sim B(n,p)$ 。</p><ul><li>期望： $\displaystyle EX=np$ ；</li><li>方差： $\displaystyle DX=np(1-p)$ 。</li></ul><h2 id="3-4-泊松分布"><a href="#3-4-泊松分布" class="headerlink" title="3.4 泊松分布"></a>3.4 泊松分布</h2><p><strong>定义（泊松分布）</strong>：形如</p><script type="math/tex; mode=display">\displaystyle P(X=k)=\frac{\lambda ^{k} }{k!} e^{-\lambda }</script><p>的分布律称为<strong>泊松分布</strong>，记作 $X\sim P(\lambda )$ 。</p><ul><li>期望： $EX=\lambda$ ；</li><li>方差： $DX=\lambda$ 。</li></ul><p>为什么需要泊松分布？或者它的意义是什么？</p><p>泊松分布源于二项分布，二项分布的性质是 $μ = np$ 。可以这么理解：现实中虽然只进行了一回 n 次试验，但是假想平行时间线上进行了无数回 n 次试验（直接多做几回 n 次试验），将这无数时间线上的成功次数 k 做算术平均，得到的均值就是μ。</p><p>泊松分布的一个作用就是近似：</p><p>当二项分布 $X\sim B(n,p)$ 中的 $n$ 很大，$p$ 很小，并且 $np$ 的大小适中，就能用<strong>泊松分布来近似计算</strong>，即 $X\sim P(np)$ 。</p><h2 id="3-5-超几何分布"><a href="#3-5-超几何分布" class="headerlink" title="3.5 超几何分布"></a>3.5 超几何分布</h2><p><strong>定义（超几何分布）</strong>：假设 $N$ 个元素分成两类，第一类有 $M(M\le N)$ 个，第二类有 $N-M$ 个，那么取出 $n$ 个元素，随机变量 $X$ 为取出的第一类元素的个数，那么其概率为：</p><script type="math/tex; mode=display">\displaystyle P(X=k)=\frac{C_{M}^{k} C_{N-M}^{n-k}  }{C_{N}^{n}  }</script><p>上述随机变量的分布称为<strong>超几何分布</strong>，记作 $X\sim H(N,n,M)$ 。</p><p>当 $N\to \infty $ 时，超几何分布近似为二项分布， $\displaystyle \frac{M }{N} \to p$ 。</p><h2 id="3-6-均匀分布"><a href="#3-6-均匀分布" class="headerlink" title="3.6 均匀分布"></a>3.6 均匀分布</h2><p><strong>定义（均匀分布）</strong>：满足概率密度函数</p><script type="math/tex; mode=display">\displaystyle f(x)=\left\{\begin{matrix} \frac{1}{b-a}  &  &a\le x\le b \\  0&  &\mathrm{else} \end{matrix}\right.</script><p>称为<strong>均匀分布</strong>，记作 $X\sim U(a,b)$ 。</p><p>其分布函数为：</p><script type="math/tex; mode=display">\displaystyle F(x) = \left\{\begin{matrix} 0 &  & x< a\\ \displaystyle \frac{x-a}{b-a}  &  & a\le x<b\\ 1 &  &b\le a\end{matrix}\right.</script><h2 id="3-7-指数分布"><a href="#3-7-指数分布" class="headerlink" title="3.7 指数分布"></a>3.7 指数分布</h2><p><strong>定义（指数分布）</strong>：满足概率密度函数：</p><script type="math/tex; mode=display">\displaystyle f(x)=\left\{\begin{matrix} \lambda e^{-\lambda x}  & x>0\\  0&x\le 0\end{matrix}\right.</script><p>称为<strong>指数分布</strong>，记作 $X\sim \mathrm{Exp}(\lambda ) $ 。</p><p>其分布函数为：</p><script type="math/tex; mode=display">\displaystyle F(x)=\left\{\begin{matrix} 1-e^{-\lambda x}  & x>0\\ 0 &x\le 0\end{matrix}\right.</script><h2 id="3-8-正态分布"><a href="#3-8-正态分布" class="headerlink" title="3.8 正态分布"></a>3.8 正态分布</h2><p><strong>定义（正态分布）</strong>：满足概率密度函数：</p><script type="math/tex; mode=display">\displaystyle \Phi (x)=\frac{1}{\sqrt{2\pi }\sigma} e^{-\frac{(x-\mu )^{2} }{2\sigma ^{2} } } ,x\in \left ( -\infty, +\infty  \right )</script><p>称为<strong>正态分布</strong>，记作 $X\sim N(\mu ,\sigma ^{2} )$ 。</p><p>其分布函数为：</p><script type="math/tex; mode=display">F(x) = \int_{-\infty }^{x} \frac{1}{\sqrt{2\pi }\sigma} e^{-\frac{(t-\mu )^{2} }{2\sigma ^{2} }}\mathrm{d}t</script><p><strong>性质 1</strong>：密度函数以 $x=\mu $ 为对称轴，并且在 $x=\mu $ 时， $\Phi (x)$ 取得最大值。</p><p><strong>性质 2</strong>：密度函数以 $y$ 轴为渐近线，并且 $x=\mu \pm \sigma $ 是函数的<strong>拐点</strong>。</p><p><strong>性质 3</strong>：当 $\sigma $ 固定， $\mu $ 越大，函数图像越靠右；反之，函数越靠左。当 $\mu $ 固定， $\sigma $ 越大，图像越低； $\sigma $ 越小，图像越高</p><hr><p><strong>标准正态</strong>：当正态分布的 $\mu =0,\sigma =0$ 时，称为标准正态分布</p><script type="math/tex; mode=display">\Phi _{0} (x)=\frac{1}{\sqrt{2\pi } } e^{-\frac{x^{2} }{2} } ,x\in \left ( -\infty,+ \infty  \right )</script><p>分布函数为：</p><script type="math/tex; mode=display">F(x) = \int_{-\infty }^{x} \frac{1}{\sqrt{2\pi }} e^{-\frac{t^{2} }{2}}\mathrm{d}t</script><p><strong>性质</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$\Phi _{0} (x)=\Phi _{0} (-x)$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$\Phi _{0} (-x)=1-\Phi _{0} (x)$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$\displaystyle \Phi (x)=\frac{1}{\sigma } \Phi _{0}(\frac{x-\mu }{\sigma } )$</td></tr></tbody></table></div><h1 id="四、随机变量及其分布"><a href="#四、随机变量及其分布" class="headerlink" title="四、随机变量及其分布"></a>四、随机变量及其分布</h1><blockquote><p>已知 $X$ 是某种分布，然后有 $Y=f(X)$ ，求 $Y$ 的分布，就是这一节内容</p></blockquote><h2 id="4-1-离散型"><a href="#4-1-离散型" class="headerlink" title="4.1 离散型"></a>4.1 离散型</h2><p><strong>方法一</strong>：离散型随机变量，直接将分布律罗列出来。</p><h2 id="4-2-连续型随机变量"><a href="#4-2-连续型随机变量" class="headerlink" title="4.2 连续型随机变量"></a>4.2 连续型随机变量</h2><p>设 $X$ 的密度函数 $f_{x} (x)$ ，并且 $Y=g(X)$ 。</p><ol><li>首先用 $F_{X}(x)$ 来表示 $F_{Y}(x)$ ；</li><li>接着两边求导，用 $f_{X}(x)$ 来表示 $f_{Y}(x)$ 。</li></ol><hr><p><strong>示例</strong>： $X$ 的密度函数 $f_{X}(x)$ ，并且 $Y=3X+2$ 。</p><p>解：由题可得：</p><script type="math/tex; mode=display">\begin{align}F_{Y}(x) & = P\left \{ Y\le x \right \} \\&=P\left \{ 3X+2\le x \right \}\\&=P\left \{ X\le \frac{x-2}{3}\right \}\\&=F_{X}(\frac{x-2}{3})\end{align}</script><p>两边求导，得：</p><script type="math/tex; mode=display">\begin{align}f_{Y}(x) = \frac{1}{3} f_{X}(\frac{x-2}{3} )\end{align}</script><p><strong>定理</strong>：$X$ 的密度函数 $f_{X}(x)$ ，并且 $Y=kX+b$ ，那么 $\displaystyle f_{Y}(x)=\frac{1}{\left | k \right | } f_{x}(\frac{x-b}{k} )$ 。</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 概率论与数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 随机变量的数字特征【概率论与数理统计】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/4_%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/4_%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-随机变量的数字特征【概率论与数理统计】"><a href="#第四章-随机变量的数字特征【概率论与数理统计】" class="headerlink" title="第四章 随机变量的数字特征【概率论与数理统计】"></a>第四章 随机变量的数字特征【概率论与数理统计】</h1><h1 id="一、数学期望"><a href="#一、数学期望" class="headerlink" title="一、数学期望"></a>一、数学期望</h1><h2 id="1-1-离散型的期望"><a href="#1-1-离散型的期望" class="headerlink" title="1.1 离散型的期望"></a>1.1 离散型的期望</h2><p><strong>定义</strong>：离散型随机变量的概率分布为：$P(X=x_{k} )=p_{k} $ ，如果级数 $\sum x_{k} p_{k} $ 绝对收敛，那么期望为：</p><script type="math/tex; mode=display">EX = \displaystyle  \sum_{k=1}^{\infty } x_{k} p_{k}</script><h2 id="1-2-连续性的期望"><a href="#1-2-连续性的期望" class="headerlink" title="1.2 连续性的期望"></a>1.2 连续性的期望</h2><p><strong>定义</strong>：连续型随机变量 $X$ ，对应的概率密度为 $f(x)$ ，如果 $\int_{-\infty }^{+\infty } xf(x)\mathrm{d}x$ 绝对收敛，那么期望为：</p><script type="math/tex; mode=display">EX=\int_{-\infty }^{+\infty } xf(x)\mathrm{d}x</script><blockquote><p>期望不一定存在。</p></blockquote><h2 id="1-3-随机变量函数的期望"><a href="#1-3-随机变量函数的期望" class="headerlink" title="1.3 随机变量函数的期望"></a>1.3 随机变量函数的期望</h2><p><strong>离散型</strong>：</p><script type="math/tex; mode=display">EY=\sum g(x_{i} )p_{i}</script><p>连续性随机变量 $Y=g(X)$ ，$X$ 的概率密度为 $f(x)$ ，那么</p><script type="math/tex; mode=display">EY=\int g(x)f(x)\mathrm{d}x</script><p>二维随机变量函数 $Z=(X,Y)$ 的期望：</p><ol><li>离散： $\displaystyle EZ =\sum_{i}\sum_{j}g(x_{i},y_{j})p_{ij}$ ；</li><li>连续性： $\displaystyle EZ =\int_{-\infty }^{+\infty }\int_{-\infty }^{+\infty }g(x_{i},y_{j})p_{ij}$ 。</li></ol><h2 id="1-4-数学期望的性质"><a href="#1-4-数学期望的性质" class="headerlink" title="1.4 数学期望的性质"></a>1.4 数学期望的性质</h2><ol><li>$EC=C$ ，即常数的期望等于常数；</li><li>$\displaystyle E(X+C)=EX+EC=EX+C$ ；</li><li>$\displaystyle E(CX)=C\cdot EX$ ；</li><li>$\displaystyle E(aX+b) = kEX+b$ ；</li><li>$\displaystyle E(X\pm Y) = EX\pm EY$ （任何时候都成立）；</li><li>如果 $X,Y$ 独立，那么 $\displaystyle E(XY) = EX\cdot EY$ ；</li></ol><h2 id="1-5-条件期望"><a href="#1-5-条件期望" class="headerlink" title="1.5 条件期望"></a>1.5 条件期望</h2><p>一个变量取了某个值的的前提下，另一个变量的期望。</p><p><strong>离散型</strong>：</p><script type="math/tex; mode=display">\displaystyle E(X|Y=y_{0} ) = \sum x_{i} p(X=x_{i}|Y=y_{0})</script><h1 id="二、方差"><a href="#二、方差" class="headerlink" title="二、方差"></a>二、方差</h1><h2 id="2-1-方差的定义"><a href="#2-1-方差的定义" class="headerlink" title="2.1 方差的定义"></a>2.1 方差的定义</h2><blockquote><p>期望是衡量数据的平均值；而期望是反映数据的集中程度。</p></blockquote><p><strong>定义（方差）</strong>： $\displaystyle DX=E(X-EX)^{2} $ ，这里注意数据的量纲</p><p><strong>标准差</strong>： $\displaystyle \sqrt{DX} $ 。</p><p><strong>离散型的方差</strong>：</p><script type="math/tex; mode=display">\displaystyle DX = \sum _{k}(x_{k}-EX)^{2}p_{k}</script><p><strong>连续型的方差</strong>：</p><script type="math/tex; mode=display">\displaystyle DX = \int_{-\infty }^{+\infty } (x_{k}-EX)^{2}f(x)\mathrm{d}x</script><p><strong>方差的计算</strong>： $\displaystyle DX = EX^{2} -(EX)^{2} $ 。</p><h2 id="2-2-方差的性质"><a href="#2-2-方差的性质" class="headerlink" title="2.2 方差的性质"></a>2.2 方差的性质</h2><ol><li>$DC=0$ ；</li><li>$\displaystyle D(X+C)=0$ ；</li><li>$\displaystyle D(CX)=C^{2} \cdot DX$ ；</li><li>$\displaystyle D(kX+b) = k^{2} DX$ ；</li><li>如果 $\displaystyle X,Y$ 独立，那么 $\displaystyle D(X\pm Y)=DX+DY$ ；</li></ol><h1 id="三、常见随机变量的期望与方差"><a href="#三、常见随机变量的期望与方差" class="headerlink" title="三、常见随机变量的期望与方差"></a>三、常见随机变量的期望与方差</h1><h2 id="3-1-离散型"><a href="#3-1-离散型" class="headerlink" title="3.1 离散型"></a>3.1 离散型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th style="text-align:center">期望</th><th style="text-align:center">方差</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0-1分布</td><td style="text-align:center">$EX=p$</td><td style="text-align:center">$DX=p(1-p)$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">二项分布：$X\sim B(n,p)$</td><td style="text-align:center">$\displaystyle EX=np$</td><td style="text-align:center">$\displaystyle DX=np(1-p)$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">几何分布 $X\sim G(p)$</td><td style="text-align:center">$\displaystyle EX = \frac{1}{p} $</td><td style="text-align:center">$\displaystyle DX=\frac{1-p}{p^{2} } $</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">泊松分布 $X\sim P(\lambda )$</td><td style="text-align:center">$\displaystyle EX=\lambda $</td><td style="text-align:center">$\displaystyle DX=\lambda $</td></tr></tbody></table></div><h2 id="3-2-连续型"><a href="#3-2-连续型" class="headerlink" title="3.2 连续型"></a>3.2 连续型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th style="text-align:center">期望</th><th style="text-align:center">方差</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">均匀分布</td><td style="text-align:center">$\displaystyle EX=\frac{a+b}{2} $</td><td style="text-align:center">$\displaystyle EX=\frac{(b-a)^{2} }{12} $</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">指数分布</td><td style="text-align:center">$\displaystyle EX=\frac{1}{\lambda } $</td><td style="text-align:center">$\displaystyle DX = \frac{1}{\lambda^{2}  } $</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">正态分布</td><td style="text-align:center">$\displaystyle EX=\mu $</td><td style="text-align:center">$\displaystyle DX = \sigma ^{2} $</td></tr></tbody></table></div><h1 id="四、协方差"><a href="#四、协方差" class="headerlink" title="四、协方差"></a>四、协方差</h1><h2 id="4-1-协方差的定义"><a href="#4-1-协方差的定义" class="headerlink" title="4.1 协方差的定义"></a>4.1 协方差的定义</h2><p><strong>定义</strong>：随机变量 $X,Y$ 的协方差为</p><script type="math/tex; mode=display">\begin{align}\displaystyle \mathrm{Cov}(X,Y) & = E\left [ \left ( X-EY \right ) \left ( Y-EX \right )  \right ] \\&=E(XY)-EX\cdot EY\end{align}</script><p>并且有：</p><script type="math/tex; mode=display">\displaystyle D(X\pm Y)=DX+DY\pm \mathrm{Cov}(X,Y)</script><h2 id="4-2-协方差的性质"><a href="#4-2-协方差的性质" class="headerlink" title="4.2 协方差的性质"></a>4.2 协方差的性质</h2><ol><li>$\displaystyle \mathrm{Cov}(X,Y)=\mathrm{Cov}(Y,X)$ ；</li><li>$\displaystyle \mathrm{Cov}(aX,bY)=ab\cdot \mathrm{Cov}(Y,X)$ ；</li><li>$\displaystyle \mathrm{Cov}(X_{1}+X_{2},Y)=\mathrm{Cov}(X_{1},Y)+\mathrm{Cov}(X_{2},Y)$ ；</li><li>$\displaystyle \mathrm{Cov}(C,Y)=0$ ；</li><li>如果 $X,Y$ 独立，那么 $\displaystyle \mathrm{Cov}(X,Y)=0$ 。</li></ol><p>协方差的大小，跟计量单位有关系，因此，为了反应不同单位下的随机变量的关系，就需要对随机变量进行<strong>标准化</strong>：</p><script type="math/tex; mode=display">\displaystyle X^{\star } =\frac{X-EX}{\sqrt{DX} } ,Y^{\star } =\frac{Y-EY}{\sqrt{DY} }</script><p>所以，标准化后的协方差为：</p><script type="math/tex; mode=display">\displaystyle \mathrm{Cov}(X^{\star },Y^{\star }) =  \frac{\mathrm{Cov}(X,Y)}{\sqrt{DX\cdot DY} } =\rho</script><p>并且引入相关系数 $\rho $ 。</p><h1 id="五、相关系数"><a href="#五、相关系数" class="headerlink" title="五、相关系数"></a>五、相关系数</h1><p><strong>定义</strong>：相关系数为：</p><script type="math/tex; mode=display">\displaystyle \rho =  \frac{\mathrm{Cov}(X,Y)}{\sqrt{DX\cdot DY} }=\frac{E(XY)-EX\cdot EY}{\sqrt{DX\cdot DY} }</script><p><strong>性质</strong>：</p><ol><li>$\displaystyle \left | \rho  \right | \le 1$ ；</li></ol><p><strong>定理</strong>：$\displaystyle \left | \rho  \right | =1$  $\displaystyle \Longleftrightarrow $  $X,Y$ 成线性相关</p><ol><li>如果 $\displaystyle \rho =1$ ，那么 $X,Y$ 完全正相关；</li><li>如果 $\displaystyle \rho =-1$ ，那么 $X,Y$ 完全负相关；</li><li>$\displaystyle \left | \rho \right |$ 接近 0 ，那么 $X,Y$ 线性关系很弱；</li><li>如果 $\displaystyle \rho =0$ ，那么 $X,Y$ 不存在线性关系。</li></ol><blockquote><p>独立指的是没有任何关系，包括线性关系和非线性关系</p></blockquote><h1 id="六、中心距与原点矩"><a href="#六、中心距与原点矩" class="headerlink" title="六、中心距与原点矩"></a>六、中心距与原点矩</h1><p><strong>原点矩</strong>： $\displaystyle EX^{k} $ 为期望 $EX$ 的 $k$ 阶原点矩；</p><p><strong>中心距</strong>： $\displaystyle E(X-EX)^{k} $ ；</p><blockquote><p>一阶中心矩为 0 ；二阶中心矩为方差。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 概率论与数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 大数定律及中心极限定理【概率论与数理统计】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/5_%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E5%8F%8A%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/03.%E6%A6%82%E7%8E%87%E8%AE%BA/5_%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E5%8F%8A%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-大数定律及中心极限定理【概率论与数理统计】"><a href="#第五章-大数定律及中心极限定理【概率论与数理统计】" class="headerlink" title="第五章 大数定律及中心极限定理【概率论与数理统计】"></a>第五章 大数定律及中心极限定理【概率论与数理统计】</h1><h1 id="一、大数定律"><a href="#一、大数定律" class="headerlink" title="一、大数定律"></a>一、大数定律</h1><p>当量重复试验的平均结果的稳定性</p><h2 id="1-1-切比雪夫不等式"><a href="#1-1-切比雪夫不等式" class="headerlink" title="1.1 切比雪夫不等式"></a>1.1 切比雪夫不等式</h2><p><strong>定理</strong>：假设 $EX$ 和 $X$ 都存在，$\displaystyle \forall \varepsilon &gt;0$ ，那么</p><script type="math/tex; mode=display">\displaystyle P(\left | X-EX \right |\ge \varepsilon  )\le \frac{DX}{\varepsilon ^{2} }</script><h2 id="1-2-切比雪夫大数定律"><a href="#1-2-切比雪夫大数定律" class="headerlink" title="1.2 切比雪夫大数定律"></a>1.2 切比雪夫大数定律</h2><p><strong>定义（收敛）</strong>： $\displaystyle a_{n}\to a$ ，那么 $\displaystyle \forall \varepsilon &gt; 0,\exists N&gt;0$ ，当 $n&gt;N$ 时， $\displaystyle \left | a_{n}-a  \right | &lt; \varepsilon $ 。</p><p><strong>定义（依概率收敛）</strong>： $\displaystyle \forall \varepsilon &gt; 0,\exists N&gt;0$ ，使得 $n&gt;N$ 时， $\displaystyle \lim_{n \to \infty} P(\left | X_{n}-a  \right | &lt; \varepsilon )=1$ 。</p><p><strong>定理（伯努利大数定律）</strong>：一个 $n$ 重伯努律事件， $A$ 发生了 $\displaystyle m_{n} $ 次， $p $ 为发生的概率， $\displaystyle \frac{m_{n} }{n} $ 为频率，那么</p><script type="math/tex; mode=display">\begin{align}\displaystyle \lim_{n \to \infty} P(\left |\frac{m_{n} }{n} -p  \right | < \varepsilon ) & = 1\\\displaystyle \lim_{n \to \infty} P(\left |\frac{m_{n} }{n} -p  \right | \ge \varepsilon ) & = 0\end{align}</script><p><strong>定理（切比雪夫大数定律）</strong>： $X_{1},X_{2},\cdots ,X_{n}$ 是不相关的随机变量，并且 $\displaystyle EX_{i} , DX_{i}$ 都存在，并且方差是有界的，即 $\displaystyle DX_{i}\le M$ ，那么 $\displaystyle \forall \varepsilon &gt; 0$ ，有</p><script type="math/tex; mode=display">\displaystyle\lim_{n \to \infty} P\left \{ \left | \frac{1}{n} \sum_{i=1}^{n}X_{i}-\frac{1}{n} \sum_{i=1}^{n}X_{i} \right | < \varepsilon \right \} =1</script><p>如何理解呢？其实就是，当 $n \to \infty$ 时，我们<strong>求得的均值</strong>，无限接近<strong>期望的均值</strong>。</p><p><strong>推论</strong>： $X_{1},X_{2},\cdots ,X_{n}$ 是独立同分布的随机变量，并且 $\displaystyle EX_{i}=\mu ,DX_{i} =\sigma ^{2} $ ，那么 $\displaystyle\forall \varepsilon &gt;0$ ，有</p><script type="math/tex; mode=display">\displaystyle \lim_{n \to \infty} P\left \{ \left | \frac{1}{n} \sum_{i=1}^{n}X_{i}-\mu   \right |< \varepsilon   \right \} =1</script><p><strong>定理（辛钦）</strong>： $X_{1},X_{2},\cdots ,X_{n}$ 是独立同分布的随机变量，并且 $\displaystyle EX_{i}=\mu$ ，方差无要求，那么 $\displaystyle\forall \varepsilon &gt;0$ ，有</p><script type="math/tex; mode=display">\displaystyle \lim_{n \to \infty} P\left \{ \left | \frac{1}{n} \sum_{i=1}^{n}X_{i}-\mu   \right |< \varepsilon   \right \} =1</script><h1 id="二、中心极限定理"><a href="#二、中心极限定理" class="headerlink" title="二、中心极限定理"></a>二、中心极限定理</h1><p>现象有大量的相互独立的因素影响，<strong>大量独立同分布</strong>的随机变量和<strong>中心极限分布</strong>是<strong>正态分布</strong>。</p><p><strong>定理</strong>： $X_{1},X_{2},\cdots ,X_{n}$ 是独立同分布的随机变量，并且 $\displaystyle EX_{i}=\mu ,DX_{i} =\sigma ^{2} $ ，如果 $\displaystyle 0&lt; \sigma ^{2} &lt; +\infty $ ，那么</p><script type="math/tex; mode=display">\displaystyle \lim_{n \to \infty} P \left ( \frac{\displaystyle \sum_{i=1}^{n} -n\mu }{\sqrt{n} \sigma } \le x \right ) =\Phi _{0} (x)</script><p><strong>定理（棣莫佛 － 拉普拉斯）</strong>：随机变量 $Y_{n}$ 是服从 $n,p$ 的二项分布，有</p><script type="math/tex; mode=display">\displaystyle \lim_{n \to \infty} P \left ( \frac{Y_{n}-np}{\sqrt{np(1-p)} }\le x  \right ) =\Phi _{0} (x)</script>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 概率论与数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏数据持久化系统</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%B3%BB%E7%BB%9F.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文章主要是介绍一种适用于游戏的简单<strong>数据持久化</strong>框架，以方便游戏开发和使用。</p><h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><p><strong>游戏数据持久化</strong>是一个游戏必不可少的模块，其中涉及很多的核心功能。首先，就是要对该模块进行需求分析。</p><ol><li>该框架能够将游戏中的对象提取成对应的数据，并且这些数据可以序列化。</li><li>该框架能将序列化的数据，存储到本地磁盘中，实现<strong>数据的可持续化</strong>。</li><li>该框架能够自动识别游戏存档(<code>Game Archive</code>)中的相关文件，包括数据文件和配置文件，并且能加载到游戏中</li><li>该框架能够根据所选的游戏存档，从数据文件中加载数据，并反序列化为游戏对象的数据。</li></ol><p>根据上述的需求，能够将该框架分为三个模块：</p><ol><li>游戏存档系统：能够检测、识别、加载对应的游戏存档；</li><li>游戏数据系统：能够将所有需要存储的游戏对象转化为<strong>可序列化的游戏数据</strong>，也能将<strong>可序列化的游戏数据</strong>加载为对应的游戏对象；</li><li>文件操作系统：能够将<strong>可序列化的游戏数据</strong>序列化，并且写入对应的存档文件夹中，同时也能从对应的存档文件夹中读取数据，并<strong>反序列化</strong>为游戏数据。</li></ol><blockquote><p>一个完整的游戏存档应该包括：游戏数据文件和游戏配置文件，并且可扩展游戏日志文件和控制台调试信息文件。</p></blockquote><p><img src="https://imageshack.yuilexi.cn/Unity3D/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%B3%BB%E7%BB%9F/%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%B3%BB%E7%BB%9F.svg" alt="游戏数据持久化系统"></p><h1 id="二、框架介绍"><a href="#二、框架介绍" class="headerlink" title="二、框架介绍"></a>二、框架介绍</h1><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol><li>游戏引擎：Unity</li><li>Unity 版本：2022.3.0f1 LTS</li><li>代码编辑器：Visual Studio Code 和 Visual Studio Professional 2022</li><li>语言：C#</li></ol><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-17</p></div></div><div class='timeline-item-content'><ol><li>创建文档</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 功能框架 </category>
          
          <category> Csharp </category>
          
          <category> 游戏数据持久化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 功能框架 </tag>
            
            <tag> 游戏数据持久化 </tag>
            
            <tag> 游戏存档 </tag>
            
            <tag> 游戏数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 线性空间【线性代数】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/7_%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/7_%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-线性空间【线性代数】"><a href="#第七章-线性空间【线性代数】" class="headerlink" title="第七章 线性空间【线性代数】"></a>第七章 线性空间【线性代数】</h1><h1 id="一、线性空间"><a href="#一、线性空间" class="headerlink" title="一、线性空间"></a>一、线性空间</h1><h2 id="1-1-数域和元素"><a href="#1-1-数域和元素" class="headerlink" title="1.1 数域和元素"></a>1.1 数域和元素</h2><p><strong>定义（数域）</strong>：设 $F$ 是一个至少包含数 0 和 1 的集合，如果 $F$ 中任意两个数的和、差、积、商（除数不为 0 ）都在 $F$ 中，则称 $F$ 是一个<strong><font color='red'>数域</font></strong>。</p><blockquote><p>有理数集 $Q$ 、实数集 $R$、复数集 $C$ 都是数域，他们分别称为<strong>有理数域</strong>、<strong>实数域</strong>、<strong>复数域</strong>。</p></blockquote><p>若集合 $V$ 中定义了某种运算， $V$ 中的任意元素进行运算所得到的结果均在 $V$ 中，则称这种运算是<strong>封闭的</strong>。</p><h2 id="1-2-线性空间的定义"><a href="#1-2-线性空间的定义" class="headerlink" title="1.2 线性空间的定义"></a>1.2 线性空间的定义</h2><p><strong>定义</strong>：设 $V$ 是一个非空集合。其元素用 $\displaystyle \alpha ,\beta, \gamma ,\delta ,\dots $ <strong>向量</strong>表示，$F$ 是一个数域，其元素用 $\displaystyle k,l,m,n,\dots $ 表示。并且满足下面条件：</p><ol><li>在集合 $V$ 的元素之间定义了一种运算，叫做<strong>加法</strong>。即对于 $V$ 中任意两个元素 $\alpha$ 和 $\beta  $ ，在 $V$ 中都有唯一的元素 $\gamma $ 与之对应，称为 $\alpha$ 和 $\beta $ 的和，记作 $\gamma = \alpha +\beta $ 。</li><li>在数域 $F$ 的数与集合 $V$ 的元素之间定义了一种运算，叫做<strong>数量乘法</strong>，也就是说，对于 $F$ 任意一个数 $k$ 与 $V$ 中任一元素 $\alpha$ ，在 $V$ 中都有唯一的元素 $\delta $ 与之对应，$\delta = k\alpha $ 称为 $k$ 与 $\alpha$ 的数量积。</li><li>$V$ 中定义的加法与数量乘法满足下列运算律：<ol><li>$\alpha +\beta = \beta +\alpha $ ；</li><li>$(\alpha +\beta)+ \gamma  = \alpha +(\beta +\gamma )$ ；</li><li>在 $V$ 中有一个元素 <strong>0</strong> ，对 $V$ 中任一元素 $\alpha$ ，都有 $\alpha +0 = \alpha $ （具有这性质的元素称为零元素）；</li><li>对于 $V$ 中任一元素 $\alpha$ ，都存在 $V$ 中元素 $\beta $ ，使 $\alpha +\beta =0$ ，称 $\beta $ 为 $\alpha$ 的负元素；</li><li>$k(\alpha +\beta ) = k\alpha +k\beta $ ；</li><li>$(k+l)\alpha = k\alpha +l\alpha $ ；</li><li>$k(l\alpha ) = (kl)\alpha $ ；</li><li>$1\alpha = \alpha $ ；</li></ol></li></ol><p>则称 $V$ 为数域 $F$ 上的<font color='red'><strong>线性空间（或向量空间）</strong></font>，简称 $V$ 的<strong>线性空间</strong>或<strong>向量空间</strong>。</p><p>$V$ 中所定义的加法以及数量乘法运算统称为 $V$ 的<strong>线性运算</strong>。 $V$ 中的元素也称为向量， $F$ 中的元素也称为<strong>数量</strong>或<strong>标量</strong>。当 $F$ 为实数域 $R$ 时，称 $V$ 为<strong>实线性空间</strong>；当 $F$ 为复数域 $C$ 时，称 $V$ 为<strong>复线性空间</strong>。</p><h2 id="1-3-线性空间的性质"><a href="#1-3-线性空间的性质" class="headerlink" title="1.3 线性空间的性质"></a>1.3 线性空间的性质</h2><p><strong>性质</strong>：零向量是唯一的。</p><p><strong>性质</strong>：向量空间 $V$ 中的每个向量的复向量是唯一的。</p><p><strong>性质</strong>：对向量空间 $V$ 中任一向量 $\alpha $ 与任一数 $k$ ，有 $0\alpha =0$ ；$k0=0$ ；$(-1)\alpha =\alpha $ 。</p><h2 id="1-4-线性子空间"><a href="#1-4-线性子空间" class="headerlink" title="1.4 线性子空间"></a>1.4 线性子空间</h2><p><strong>定义</strong>：若 $W$ 为数域 $F$ 上的线性空间 $V$ 的非空子集，且 $W$ 满足如下条件：</p><ol><li>对任意的 $k\in F$ ，$a\in W$ ，则 $k\alpha \in W$ ；</li><li>对任意的 $\alpha ,\beta \in W$ ，则 $\alpha+\beta \in W$ ；</li></ol><p>则称 $W$ 为 $V$ 的<font color='red'>线性子空间</font>，简称<strong>子空间</strong>。换句话说，当且仅当 $W$ 对 $V$ 中的加法与数乘运算是封闭的，$W$ 是向量空间 $V$ 的子空间。</p><p>若 $W$ 是线性空间 $V$ 的子空间，由定义不难得出，它也是线性空间。</p><h1 id="二、线性空间的基与向量坐标"><a href="#二、线性空间的基与向量坐标" class="headerlink" title="二、线性空间的基与向量坐标"></a>二、线性空间的基与向量坐标</h1><h2 id="2-1-基、维数、坐标"><a href="#2-1-基、维数、坐标" class="headerlink" title="2.1 基、维数、坐标"></a>2.1 基、维数、坐标</h2><p><strong>定义</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 是数域 $F$ 上的线性空间 $V$ 中的 $m$ 个向量， $k_{1} ,k_{2} ,\cdots ,k_{m} $ 是 $F$ 中的数，则称 $k_{1}a_{1}+k_{2}a_{2}+\cdots +k_{m}a_{m} = \beta $ 为向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 的一个线性组合，或者 $\beta $ 可由向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 线性表示。</p><p><strong>定义</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 是数域 $F$ 上的线性空间 $V$ 中向量，若存在 $F$ 中不全为零的数 $k_{1},k_{2},\dots ,k_{m}$ ，使 $k_{1}a_{1}+k_{2}a_{2}+\cdots +k_{m}a_{m} = 0$ ，则称向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ <strong>线性相关</strong>；否则称向量组<strong>线性无关</strong>。</p><p><strong>定义</strong>：设 $V$ 是数域 $F$ 上的线性空间， $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 是 $V$ 中 $n$ 个线性无关的向量，若 $V$ 中任一向量 $a$ 均可由 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 线性表示，则称线性空间 $V$ 是 <strong>$n$ 维线性空间</strong>， $n$ 称为 $V$ 的<strong>维数</strong>，记作： $\text{dim} V = n$ ，而称 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 为 $V$ 的一组<strong>基</strong>。如果 $V$ 中有任意多个线性无关向量，则称 <script type="math/tex">V</script> 是<strong>无限维线性空间</strong>。</p><p><strong>定义</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 是 $n$ 维线性空间 $V$ 的一组基，$\beta \in V$ 且有</p><script type="math/tex; mode=display">\beta = x_{1}a_{1}+x_{2}a_{2} +\dots  +x_{n}a_{n}</script><p>则称 $\begin{bmatrix} x_{1} &amp; x_{2} &amp; \cdots &amp;x_{n}\end{bmatrix}^{T}$ 为 $\beta $ 在基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 下的<strong>坐标向量</strong>。并且令 $x=\begin{bmatrix} x_{1} &amp; x_{2} &amp; \cdots &amp;x_{n}\end{bmatrix}^{T}$ ，且令矩阵 $A= \begin{bmatrix} \alpha _{1}  &amp;  \alpha _{2} &amp; \cdots  &amp; \alpha _{n}\end{bmatrix}$ ，那么上述等式就转化为</p><script type="math/tex; mode=display">\beta =Ax</script><p>即：</p><ul><li>左边：线性空间 $V$ 中的任一向量（元素）；</li><li>右边：线性空间 $V$ 的一组<strong>基</strong>构成的<strong>基矩阵</strong>乘以<strong>向量在该基下的坐标</strong>。</li></ul><h2 id="2-2-基变换与坐标变换"><a href="#2-2-基变换与坐标变换" class="headerlink" title="2.2 基变换与坐标变换"></a>2.2 基变换与坐标变换</h2><p>设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 与 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 为 $n$ 维线性空间 $V$ 的两组基，则 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 可由 $V$ 的基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 表示：</p><script type="math/tex; mode=display">\left\{\begin{matrix} \beta _{1}  & = & b_{11}a _{1}   & + & b_{21}a _{2} & + & \dots  & + & b_{n1}a _{n}\\ \beta _{2} & = & b_{12}a _{1} & + & b_{22}a _{2} & + & \dots  & + & b_{n2}a _{n}\\  &  & \vdots  &  &  &  &  &  & \\ \beta _{n} & = & b_{1n}a _{1}   & + & b_{2n}a _{2}   & + & \dots  & + &b_{nn}a _{n}  \end{matrix}\right.</script><p>或者写成矩阵形式</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) \begin{bmatrix} b_{11}  & b_{12}  &  \cdots &  b_{1n}\\ b_{21}  &  b_{22} &  \cdots  &  b_{2n}\\ \vdots  &  \vdots& \ddots  & \vdots\\  b_{n1} &  b_{n2} &  \cdots & b_{nn}\end{bmatrix}</script><p>若记 $B = (b_{ij} )_{n\times n} $ ，那么就可以简写为：</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) B</script><p>则称 $n$ 阶矩阵 $B$ 为由基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 到基 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 的<strong>过渡矩阵</strong>。</p><p>过渡矩阵有以下性质：</p><ol><li>过渡矩阵 $B$ 的第 $j$ 列恰为 $\beta _{j} $ 在基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 下的坐标；</li><li>过渡矩阵 $B$ 可逆。事实上，因为 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 线性无关，则 $A$ 的列向量组线性无关，故 $B$ 为可逆矩阵。</li></ol><p><strong>定理</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 与 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 为 $n$ 维线性空间 $V$ 的两组基，由 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 到基 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 的过渡矩阵为 $B = (b_{ij} )_{n\times n} $ ，即</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) B</script><p>若向量 $\eta $ 在这两组基下的坐标分别为 $x = (x_{1},x_{2},\dots ,x_{n} )^{T} $ 和 $y = (y_{1},y_{2},\dots ,y_{n} )^{T} $ ，那么</p><script type="math/tex; mode=display">\mathbf{x}  = \mathbf{Ay} \text{或者} \mathbf{y}  =\mathbf{ A^{-1}x }</script><p>上式被称为<strong>坐标变换公式</strong>。</p><blockquote><p>在向量不变的前提下，线性空间的<strong>基</strong>发生变化，那么向量的<strong>坐标</strong>也会发生对应的变化</p></blockquote><h1 id="三、线性变换"><a href="#三、线性变换" class="headerlink" title="三、线性变换"></a>三、线性变换</h1><h2 id="3-1-映射"><a href="#3-1-映射" class="headerlink" title="3.1 映射"></a>3.1 映射</h2><p><strong>定义 5.8</strong>：设 $M$ 与 $N$ 是两个非空集合，如果有一个法则 $f$ ，使得对 $M$ 中的每个元素 $a$ 都有 $N$ 中唯一确定的 $b$ 与之对应，那么就称 $f$ 是 $M$ 到 $N$ 的一个<strong>映射</strong>，记作</p><script type="math/tex; mode=display">f:\mathbf{M} \to \mathbf{N}</script><p>并称 $b$ 为 $a$ 在 $f$ 下的<strong>像</strong>，而 $a$ 称为 $b$ 在映射 $f$ 下的一个<strong>原像</strong>，记作</p><script type="math/tex; mode=display">f:a\to b\quad \textbf{或} f(a) = b</script><p>集合 $M$ 称为映射 $f$ 的<strong>定义域</strong>。如果对于任意的 $\displaystyle a,b\in M$ ，都有 $f(a)\ne f(b)\quad (a\ne b)$ ，则称 $f$ 是<strong>单射</strong>；如果对于任意的 $b\in N,a\in M$ ，都有 $f(a)=b$ ，则称 $f$ 是<strong>满射</strong>；如果 $f$ 既是单射又是满射，则称 $f$ 是<strong>双射</strong>（或称为<strong>一一映射</strong>）。</p><h2 id="3-2-线性变换的定义"><a href="#3-2-线性变换的定义" class="headerlink" title="3.2 线性变换的定义"></a>3.2 线性变换的定义</h2><p><strong>定义</strong>：设数域 $F$ 上的线性空间 $V_{1} $ 和 $V_{2} $ 分别是 $n$ 和 $m$ 维的。 $T$ 是 $V_{1} $ 到 $V_{2} $ 的一个映射，且满足：</p><ol><li>对任意的 $\alpha ,\beta \in V_{1} $ ，有 $T(\alpha +\beta )=T(\alpha )+T(\beta )$ ；</li><li>对任意的 $\alpha \in V,k\in F$ ，有 $T( k\alpha)=kT(\alpha )$ ；</li></ol><p>则称 $T$ 是从线性空间 $V_{1} $ 到 $V_{2} $ 的<strong>线性映射</strong>。若 $V_{2} =F$ ，则称该线性映射为<strong>线性函数</strong>；若 $V_{1} =V_{2} $ ，则称该线性映射为线性空间$V_{1}$ 上的线性变换，简称<strong>线性变换</strong>。</p><blockquote><p>只有<strong>高维空间投影到低维空间</strong>，而不能从<strong>低维空间或投影到高维空间</strong>，也就是说，只能有<strong>高维观测低位而不能有低维观测高维</strong>。</p></blockquote><h2 id="3-3-线性变换的性质"><a href="#3-3-线性变换的性质" class="headerlink" title="3.3 线性变换的性质"></a>3.3 线性变换的性质</h2><p><strong>性质</strong>： $T(0) = 0$ 。</p><p><strong>性质</strong>： $T(-\alpha ) = -T(\alpha )$ 。</p><p><strong>性质</strong>：若 $\beta = k_{1}\alpha _{1}+k_{2}\alpha _{2}+\dots +k_{m}\alpha _{m} $ ，则</p><script type="math/tex; mode=display">T(\beta ) = k_{1}T\left ( \alpha_{1} \right )+k_{2}T\left ( \alpha _{2} \right ) +\dots +k_{m}T\left ( \alpha _{m}   \right )</script><p><strong>性质</strong>：若向量组 $\alpha _{1},\alpha _{2},\dots ,\alpha _{m}  $ 线性相关，则向量组 $T\left ( \alpha _{1}\right ),T\left ( \alpha _{2} \right ) ,\dots,T\left ( \alpha _{m}   \right )$ 也线性相关。</p><h1 id="四、线性变换的矩阵表示"><a href="#四、线性变换的矩阵表示" class="headerlink" title="四、线性变换的矩阵表示"></a>四、线性变换的矩阵表示</h1><h2 id="4-1-线性变换的矩阵"><a href="#4-1-线性变换的矩阵" class="headerlink" title="4.1 线性变换的矩阵"></a>4.1 线性变换的矩阵</h2><p>设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 是 $n$ 维线性空间 $V$ 的一组基，$T$ 是 $V$ 上的线性变换，那么对 $V$ 中的向量</p><script type="math/tex; mode=display">{\color{Red}  \xi =x_{1} \alpha _{1}+x_{2} \alpha _{2}+\dots +x_{n} \alpha _{n}}</script><p>由线性变换的性质，有</p><script type="math/tex; mode=display">{\color{blue} T\left ( \xi \right )  =x_{1} T\left ( \alpha _{1} \right ) +x_{2} T\left ( \alpha _{2} \right ) +\dots +x_{n} T\left ( \alpha _{n} \right ) }</script><p>因此，对于线性变换 $T$ ，如果知道 $T$ 关于基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 的像 $T\left ( \alpha _{1} \right ) , T\left ( \alpha _{2} \right ),\dots ,T\left ( \alpha _{n} \right )$ ，则 $V$ 中任一向量 $\xi $ 的像 $T\left ( \xi \right ) $ 就完全确定。</p><p>由于 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 的像 $T\left ( \alpha _{1} \right ) , T\left ( \alpha _{2} \right ),\dots ,T\left ( \alpha _{n} \right )$ 可由 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 线性表示，即有：</p><script type="math/tex; mode=display">\left\{\begin{matrix} T(\alpha _{1} ) & = & {\color{Violet} a_{11}} \alpha _{1} & + &  {\color{Violet} a_{21}} \alpha _{2}  & + & \dots  & + &  {\color{Violet} a_{n1}} \alpha _{n} \\  T(\alpha _{2} ) & = &  {\color{Violet} a_{12}} \alpha _{1}  & + &  {\color{Violet} a_{22}} \alpha _{2}  & + & \dots & + &  {\color{Violet} a_{n2}} \alpha _{n} \\  &  &  & \vdots  &  &  &  &  & \\  T(\alpha _{n} ) & = &  {\color{Violet} a_{1n}} \alpha _{1}  & + &  {\color{Violet} a_{2n}} \alpha _{2}  & + & \dots & + & {\color{Violet} a_{nn}} \alpha _{n} \end{matrix}\right.</script><p>若记</p><script type="math/tex; mode=display">\begin{align}T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} ) & = T(\alpha _{1})+T(\alpha _{2})+\dots +T(\alpha _{n})\\ \displaystyle & = (\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\begin{bmatrix}{\color{Violet}  a_{11}}   & {\color{Violet}  a_{12}} & \dots  & {\color{Violet}  a_{1n}}\\ {\color{Violet}  a_{121}} & {\color{Violet}  a_{22}} & \cdots  & {\color{Violet}  a_{2n}}\\ \vdots  & \vdots  &  \ddots &\vdots  \\ {\color{Violet}  a_{n1}} & {\color{Violet}  a_{n2}} & \dots  &{\color{Violet}  a_{nn}}\end{bmatrix}\end{align}</script><p>或者</p><script type="math/tex; mode=display">T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )  =(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\mathbf{A}</script><p><strong>定义</strong>：设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 为 $n$ 维线性空间 $V$ 的一组基， $T$ 为 $V$ 的一个线性变换。若 $n$ 阶矩阵 $A$ 满足</p><script type="math/tex; mode=display">T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )  =(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\mathbf{A}</script><p>则称 $n$ 阶矩阵 $A$ 为线性变换 $T$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的<strong>表示矩阵</strong>。</p><p><strong>定理 </strong>：设 $T$ 是 $n$ 维线性空间 $V$ 上的线性变换， $T$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，向量 $\xi$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标为 $\mathbf{x} =(x_{1},x_{2},\dots ,x_{n})^{T} $ ， $T(\xi )$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标为 $\mathbf{y} =(y<em>{1},y</em>{2},\dots ,y_{n})^{T} $ ，则</p><script type="math/tex; mode=display">\mathbf{y = Ax}</script><h2 id="4-2-线性变换在不同矩阵基下矩阵的关系"><a href="#4-2-线性变换在不同矩阵基下矩阵的关系" class="headerlink" title="4.2 线性变换在不同矩阵基下矩阵的关系"></a>4.2 线性变换在不同矩阵基下矩阵的关系</h2><p><strong>定理 5.3</strong>：设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 和 $\beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 是 $n$ 维线性空间 $V$ 的两组基， $V$ 上的线性变换 $T$ 在这两种基下的矩阵分别为 $A$ 和 $B$ ，且从基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 到基 $\beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 的过渡矩阵为  $P$ ，那么</p><script type="math/tex; mode=display">\mathbf{B = P^{-1} AP}</script><h1 id="五、线性变换的特征值与特征向量"><a href="#五、线性变换的特征值与特征向量" class="headerlink" title="五、线性变换的特征值与特征向量"></a>五、线性变换的特征值与特征向量</h1><h2 id="5-1-特征值与特征向量"><a href="#5-1-特征值与特征向量" class="headerlink" title="5.1 特征值与特征向量"></a>5.1 特征值与特征向量</h2><p><strong>定义</strong>：设 $T$ 是数域 $F$ 上线性空间 $V$ 的线性变换，若存在数 $\lambda \in \mathbf{F} $ 和非零向量 $\alpha \in V$ ，使得</p><script type="math/tex; mode=display">T(\alpha ) = \lambda \alpha</script><p>则称 $ \lambda$ 为 $T$ 的一个特征值，而 $\alpha $ 称为 $T$ 属于特征值 $\lambda $ 的特征向量。</p><p><strong>定理 </strong>：设 $T$ 是 $n$ 维线性空间 $V$ 上的线性变换，$T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，则：</p><ol><li>$\lambda $ 是 $T$ 的特征值得充要条件是$\lambda $ 为 $A$ 的特征值；</li><li>$\alpha \in V$ 是 $T$ 的属于特征值 $\lambda $ 的特征向量的充要条件是 $\alpha $ 在基  $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标是矩阵 $A$ 的属于特征值 $\lambda $ 的特征向量。</li></ol><h2 id="5-2-值域与核"><a href="#5-2-值域与核" class="headerlink" title="5.2 值域与核"></a>5.2 值域与核</h2><p><strong>定义</strong>：设 $T$ 是线性空间 $V$ 中的线性变换，$V$ 中所有元素在 $T$ 下的像所组成的集合。</p><script type="math/tex; mode=display">\left \{ \beta |\beta  = T(\alpha ) ,\alpha \in V\right \}</script><p>称为 $T$ 的<strong>值域</strong>，记作 $\text{Im} T\quad \text{或者} T(V)$ 。零向量的所有原像的集合：</p><script type="math/tex; mode=display">\left \{ \alpha | T(\alpha )=0 ,\alpha \in V\right \}</script><p>称为 $T$ 的<strong>核</strong>，记作 $\text{Ker} T\quad \text{或者} T^{-1} (V)$ 。</p><p>关于线性变换的值域与核有以下性质：</p><ol><li>线性变换 $T$ 的值域 $\text{Im} T$ 是 $V$ 的子空间；</li><li>线性变换 $T$ 的核 $\text{Ker} T$ 是 $V$ 的子空间。</li></ol><p><strong>定理</strong>：设 $V$ 是 $n$ 维线性空间， $V$ 上的线性变换 $T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵 $A$ ，则</p><ol><li>$\text{Im} T$ 的维数等于向量组 $T(\alpha_{1}  ),T(\alpha_{2}  ),\dots ,T(\alpha_{n}  )$ 的<strong>秩</strong>，也等于矩阵 $A$ 的秩；</li><li>$\text{Im} T$ 的基是向量组 $T(\alpha_{1}  ),T(\alpha_{2}  ),\dots ,T(\alpha_{n}  )$ 的一个极大无关组。</li></ol><p><strong>定理</strong>：设 $V$ 是 $n$ 维线性空间， $V$ 上的线性变换 $T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，则</p><ul><li>$T$ 的核 $\text{Ker} T$ 的维数等于 $n-R(A)$ ；</li><li>$V$ 中齐次线性方程组 $Ax = 0$ 的基础解系构成 $T$ 的核 $\text{Ker} T$的基。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 二次型【线性代数】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/6_%E4%BA%8C%E6%AC%A1%E5%9E%8B.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/6_%E4%BA%8C%E6%AC%A1%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-二次型【线性代数】"><a href="#第六章-二次型【线性代数】" class="headerlink" title="第六章 二次型【线性代数】"></a>第六章 二次型【线性代数】</h1><h1 id="一、二次型的定义"><a href="#一、二次型的定义" class="headerlink" title="一、二次型的定义"></a>一、二次型的定义</h1><p>顾名思义，二次型就是每一项全为<strong>二次</strong>的多项式。</p><p><strong>定义（<font color="red">二次型</font>）</strong>：已知 $n$ 个<strong>变量</strong> $\displaystyle x_{1},x_{2},\cdots ,x_{n} $ 的二次齐次多项式</p><script type="math/tex; mode=display">\begin{align}f(x_{1},x_{2},\cdots ,x_{n}) &=a_{11}x_{1}^{2}+2a_{12}x_{1}x_{2}+\dots + 2a_{1n}x_{1}x_{n}\\& \quad +a_{22}x_{2}^{2}+2a_{23}x_{2}x_{3}+\dots + 2a_{2n}x_{2}x_{n}\\&\quad +\cdots \\&\quad + a_{nn}x_{n}^{2}     \end{align}</script><p>称为 $n$ 元<font color='red'><strong>二次型</strong></font>。 $a_{ij}$ 称为二次型 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 的系数，当 $a_{ij}$ 为实数时，称 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 为<strong>实二次型</strong>；当 $a_{ij}$ 为复数时，称 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 为<strong>复二次型</strong>。其中含平方的称为<strong>平方项</strong>，其余的称为<strong>交叉项</strong></p><p>令 $\color{Red} \mathbf{a_{ij}=a_{ji}} $  ，通过这样将交叉项进行拆分，那么二次型可以表示为下面的形式：</p><script type="math/tex; mode=display">\begin{matrix} f(x)= & a_{11}x_{1}^{2}& + &  a_{12}x_{1}x_{2} & + & \dots  & + &  a_{1n}x_{1}x_{n} \\  & a_{21}x_{2}x_{1} & + & a_{22}x_{2}^{2} & + & \dots & + & a_{2n}x_{2}x_{n}\\  &  &  &  & \cdots  &  &  & \\  & a_{n1}x_{n}x_{1} & + & a_{n2}x_{n}x_{2} & + & \dots  & + &a_{nn}x_{n}^{2}\end{matrix}</script><p>令 $x=\begin{bmatrix} x_{1}  &amp; x_{2} &amp; \cdots  &amp;x_{n}\end{bmatrix}^{T} $ 和矩阵 $\displaystyle A=\begin{bmatrix} a_{11}  &amp; a_{12} &amp; \cdots  &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n}\\ \vdots  &amp; \vdots &amp; \ddots  &amp; \vdots\\ a_{n1} &amp; a_{n2} &amp; \cdots &amp;a_{nn}\end{bmatrix}$ ，那么二次型可以用矩阵形式表示为</p><script type="math/tex; mode=display">f(x)=x^{T}Ax</script><p>其中 $\displaystyle A = A^{T} $ 为<strong>对称矩阵</strong>，将上式称为二次型的矩阵形式，对称矩阵 $A$ 称为二次型的矩阵， $A$ 的秩称为<strong>二次型的秩</strong>。</p><p><strong>二次型矩阵化一般多项式的步骤</strong>：</p><ol><li>判断<strong>矩阵</strong>是否为对称矩阵（<strong>二次型矩阵一定是对称矩阵</strong>）；</li><li>主对角线元素直接作为平方项；</li><li>去主对角线右上角元素的 2 倍，所谓交叉项的系数。</li></ol><p><strong>标准型二次型</strong>：只含平方项的二次型，称为<strong>标准二次型</strong>，且对应的二次型矩阵为对角型矩阵。</p><blockquote><p>很显然，二次型 $\displaystyle x^{T} Ax$ 为标准形的<strong>充分必要</strong>条件是 $A$ 为对角矩阵。研究二次型的目的之一，就是寻找一个线性变化将其化为标准形。</p></blockquote><p><strong>二次型的标准化</strong>：已知二次型为 $f(x)=x^{T} Ax$ ，矩阵 $A$ 为一般对称矩阵，如果存在 $x=Cy$ ，使得</p><script type="math/tex; mode=display">f(y)=(Cy)^{T} ACy=y^{T}C^{T}ACy =y^{T}\Lambda y</script><p>成立，那么称此过程为二次型的标准化过程。</p><blockquote><p><a name="二次型标准化总结">总结</a>：二次型的标准化过程，就是看看能不能找到一个矩阵，使得 $C^{T} AC=\Lambda $ 成立。已知 $A$ 是<strong>对称矩阵</strong>，而在之前的学习中知道<strong>对称矩阵必定能够对角化</strong>，即 $C^{-1} AC=\Lambda $ （ $C$ 是由特征列向量依次排列组成的方阵， $\Lambda$ 是对角矩阵，主对角线依次是对应的特征值）。如果 $C^{-1} =C^{T} $ 即 $C^{-1}AC =C^{T}AC=\Lambda  $ ，那就找到了满足条件的矩阵。而满足 $C^{-1} =C^{T}$ 说明矩阵 $C$ 是正交矩阵，最终目的就是<strong>计算出矩阵 $A$ 的特征向量正交化、单位化之后，组成的正交矩阵 $C$ </strong>。</p></blockquote><h1 id="二、矩阵的合同"><a href="#二、矩阵的合同" class="headerlink" title="二、矩阵的合同"></a>二、矩阵的合同</h1><p><strong>定义（矩阵的合同）</strong> ：设 $A,B$ 为 $n$ 阶矩阵。如果存在可逆矩阵$C$ ，使 $\displaystyle C^{T} AC=B$ ，则称 $A$ 与 $B$ 是<font color='red'>合同的</font>，记作 $\displaystyle A\simeq B$ 。</p><p>合同的性质：</p><ul><li>自反性：对任意 $n$ 阶矩阵，有 $\displaystyle A\simeq A$ ；</li><li>对称性：若 $\displaystyle A\simeq B$ ，则$\displaystyle B\simeq A$ ；</li><li>传递性：若 $\displaystyle A\simeq B,B\simeq C$ ，则 $\displaystyle A\simeq C$ 。</li></ul><p><strong>定理</strong> ：设 $n$ 阶矩阵$A$ 与 $B$ 合同，且 $A$ 为对称矩阵，则 $B$ 也是对称矩阵，且秩相等</p><script type="math/tex; mode=display">\displaystyle R(A) = R(B)</script><p><strong>定理</strong>：如果 $\displaystyle A\simeq B$ ，且 $A,B$ 是可逆矩阵，那么 $A^{-1} \simeq B^{-1}$ 。</p><h1 id="三、化二次型为标准型"><a href="#三、化二次型为标准型" class="headerlink" title="三、化二次型为标准型"></a>三、化二次型为标准型</h1><p><strong>定理</strong> ：任何实二次型 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} ) = x^{T} Ax$ 总可以经过适当的<strong>可逆线性（非退化线性）</strong>变换化为规范形，而且规范形是唯一 的。</p><p><strong>定义</strong> ：实二次型 $\displaystyle f(x) = x^{T} Ax$ 的标准形中正平方项的个数 $p$ 称为二次型 $f$ 的<font color='red'>正惯性指数</font>；负平方项的个数 $q$ 称为二次型 $f$ 的<font color='red'>负惯性指数</font>；它们的差 $p-q$ 称为二次型 $f$ 的<font color='red'>符号差</font>。</p><h2 id="3-1-配方法"><a href="#3-1-配方法" class="headerlink" title="3.1 配方法"></a>3.1 配方法</h2><p>利用公式 $\displaystyle (a\pm b)^{2} = a^{2}\pm 2ab+b^{2} $ 和 $\displaystyle (a-b)(a+b) = a^{2}-b^{2}$ 将二次型配成标准形的方法，称为<strong>配方法</strong>。</p><blockquote><p>注意：最终是要求得线性变换得矩阵 $C$ ，即 $x=Cy$ 。</p></blockquote><h2 id="3-2-初等变换"><a href="#3-2-初等变换" class="headerlink" title="3.2 初等变换"></a>3.2 初等变换</h2><p>求解满足 $C^{T} AC=\Lambda $ 的矩阵 $C$ 。</p><p>设 $C=P_{1} P_{2} \cdots P_{s} $ ，那么能得到：</p><script type="math/tex; mode=display">\begin{align}EP_{1} P_{2} \cdots P_{s} & = C\\P^{T}_{s}\cdots P^{T}_{2}P^{T}_{1}  AP_{1} P_{2} \cdots P_{s} & = \Lambda \end{align}</script><p>那么，就能得到：</p><ol><li>对 $A,E$ 做同样的初等列变换</li><li>只对 $A$ 做相应的初等行变换（注：相应的初等行变换是指，列怎么变，行就怎么变）</li><li>当 $A$ 化为对角阵时，单位矩阵 $E$ 就能化成矩阵 $C$ 。</li></ol><h2 id="3-3-正交替换"><a href="#3-3-正交替换" class="headerlink" title="3.3 正交替换"></a>3.3 正交替换</h2><p>根据前面的<a href="#二次型标准化总结">二次型标准化总结</a>可知，化二次型为标准型，就是去求矩阵 $A$ 的特征向量正交化、单位化后，构成的正交矩阵，就是线性替换 $x=Cy$ 中的矩阵。下面用一个完整例题来进行正交替换得讲解。</p><h1 id="四、正定二次型"><a href="#四、正定二次型" class="headerlink" title="四、正定二次型"></a>四、正定二次型</h1><p>在数学、物理、力学领域中都有广泛应用的实二次型———<font color='red'>正定二次型</font>。</p><p><strong>定义</strong> ：设 $\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax$ 为 $n$ 个变量的实二次型。</p><p>（1）如果对任何非零向量 $x = (x_{1},x_{2},\dots ,x_{n} )$ ，都有</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax >0\quad(<0)</script><p>则称 $f = x^{T} Ax$ 为<strong>正定（负定）二次型</strong>，并称二次型矩阵 $A$ 为<strong>正定（负定）矩阵</strong>。</p><p>（2）如果对任何非零向量 $x = (x_{1},x_{2},\dots ,x_{n} )$ ，都有</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax \ge 0\quad(\le 0)</script><p>则称 $f = x^{T} Ax$ 为<strong>半正定（半负定）二次型</strong>，并称二次型矩阵 $A$ 为<strong>半正定（半负定）矩阵</strong>。</p><p>（3）如果二次型 $\displaystyle f(x_{1},x_{2},\dots ,x_{n} )$ 既不是半正定，也不是半负定的，就称 $f = x^{T} Ax$ 为不定的，矩阵 $A$ 称为<strong>不定矩阵</strong>。</p><p>将二次型化为标准型后，得 $f(y)=y^{T}\Lambda y$ ，那么</p><ol><li>主对角线元素全为正数，则是正定；</li><li>主对角线元素全为负数，则是负定；</li><li>主对角线元素全为非负数，则是半正定；</li><li>主对角线元素全为非正数，则是半负定；</li><li>主对角线元素有正有负可能有0，则是不定。</li></ol><blockquote><p>正定、负定、半正定、半负定都是<strong>有定的</strong>。</p></blockquote><hr><p><strong>定理</strong>：<strong>可逆的线性变换不改变二次型的正定性</strong>。</p><p><strong>推论</strong>：设 $n$ 阶实矩阵 $A$ 与 $B$ 合同，则 $A$ 正定的充分必要条件是 $B$ 也正定。</p><p><strong>定理</strong>：设 $\displaystyle f(x_{1},x_{2},\dots ,x_{n}) = x^{T} Ax$ 是 $n$ 元实二次型，则下面命题等价：</p><ol><li>$\displaystyle f = x^{T} Ax$ 是正定二次型，即矩阵 $A$ 是正定矩阵；</li><li>$A$ 的特征值均为正数；</li><li>$\displaystyle f = x^{T} Ax$ 的正惯性指数为 $n$ ；</li><li>$A$ 与单位矩阵 $E$ 合同；</li><li>存在可逆矩阵 $B$ ，使得 $\displaystyle A = B^{T} B$ 。</li></ol><p><strong>推论</strong>：设 $\displaystyle A = (a_{ij} )$ 是 $n$ 阶正定矩阵，则：</p><ol><li>矩阵 $A$ 的主对角线元 $\displaystyle a_{ij}&gt; 0$ ；</li><li>矩阵 $A$ 的行列式 $\displaystyle \left | A \right | &gt; 0$ 。</li></ol><p><strong>定义</strong>：设 $\displaystyle A = (a_{ij} )$ 是 $n$ 阶方阵，依次取 $A$ 的前 $k$ 行与前 $k$ 列所构成的子式</p><script type="math/tex; mode=display">\Delta _{k}  = \begin{bmatrix} a_{11}  & a_{12} & \dots  &a_{1k}\\ a_{21} & a_{22} & \dots  &a_{2k} \\\vdots   & \cdots  & \ddots  &\vdots  \\ a_{k1} &  a_{k2} & \dots  & a_{kk}\end{bmatrix},\quad k = 1,2,\dots ,n</script><p>称为矩阵 $A$ 的 <strong>$k$ 阶顺序主子式</strong>。</p><p><strong>定理</strong>： $n$ 元实二次型 $\displaystyle f(x_{1},x_{2},\dots ,x_{n}) = x^{T} Ax$ 正定的充要条件是 $A$ 的 $n$ 个顺序主子式均大于零，该定理也称为<strong>霍尔维茨定理</strong>。</p><p><strong>推论</strong>：对于 $n$ 元实二次型 $\displaystyle f = x^{T} Ax$ ，则下面命题等价：</p><ol><li>$f$ 是负定二次型；</li><li>$f$ 的负惯性指数为 $n$ ；</li><li>$A$ 的特征值全为负数；</li><li>$A$ 合同于 $-E$ ；</li><li>$A$ 的奇数阶顺序主子式全为负数，偶数阶顺序主子式全为正数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 特征值与特征向量【线性代数】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/5_%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/5_%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-特征值与特征向量【线性代数】"><a href="#第五章-特征值与特征向量【线性代数】" class="headerlink" title="第五章 特征值与特征向量【线性代数】"></a>第五章 特征值与特征向量【线性代数】</h1><p><strong>特征值与特征向量</strong>是方阵才有的性质</p><h1 id="一、特征值和特征向量的概念"><a href="#一、特征值和特征向量的概念" class="headerlink" title="一、特征值和特征向量的概念"></a>一、特征值和特征向量的概念</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p><strong>定义</strong>：设矩阵 $A$ 是 $n$ 阶方阵，存在非零列向量 $\alpha $ ，使得：</p><script type="math/tex; mode=display">A\alpha =\lambda \alpha</script><p>成立，则称 $\lambda$ 是特征值，向量 $\alpha $ 为对应于 $\lambda$ 的特征向量。</p><blockquote><p>注意：</p><ul><li>特征向量一定是<strong>列向量</strong>，且一定是<strong>非零向量</strong>；</li><li>特征值 $\lambda$ 可以取 0 。</li></ul><p>本质上是向量空间的变换，可以把变换矩阵 $A$ 看作是一组列向量，而 $\alpha $ 相当于在原线性空间中的<strong>坐标</strong>，经变换后，其<strong>坐标值</strong>发生改变，而其余的性质不发生任何改变（长度、方向、形状、体积等所有性质）。</p></blockquote><p>将上述 $A\alpha =\lambda \alpha$ 进行移项处理，得到 $(\lambda E-A)\alpha =0$ ，根据定义可得 $\alpha \ne 0$ ，因此，就相当于求齐次方程组的非零解，而齐次方程有非零解的<strong>充分必要</strong>是<strong>系数行列式等于 0 </strong>。 $\lambda E-A$ 被称为<strong>特征矩阵</strong>， $|\lambda E-A|$ 被称为<strong>特征行列式</strong>， $|\lambda E-A|=0$ 被称为<strong>特征方程</strong>。</p><p><strong>定理</strong>：如果 $\lambda$ 是矩阵 $A$ 的特征值， $\alpha$ 是其对应的特征向量，那么 $k\alpha(k\ne 0)$ 也是其对应的特征向量。</p><ul><li><p>证明：</p><p>  假设上述结论成立，即</p><script type="math/tex; mode=display">  Ak\alpha =\lambda k\alpha</script><p>  根据矩阵数乘的运算律，可以得到：</p><script type="math/tex; mode=display">  k(A\alpha)=k(\lambda \alpha )</script><p>  又因为 $k\ne 0$ ，所以，两边约掉常数 $k$ ，得到：</p><script type="math/tex; mode=display">  A\alpha =\lambda \alpha</script><p>  假设成立，证毕。</p></li></ul><p><strong>定理</strong>： $\alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ 是 $ \lambda $ 对应的特征向量，那么 $k_{1} \alpha _{1}+k_{2}\alpha _{2}+\cdots+k_{s}\alpha _{s} $ 也是 $ \lambda $ 对应的特征向量。</p><h2 id="1-2-求特征值"><a href="#1-2-求特征值" class="headerlink" title="1.2 求特征值"></a>1.2 求特征值</h2><p>根据上一节的知识可得，求解 $|\lambda E-A|=0$ 的结果，就是求解特征值 $\lambda $ 。</p><hr><p>例题：求矩阵 $\displaystyle A=\begin{bmatrix} -1 &amp; 1 &amp; 0\\ -4 &amp; 3 &amp; 0\\ 1 &amp; 0 &amp;0\end{bmatrix}$ 的特征值。</p><p>解：</p><script type="math/tex; mode=display">\begin{align}&\lambda E -A=\begin{bmatrix} \lambda+1 & -1 & 0\\ 4 & \lambda-3 & 0\\ -1 & 0 &\lambda-2\end{bmatrix}\\&|\lambda E -A| = \begin{vmatrix} \lambda+1 & -1 & 0\\ 4 & \lambda-3 & 0\\ -1 & 0 &\lambda-2\end{vmatrix}=0\end{align}</script><p>然后将行列式展开可以得到：</p><script type="math/tex; mode=display">(\lambda -2) \left [ (\lambda+1)(\lambda -3) +4 \right ] =0</script><p>整理可得：</p><script type="math/tex; mode=display">(\lambda -2) (\lambda -1)^{2}  =0</script><p>那么，解出的特征值为：</p><script type="math/tex; mode=display">\lambda _{1} =1,\quad \lambda _{2} =1,\quad \lambda _{3}=2</script><blockquote><p>上三角、下三角、对角线矩阵的特征值就是主对角线元素。</p></blockquote><h2 id="1-3-性质"><a href="#1-3-性质" class="headerlink" title="1.3 性质"></a>1.3 性质</h2><p><strong>性质 1⭐⭐</strong>： $A$ 和 $A^{T}$ 的特征值相同。</p><ul><li>证明：<script type="math/tex; mode=display">  |\lambda E-A^{T} | = |\lambda E^{T} -A^{T} |=|(\lambda E -A)^{T}|=|\lambda E-A|</script></li></ul><p><strong>性质 2</strong>：</p><p><strong>性质 3⭐⭐⭐</strong>： $n$ 个特征值 $\lambda _{1},\lambda _{2},\cdots ,\lambda _{n} $ ，那么</p><ol><li><p>$\lambda _{1}+\lambda _{2}+\cdots +\lambda _{n} =\text{主对角线元素之和} $ ；<strong>主对角线元素之和也被称为矩阵的迹，记作 $\mathrm{tr} (A)$</strong> 。</p></li><li><p>$\lambda _{1}\lambda _{2}\cdots \lambda _{n} =|A|$ 。</p><p> 证明：</p><p> 已知特征值是 $\lambda _{1},\lambda _{2},\cdots ,\lambda _{n} $ ，那么行列式就可以化作：</p><script type="math/tex; mode=display"> |\lambda E-A|=(\lambda -\lambda _{1})(\lambda -\lambda _{2})\cdots (\lambda -\lambda _{n})=0</script><p> 上式进行展开，得：</p><script type="math/tex; mode=display"> |\lambda E-A|=\lambda^{n}-(\lambda _{1}+\lambda _{2}+\cdots +\lambda _{n})\lambda ^{n-1} +\dots +(-1)^{n} \lambda _{1}\lambda _{2}\cdots \lambda _{n}</script><p> 到这里需要关注 $\lambda ^{n-1} $ 项和常数项。</p><p> 行列式按照第一行展开：</p><script type="math/tex; mode=display"> \begin{align}|\lambda E-A| & = \begin{bmatrix}\lambda -a_{11}  & -a_{12} & \cdots  & -a_{1n}\\-a_{21} & \lambda -a_{22}  &   \cdots & -a_{2n}\\ \vdots  & \vdots  & \ddots  & \vdots \\ -a_{n1} & -a_{n2} & \cdots  & \lambda -a_{nn}\end{bmatrix}\\ & = (-1)^{1+1} (\lambda -a_{11})M_{11}+(-1)^{1+2}(-a_{12})M_{12}\\ & \quad +\cdots +(-1)^{1+n}(-a_{1n})M_{1n}\end{align}</script><p> 观察上面的行列式展开式，不难发现，只有第一项 $(-1)^{1+1} (\lambda -a_{11})M_{11}$ 含有 $\lambda ^{n-1}$ ，因此，将第一项的代数余子式，再次按照第一行展开，发现还是第一项含有 $\lambda ^{n-1}$ ，以此类推，得到</p><script type="math/tex; mode=display"> \begin{align}|\lambda E-A| & = (\lambda -a_{11})(\lambda -a_{22})\cdots (\lambda -a_{nn})+\cdots \\&=\lambda ^{n} -(a_{11}+a_{22}+\cdots +a_{nn}) \lambda ^{n-1} +\cdots \end{align}</script><p> 然后，令 $\lambda =0$ ，那么除常数项以外，其余项都是 0 ，并且行列式变成 $|-A|$ ，因此常数项就是：</p><script type="math/tex; mode=display"> |-A|=(-1)^{n}|A|</script><p> 所以，整理可以得到：</p><script type="math/tex; mode=display"> \begin{align}|\lambda E-A| & = \lambda^{n}-(\lambda _{1}+\lambda _{2}+\cdots +\lambda _{n})\lambda ^{n-1} +\dots +(-1)^{n} \lambda _{1}\lambda _{2}\cdots \lambda _{n}\\|\lambda E-A| & = \lambda ^{n} -(a_{11}+a_{22}+\cdots +a_{nn}) \lambda ^{n-1} +\cdots+ (-1)^{n}|A| \end{align}</script></li></ol><p><strong>性质 4</strong>：互不相同的特征值 $\lambda _{1},\lambda _{2},\cdots ,\lambda _{s} $ 对那个的特征向量 $\alpha _{1},\alpha _{2},\cdots ,\alpha _{s}$ 必定<strong>线性无关</strong>。</p><p><strong>性质 5</strong>： $k$ 重特征根，对应的线性无关的特征向量的个数是 $\le k$ 个。</p><p><strong>性质 6</strong>：如果一个特征值对应的特征向量之间是线性无关的，那么所有这些特征向量之间，也是线性无关的。</p><p><strong>其余性质</strong>：</p><ol><li>$\lambda $ 是矩阵 $A$ 的特征值，那么 $k\lambda $ 是矩阵 $kA$ 的特征值。</li><li>$\lambda $ 是矩阵 $A$ 的特征值，那么 $\lambda ^{n}$ 是矩阵 $A ^{n} $ 的特征值</li></ol><h1 id="二、相似矩阵与可对角化条件"><a href="#二、相似矩阵与可对角化条件" class="headerlink" title="二、相似矩阵与可对角化条件"></a>二、相似矩阵与可对角化条件</h1><h2 id="2-1-相似矩阵的定义"><a href="#2-1-相似矩阵的定义" class="headerlink" title="2.1 相似矩阵的定义"></a>2.1 相似矩阵的定义</h2><p><strong>定义（相似矩阵）</strong>：设 $A,B$ 是 $n$ 阶方阵，如果存在 $n$ 阶可逆矩阵 $P$ ，使得 $P^{-1} AP=B$ ，那么称矩阵 $A$ 是矩阵 $B$ 的相似矩阵，记作 $A\sim B$ 。</p><p><strong>相似的性质</strong>：</p><ul><li>反身性：$A\sim A$ ；</li><li>对称性： $A\sim B\Longrightarrow B\sim A$ ；</li><li>传递性： $A\sim B,B\sim C\Longrightarrow A\sim C$ 。</li></ul><h2 id="2-2-相似矩阵的性质"><a href="#2-2-相似矩阵的性质" class="headerlink" title="2.2 相似矩阵的性质"></a>2.2 相似矩阵的性质</h2><p><strong>性质 1</strong>：如果 $A\sim B$ ，那么矩阵 $A,B$ 有相同的特征值，且 $|A|=|B|$ ，且 $\mathrm{tr}(A)=\mathrm{tr}(B)  $ 。</p><ul><li>证明<script type="math/tex; mode=display">  \begin{align}  |\lambda E-B| & = |\lambda E-P^{-1} AP| = |\lambda P^{-1} EP-P^{-1} AP|\\  &=|P^{-1} ||\lambda E-A||P|=|\lambda E-A|  \end{align}</script></li></ul><p><strong>性质 2</strong>：如果 $A\sim B$ ，那么 $A$ 可逆 $\Longleftrightarrow $  $B$ 可逆，且 $A^{-1}\sim  B^{-1} $ </p><ul><li>如果 $A\sim B$ ，那么矩阵 $A,B$ 同时可逆或者同时不可逆。</li></ul><p><strong>性质 3</strong>：<strong>如果 $A\sim B$ ，那么 $A^{m}\sim  B^{m} $</strong> 。</p><ul><li>证明：<script type="math/tex; mode=display">  B^{m}= (P^{-1} AP)^{m} =P^{-1} APP^{-1} AP\cdots P^{-1} AP=P^{-1} A^{m} P</script></li></ul><h2 id="2-3-对角型相似"><a href="#2-3-对角型相似" class="headerlink" title="2.3 对角型相似"></a>2.3 对角型相似</h2><p>矩阵 $A$ 与一个对角型矩阵相似，即表示为：$P^{-1} AP=\Lambda $ ，与对角型形似的条件</p><p><a name="对角化矩阵的条件" alt="none"> </a><strong>定理</strong>： $A\sim \Lambda $  $\Longleftrightarrow $  $A$ 有 $n$ 个线性无关的特征向量。并且如果特征值为 $\lambda _{1} ,\lambda _{2},\cdots ,\lambda _{n}$ ，对应的对角矩阵为：</p><script type="math/tex; mode=display">\Lambda= \begin{bmatrix}\lambda _{1}   &  &  & \\  & \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  &\lambda _{n}\end{bmatrix}</script><ul><li><p>证明：</p><p>  设可逆矩阵 $P$ 为</p><script type="math/tex; mode=display">  P=\begin{bmatrix} \alpha _{1} & \alpha _{2} & \cdots  &\alpha _{n}\end{bmatrix}</script><p>  因为矩阵 $P$ 是可逆矩阵，所以 $|P|\ne 0$ ，即 $\alpha _{1} , \alpha _{2} , \cdots  ,\alpha _{n}$ 均为非零列向量。设设对角矩阵为</p><script type="math/tex; mode=display">  \Lambda = \begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script><p>  那么， $P^{-1} AP=\Lambda $ 可以转化为 $ AP=P\Lambda $ ，即</p><script type="math/tex; mode=display">  A\begin{bmatrix} \alpha _{1} & \alpha _{2} & \cdots  &\alpha _{n}\end{bmatrix}=\begin{bmatrix} \alpha _{1} & \alpha _{2} & \cdots  &\alpha _{n}\end{bmatrix}\begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script><p>  因此，对应相等，即可得到：</p><script type="math/tex; mode=display">  A\alpha _{i}=\lambda _{i} \alpha _{i}</script><p>  因为 $\alpha _{i}\ne 0 $ ，所以 $\lambda _{i}$  是矩阵 $A$ 的特征值，向量 $\alpha _{i}$ 是 $\lambda _{i}$  对应的特征向量。</p></li><li><p>推论： $A$ 有 $n$ 个互不相同的特征值，那么 $A\sim \Lambda =\begin{bmatrix} \lambda _{1}  &amp;  &amp;  \\  &amp; \ddots  &amp;   \\  &amp;  &amp;   \lambda _{n}\end{bmatrix}$ 。（<strong>这是一个充分条件</strong>）</p></li></ul><blockquote><p>💎💎💎💎💎因此，如果证明一个矩阵相似与对角型矩阵，那么就需要证<strong>矩阵有 $n$ 个线性无关的特征向量</strong>。</p><p>并且特征方程中，互异的单根对应的特征向量必定是线性无关的；因此，要看<strong>重根对应的特征向量中线性无关的个数</strong>。</p></blockquote><p><strong>定理</strong>： $A\sim \Lambda $  $\Longleftrightarrow $ 每一个 $k$ 重根的基础解系有 $k$ 个。</p><h1 id="三、实对称矩阵的对角化"><a href="#三、实对称矩阵的对角化" class="headerlink" title="三、实对称矩阵的对角化"></a>三、实对称矩阵的对角化</h1><p>知识回顾：前面我们了解到，并不是所有的矩阵都能对角化，必须满足存在可逆矩阵 $P$ ，使得 $P^{-1}AP=\Lambda$ 成立，那么就需要矩阵 $A$ 有 $n$ 个线性无关的特征向量。</p><p>那么，这一节学习的实对称矩阵，总结为一句话：<strong>实对称矩阵都能对角化</strong>。</p><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p><strong>定义（<font color="red">内积</font>）</strong>：对于任意同维向量 $x = \begin{bmatrix} x_{1}  &amp; x_{2}  &amp; \cdots  &amp;x_{n} \end{bmatrix}^{T}$ 和 $y = \begin{bmatrix} y_{1}  &amp; y_{2}  &amp; \cdots  &amp;y_{n} \end{bmatrix}^{T}$ ，那么称</p><script type="math/tex; mode=display">\left \langle x,y \right \rangle =x^{T}y=x_{1} y_{1}+x_{2} y_{2}+\cdots +x_{n} y_{n}</script><p>为向量 $x,y$ 的<font color="red"><strong>内积</strong></font>。</p><blockquote><p><strong>注意：内积是一个数</strong>。</p></blockquote><p><strong>内积的性质</strong>：</p><ul><li>$\left \langle x,y \right \rangle =\left \langle y,x \right \rangle $ ;</li><li>$\left \langle x,ky \right \rangle =\left \langle kx,y \right \rangle =k\left \langle x,y \right \rangle $ ；</li><li>$\left \langle x+y,z \right \rangle =\left \langle x,z \right \rangle +\left \langle y,z \right \rangle $ ；</li><li>$\left \langle x,x \right \rangle \ge 0 \quad (\text{当且仅当} x=0 \text{时取等}  )$ 。</li></ul><p><strong>定义（<font color="red">范数</font>）</strong>：对于任意的（列）向量 $x = \begin{bmatrix} x_{1}  &amp; x_{2}  &amp; \cdots  &amp;x_{n} \end{bmatrix}^{T}$ ，那么称</p><script type="math/tex; mode=display">\left \| x \right \| =\sqrt{x^{T} x} =\sqrt{x_{1}^{2}+x_{2}^{2}+\cdots +x_{n}^{2}}</script><p>为向量 $x$ 的<font color="red"><strong>范数</strong></font>。（<strong>也称为向量的长度、模</strong>）</p><blockquote><p>特别地，<strong>范数</strong>为 1 的向量被称为<strong>单位向量</strong>；称 $\frac{1}{\left | x \right |} x(x\ne 0)$ 为向量 $x$ 的单位向量，也称将向量 $x$ 单位化，记作 $x^{\circ} =\frac{1}{\left | x \right |} x(x\ne 0)$ 。</p></blockquote><p><strong>向量的范数的性质</strong>：</p><ul><li>非负性： $\left | x \right | \ge 0\quad (\text{当且仅当} x=0 \text{时取等})$ ；</li><li>齐次性： $\left | kx \right |=k\left | x \right |$ ；</li><li>三角不等式： $\left | x+y \right |\le \left | x \right |+\left | y\right |$ ；</li><li>柯西-布涅柯夫斯基不等式不等式： $\left | \left \langle x,y \right \rangle  \right | \le \left | x \right |+\left | y \right | $ 。</li></ul><p><strong>定义（<font color="red">向量的夹角</font>）</strong>：设 $x,y$ 是 $n$ 维非零向量，称</p><script type="math/tex; mode=display">\displaystyle \theta  = \arccos \frac{\left \langle x^{T} y \right \rangle }{\left \| x \right \|+\left \| y \right \|  }</script><p>为向量 $x,y$ 的夹角。特别地，当 $\left \langle x,y \right \rangle = x^{T} y=0$ 时， <script type="math/tex">\displaystyle \theta  = \pm \frac{\pi }{2}</script> ，这时，称向量 $x$ 与 $y$ <font color='red'>正交（或垂直）</font>。<strong>显然，零向量与任何向量正交</strong>。</p><blockquote><ul><li>两两正交的向量组（<strong>不含零向量</strong>）称为<font color='red'><strong>正交向量组</strong></font>。</li><li>由单位向量构成的正交向量组称为标准（规范）正交向量组。</li></ul><p>正交的意义是：在 $n$ 维向量空间中，任意两个维度之间都是正交的（垂直的），且对应维度的方向向量都是单位向量（长度为 1 ）。（参考三维空间坐标系）</p></blockquote><p><strong>定理</strong>：如果向量组 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{s}$ 是正交向量组，那么 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{s}$ 必定是线性无关的。</p><hr><p><a name="施密特正交化方法" alt="none"> </a>⭐<font color='red'><strong>施密特（Schmidt）正交化方法</strong></font>：</p><p>给定一组线性无关的向量组 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{s}$ ，求与之等价的正交向量组 $\beta  _{1} ,\beta _{2},\cdots ,\beta _{s}$ ：</p><script type="math/tex; mode=display">\begin{align}\beta _{1} & =\alpha _{1} \\\beta _{2} & =\alpha_{2} -\frac{\beta _{1}^{T}\alpha_{2}}{\beta _{1}^{T} \beta _{1}}\beta _{1}\\\beta _{3} & =\alpha_{3} -\frac{\beta _{1}^{T}\alpha_{3}}{\beta _{1}^{T} \beta _{1}}\beta _{1}-\frac{\beta _{2}^{T}\alpha_{3}}{\beta _{2}^{T} \beta _{2}}\beta _{2}\\&\dots \\\beta _{m} & =\alpha_{m} -\sum_{j=1}^{m-1} \frac{\beta _{j}^{T}\alpha_{m}}{\beta _{j}^{T} \beta _{j}}\beta _{j}\\\end{align}</script><p><strong>为什么要使用施密特正交化法</strong>：<a href="https://zhuanlan.zhihu.com/p/136627868">如何理解施密特（Schmidt）正交化 - 知乎 (zhihu.com)</a></p><ul><li>在一个平面，或者三维空间中，任意一点都可以被坐标系表示出来。而我们更喜欢的是单位直角坐标系，因为在一个单位直角坐标系中，任意一个向量的坐标分量，通过简单的投影就可以搞定。</li><li>因此，如何找到欧式空间的一个“直角坐标系”，变得非常重要。施密特正交化法就告诉我们了一种把“任意坐标系”变为“直角坐标系”的方法。</li></ul><p><strong>定义（正交矩阵）</strong>：设矩阵 $A$ 是 $n$ 阶方阵，如果 $A^{T}A=E$ ，那么称矩阵 $A$ 为<strong>正交矩阵</strong>。</p><blockquote><p> $n$ 线性空间中的<strong>正交基</strong>矩阵就是 $A$ 。</p><p> 正交矩阵一定是可逆的，且 $A^{-1} =A^{T} $ 。</p></blockquote><h2 id="3-2-性质"><a href="#3-2-性质" class="headerlink" title="3.2 性质"></a>3.2 性质</h2><p><strong>性质 1</strong>：如果 $A$ 是正交矩阵，那么 $|A|=\pm 1$ 。</p><p><strong>性质 2</strong>：如果 $A$ 是正交矩阵，那么 $A^{-1}=A^{T}$ ，且 $A^{-1}$ 和 $A^{T}$ 均是正交矩阵。</p><p><strong>性质 3</strong>：如果矩阵 $A,B$ 是正交矩阵，那么矩阵 $AB$ 也是正交矩阵。</p><p><strong>性质 4</strong>：如果矩阵 $A$ 是正交矩阵，且 $\alpha, \beta $ 是列向量，那么 $\left \langle A\alpha, A\beta  \right \rangle =\left \langle \alpha, \beta  \right \rangle $ 。</p><p><strong>定理</strong>：矩阵 $A$ 是正交矩阵 $\Longleftrightarrow $ 矩阵 $A$ 的列（行）向量是标准正交向量组。</p><h2 id="3-3-实对称矩阵的对角化"><a href="#3-3-实对称矩阵的对角化" class="headerlink" title="3.3 实对称矩阵的对角化"></a>3.3 实对称矩阵的对角化</h2><p><strong>定理</strong>： $n$ 阶是对称矩阵，那么 $n$ 个特征值都是实数，并且 $n$ 个特征向量都是实向量。</p><p><strong>定理</strong>：<strong>实对称矩阵 $n$ 的不同特征值对应的特征向量，必定正交</strong>。</p><ul><li><p>证明：</p><p>  ​    设实对称矩阵 $A$ ，则 $A=A^{T}$ ；设 $\lambda _{1} ,\lambda _{2}$ 是任意两个不同特征值，那么可以得到：</p><script type="math/tex; mode=display">  \begin{align}A\alpha _{1} & = \lambda _{1}\alpha _{1}\\A\alpha _{2} & = \lambda _{2}\alpha _{2}\end{align}</script><p>  ​    做内积，可以得到：</p><script type="math/tex; mode=display">  \begin{align}\left \langle A\alpha _{1} ,\alpha _{2}  \right \rangle &=\left \langle \lambda _{1} \alpha _{1} ,\alpha _{2} \right \rangle\\(A\alpha _{1})^{T}\alpha _{2}&= \lambda _{1} \alpha _{1}^{T}  \alpha _{2}\\\alpha _{1}^{T}A^{T}\alpha _{2}&= \lambda _{1} \alpha _{1}^{T}  \alpha _{2}\\\alpha _{1}^{T}A\alpha _{2}&= \lambda _{1} \alpha _{1}^{T}  \alpha _{2}\\\alpha _{1}^{T}\lambda _{2} \alpha _{2}&= \lambda _{1} \alpha _{1}^{T}  \alpha _{2}\\(\lambda _{2}-\lambda _{1})\alpha _{1}^{T}\alpha _{2}&=0\end{align}</script><p>  ​    又因为 $\lambda _{1}\ne \lambda _{2}$ ，所以：</p><script type="math/tex; mode=display">  \alpha _{1}^{T}\alpha _{2}=0</script><p>  ​    证毕。</p></li></ul><p><strong>正交相似</strong>：矩阵 $A,B$ 是同阶矩阵，存在正交矩阵 $P$ ，使得 $P^{-1} AP=B$ 成立，那么称 $A$ 是 $B$ 的正交相似矩阵。</p><p><strong>定理</strong>：设 $A$ 为 $n$ 阶实对称矩阵，则存在正交矩阵 $Q$ ，使得</p><script type="math/tex; mode=display">\displaystyle Q^{-1} AQ = Q^{T} AQ  =\Lambda =\begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script><p>其中 $\displaystyle \lambda _{1},\lambda _{2},\dots ,\lambda _{n} $ 为 $A$ 的特征值。</p><p><strong>推论</strong>：设 $A$ 为 $n$ 阶实对称矩阵， $\lambda$ 为 $A$ 的 $k$ 重特征值，则 $A$ 必有 $k$ 个对应于特征值 $\lambda$ 的线性无关的特征向量。</p><hr><p><font color="red"><strong>求解步骤</strong></font>：给定实对称矩阵 $A$ ，求正交矩阵 $Q$ ，使得 $Q^{-1} AQ=\Lambda $ 。</p><ol><li>求出矩阵 $A$ 的所有特征值；</li><li>求出矩阵 $A$ 的所有特征向量（对于 $k$ 重根，要求出对应的一个基础解系）；</li><li>将求出的所有特征向量正交化，单位化；</li><li>特征向量按照<strong>列向量</strong>依次排列成矩阵 $Q$ ，对应的对角矩阵的主对角线依次是对应的<strong>特征值</strong>。</li></ol><blockquote><p>注意：在进行特征向量正交化的时候要注意</p><ul><li>如果所有特征值都不相同，即没有重根，那么对应的特征向量就是正交的；</li><li>如果有 $k$ 重根，但是不同根之间依旧还是正交的，因此，只需要处理 $k$ 重根对应的 $k$ 个线性无关的特征向量，使其正交化就行了，即仅给 $k$ 重根对应的特征向量进行<a href="#施密特正交化">施密特正交化</a>。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 向量(Vector)【线性代数】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/3_%E5%90%91%E9%87%8F(Vector).html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/3_%E5%90%91%E9%87%8F(Vector).html</url>
      
        <content type="html"><![CDATA[<h1 id="三、向量-Vector-【线性代数】"><a href="#三、向量-Vector-【线性代数】" class="headerlink" title="三、向量(Vector)【线性代数】"></a>三、向量(Vector)【线性代数】</h1><h1 id="一、向量的定义"><a href="#一、向量的定义" class="headerlink" title="一、向量的定义"></a>一、向量的定义</h1><p><a name="star" alt="none"> </a><a name="第三章向量" alt="none"> </a><strong>定义</strong>： $n$ 个数 $a_{1},a_{2},\dots ,a_{n}$ 组成的有序数组，称为<strong>向量</strong>。其中， $a_{i}$ 称为分量。 $n$ 称为向量的<strong>维数</strong>。</p><p><strong>行向量</strong>：形如 $\begin{bmatrix} a_{1} &amp; a_{2} &amp; \dots  &amp;a_{n}\end{bmatrix}$ 的向量，称为<strong>行向量</strong>。</p><p><strong>列向量</strong>：形如 $\displaystyle \begin{bmatrix} a_{1} \\ a_{2} \\ \dots  \\ a_{n}\end{bmatrix}$ 的向量，称为<strong>列向量</strong>。</p><blockquote><p>在没有特殊说明的情况下，提到向量一律按照列向量的对待</p></blockquote><p><strong>零向量</strong>：向量的各分量都为 0 ，记作 $\mathbf{0} $ 。</p><h1 id="二、向量的线性关系"><a href="#二、向量的线性关系" class="headerlink" title="二、向量的线性关系"></a>二、向量的线性关系</h1><p><strong>线性组合</strong>：设向量组 $\beta ,\alpha _{1},\alpha _{2},\dots ,\alpha _{s}$ 都是 $n$ 维向量，若存在 $k_{1},k_{2},\cdots ,k_{s} $ ，使得</p><script type="math/tex; mode=display">\beta =k_{1}\alpha_{1}+k_{2}\alpha_{2}+\cdots+k_{s}\alpha_{s}</script><p>称该向量组是一个线性组合，或者线性表示。</p><blockquote><ul><li>零向量可以由任意向量组来表示。</li><li>向量组中的任一向量，都以可有向量组其余的向量表示。</li><li>任意向量可由 $\varepsilon_{1}  =\left [1,0,\cdots ,0  \right ] ^{T} ,\varepsilon_{1}  =\left [0,1,\cdots ,0  \right ] ^{T},\dots ,\varepsilon_{n}  =\left [0,0,\cdots ,1  \right ] ^{T}$ 表示。</li><li>不管向量是行向量还是列向量，都<strong>左乘</strong>系数。</li></ul></blockquote><p>上述线性组合可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix} \alpha _{1}  &\alpha _{2}  & \dots  &\alpha _{s}\end{bmatrix}\begin{bmatrix}k_{1}  \\k_{2} \\ \vdots \\k_{s}\end{bmatrix} = \beta</script><p><strong>向量组的等价</strong>：给定两给向量组 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{m}$ 和向量组 $\beta_{1} ,\beta_{2},\cdots ,\beta _{m}$ ，并且都是同维的，如果 $\alpha$ 向量组中的每个向量，都可以用 $\beta$ 向量组线性表示（或者 $\beta$ 向量组中的每个向量，都可以用 $\alpha$ 向量组线性表示）那么称<strong>这两个向量组是等价的</strong>，记作 $\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix}\cong\begin{bmatrix}\beta _{1}  &amp; \beta _{2} &amp;\cdots  &amp;\beta _{m}\end{bmatrix} $ 。</p><p>性质：</p><ol><li>反身性： $\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix}\cong\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix} $ ；</li><li>对称性：如果 $\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix}\cong\begin{bmatrix}\beta _{1}  &amp; \beta _{2} &amp;\cdots  &amp;\beta _{m}\end{bmatrix} $ ，那么 $\begin{bmatrix}\beta _{1}  &amp; \beta _{2} &amp;\cdots  &amp;\beta _{m}\end{bmatrix}\cong\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix} $ 。</li><li>传递性： 如果 $\begin{bmatrix}\alpha \end{bmatrix}\cong\begin{bmatrix} \beta\end{bmatrix} $ ，且 $\begin{bmatrix} \beta\end{bmatrix}\cong\begin{bmatrix}\gamma \end{bmatrix} $ ，那么 $\begin{bmatrix}\alpha \end{bmatrix}\cong\begin{bmatrix}\gamma \end{bmatrix} $ 。</li></ol><p><strong>线性无关</strong>：已知 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 是 $n$ 个 $m$ 维向量，若存在一组不全为 0 的系数 $k_{1},k_{2},\cdots ,k_{n} $ 使得</p><script type="math/tex; mode=display">k_{1}\alpha_{1}+k_{2}\alpha_{2}+\cdots+k_{n}\alpha_{n}=0</script><p>成立，则称 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 是<strong>线性相关</strong>的；反之，则称为<strong>线性无关</strong>。</p><blockquote><ol><li>向量组中的两两向量成比例，则是线性相关的。</li><li>含零向量的任意向量组必定是线性相关的。</li><li>一个零向量必定线性相关的。</li><li>任意一个非零向量必定线性无关。</li></ol></blockquote><p><strong>定理</strong>：如果 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{r}$ 是线性相关的，那么 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{r},\alpha _{r+1},\cdots ,\alpha _{s}$ 必定也是线性相关的。</p><p><strong>定理</strong> 1： $\alpha _{1} ,\alpha _{2} ,\cdots  ,\alpha _{s} $ 线性相关 $\Longleftrightarrow $ 至少一个向量可有其余向量线性表示。</p><p><strong>定理 2</strong>： $\alpha _{1} ,\alpha _{2} ,\cdots  ,\alpha _{s} $ 线性无关，且 $\alpha _{1} ,\alpha _{2} ,\cdots  ,\alpha _{s}, \beta$ 线性相关，那么 $\beta $ 可由 $\alpha _{1},\alpha _{2},\cdots ,\alpha _{n}$ <strong>唯一线性表示</strong>。</p><blockquote><p> $n+1$ 个 $n$ 维向量一定是线性相关的。（相当于 $n$ 个未知量和 $n+1$ 个方程）。</p></blockquote><h1 id="三、向量组的秩"><a href="#三、向量组的秩" class="headerlink" title="三、向量组的秩"></a>三、向量组的秩</h1><p><strong>定义（极大线性无关组）</strong>：向量组 $\alpha _{1},\alpha _{2},\cdots ,\alpha _{m}$ ， 而 $\alpha  _{1},\alpha  _{2},\cdots ,\alpha _{s} $ 是向量组的一部分，并且子向量组是线性无关的，同时任意的 $s+1$ 个向量是线性相关的，那么称 $\alpha  _{1},\alpha  _{2},\cdots ,\alpha _{s} $ 是一个<strong>极大线性无关组</strong>。</p><p><strong>定理</strong>： $\alpha  _{1},\alpha  _{2},\cdots ,\alpha _{s} $ 线性无关，任意 $s+1$ 个向量是线性相关的。</p><p><strong>定义（向量组的秩）</strong>：极大线性无关组所含向量的个数，即为<strong>向量组的秩</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 线性方程组【线性代数】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/4_%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/4_%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84.html</url>
      
        <content type="html"><![CDATA[<h1 id="四、线性方程组【线性代数】"><a href="#四、线性方程组【线性代数】" class="headerlink" title="四、线性方程组【线性代数】"></a>四、线性方程组【线性代数】</h1><h1 id="一、线性方程组"><a href="#一、线性方程组" class="headerlink" title="一、线性方程组"></a>一、线性方程组</h1><p>引例：（鸡兔同笼），共8只，腿共20只。</p><p>解：设鸡兔的个数分别为 $x_{1},x_{2}$ ，那么得到：</p><script type="math/tex; mode=display">\left\{\begin{matrix}x_{1}   & + & x_{2} & =&8\\x_{1}  & + & 2x_{2} & =&20\end{matrix}\right.</script><p>那么，上述方程组可以使用矩阵来表示：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 1\\ 1 &2\end{bmatrix}\cdot \begin{bmatrix} x_{1} \\ x_{2}\end{bmatrix}=\begin{bmatrix}8 \\20\end{bmatrix}</script><p>即 $AX=B$ ，矩阵 $A$ 称为系数矩阵，矩阵 $X$ 称为未知量矩阵（向量），矩阵 $B$ 称为结果矩阵（向量）。</p><h1 id="二、方程组有解的判定"><a href="#二、方程组有解的判定" class="headerlink" title="二、方程组有解的判定"></a>二、方程组有解的判定</h1><p>设方程组为：</p><script type="math/tex; mode=display">\left\{\begin{matrix} x_{1}  & + & x_{2}  & + & x_{3}  & = & 1\\ x_{1}  & - & x_{2}  & - & x_{3}  & = & -3\\ 2x_{1}  & + & 9x_{2}  & + & 10x_{3}  & = & 11\\\end{matrix}\right.</script><p>那么<strong>系数矩阵</strong>为：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 1 & 1\\ 1 & -1 &-1 \\ 2 &  9&10\end{bmatrix}</script><p>增广矩阵为：</p><script type="math/tex; mode=display">\widetilde{A} =\begin{bmatrix} 1 & 1 & 1&1\\ 1 & -1 &-1 &-3\\ 2 &  9&10&11\end{bmatrix}</script><p>方程组用向量表示为：</p><script type="math/tex; mode=display">x_{1}\begin{bmatrix} 1\\ 1\\2\end{bmatrix} +x_{2}\begin{bmatrix} 1\\ -1\\9\end{bmatrix}+x_{3}\begin{bmatrix} 1\\ -1\\10\end{bmatrix} =\begin{bmatrix} 1\\ -3\\11\end{bmatrix}</script><p>方程组 $n$ 解的判定</p><ul><li>唯一解：$R(A)=R(\widetilde{A}) = \mathrm{min}\left \{ \text{行数},\text{列数}  \right \}  $ ，即<strong>矩阵为满秩</strong>。</li><li>无穷多解： $R(A)=R(\widetilde{A}) &lt; \mathrm{min}\left \{ \text{行数},\text{列数}  \right \}  $ ，即为<strong>非满秩</strong> ，其中 $n-r$ 称为自由量的个数；</li><li>无解： $R(A)&lt; R(\widetilde{A})$ 。</li></ul><p>解题的一般步骤：</p><ol><li>先写出方程组的系数矩阵 $A$ 以及增广矩阵 $\widetilde{A}$ ；</li><li>将上述矩阵化为<strong>行阶梯型矩阵</strong>；</li><li>观察系数矩阵以及增广矩阵的秩 $R(A)，R(\widetilde{A})$ 的关系</li><li>若 $R(A)=R(\widetilde{A})$ ，则方程有解<ol><li>如果矩阵为满秩（$r=n$），则有唯一解；</li><li>如果矩阵为非满秩（$r&lt;n$），则有无穷多解，并且有 $n-r$ 个自由量。</li></ol></li><li>若  $R(A)&lt; R(\widetilde{A})$ ，则方程无解。</li></ol><h1 id="三、齐次方程组的解"><a href="#三、齐次方程组的解" class="headerlink" title="三、齐次方程组的解"></a>三、齐次方程组的解</h1><p>结果矩阵为 0 的方程组，称为<strong>齐次方程组</strong>，即：</p><script type="math/tex; mode=display">Ax=0</script><p>此时， $R(A)\equiv R(\widetilde{A} )$ ，所以，<strong>齐次方程组必定是有解的（必定含零解）</strong>。</p><p>解的判定：</p><ol><li>齐次线性方程组有唯一零解 $\Longleftrightarrow $  $R(A)=n$ </li><li>齐次线性方程组有无穷多解 $\Longleftrightarrow$ $R(A)&lt;n$ ，且有 $n-r$ 个自由量。</li><li><strong>齐次线性方程组<font color="green">不存在</font>唯一非零解</strong>。</li><li>若方程组个数等于未知量个数（<a href="#克莱姆法则">克莱姆法则</a>）<ol><li>有非零解  $\Longleftrightarrow$  $|A|=0$ ；</li><li>只有零解  $\Longleftrightarrow$  $|A|\ne 0$ 。</li></ol></li></ol><h1 id="四、线性方程组解的结构"><a href="#四、线性方程组解的结构" class="headerlink" title="四、线性方程组解的结构"></a>四、线性方程组解的结构</h1><p>解的类型有：唯一解、无解、无穷解。其中，无穷多解描述是比较麻烦的，因此，使用解的结构来描述无穷多解的情况。</p><h2 id="4-1-齐次方程组"><a href="#4-1-齐次方程组" class="headerlink" title="4.1 齐次方程组"></a>4.1 齐次方程组</h2><p>设齐次方程组 $Ax=0$ 有无穷多解：</p><ul><li>假设 $\eta _{1} ,\eta _{2}$ 是方程组的解，那么 $\eta _{1}+\eta _{2}$ 也是方程组的解。</li><li>假设 $\eta$ 是方程组的解，那么 $c\eta$ 也是方程组的解（ $c$ 是常数 ）。</li></ul><p><strong>基础解系</strong>：解向量 $\eta _{1} ,\eta _{2},\cdots ,\eta _{s}$ 满足：</p><ol><li>$\eta _{1} ,\eta _{2},\cdots ,\eta _{s}$ <strong>线性无关</strong>；</li><li>任意解都能用  $\eta _{1} ,\eta _{2},\cdots ,\eta _{s}$ 线性表示。</li></ol><blockquote><p><strong>基础解系就是方程组所有解向量中的一组极大线性无关组（注意：可能有多个极大无关组，也就是说有多个基础解系），并且方程组有多少个自由量，就代表着极大无关组有多少个解向量</strong>。</p></blockquote><p>求解基础解系的过程：</p><p><img src="https://imageshack.yuilexi.cn/University/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%AE%8B%E6%B5%A9%E7%89%88/%E6%B1%82%E8%A7%A3%E5%9F%BA%E7%A1%80%E8%A7%A3%E7%B3%BB%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="求解基础解系的过程"></p><p><strong>性质</strong>： 如果矩阵 $AB=0$ ，那么 $R(A)+R(B)\le n$ </p><h2 id="4-2-非齐次线性方程组"><a href="#4-2-非齐次线性方程组" class="headerlink" title="4.2 非齐次线性方程组"></a>4.2 非齐次线性方程组</h2><p>形如 $Ax=b$ 的方程组，称为<strong>非齐次线性方程组</strong>。</p><ol><li>$\alpha _{1} ,\alpha _{1}$ 是方程组 $Ax=b$ 的解，那么 $\alpha _{1} -\alpha _{1}$ 是方程 $Ax=0$ 的解；</li><li>$\alpha _{0} $ 是方程组 $Ax=b$ 的解，  $\eta $ 是 $Ax=0$ 的解，那么 $\alpha _{0}+ \eta $ 也是 $Ax=b$ 的解</li></ol><p>非齐次解的结构：</p><p><strong>定理</strong>：如果 $\alpha _{0} $ 是方程组 $Ax=b$ 的一个解（特解）， $\eta $ 是 $Ax=0$ 的通解。其中：</p><script type="math/tex; mode=display">\eta =c_{1}\eta _{1}+c_{2}\eta _{2}+\cdots +c_{n-r}\eta _{n-r}</script><p>是 $Ax=0$ 的一个基础解系。那么：</p><script type="math/tex; mode=display">\alpha _{0} +c_{1}\eta _{1}+c_{2}\eta _{2}+\cdots +c_{n-r}\eta _{n-r}</script><p>就是非齐次线性方程组 $Ax=b$ 的通解。</p><hr><p><strong>非齐次线性方程组的通解求解步骤</strong>：</p><ol><li>写出增广矩阵 $\widetilde{A}$ ，只进行初等行变换，化为<strong>最简行阶梯型矩阵</strong>；</li><li>非零行的首非零元的 1 留在左边，其余元素移到等号右边；</li><li>令自由未知量均取 0 ，得 $Ax=b$ 的一个特解；</li><li>令方程组右边的 $b=0$ ，得到 $Ax=0$ 的方程组，并且解出对应的一个基础解系</li><li>将齐次方程组的通解与非齐次方程组的特解相加，得到非齐次线性方程组的<strong>通解</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 矩阵(Martix)【线性代数】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/2_%E7%9F%A9%E9%98%B5(Martix).html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/2_%E7%9F%A9%E9%98%B5(Martix).html</url>
      
        <content type="html"><![CDATA[<h1 id="二、矩阵-Matrix-【线性代数】"><a href="#二、矩阵-Matrix-【线性代数】" class="headerlink" title="二、矩阵(Matrix)【线性代数】"></a>二、矩阵(Matrix)【线性代数】</h1><h1 id="一、矩阵的概念"><a href="#一、矩阵的概念" class="headerlink" title="一、矩阵的概念"></a>一、矩阵的概念</h1><p>形如下面形式的一组<strong>数表</strong>，称为 $m\times n$ 矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix} a_{11}  & a_{12} & \cdots  & a_{1n}\\ a_{21} & a_{22} & \cdots & a_{2n}\\ \vdots  & \vdots & \ddots  & \vdots\\ a_{m1} &a_{m2}  & \cdots &a_{mn}\end{bmatrix}</script><p>矩阵与行列式区别：</p><ul><li>矩阵是一组数表，而行列式本质上是一个数。</li><li>行列式符号是 $|\cdots|$ ；矩阵符号是 $(\dots) or [\dots]$ 。</li><li>行列式的<strong>行权等于列权（地位相等）</strong>，行列数必须相等，而矩阵行列数可以不相等。</li></ul><p><strong>零矩阵</strong>：元素全为 0 的<strong>矩阵</strong>称为零矩阵。</p><p><strong>单位矩阵</strong>：对于一个方阵，主对角线上全为 1 ，其余全为 0 的矩阵，称为 <strong>$n$ 阶单位矩阵</strong>。</p><script type="math/tex; mode=display">\begin{bmatrix}1  & &  &\\ & 1 &  & \\  &  & \ddots  &\\&  &  &1\end{bmatrix}</script><p><strong>同型矩阵</strong>：行列数对应相等的两个矩阵，称为同型矩阵。</p><div align="center">    <font color="red">两个矩阵相等的一个前提是同型矩阵</font></div><blockquote><ul><li>只有一个数的矩阵，可以不用写符号。</li><li>两个 0 矩阵不一定相等。</li></ul></blockquote><p>矩阵的属性：</p><ol><li>矩阵的秩</li><li>特征值</li><li>特征向量</li><li>行列式</li></ol><h1 id="二、矩阵的运算"><a href="#二、矩阵的运算" class="headerlink" title="二、矩阵的运算"></a>二、矩阵的运算</h1><h2 id="2-1-矩阵的加减法"><a href="#2-1-矩阵的加减法" class="headerlink" title="2.1 矩阵的加减法"></a>2.1 矩阵的加减法</h2><p>两个矩阵能够相加减，必须是<strong>同型矩阵</strong>。矩阵的加减法是将每一个元素对应相加减。</p><script type="math/tex; mode=display">\begin{align} &\begin{bmatrix} a_{11} &  a_{12} & \cdots  & a_{1n} \\ a_{21} &  a_{22} & \cdots  & a_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ a_{m1} &  a_{m2} & \cdots  & a_{mn} \\\end{bmatrix} \pm \begin{bmatrix} b_{11} &  b_{12} & \cdots  & b_{1n} \\ b_{21} &  b_{22} & \cdots  & b_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ b_{m1} &  b_{m2} & \cdots  & b_{mn} \\\end{bmatrix}\\ & = \begin{bmatrix} a_{11}\pm b_{11} &  a_{12}\pm b_{12} & \cdots  & a_{1n}\pm b_{1n} \\ a_{21}\pm b_{21} &  a_{22}\pm b_{22} & \cdots  & a_{2n}\pm b_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ a_{m1}\pm b_{m1} &  a_{m2}\pm b_{m2} & \cdots  & a_{mn}\pm b_{mn} \\\end{bmatrix}\end{align}</script><p> 运算律：</p><ol><li>$A\pm B=B\pm A$ ；</li><li>$(A+B)+C=A+(B+C)$ ；</li><li>$A+0=A$ ；</li></ol><h2 id="2-2-矩阵的数乘运算"><a href="#2-2-矩阵的数乘运算" class="headerlink" title="2.2 矩阵的数乘运算"></a>2.2 矩阵的数乘运算</h2><p>一个数 $k$ 乘以一个矩阵，就是把矩阵中的每个元素都乘以 $k$ 。</p><script type="math/tex; mode=display">k\begin{bmatrix} a_{11} &  a_{12} & \cdots  & a_{1n} \\ a_{21} &  a_{22} & \cdots  & a_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ a_{m1} &  a_{m2} & \cdots  & a_{mn} \\\end{bmatrix}=\begin{bmatrix} ka_{11} &  ka_{12} & \cdots  & ka_{1n} \\ ka_{21} &  ka_{22} & \cdots  & ka_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ ka_{m1} &  ka_{m2} & \cdots  & ka_{mn} \\\end{bmatrix}</script><p>矩阵提公因子：矩阵所有元素均有公因子，并且公因子<strong>外提一次</strong> </p><h2 id="2-3-矩阵的乘法"><a href="#2-3-矩阵的乘法" class="headerlink" title="2.3 矩阵的乘法"></a>2.3 矩阵的乘法</h2><p>有两个矩阵 $A_{ml}$ 和矩阵 $B_{ln}$ ，矩阵 $A\times B$ 就是将 $A$ 的行元素对应乘以 $B$ 的列元素之和，就是新的矩阵的元素。（和行列式的乘法类似）。</p><blockquote><p><strong>矩阵相乘的前提是：左边的列数等于右边的行数</strong>；矩阵相乘后的结果矩阵，其行数等于原左边矩阵的行数，其列数等于原右边矩阵的列数。</p></blockquote><p>运算律：</p><ol><li>$AB\ne BA$ ，有时 $AB$ 有意义的时候， $BA$ 不一定有意义。</li><li>$AB=0$ ，那么<strong>推不出来</strong> $A=0\text{或}B=0$ 。</li><li>$AB=AC,A\ne0$ ，同样推不出来 $A=C$ 。</li><li>$A0=0$ 。</li><li>$AE=A,EB=B$ ，其中， $E$ 的单位矩阵。</li><li>$(AB)C=A(BC)$ 。</li><li>$(A+B)C=AC+BC,C(A+B)=CA+CB$ 。</li><li>$kAB = k(AB) = A(kB)$ 。</li></ol><h2 id="2-4-矩阵的幂运算"><a href="#2-4-矩阵的幂运算" class="headerlink" title="2.4 矩阵的幂运算"></a>2.4 矩阵的幂运算</h2><p>形如 $A^{k} = AA\cdots A$ 的运算，称为<strong>矩阵的幂运算</strong>。特别地。规定 $A^{0}=E$ 。</p><p>运算律：</p><ol><li>$A^{k_{1}}A^{k_{2}}=A^{k_{1}+k_{2}}$ ；</li><li>一般地， $(AB)^{k} \ne A^{k}B^{k}$ ；</li><li>一般情况下， $(A+B)^{2} \ne A^{2}+2AB+B^{2} $ ；<ol><li>$(A+B)^{2} = A^{2} +B^{2}+AB+BA $ ；</li><li>$(A-B)^{2} \ne A^{2}-2AB+B^{2}$；</li><li>$(A+E)^{2} = A^{2} +E^{2}+2AE $ ；</li></ol></li></ol><h2 id="2-5-矩阵的转置"><a href="#2-5-矩阵的转置" class="headerlink" title="2.5 矩阵的转置"></a>2.5 矩阵的转置</h2><p>假设矩阵 $A=\begin{bmatrix} 1 &amp; 2 &amp; 3\\  1&amp; 1 &amp;1\end{bmatrix}$ ，那么，矩阵 $\begin{bmatrix} 1 &amp; 1 \\  2&amp; 1 \\ 3 &amp; 1 \end{bmatrix}$ 称为 $A$ 的转置矩阵。</p><p><strong>定义（矩阵转置）</strong> 设矩阵 $A_{mn}$ ，将对应的行换成列，对应的列换成行，得到的新矩阵称为 $A$ 的转置矩阵，记作 $A^{T}(\text{或者}A^{‘})$ 。显然，转置矩阵是 $n\times m$ 阶的矩阵。</p><p><strong>性质</strong>：</p><ol><li><p>$(A^{T} )^{T} =A$ ；</p></li><li><p>$(A+B)^{T} =A^{T} +B^{T}$ ；</p></li><li><p>$(kA)^{T}=kA^{T}$ ；</p></li><li><p>$(AB)^{T}=B^{T}A^{T}$ ；</p><p> ​    推广：</p><ol><li>$(A_{1}A_{2}\cdots A_{n} )^{T}=A_{n} ^{T}\cdots A_{2} ^{T}A_{1} ^{T}$ ；</li></ol></li></ol><h1 id="三、特殊矩阵"><a href="#三、特殊矩阵" class="headerlink" title="三、特殊矩阵"></a>三、特殊矩阵</h1><h2 id="3-1-数量矩阵"><a href="#3-1-数量矩阵" class="headerlink" title="3.1 数量矩阵"></a>3.1 数量矩阵</h2><p>形如：</p><script type="math/tex; mode=display">\begin{bmatrix} a &  &  &  & \\  & a &  &  & \\  &  & a &  & \\  &  &  & \ddots  & \\  &  &  &  &a\end{bmatrix}</script><p>其中， $a$ 是常数。这样的矩阵称为<strong>数量矩阵</strong>。<strong>显然，数量矩阵都是方阵</strong>。</p><blockquote><p>单位阵和零矩阵都是特殊的单位矩阵。</p></blockquote><p><strong>一个数乘以一个数量矩阵、两个数量矩阵之和、两个数量矩阵相减、两个数量矩阵相减、两个数量矩阵相乘，结果都是数量矩阵</strong>。</p><h2 id="3-2-对角矩阵"><a href="#3-2-对角矩阵" class="headerlink" title="3.2 对角矩阵"></a>3.2 对角矩阵</h2><p>形如：</p><script type="math/tex; mode=display">\begin{bmatrix} a_{1}  &  &  &  & \\  & a_{2} &  &  & \\  &  & a_{3} &  & \\  &  &  & \ddots  & \\  &  &  &  &a_{n}\end{bmatrix}</script><p>的矩阵称为<strong>对角矩阵</strong>。</p><blockquote><p>数量矩阵是特殊的对角型矩阵。</p></blockquote><h2 id="3-4-三角矩阵"><a href="#3-4-三角矩阵" class="headerlink" title="3.4 三角矩阵"></a>3.4 三角矩阵</h2><p>主对角线左下方全是 0 的矩阵是上三角矩阵；主对角线右上方全是 0 的矩阵是下三角矩阵。</p><blockquote><p>对角型矩阵是特殊的上三角矩阵和下三角矩阵。</p></blockquote><h2 id="3-5-对称和反对称"><a href="#3-5-对称和反对称" class="headerlink" title="3.5 对称和反对称"></a>3.5 对称和反对称</h2><p><strong>对称矩阵</strong>：满足 $a_{ij}=a_{ji}$ 的矩阵称为对称矩阵。<strong>$A^{T}=A$的矩阵称为对称矩阵</strong>。 </p><ol><li>$A,B$ 是对称矩阵，那么 $A\pm B$ 也是对称矩阵。</li><li>$A$ 是对称矩阵，那么 $(kA)^{T}$ 也是对称矩阵。</li><li>$AA^{T},A^{T}A$ 都是对称矩阵。</li></ol><p><strong>定义（反对称矩阵）</strong> 满足 $a_{ij}=-a_{ji}$ 的矩阵，称为反对称矩阵。</p><blockquote><p><strong>反对称矩阵的主对角线全为零；对称矩阵的主对角线无要求</strong>。</p></blockquote><h1 id="四、逆矩阵"><a href="#四、逆矩阵" class="headerlink" title="四、逆矩阵"></a>四、逆矩阵</h1><p>之前，我已经探讨过矩阵的加、减、数乘、乘，那么，矩阵有没有除法呢？这就引出一个新的概念：<strong>逆矩阵</strong>。</p><h2 id="4-1-方阵的行列式"><a href="#4-1-方阵的行列式" class="headerlink" title="4.1 方阵的行列式"></a>4.1 方阵的行列式</h2><p>设方阵 $A$ ，那么，将 $A$ 中所有元素构成一个行列式，这个行列式称为<strong>方阵的行列式</strong>，记作 $|A|$ 。</p><blockquote><p>注意：行列式是一个数，而矩阵是一个数表。二者有着本质上的区别。<strong>行列式是矩阵的一个属性</strong>。</p></blockquote><p><strong>性质</strong>：</p><ol><li>性质1： $|A^{T}|=|A|$ ，即行列式转置，值不变。</li><li>性质2： $|kA|=k^{n}|A|$ ，其中， $n$ 是方阵的阶。</li><li>性质3： $|AB|=|A|\cdot|B|$ 。<ol><li>性质3-1： $|A_{1}A_{2}\dots A_{n}|=|A_{1}||A_{2}|\cdots |A_{n}|$ 。</li></ol></li></ol><h2 id="4-2-伴随矩阵"><a href="#4-2-伴随矩阵" class="headerlink" title="4.2 伴随矩阵"></a>4.2 伴随矩阵</h2><p><strong>定义（伴随矩阵）</strong> 设矩阵 $\displaystyle \begin{bmatrix} a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n}\\ \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots \\ a_{m1} &amp; a_{m2} &amp; \cdots  &amp; a_{mn}\end{bmatrix}$ ，并且 $A_{ij}$ 是矩阵 $A$ 的<strong>代数余子式</strong> ，然后代数余子式按顺序组成的矩阵的<strong>转置矩阵</strong>，称为矩阵 $A$ 的伴随矩阵，记作 $A^{*}$：</p><script type="math/tex; mode=display">\displaystyle A ^{\ast }=\begin{bmatrix} A_{11} & A_{21} & \cdots  & A_{m1}\\ A_{12} & A_{22} & \cdots  & A_{m2}\\ \vdots  & \vdots  & \ddots  & \vdots \\ A_{1n} & A_{2n} & \cdots  & A_{nm}\end{bmatrix} =\begin{bmatrix} A_{11} & A_{12} & \cdots  & A_{1n}\\ A_{21} & A_{22} & \cdots  & A_{2n}\\ \vdots  & \vdots  & \ddots  & \vdots \\ A_{m1} & A_{m2} & \cdots  & A_{mn}\end{bmatrix}^{T}</script><div align="center">    <p>        --------------------    </p>    <p>        按行求，按列放    </p>    <p>        --------------------    </p></div><p><strong>定理1</strong>：任意方阵 $A$ ，那么 $AA^{\ast }=A^{\ast }A=|A|E$ 。</p><p>证明：</p><script type="math/tex; mode=display">\begin{align}AA^{\ast } & = \begin{bmatrix} a_{11} & a_{12} & \dots  & a_{1n}\\a_{21} & a_{22} & \dots & a_{2n}\\ \vdots  &  \vdots&  \ddots & \vdots\\ a_{m1} & a_{m2} & \dots &a_{mn}\end{bmatrix}\begin{bmatrix} A_{11} & A_{21} & \cdots  & A_{m1}\\ A_{12} & A_{22} & \cdots  & A_{m2}\\ \vdots  & \vdots  & \ddots  & \vdots \\ A_{1n} & A_{2n} & \cdots  & A_{nm}\end{bmatrix}\\&=\begin{bmatrix} |A| &  &  & \\  & |A| &  & \\  &  & |A| & \\  &  &  &|A|\end{bmatrix}=|A|E\end{align}</script><p><strong>推论1-1</strong>：当 $|A|\ne 0$ 时， $|A^{\ast}|=|A|^{n-1}$ 。（后续能够证明，当 $|A| =0$ ，该推论依旧成立）。</p><p>证明：</p><script type="math/tex; mode=display">\left | AA^{\ast} \right |  = \left | \left | A \right | E \right | =\left | A \right |^{n}</script><p>那么，上式左边可以化为：</p><script type="math/tex; mode=display">\left | A \right |^{n}  =\left | AA^{\ast} \right | =|A|\cdot |A^{\ast } |</script><p>移项化简可得：</p><script type="math/tex; mode=display">|A^{\ast } |=\left | A \right |^{n-1}</script><p>至此证毕。</p><h2 id="4-3-逆矩阵"><a href="#4-3-逆矩阵" class="headerlink" title="4.3 逆矩阵"></a>4.3 逆矩阵</h2><p><strong>定义（逆矩阵）</strong> 设矩阵 $A$ 为 $n$ 阶方阵，存在 $n$ 阶方阵 $B$ ，使得 $AB=BA=E$ ，那么，称矩阵 $B$ 为 $A$ 的逆矩阵，记作： $A^{-1}$ 。</p><blockquote><p>注意：不要写成 $\displaystyle \frac{1}{A} $ 样的形式，这样的表示是错误的。 $A^{-1}$ 表示的是逆矩阵，而不是矩阵 $A$ 的负一次方。</p></blockquote><p>结论：</p><ol><li>未必所有方阵均可逆；</li><li>如果矩阵 $A$ 可逆，那么逆矩阵一定唯一。</li></ol><h2 id="4-4-逆矩阵的判定"><a href="#4-4-逆矩阵的判定" class="headerlink" title="4.4 逆矩阵的判定"></a>4.4 逆矩阵的判定</h2><p>奇异矩阵和非奇异矩阵：</p><ul><li>如果矩阵 $A$ 满足 $|A|\ne 0$ ，那么矩阵 $A$ 称为非奇异矩阵、非退化矩阵、满秩矩阵；</li><li>如果矩阵 $A$ 满足 $|A|= 0$ ，那么矩阵 $A$ 称为奇异矩阵、退化矩阵、非满秩矩阵。</li></ul><p><strong>定理</strong>：矩阵 $A$ 可逆的<strong>充分必要条件</strong>是： $|A|\ne 0$ ，此时， $\displaystyle A^{-1}=\frac{1}{|A|} A^{\ast }$ 。</p><p><strong>推论</strong>：设 $A,B$ 都为 $n$ 阶方阵，如果 $AB=E\quad(BA=E)$ ，那么 $A$ 可逆，且 $A^{-1}=B$ 。♨️♨️♨️♨️♨️♨️</p><h2 id="4-5-逆矩阵的求法"><a href="#4-5-逆矩阵的求法" class="headerlink" title="4.5 逆矩阵的求法"></a>4.5 逆矩阵的求法</h2><p>方法</p><ol><li><p>方法一：伴随矩阵法。</p><p> ​    （上面的内容已经证明过了）</p></li><li><p>方法二：初等变换法。</p></li></ol><h2 id="4-5-逆矩阵的性质"><a href="#4-5-逆矩阵的性质" class="headerlink" title="4.5 逆矩阵的性质"></a>4.5 逆矩阵的性质</h2><p><strong>性质 4</strong>：如果矩阵 $A$ 可逆，那么 $A^{-1}$ 也可逆，并且 $(A^{-1} )^{-1} $ 。</p><p><strong>性质 5</strong>：如果矩阵 $A,B$ 均可逆，那么 $AB$ 可逆，并且 $(AB)^{-1}=B^{-1} A ^{-1} $ 。</p><p><strong>性质 6</strong>：如果矩阵 $A$ 可逆，那么 $A^{T} $ 可逆，并且 $(A^{T} )^{-1}=(A^{-1} )^{T} $ 。</p><p><strong>性质 7</strong>：如果矩阵 $A$ 可逆，那么 $\displaystyle |A^{-1}| = |A|^{-1} = \frac{1}{|A|} $ 。</p><p><strong>性质 8</strong>：如果矩阵 $A$ 可逆，那么 $A^{\ast } $ 也可逆，并且 $\displaystyle (A^{\ast } )^{-1} = \frac{1}{|A|}A$ 。</p><h2 id="2-5-分块矩阵"><a href="#2-5-分块矩阵" class="headerlink" title="2.5 分块矩阵"></a>2.5 分块矩阵</h2><p>将一个高阶的矩阵进行分块（注意：分块的时候要按整行或者整列进行切割）</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 2 & 3 \vdots& 4\\\dots &\dots &\dots \vdots&\dots \\ 5 &  6& 7 \vdots&8 \\ 9 &  10& 11 \vdots& 12\\ 13 &  14&  15\vdots&16\end{bmatrix}=\begin{bmatrix} A_{11} & A_{12}\\ A_{21} &A_{22}\end{bmatrix}</script><p><strong>标准形</strong>： </p><script type="math/tex; mode=display">\begin{bmatrix} 1 &  &  &  &  & \\  &  \ddots &  &  &  & \\  &  & 1 &  &  & \\  &  &  & 0 &  & \\  &  &  &  & \ddots  & \\  &  &  &  &  &0\end{bmatrix}_{m\times n} =\begin{bmatrix} E & 0\\ 0 &0\end{bmatrix}</script><p>分块矩阵的运算与一般矩阵的运算基本相同。</p><p>分块矩阵的转置：</p><script type="math/tex; mode=display">\begin{bmatrix} A_{11} & A_{12}\\ A_{21} &A_{22}\end{bmatrix}^{T}= \begin{bmatrix} A_{11}^{T} & A_{21}^{T}\\ A_{12}^{T} &A_{22}^{T}\end{bmatrix}</script><hr><p>例题：设分块矩阵 $\displaystyle H=\begin{bmatrix} A_{m\times m}  &amp; C_{m\times n}\\  0&amp;B_{n\times n}\end{bmatrix}$ ， $A,B$ 是可逆矩阵，求证： $|H|=|A|\cdot |B|$ 。</p><p>证明：使用拉普拉斯定理得：</p><script type="math/tex; mode=display">\begin{bmatrix} A_{m\times m} & C_{m\times n}\\  0&B_{n\times n}\end{bmatrix}=A\cdot (-1)^{m+m}\cdot B=AB</script><p>因此，可以得到：</p><script type="math/tex; mode=display">|H|=|A|\cdot|B|</script><h1 id="六、初等变换和初等矩阵"><a href="#六、初等变换和初等矩阵" class="headerlink" title="六、初等变换和初等矩阵"></a>六、初等变换和初等矩阵</h1><h2 id="6-1-初等变换"><a href="#6-1-初等变换" class="headerlink" title="6.1 初等变换"></a>6.1 初等变换</h2><p>初等行变换和初等列变换：</p><ol><li>交换矩阵得某两行（列）元素。</li><li>某一行（列）乘以 $k(k\ne 0)$ 。</li><li>某一行（列）的 $k$ 倍加到另一行（列）上去。</li></ol><script type="math/tex; mode=display">[\dots ]\to [\dots ]\to [\dots ]</script><blockquote><p>注意：初等变换后的矩阵与原矩阵不一定相等，这是一种等效变换，但是不是相等变换。</p><p>注意：<strong>初等变换是一种可逆变换</strong>。</p></blockquote><p><strong>定理</strong>：任何矩阵可以通过<strong>初等变换</strong>化为标准形。</p><h2 id="6-2-等价"><a href="#6-2-等价" class="headerlink" title="6.2 等价"></a>6.2 等价</h2><p><strong>定义</strong>：矩阵 $A$ 经过初等变换得到矩阵 $B$ ，那么称 $A,B$ 是等价的，记作 $A\cong B $ 。</p><p><strong>性质</strong>：</p><ol><li><strong>反身性</strong>： $A\cong A$ ；</li><li><strong>对称性</strong>：已知 $A\cong B $ 。那么 $B\cong A$ ；</li><li><strong>传递性</strong>：已知 $A\cong B,B\cong C$ ，那么 $A\cong C$ 。</li></ol><h2 id="6-3-初等方阵"><a href="#6-3-初等方阵" class="headerlink" title="6.3 初等方阵"></a>6.3 初等方阵</h2><p><strong>定义</strong>：对一个 $n$ 阶的单位矩阵做一次初等变换，得到的矩阵称为<strong>初等方阵</strong>。</p><blockquote><p>初等方阵均可逆。其逆矩阵也是初等方阵。初等方阵的转置矩阵也是初等矩阵。</p></blockquote><p><strong>定理</strong>：设 $A$ 是任意一个矩阵，并且存在一个进行第 $i$ 种初等变换得到的初等矩阵，初等矩阵<strong>左乘</strong>矩阵 $A$ ，相当于对矩阵 $A$ 实施了同种的第 $i$ 种初等行变换。如果是初等矩阵<strong>右乘</strong>矩阵 $A$ ，相当于对 $A$ 实施了同种的第 $i$ 种初等行变换。</p><p><strong>初等变换的作用</strong>：——左行右列——</p><p><code>E(...)A = B</code> ，注意，<strong>这里是 <code>=</code> 号。我们在之前的学习中知道，初等变换后的矩阵与原矩阵，一般不相等，因此用 <code>→</code> 表示，但是，有时为了方便计算和证明，我们需要进行 <code>=</code> 的使用，那么，这时候就可以用左乘右乘，来建立一种相等的关系</strong>。</p><p><strong>定义 3</strong>：对于任意的矩阵 $A$ ，存在初等矩阵 $P_{1},P_{2},\dots ,P_{s}$ 和初等矩阵 $Q_{1},Q_{2},\dots ,Q_{t}$ ，使得 $P_{1}P_{2}\dots P_{s}AQ_{1}Q_{2}\dots Q_{t}$ 为标准形。</p><ul><li>解释：矩阵 $A$ 通过初等变换化为标准形，那么，在初等变换的过程中，可能有行变换（左乘），可能有列变换（右乘），那就相当于左乘和右乘若干矩阵。</li></ul><p><strong>推论 1</strong>：已知矩阵 $A,B$ 是等价的，那么存在可逆矩阵 $P,Q$ ，使得 $PAQ=B$ 。</p><ul><li>解释：因为 $A,B$ 是等价的，就是说 $A$ 可以通过若干次初等变换，得到矩阵 $B$ ，即<strong>相当于左乘和右乘对应的初等矩阵</strong>。此外，初等矩阵是可逆矩阵，那么初等矩阵的乘积也是可逆矩阵，将所有左乘的初等矩阵相乘，得到 $P$ ，右乘矩阵 $Q$ 同理，最终能得到 $PAQ=B$ 。</li></ul><p><strong>定义 4</strong>：已知矩阵 $A$ 是可逆矩阵，那么 $A$ 的标准形为单位矩阵 $E$ 。（ $\Leftrightarrow $ ）</p><ul><li>必要性：</li><li>充分性：</li></ul><p><strong>定义 5</strong>：矩阵 $A$ 是可逆矩阵 $\Leftrightarrow $  $A=P_{1}P_{2}\cdots P_{s}$ 。</p><h2 id="6-4-初等变换法求逆阵"><a href="#6-4-初等变换法求逆阵" class="headerlink" title="6.4 初等变换法求逆阵"></a>6.4 初等变换法求逆阵</h2><p>设矩阵 $A$ 可逆，那么 $A^{-1}$ 也是可逆的。所以，可以把 $A^{-1}$ 表示成：</p><script type="math/tex; mode=display">A^{-1}=Q_{1}Q_{2}\dots Q_{t}</script><p>上式同时右乘矩阵 $A$ 得：</p><script type="math/tex; mode=display">A^{-1}A=Q_{1}Q_{2}\dots Q_{t}A=E</script><p>而根据前面的学习，我们知道：$Q_{1}Q_{2}\dots Q_{t}E=A^{-1}$ 。</p><p>最终得到如下两个式子：</p><script type="math/tex; mode=display">\begin{align}& Q_{1}Q_{2}\dots Q_{t}A=E  &(1)\\& Q_{1}Q_{2}\dots Q_{t}E=A^{-1} &(1)\\\end{align}</script><p>式子 (1) 相当于将 $A$ 进行 $t$ 得初等行变换，最终化为单位矩阵 $E$ ，而单位矩阵 $E$ 进行<strong>一样</strong>的初等行变换，那么最终会化为 $A^{-1}$ 。</p><p>上述求解<strong>逆矩阵</strong>的方法，被称为<strong>初等行变换法</strong>，构造为 $\begin{bmatrix} A &amp; \vdots  &amp;E\end{bmatrix}$ ，经过初等行变换得到 $\begin{bmatrix} E &amp; \vdots  &amp;A^{-1} \end{bmatrix}$ 。（只做行变换，不能做列变换）</p><blockquote><p>同样的，还存在<strong>初等列变换</strong>求解逆矩阵，与行变换类似。构造的形式是 $\begin{bmatrix}A \\\dots  \\E\end{bmatrix}\to \begin{bmatrix}E \\\dots  \\A^{-1} \end{bmatrix}$ 。</p></blockquote><h1 id="七、矩阵的秩"><a href="#七、矩阵的秩" class="headerlink" title="七、矩阵的秩"></a>七、矩阵的秩</h1><h2 id="7-1-秩的定义"><a href="#7-1-秩的定义" class="headerlink" title="7.1 秩的定义"></a>7.1 秩的定义</h2><p><strong>定义（ $k$ 阶子式）</strong>：对于给定的矩阵 $A$ ，任取 $k$ 行 $k$ 列，<strong>组成的行列式</strong>，称为 $k$ 阶子式。</p><p>非零子式的最高阶数，就称为<strong>矩阵的秩</strong>，记作 $R(A)$ 。</p><hr><p>那么，矩阵的秩有什么含义吗？</p><p><font color='red'>行阶梯矩阵</font> 是指满足下面两个条件的矩阵：</p><ol><li>如果有零行（元素全为零的行），则零行位于非零行的下方；</li><li>非零行的首个非零元素（亦称为基准或主元素），前面零元的个数从上往下依次严格增加。</li></ol><p>当行阶梯矩阵进一步满足：非零行的首非零元均为 1 ，且所在列的其余元素均为 0 ，则称为 <font color='red'>最简行阶梯矩阵</font>（或称<font color='red'>行最简形</font>） 。</p><p><strong>矩阵的秩就是表示行阶梯矩阵非零行的个数</strong>。</p><p><strong>满秩</strong>：行阶梯矩阵没有非零行，即非零子式的最高阶数等于矩阵的阶数（行数、列数中的较小值）。</p><h2 id="7-2-秩的性质"><a href="#7-2-秩的性质" class="headerlink" title="7.2 秩的性质"></a>7.2 秩的性质</h2><p><strong>性质 1</strong>：已知矩阵 $A$ 是 $m\times n$ 矩阵，那么 $0\le R(A)\le \mathrm{min} \left \{ m,n \right \} $ 。</p><ul><li>行满秩： $R(A)=m$ 取所有行，行满秩；</li><li>列满秩： $R(A)=n$ 取所有列，列满秩；</li><li>行满秩与列满秩，都是满秩。</li><li>如果 $R(A)&lt; \mathrm{min} \left \{ m,n \right \} $ ，那么就称为<strong>降秩</strong>。</li><li>$A$ 是方阵，且 $A$ 是满秩 $\Leftrightarrow $ $A$ 是可逆矩阵  $\Leftrightarrow $  $|A|\ne 0$ 。</li></ul><p><strong>定理 1</strong>： $R(A)=r$  $\Leftrightarrow $ 有一个 $r$ 阶子式不为 0 ，所有的 $r+1$ 阶子式全为 0 .</p><p><strong>性质 2</strong>： $R(A)=R(A^{T})$ 。</p><p><strong>性质 3</strong>：$R(A)=0\iff A=O$ 。</p><p><strong>性质 4</strong>：若 $A\cong B$ ，则 $\displaystyle R(A) = R(B)$ 。</p><p><strong>性质 5</strong>：$\displaystyle R\begin{bmatrix}A &amp; O\\O &amp; B\end{bmatrix} = R(A) +R(B)$ 。</p><p><strong>性质 6</strong>：$\displaystyle R(A\pm B)\le R(A)+R(B)$ 。</p><ul><li>证明：<script type="math/tex; mode=display">  \begin{align}\displaystyle \begin{bmatrix} A & O\\ O &B\end{bmatrix}\cong  \displaystyle \begin{bmatrix} A & O\\ A &B\end{bmatrix}\cong  \displaystyle \begin{bmatrix} A & A\\ A &A+B\end{bmatrix}\end{align}</script>  ​    所以：<script type="math/tex; mode=display">  \displaystyle R(A)+R(B) = R\begin{bmatrix} A & A\\ A &A+B\end{bmatrix}\ge R(A+B)</script>  ​    同理可证：<script type="math/tex; mode=display">  \displaystyle R(A)+R(B)\ge R(A- B)</script></li></ul><p><strong>性质 7</strong>：${\color{Red} \displaystyle \text{max}\left \{ R(A),R(B) \right \} \le R(A,B)\le R(A)+R(B)} $ 。</p><p><strong>性质 8</strong>：若 $A$ 为 $n$ 阶方阵，则 $\displaystyle R(A)=n\Longleftrightarrow A $ 是可逆矩阵。</p><p><strong>性质 9</strong>：$\displaystyle R(AB)\le\text{min} \left \{ R(A),R(B) \right \} $ （<strong>乘法矩阵的秩在减小，只有都是满秩才取等</strong>）。</p><p><strong>性质 10</strong>：若 $P,Q$ 可逆，则 $\displaystyle R(A) = R(PA)=R(AQ)=R(PAQ)$ （可逆矩阵不影响矩阵的秩，可逆矩阵一定是满秩）；</p><p><strong>性质 11</strong>：若 $A,B$ 均为 $n$ 阶方阵，则 $\displaystyle R(AB)\ge R(A)+R(B)-n$ 。</p><p> （ $\displaystyle R(A)+R(B)-n\le R(AB)\le \text{min}\left \{ R(A),R(B) \right \} $ ，上式被称为<font color='red'>西尔维斯特不等式</font>）。</p><p><strong>性质 12</strong>：<strong><code>Frobenius</code></strong>不等式： $\displaystyle R(ABC)\ge R(AB)+R(BC)-R(B)$ ；</p><p><strong>性质 13</strong>：$\displaystyle R(A_{m\times n} )=n\Longleftrightarrow \text{齐次方程组}  Ax=0 \text{只有零解}$ 。</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 行列式【线性代数】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/1_%E8%A1%8C%E5%88%97%E5%BC%8F.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/1_%E8%A1%8C%E5%88%97%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-行列式【线性代数】"><a href="#第一章-行列式【线性代数】" class="headerlink" title="第一章 行列式【线性代数】"></a>第一章 行列式【线性代数】</h1><h1 id="一、行列式的定义"><a href="#一、行列式的定义" class="headerlink" title="一、行列式的定义"></a>一、行列式的定义</h1><h2 id="1-1-解方程组"><a href="#1-1-解方程组" class="headerlink" title="1.1 解方程组"></a>1.1 解方程组</h2><p>假设有一个二元一次方程组：$\displaystyle\left\{\begin{matrix} 5x &amp; + &amp; 6y &amp; = &amp; 7 \\ 9x &amp; + &amp; 4y &amp; = &amp; 3\end{matrix}\right.$ ，按照解二元一次方程组的形式，可以得到如下结果：</p><script type="math/tex; mode=display">\left\{\begin{matrix} x & = & \displaystyle \frac{7\times 4-6\times 3}{5\times 4-6\times 9} \\ y & = &\displaystyle \frac{3\times 5-7\times 9}{5\times 4-6\times 9} \end{matrix}\right.</script><p>观察上面的式子可以得到：分母的形式和大小完全一致，并且分子的形式非常类似。因此，我们在这里定义一种新的运算： $\displaystyle \begin{vmatrix} a &amp; b\\ c &amp;d\end{vmatrix}=ad-bc$ ，那么上面的 $x,y$ 就能得到：</p><script type="math/tex; mode=display">\left\{\begin{matrix}x = \displaystyle \frac{7\times 4-6\times 3}{5\times 4-6\times 9}= \displaystyle \frac{\begin{vmatrix} 7 & 6\\  3&4\end{vmatrix} }{\begin{vmatrix} 5 & 6\\ 9& 4\end{vmatrix} } \\y = \displaystyle \displaystyle \frac{3\times 5-7\times 9}{5\times 4-6\times 9}= \displaystyle \frac{\begin{vmatrix} 5 & 7\\  9&3\end{vmatrix} }{\begin{vmatrix} 5 & 6\\ 9& 4\end{vmatrix} } \\\end{matrix}\right.</script><h2 id="1-2-二阶行列式"><a href="#1-2-二阶行列式" class="headerlink" title="1.2 二阶行列式"></a>1.2 二阶行列式</h2><p>我们由<a href="#1-1-解方程组">1.1 解方程组</a>中的新运算进行推广，得出一般的二阶行列式。</p><p><strong>二阶行列式</strong>：由<strong>两行两列</strong>共四个元素组成，并且其行列式的表示方式为：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11}  & a_{12}\\ a_{21} & a_{22}\end{vmatrix}</script><p>行列式的元素用 $a_{ij}$ 表示，其中，$i$ 表示为行标； $j$ 表示为列标。<strong>行列式的值</strong>的计算公式为：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11}  & a_{12}\\ a_{21} & a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}</script><p><strong>主对角线</strong>：从<strong>左上角</strong>到<strong>右下角</strong>画一条斜线，落在斜线上的元素构成<strong>行列式的主对角线</strong>，即 $\displaystyle a_{ij} (i=j)$ ；</p><p><strong>次对角线</strong>：从<strong>右上角</strong>到<strong>左下角</strong>画一条线，落在斜线上的的元素构成<strong>行列式的次对角线</strong>。</p><h2 id="1-3-三阶行列式"><a href="#1-3-三阶行列式" class="headerlink" title="1.3 三阶行列式"></a>1.3 三阶行列式</h2><p>三阶行列式：</p><p><img src="https://imageshack.yuilexi.cn/University/线性代数/线性代数-宋浩版/三阶行列式的划线计算.png" alt="三阶行列式的划线计算"></p><h2 id="1-4-排列"><a href="#1-4-排列" class="headerlink" title="1.4 排列"></a>1.4 排列</h2><p><strong>排列</strong>：由 $1,2,\cdots,n$ 组成的一个<strong>有序</strong>数组，叫做 $n$ 级排序。例如：一个常见的三级排列为 $123,132,213,231,312,321$ 。</p><blockquote><p>一定要注意：<strong>有序</strong>。这个数列一定是连续的，不能缺数。例如： $3145$ 中，缺少 $2$ ，因此，这个数不是一个四级排列。</p><ul><li>$n$ 级排列，一共有 $n(n-1)\cdots 3\times2\times1=n!$ 种</li></ul></blockquote><p><strong>逆序</strong>：较大数排列在较小数的前面。</p><p><strong>逆序数</strong>：逆序的总数。例如：$\displaystyle M(4213) = 3+1=4$ （4后面有3个；2后面有1个）。</p><blockquote><p>数逆序数的方法：从第一个数开始，数后面有几个比它小的，并且将所有累和。</p><ul><li>偶排列：逆序数为偶数；</li><li>奇排列：逆序数为奇数。</li></ul></blockquote><p><strong>$N$级标准排列</strong>： $N(1,2,\cdots,n)=0$ 。</p><p>$\displaystyle N(n(n-1)\cdots3\times2\times1)=n-1+n-2+\cdots+2+1 = \frac{n(n-1)}{2} $ 。</p><p><strong>对换</strong>：交换两个数。</p><p><strong>定理 1.1.1</strong> 进行一次对换后，排列的奇偶性就会改变。</p><p><strong>定理 1.1.2</strong>  $n$ 级排列中，奇排列与偶排列个数相等。</p><h2 id="1-5-n-阶行列式"><a href="#1-5-n-阶行列式" class="headerlink" title="1.5 $n$ 阶行列式"></a>1.5 $n$ 阶行列式</h2><p>如果在高阶行列式中，使画线的方式进行计算，会比较麻烦，画的线会非常多，因此，需要找到一种计算行列数的基本方法公式。</p><p>在三阶行列式。计算方法如下：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \begin{vmatrix} a_{11} & a_{12} & a_{13}\\ a_{21} & a_{22} & a_{23}\\ a_{31} & a_{32} & a_{33}\end{vmatrix} = & a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}\\&-a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}\end{align}</script><p>行标按标准排序，按照<strong>列标</strong>取标准排得：</p><script type="math/tex; mode=display">\begin{align}\displaystyle & 123(0),231(2),312(2)& \text{偶排列} \\& 321(3),213(1),132(1)& \text{奇排列}\end{align}</script><p><strong>$n$阶行列式第一定义（按行展开）</strong> 行标按标准排序，列标取排列得所有可能，从不同行不同列取出元素相乘，符号由列标得奇（负）偶（正）性决定。</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix} = \displaystyle \sum_{j_{1}j_{2}\cdots j_{n}} (-1)^{N(j_{1}j_{2}\cdots j_{n})}a_{1j_{1}} a_{2j_{2}}\cdots a_{nj_{n}}</script><blockquote><p>主对角线、次对角线定义一致。特别的，一阶行列式的大小等于其本身。</p></blockquote><hr><p><strong>下三角行列式</strong>：<strong>下三角行列式的值等于主对角线元素相乘</strong></p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & 0 & \dots  &0 \\ a_{21} & a_{22} & \dots &0 \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix} = a_{11}a_{22}\dots a_{nn}</script><p>解答：根据前面的知识我们知道，行列式的计算公式中的每一项，都是在每一行中取一个值，并所有值得列标构成一个排列，因此，相当于每一行或者每一列最多取一个值。此时，规定行标按标准排列，因此，列标取 $1,2,\dots,n$ 时，该项不为零；其余情况下，项都为零。 </p><p><img src="https://imageshack.yuilexi.cn/University/线性代数/线性代数-宋浩版/下三角行列式的计算.png" alt="下三角行列式的计算"></p><hr><p><strong>上三角行列式</strong>：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots   &a_{1n} \\0 & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ 0 & 0 & \dots &a_{nn}\end{vmatrix} = a_{11}a_{22}\dots a_{nn}</script><p><strong>对角型行列式</strong>：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & 0 & \dots   &0 \\0 & a_{22} & \dots &0 \\ \vdots  & \vdots & \ddots  & \vdots\\ 0 & 0 & \dots &a_{nn}\end{vmatrix} = a_{11}a_{22}\dots a_{nn}</script><p><strong>右下三角矩阵</strong>：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} 0 & \dots & 0   &a_{1n} \\0 & \dots & a_{2(n-1)} &a_{2n} \\ \vdots  & \vdots & \dots & \vdots\\a_{n1} & \dots & a_{n(n-1)} &a_{nn}\end{vmatrix} = (-1)^{\frac{n(n-1)}{2} } a_{1n}a_{2(n-1)}\dots a_{n1}</script><p><strong>$n$阶行列式第二定义（按列展开）</strong> 列标按标准排序，行标取排列得所有可能，从不同行不同列取出元素相乘，符号由列标得奇（负）偶（正）性决定。</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix} = \displaystyle \sum_{i_{1}i_{2}\cdots i_{n}} (-1)^{N(i_{1}i_{2}\cdots i_{n})}a_{i_{1}1} a_{i_{2}2}\cdots a_{i_{n}n}</script><p><strong>$n$阶行列式第三定义（不按行列展开）</strong> 列标按标准排序，行标取排列得所有可能，从不同行不同列取出元素相乘，符号由列标得奇（负）偶（正）性决定。</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix} = \displaystyle \sum_{i_{1}i_{2}\cdots i_{n},j_{1}j_{2}\cdots j_{n}} (-1)^{N(i_{1}i_{2}\cdots i_{n})+N(j_{1}j_{2}\cdots j_{n})}a_{i_{1}j_{1}} a_{i_{2}j_{2}}\cdots a_{i_{n}j_{n}}</script><h1 id="二、行列式的性质"><a href="#二、行列式的性质" class="headerlink" title="二、行列式的性质"></a>二、行列式的性质</h1><h2 id="2-1-转置"><a href="#2-1-转置" class="headerlink" title="2.1 转置"></a>2.1 转置</h2><p>假设有行列式</p><script type="math/tex; mode=display">\displaystyle D=\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix}</script><p>那么，行列式的转置行列式为</p><script type="math/tex; mode=display">\displaystyle D^{T}=\displaystyle \begin{vmatrix} a_{11} & a_{21} & \dots  &a_{n1} \\ a_{12} & a_{22} & \dots &a_{n2} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{1n} & a_{2n} & \dots &a_{nn}\end{vmatrix}</script><blockquote><p> 相当于将对应的行换成列，对应的列换成行。（沿主对角线进行镜像翻转）。</p></blockquote><h2 id="2-2-性质"><a href="#2-2-性质" class="headerlink" title="2.2 性质"></a>2.2 性质</h2><blockquote><p>（<strong>行列式的性质，对行成立，那么对列也成立</strong>）</p></blockquote><ol><li><p>行列式的两次转置等于其本身，即 $\displaystyle (D^{T} )^{T} =D$ 。</p></li><li><p><strong>行列式转置后，其值的大小不变</strong>，即 $D^{T} = D$ 。</p><p> 证明：转置前的行列式，按第一定义展开；转置后的行列式，按第二定义展开。两种展开后对应的每一项的结果都是相等。</p></li><li><p><strong>行列式中，交换两行（列）的位置，行列式的值变号</strong>。</p><p> 证明：交行两行（列），相当于行列式展开的每一项，对应的<strong>行（列）排序</strong>中的某两个数，进行一次<strong>对换</strong>，因此，所有项的符号都会改变，最终会使行列式的结果变号。</p><p> 推论：</p><ol><li>行列式有两行或者两列对应相等，那么行列式的值等于零。</li></ol></li><li><p><strong>行列式中的某一行（列）都乘以 $K$ ，那么行列式的值变为原来的 $K$ 倍</strong>。</p><p> 证明：由<strong>行列式的第一、二、三定义</strong>可知，在乘以 $K$ 倍的一行（列），无论取那个元素，都相当于对应的展开项乘以 $K$ 倍，因此，每一个展开项就可以提取一个 $K$ 倍的系数。</p><p> 推论：<strong>某一行都有公因子 $K$ 那么可以将 $K$ 提到行列式外</strong>。</p><script type="math/tex; mode=display"> \displaystyle \displaystyle \begin{vmatrix} Ka_{11} & Ka_{12} & \dots  &Ka_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix}=K\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix}</script></li><li><p><strong>两行（列）对应成比例，那么行列式的值为 0</strong> 。</p><p> 证明：由<strong>推论4-1</strong>和<strong>推论3-1</strong>可以推导得到。</p><p> 推论：某一行（列）全为零，行列式为 0 。</p></li><li><p>行列式的某一行（列）是两数之和，那么该行列式可以表示为两个行列式相加。（将两数和的那一行分开，其余行保持不变）</p><p> 例如：</p><script type="math/tex; mode=display"> \begin{vmatrix} 1 & 2 & 3\\ 7+8 & 2+3 & 9+10\\ 8 & 8 &9\end{vmatrix} = \begin{vmatrix} 1 & 2 & 3\\ 7 & 2 & 9\\ 8 & 8 &9\end{vmatrix} +\begin{vmatrix} 1 & 2 & 3\\ 8 & 3 & 10\\ 8 & 8 &9\end{vmatrix}</script><p> 例题：</p><script type="math/tex; mode=display"> \begin{vmatrix} b+c & c+a & a+b\\a+b & b+c & c+a\\ c+a & a+b &b+c\end{vmatrix}</script></li><li><p><strong>行列式乘以一个数，并且加到另一行上去，那么行列式的值不变</strong>。</p><p> 证明：由<strong>定理6</strong>和<strong>定理5</strong>推到可以得到。</p></li></ol><blockquote><p><strong>两行对应成比例、某一行为0、两行相等</strong>，那么行列式为0。但是，行列式为0，不一定满足<strong>上述三种的其一</strong>。</p></blockquote><hr><p>例题：（考察定理7） 求解行列式 $\displaystyle D = \begin{vmatrix}1  &amp;  2&amp; 0 &amp; 1\\ 2 &amp; 3 &amp; 10 &amp; 0\\ 0 &amp; 3 &amp; 5 &amp; 18\\ 5 &amp; 10 &amp; 15 &amp;4\end{vmatrix}$ 。</p><p>解：</p><script type="math/tex; mode=display">\begin{align}\displaystyle D & = \begin{vmatrix}1  &  2& 0 & 1\\ 2 & 3 & 10 & 0\\ 0 & 3 & 5 & 18\\ 5 & 10 & 15 &4\end{vmatrix}  = \begin{vmatrix}1  &  2& 0 & 1\\ 0 & -1 & 10 & -2\\ 0 & 3 & 5 & 18\\ 0 & 0 & 15 &-1\end{vmatrix}\\ & = \begin{vmatrix}1  &  2& 0 & 1\\ 0 & -1 & 10 & -2\\ 0 & 0 & 35 & 12\\ 0 & 0 & 15 &-1\end{vmatrix}  = \begin{vmatrix}1  &  2& 0 & 1\\ 0 & -1 & 10 & -2\\ 0 & 0 & 35 & 12\\ 0 & 0 & 0 &-\frac{43}{7} \end{vmatrix}\\ & = 215\end{align}</script><p>注：上三角行列式的值等于对角线乘积。</p><h1 id="三、行列式展开"><a href="#三、行列式展开" class="headerlink" title="三、行列式展开"></a>三、行列式展开</h1><h2 id="3-1-余子式"><a href="#3-1-余子式" class="headerlink" title="3.1 余子式"></a>3.1 余子式</h2><p>在行列式中，选取某个元素 $a_{ij}$ ，并且去掉该元素所在行列的所有元素，其余元素保持不变，形成的新的行列式称为<strong>$a_{ij}$的余子式</strong>，记作 $M_{ij}$ 。</p><p><strong>代数余子式</strong>：在余子式的基础上，增加一个系数，并且用 $A_{ij}$ 表示，其关系为 $A_{ij}  = (-1)^{i+j} M_{ij}$ 。</p><h2 id="3-2-按行（列）展开"><a href="#3-2-按行（列）展开" class="headerlink" title="3.2 按行（列）展开"></a>3.2 按行（列）展开</h2><p><strong>定理 （按行/列展开）</strong> 行列式按某一行展开，相当于该行<strong>对应元素</strong>与其<strong>代数余子式</strong>的乘积，并且所有项累和。公式表示为：</p><script type="math/tex; mode=display">D = a_{i1} A_{i1}+a_{i2} A_{i2} +\dots +a_{in} A_{in}</script><p>按列展开的公式为：</p><script type="math/tex; mode=display">D = a_{1i} A_{1i}+a_{2i} A_{2i} +\dots +a_{ni} A_{ni}</script><p>按行（列）展开的作用：</p><ol><li>可以是当前行列式降阶；</li><li>选取 0 元素多的行或者列展开，计算量较小</li></ol><h2 id="3-3-异乘变零定理"><a href="#3-3-异乘变零定理" class="headerlink" title="3.3 异乘变零定理"></a>3.3 异乘变零定理</h2><p><strong>定理（异乘变零）</strong> ：<strong>某行元素与另一行元素的代数余子式的乘积之和，等于零</strong>。</p><p>证明：</p><p>设一个四阶行列式 $\displaystyle D_{1}=\begin{vmatrix} 1 &amp; 1 &amp; 2 &amp; 3\\ 0 &amp; 0 &amp; 8 &amp; 9\\ 2 &amp; 5 &amp; 5 &amp; 4\\ 9 &amp; 9 &amp; 9 &amp;10\end{vmatrix}$ ，并且 $A_{11},A_{12},A_{13},A_{14}$ 是第一行的代数余子式，并且用第四行的元素乘以第一行的代数余子式，得到的式子如下：</p><script type="math/tex; mode=display">9A_{11}+9A_{12}+9A_{13}+10A_{14}</script><p>那么这时候，设行列式 $\displaystyle D_{2}=\begin{vmatrix} 9 &amp; 9 &amp; 9 &amp; 10\\ 0 &amp; 0 &amp; 8 &amp; 9\\ 2 &amp; 5 &amp; 5 &amp; 4\\ 9 &amp; 9 &amp; 9 &amp;10\end{vmatrix}$ ，并且观察可以得到，行列式 $D_{2}$ 第一行的代数余子式与 $D_{1}$ 第一行的代数余子式，分别对应相等。接下来行列式 $D_{2}$ 按照第一行展开，得到：</p><script type="math/tex; mode=display">\displaystyle D_{2}=\begin{vmatrix} 9 & 9 & 9 & 10\\ 0 & 0 & 8 & 9\\ 2 & 5 & 5 & 4\\ 9 & 9 & 9 &10\end{vmatrix}=9A_{11}+9A_{12}+9A_{13}+10A_{14}</script><p>而根据<strong>行列式性质中的推论3-1</strong>可得， $D_{2}=0$ （有两行对应相等），因此，得到：</p><script type="math/tex; mode=display">9A_{11}+9A_{12}+9A_{13}+10A_{14}=0</script><p>至此，<strong>异乘变零</strong>定理证毕。</p><h2 id="3-4-拉普拉斯"><a href="#3-4-拉普拉斯" class="headerlink" title="3.4 拉普拉斯"></a>3.4 拉普拉斯</h2><p><strong>$k$阶子式</strong> ：设行列式 $\begin{vmatrix}1  &amp; 2 &amp; 3 &amp; 4\\ 1 &amp; 1 &amp; 2 &amp; 5\\ 1 &amp; 1 &amp; 0 &amp; 8\\ 9 &amp; 9 &amp; 9 &amp;10\end{vmatrix}$ ，并且取第一二行，第一二列，那么，行列式 $\begin{vmatrix}1  &amp; 2 \\ 1 &amp; 1 \\\end{vmatrix}$ 就称为 <strong>2阶子式</strong>。形如上述方式，取 $k$ 个行列，那么得到的就称为<strong>$k$阶子式</strong>。</p><p><strong>$k$阶余子式</strong>：去掉 $k$ 个行与列的所有元素，剩余的行列式就是<strong>余子式</strong>。</p><p><strong>$k$阶代数余子式</strong>：$\displaystyle A = (-1)^{\sum i +\sum j} M$ 。</p><p><strong>定理（拉普拉斯展开定理）</strong> 取定 $k$ 行，由 $k$ 行元素组成的所有 <strong>$k$ 阶子式</strong>与代数余子式乘积之和，等于该行列式的值。</p><h2 id="3-5-行列式相乘定理"><a href="#3-5-行列式相乘定理" class="headerlink" title="3.5 行列式相乘定理"></a>3.5 行列式相乘定理</h2><p><strong>必须是同阶行列式才能进行矩阵形式相乘</strong>。行列式相乘的规则与矩阵相乘的规则类似。</p><p>$A\times B=C$ 就是分别用 $A$ 的行元素乘以 $B$ 的列元素并相加，得到 $C$ 的元素。</p><h1 id="四、行列式的计算"><a href="#四、行列式的计算" class="headerlink" title="四、行列式的计算"></a>四、行列式的计算</h1><ol><li>方法一：化成上三角矩阵；</li><li>方法二：是用代数余子式降阶计算。</li></ol><h2 id="4-1-“爪”型或者三叉型"><a href="#4-1-“爪”型或者三叉型" class="headerlink" title="4.1 “爪”型或者三叉型"></a>4.1 “爪”型或者三叉型</h2><h2 id="4-2-范德蒙得行列式"><a href="#4-2-范德蒙得行列式" class="headerlink" title="4.2 范德蒙得行列式"></a>4.2 范德蒙得行列式</h2><p>形如下面形式的行列式，称为<strong>范德蒙得行列式</strong></p><script type="math/tex; mode=display">\begin{vmatrix} 1 & 1 & \cdots  & 1\\ x_{1}  & x_{2} & \dots  & x_{n}\\x_{1}^{2}   & x_{2}^{2}  & \dots  & x_{n}^{2} \\\vdots    & \vdots & \dots  & \vdots\\x_{1}^{n-2}   & x_{2}^{n-2} & \dots  & x_{n}^{n-2}\\x_{1}^{n-1}   & x_{2}^{n-1} & \dots  & x_{n}^{n-1}\end{vmatrix} = \displaystyle \prod_{1\le j<i\le n}(x_{i}-x_{j}  )</script><p>证明：将上述行列式进行变换，每一行的 $-x_{1}$ 倍加到下一行上去，得到</p><script type="math/tex; mode=display">\begin{vmatrix} 1 & 1 & \cdots  & 1\\0  & x_{2}-x_{1} & \dots  & x_{n}-x_{1}\\0   & x_{2}^{2}-x_{1}x_{2}  & \dots  & x_{n}^{2} -x_{1}x_{n}\\\vdots    & \vdots & \dots  & \vdots\\0   & x_{2}^{n-2}-x_{1}x_{2}^{n-3} & \dots  & x_{n}^{n-2}-x_{1}x_{n}^{n-3}\\0   & x_{2}^{n-1} -x_{1}x_{2}^{n-2}& \dots  & x_{n}^{n-1}-x_{1}x_{n}^{n-2}\end{vmatrix}</script><p>然后按照第一列展开得：（$n-1$阶行列式）</p><script type="math/tex; mode=display">\begin{vmatrix}x_{2}-x_{1} & \dots  & x_{n}-x_{1}\\x_{2}^{2}-x_{1}x_{2}  & \dots  & x_{n}^{2} -x_{1}x_{n}\\\vdots & \dots  & \vdots\\x_{2}^{n-2}-x_{1}x_{2}^{n-3} & \dots  & x_{n}^{n-2}-x_{1}x_{n}^{n-3}\\x_{2}^{n-1} -x_{1}x_{2}^{n-2}& \dots  & x_{n}^{n-1}-x_{1}x_{n}^{n-2}\end{vmatrix}</script><p>此时，将上述行列式提取公因子得：</p><script type="math/tex; mode=display">(x_{2}-x_{1})(x_{3}-x_{1})\cdots (x_{n}-x_{1})\begin{vmatrix} 1 & 1 & 1 & \dots  & 1\\ x_{2}& x_{3} & x_{4} & \dots & x_{n}\\ x_{2}^{2}  & x_{3}^{2} & x_{4}^{2} & \dots & x_{n}^{2}\\ \vdots  & \vdots & \vdots & \ddots & \vdots\\ x_{2}^{n-2}  & x_{3}^{n-2} & x_{4}^{n-2} & \dots &x_{n}^{n-2}\end{vmatrix}</script><p>这时候，观察后面的行列式，这依旧是一个范德蒙得行列式，但是它是 $n-1$ 阶的。然后重复前面的步骤，就能得到题目中的证理。</p><h2 id="4-3-反对称行列式"><a href="#4-3-反对称行列式" class="headerlink" title="4.3 反对称行列式"></a>4.3 反对称行列式</h2><p><strong>对称行列式</strong>：$a_{ij}=a_{ji}$</p><ol><li>主对角线元素没有要求；</li><li>沿对角线成对称位置的元素对应相等。</li></ol><p><strong>反对称行列式</strong> ： $a_{ij}=-a_{ji}$ 。</p><ol><li>主对角线元素全为 0 ；</li><li>沿对角线成对称位置的元素互为相反数。</li></ol><p><strong>定理</strong> 奇数阶的反对称行列式等于0。</p><h1 id="五、克莱姆法则"><a href="#五、克莱姆法则" class="headerlink" title="五、克莱姆法则"></a>五、克莱姆法则</h1><blockquote><p>只适用于方程的个数等于未知量的个数</p></blockquote><p>设三元一次方程组：</p><script type="math/tex; mode=display">\left\{\begin{matrix} x_{1}  & + &  x_{2}& + & x_{3} & = &1 \\  x_{1}& -&  x_{2}& + & 5x_{3} & = & 6\\  -x_{1}& + & x_{2} & + &6x_{3}  & = &9\end{matrix}\right.</script><p>满足：</p><ol><li>$n$ 个方程， $n$ 个未知量；</li><li>$D\ne 0$ ；</li><li>那么， $\displaystyle x_{j}  = \frac{D_{j} }{D} $ 。</li></ol><p>其中：</p><script type="math/tex; mode=display">\begin{align}&D = \begin{vmatrix} 1 & 1 & 1\\ 1 & -1 & 5\\ -1 & 1 &6\end{vmatrix}& D_{1} = \begin{vmatrix} 1 & 1 & 1\\ 6 & -1 & 5\\9 & 1 &6\end{vmatrix} \\& D_{2} = \begin{vmatrix} 1 & 1 & 1\\ 1 & 6 & 5\\-1 & 9 &6\end{vmatrix} &D_{3} = \begin{vmatrix} 1 & 1 & 1\\ 1 & -1 & 6\\-1 & 1 &9\end{vmatrix} \end{align}</script><blockquote><p>缺点：计算量很大，不推荐使用。比较适合计算机解题</p></blockquote><p><strong>定理 2</strong> 如果是一个齐次方程组，并且方程的个数等于未知量的个数，且 $D\ne0$ ，那么，该方程组只有零解。如果是一个齐次方程组，并且方程的个数等于未知量的个数，且 $D=0$ ，那么，该方程组有非零解。</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数-宋浩版</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%AE%8B%E6%B5%A9%E7%89%88.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%AE%8B%E6%B5%A9%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="一、行列式"><a href="#一、行列式" class="headerlink" title="一、行列式"></a>一、行列式</h1><h2 id="1-1-行列式的定义"><a href="#1-1-行列式的定义" class="headerlink" title="1.1 行列式的定义"></a>1.1 行列式的定义</h2><h3 id="1-1-1-解方程组"><a href="#1-1-1-解方程组" class="headerlink" title="1.1.1 解方程组"></a>1.1.1 解方程组</h3><p>假设有一个二元一次方程组：$\displaystyle\left\{\begin{matrix} 5x &amp; + &amp; 6y &amp; = &amp; 7 \\ 9x &amp; + &amp; 4y &amp; = &amp; 3\end{matrix}\right.$ ，按照解二元一次方程组的形式，可以得到如下结果：</p><script type="math/tex; mode=display">\left\{\begin{matrix} x & = & \frac{7\times 4-6\times 3}{5\times 4-6\times 9} \\ y & = &\frac{3\times 5-7\times 9}{5\times 4-6\times 9} \end{matrix}\right.</script><p>观察上面的式子可以得到：分母的形式和大小完全一致，并且分子的形式非常类似。</p><p>因此，我们在这里定义一种新的运算： $\displaystyle \begin{vmatrix} a &amp; b\\ c &amp;d\end{vmatrix}=ad-bc$ ，那么上面的 $x,y$ 就能得到：</p><script type="math/tex; mode=display">\left\{\begin{matrix} x & = & \frac{7\times 4-6\times 3}{5\times 4-6\times 9} =& \frac{\begin{vmatrix} 7 & 6\\ 3 &4\end{vmatrix}}{\begin{vmatrix} 5 & 6\\ 9 &4\end{vmatrix}} \\ y & = &\frac{3\times 5-7\times 9}{5\times 4-6\times 9} =&\frac{\begin{vmatrix} 5 & 7\\ 9 &3\end{vmatrix}}{\begin{vmatrix} 5 & 6\\ 9 &4\end{vmatrix}}\end{matrix}\right.</script><h3 id="1-1-2-二阶行列式"><a href="#1-1-2-二阶行列式" class="headerlink" title="1.1.2 二阶行列式"></a>1.1.2 二阶行列式</h3><p>我们由<a href="#1-1-解方程组">1.1 解方程组</a>中的新运算进行推广，得出一般的二阶行列式。</p><p>二阶行列式：由<strong>两行两列</strong>共四个元素组成，并且其行列式的表示方式为：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11}  & a_{12}\\ a_{21} & a_{22}\end{vmatrix}</script><p>行列式的元素用 $a_{ij}$ 表示，其中，$i$ 表示为行标； $j$ 表示为列标。<strong>行列式的值</strong>的计算公式为：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11}  & a_{12}\\ a_{21} & a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}</script><p><strong>主对角线</strong>：从<strong>左上角</strong>到<strong>右下角</strong>画一条斜线，落在斜线上的元素构成<strong>行列式的主对角线</strong>，即 $\displaystyle {a_{ij}|i=j}$ ；</p><p><strong>次对角线</strong>：从<strong>右上角</strong>到<strong>左下角</strong>画一条线，落在斜线上的的元素构成<strong>行列式的次对角线</strong>。</p><blockquote><p>$\displaystyle \begin{vmatrix} \text{爱}  &amp; \text{辈}\\ \text{子} &amp;\text{你}\end{vmatrix} = \text{爱你}-\text{辈子}$</p></blockquote><h3 id="1-1-3-三阶行列式"><a href="#1-1-3-三阶行列式" class="headerlink" title="1.1.3 三阶行列式"></a>1.1.3 三阶行列式</h3><p>三阶行列式：</p><p><img src="https://imageshack.yuilexi.cn/University/线性代数/线性代数-宋浩版/三阶行列式的划线计算.png" alt="三阶行列式的划线计算"></p><h3 id="1-1-4-排列"><a href="#1-1-4-排列" class="headerlink" title="1.1.4 排列"></a>1.1.4 排列</h3><p><strong>排列</strong>：由 $1,2,\cdots,n$ 组成的一个<strong>有序</strong>数组，叫做 $n$ 级排序。例如：一个常见的三级排列为 $123,132,213,231,312,321$ 。</p><blockquote><p>一定要注意：<strong>有序</strong>。这个数列一点是连续的，不能缺数。例如： $3145$ 中，缺少 $2$ ，因此，这个数不是一个四级排列。</p><ul><li>$n$ 级排列，一共有 $n(n-1)\cdots 3\times2\times1=n!$ 种</li></ul></blockquote><p><strong>逆序</strong>：较大数排列在较小数的前面。</p><p><strong>逆序数</strong>：逆序的总数。例如：$\displaystyle M(4213) = 3+1=4$ （4后面有3个；2后面有1个）。</p><blockquote><p>数逆序数的方法：从第一个数开始，数后面有几个比它小的，并且将所有累和。</p><ul><li>偶排列：逆序数为偶数；</li><li>奇排列：逆序数为奇数。</li></ul></blockquote><p><strong>$N$级标准排列</strong>： $N(1,2,\cdots,n)=0$ 。</p><p>$\displaystyle N(n(n-1)\cdots3\times2\times1)=n-1+n-2+\cdots+2+1 = \frac{n(n-1)}{2} $ 。</p><p><strong>对换</strong>：交换两个数。</p><p><strong>定理 1.1.1</strong> 进行一次对换后，排列的奇偶性就会改变。</p><p><strong>定理 1.1.2</strong>  $n$ 级排列中，奇排列与偶排列个数相等。</p><h3 id="1-1-5-n-阶行列式"><a href="#1-1-5-n-阶行列式" class="headerlink" title="1.1.5 $n$ 阶行列式"></a>1.1.5 $n$ 阶行列式</h3><p>如果在高阶行列式中，使画线的方式进行计算，会比较麻烦，画的线会非常多，因此，需要找到一种计算行列数的基本方法公式。</p><p>在三阶行列式。计算方法如下：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \begin{vmatrix} a_{11} & a_{12} & a_{13}\\ a_{21} & a_{22} & a_{23}\\ a_{31} & a_{32} & a_{33}\end{vmatrix} = & a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}\\&-a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}\end{align}</script><p>行标按标准排序，按照<strong>列标</strong>取标准排得：</p><script type="math/tex; mode=display">\begin{align}\displaystyle & 123(0),231(2),312(2)& \text{偶排列} \\& 321(3),213(1),132(1)& \text{奇排列}\end{align}</script><p><strong>$n$阶行列式第一定义（按行展开）</strong> 行标按标准排序，列标取排列得所有可能，从不同行不同列取出元素相乘，符号由列标得奇（负）偶（正）性决定。</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix} = \displaystyle \sum_{j_{1}j_{2}\cdots j_{n}} (-1)^{N(j_{1}j_{2}\cdots j_{n})}a_{1j_{1}} a_{2j_{2}}\cdots a_{nj_{n}}</script><blockquote><p>主对角线、次对角线定义一致。</p><p>特别的，一阶行列式的大小等于其本身。</p></blockquote><hr><p><strong>下三角行列式</strong>：<strong>下三角行列式的值等于主对角线元素相乘</strong></p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & 0 & \dots  &0 \\ a_{21} & a_{22} & \dots &0 \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix} = a_{11}a_{22}\dots a_{nn}</script><p>解答：根据前面的知识我们知道，行列式的计算公式中的每一项，都是在每一行中取一个值，并所有值得列标构成一个排列，因此，相当于每一行或者每一列最多取一个值。此时，规定行标按标准排列，因此，列标取 $1,2,\dots,n$ 时，该项不为零；其余情况下，项都为零。 </p><p><img src="https://imageshack.yuilexi.cn/University/线性代数/线性代数-宋浩版/下三角行列式的计算.png" alt="下三角行列式的计算"></p><p><strong>上三角行列式</strong>：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots   &a_{1n} \\0 & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ 0 & 0 & \dots &a_{nn}\end{vmatrix} = a_{11}a_{22}\dots a_{nn}</script><p><strong>对角型行列式</strong>：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & 0 & \dots   &0 \\0 & a_{22} & \dots &0 \\ \vdots  & \vdots & \ddots  & \vdots\\ 0 & 0 & \dots &a_{nn}\end{vmatrix} = a_{11}a_{22}\dots a_{nn}</script><p><strong>右下三角矩阵</strong>：</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} 0 & \dots & 0   &a_{1n} \\0 & \dots & a_{2(n-1)} &a_{2n} \\ \vdots  & \vdots & \dots & \vdots\\a_{n1} & \dots & a_{n(n-1)} &a_{nn}\end{vmatrix} = (-1)^{\frac{n(n-1)}{2} } a_{1n}a_{2(n-1)}\dots a_{n1}</script><p><strong>$n$阶行列式第二定义（按列展开）</strong> 列标按标准排序，行标取排列得所有可能，从不同行不同列取出元素相乘，符号由列标得奇（负）偶（正）性决定。</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix} = \displaystyle \sum_{i_{1}i_{2}\cdots i_{n}} (-1)^{N(i_{1}i_{2}\cdots i_{n})}a_{i_{1}1} a_{i_{2}2}\cdots a_{i_{n}n}</script><p><strong>$n$阶行列式第三定义（不按行列展开）</strong> 列标按标准排序，行标取排列得所有可能，从不同行不同列取出元素相乘，符号由列标得奇（负）偶（正）性决定。</p><script type="math/tex; mode=display">\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix} = \displaystyle \sum_{i_{1}i_{2}\cdots i_{n},j_{1}j_{2}\cdots j_{n}} (-1)^{N(i_{1}i_{2}\cdots i_{n})+N(j_{1}j_{2}\cdots j_{n})}a_{i_{1}j_{1}} a_{i_{2}j_{2}}\cdots a_{i_{n}j_{n}}</script><h2 id="1-2-行列式的性质"><a href="#1-2-行列式的性质" class="headerlink" title="1.2 行列式的性质"></a>1.2 行列式的性质</h2><h3 id="1-2-1-转置（Transform）"><a href="#1-2-1-转置（Transform）" class="headerlink" title="1.2.1 转置（Transform）"></a>1.2.1 转置（Transform）</h3><p>假设有行列式</p><script type="math/tex; mode=display">\displaystyle D=\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix}</script><p>那么，行列式的转置行列式为</p><script type="math/tex; mode=display">\displaystyle D^{T}=\displaystyle \begin{vmatrix} a_{11} & a_{21} & \dots  &a_{n1} \\ a_{12} & a_{22} & \dots &a_{n2} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{1n} & a_{2n} & \dots &a_{nn}\end{vmatrix}</script><blockquote><p> 相当于将对应的行换成列，对应的列换成行。（沿主对角线进行镜像翻转）。</p></blockquote><h3 id="1-2-2-性质"><a href="#1-2-2-性质" class="headerlink" title="1.2.2 性质"></a>1.2.2 性质</h3><p><strong>性质</strong>：（行列式的性质，对行成立，那么对列也成立）</p><ol><li><p>行列式的两次转置等于其本身，即 $\displaystyle (D^{T} )^{T} =D$ 。</p></li><li><p><strong>行列式转置后，其值的大小不变</strong>，即 $D^{T} = D$ 。</p><p>   证明：转置前的行列式，按第一定义展开；转置后的行列式，按第二定义展开。两种展开后对应的每一项的结果都是相等。</p></li><li><p><strong>行列式中，交换两行（列）的位置，行列式的值变号</strong>。</p><p> ​    证明：交行两行（列），相当于行列式展开的每一项，对应的<strong>行（列）排序</strong>中的某两个数，进行一次<strong>对换</strong>，因此，所有项的符号都会改变，最终会使行列式的结果变号。</p><p> ​    推论：</p><ol><li>行列式有两行或者两列对应相等，那么行列式的值等于零。</li></ol></li><li><p>行列式中的某一行（列）都乘以 $K$ ，那么行列式的值变为原来的 $K$ 倍。</p><p> ​    证明：由<strong>行列式的第一、二、三定义</strong>可知，在乘以 $K$ 倍的一行（列），无论取那个元素，都相当于对应的展开项乘以 $K$ 倍，因此，每一个展开项就可以提取一个 $K$ 倍的系数。</p><p> ​    推论：</p><ol><li><strong>某一行都有公因子 $K$ 那么可以将 $K$ 提到行列式外</strong><script type="math/tex; mode=display"> \displaystyle \displaystyle \begin{vmatrix} Ka_{11} & Ka_{12} & \dots  &Ka_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix}=K\displaystyle \begin{vmatrix} a_{11} & a_{12} & \dots  &a_{1n} \\ a_{21} & a_{22} & \dots &a_{2n} \\ \vdots  & \vdots & \ddots  & \vdots\\ a_{n1} & a_{n2} & \dots &a_{nn}\end{vmatrix}</script></li></ol></li><li><p>两行（列）对应成比例，那么行列式的值为 0 。</p><p> ​    证明：由<strong>推论4-1</strong>和<strong>推论3-1</strong>可以推导得到。</p><p> ​    推论：</p><ol><li>某一行（列）全为零，行列式为 0 。</li></ol></li><li><p>行列式的某一行（列）是两数之和，那么该行列式可以表示为两个行列式相加。（将两数和的那一行分开，其余行保持不变）</p><p> ​    例如：</p><script type="math/tex; mode=display"> \begin{vmatrix} 1 & 2 & 3\\ 7+8 & 2+3 & 9+10\\ 8 & 8 &9\end{vmatrix} = \begin{vmatrix} 1 & 2 & 3\\ 7 & 2 & 9\\ 8 & 8 &9\end{vmatrix} +\begin{vmatrix} 1 & 2 & 3\\ 8 & 3 & 10\\ 8 & 8 &9\end{vmatrix}</script><p> ​    例题：</p><script type="math/tex; mode=display"> \begin{vmatrix} b+c & c+a & a+b\\a+b & b+c & c+a\\ c+a & a+b &b+c\end{vmatrix}</script></li><li><p><strong>行列式乘以一个数，并且加到另一行上去，那么行列式的值不变</strong>。</p><p> ​    证明：由<strong>定理6</strong>和<strong>定理5</strong>推到可以得到。</p></li></ol><blockquote><p><strong>两行对应成比例、某一行为0、两行相等</strong>，那么行列式为0。但是，行列式为0，不一定满足<strong>上述三种的其一</strong>。</p></blockquote><hr><p>例题：（考察定理7） 求解行列式 $\displaystyle D = \begin{vmatrix}1  &amp;  2&amp; 0 &amp; 1\\ 2 &amp; 3 &amp; 10 &amp; 0\\ 0 &amp; 3 &amp; 5 &amp; 18\\ 5 &amp; 10 &amp; 15 &amp;4\end{vmatrix}$ 。</p><p>解：</p><script type="math/tex; mode=display">\begin{align}\displaystyle D & = \begin{vmatrix}1  &  2& 0 & 1\\ 2 & 3 & 10 & 0\\ 0 & 3 & 5 & 18\\ 5 & 10 & 15 &4\end{vmatrix}  = \begin{vmatrix}1  &  2& 0 & 1\\ 0 & -1 & 10 & -2\\ 0 & 3 & 5 & 18\\ 0 & 0 & 15 &-1\end{vmatrix}\\ & = \begin{vmatrix}1  &  2& 0 & 1\\ 0 & -1 & 10 & -2\\ 0 & 0 & 35 & 12\\ 0 & 0 & 15 &-1\end{vmatrix}  = \begin{vmatrix}1  &  2& 0 & 1\\ 0 & -1 & 10 & -2\\ 0 & 0 & 35 & 12\\ 0 & 0 & 0 &-\frac{43}{7} \end{vmatrix}\\ & = 215\end{align}</script><p>注：上三角行列式的值等于对角线乘积。</p><h2 id="1-3-行列式按行展开"><a href="#1-3-行列式按行展开" class="headerlink" title="1.3 行列式按行展开"></a>1.3 行列式按行展开</h2><h3 id="1-3-1-余子式"><a href="#1-3-1-余子式" class="headerlink" title="1.3.1 余子式"></a>1.3.1 余子式</h3><p>在行列式中，选取某个元素 $a_{ij}$ ，并且去掉该元素所在行列的所有元素，其余元素保持不变，形成的新的行列式称为<strong>$a_{ij}$的余子式</strong>，记作 $M_{ij}$ 。</p><p><strong>代数余子式</strong>：在余子式的基础上，增加一个系数，并且用 $A_{ij}$ 表示，其关系为 $A_{ij}  = (-1)^{i+j} M_{ij}$ 。</p><h3 id="1-3-2-按行（列）展开"><a href="#1-3-2-按行（列）展开" class="headerlink" title="1.3.2 按行（列）展开"></a>1.3.2 按行（列）展开</h3><p><strong>定理 （按行/列展开）</strong> 行列式按某一行展开，相当于该行<strong>对应元素</strong>与其<strong>代数余子式</strong>的乘积，并且所有项累和。公式表示为：</p><script type="math/tex; mode=display">D = a_{i1} A_{i1}+a_{i2} A_{i2} +\dots +a_{in} A_{in}</script><p>按列展开的公式为：</p><script type="math/tex; mode=display">D = a_{1i} A_{1i}+a_{2i} A_{2i} +\dots +a_{ni} A_{ni}</script><p>按行（列）展开的作用：</p><ol><li>可以是当前行列式降阶；</li><li>选取 0 元素多的行或者列展开，计算量较小</li></ol><h3 id="1-3-3-异乘变零定理"><a href="#1-3-3-异乘变零定理" class="headerlink" title="1.3.3 异乘变零定理"></a>1.3.3 异乘变零定理</h3><p><strong>定理（异乘变零）</strong> 某行元素与另一行元素的代数余子式的乘积之和，等于零。</p><p>证明：</p><p>设一个四阶行列式 $\displaystyle D_{1}=\begin{vmatrix} 1 &amp; 1 &amp; 2 &amp; 3\\ 0 &amp; 0 &amp; 8 &amp; 9\\ 2 &amp; 5 &amp; 5 &amp; 4\\ 9 &amp; 9 &amp; 9 &amp;10\end{vmatrix}$ ，并且 $A_{11},A_{12},A_{13},A_{14}$ 是第一行的代数余子式，并且用第四行的元素乘以第一行的代数余子式，得到的式子如下：</p><script type="math/tex; mode=display">9A_{11}+9A_{12}+9A_{13}+10A_{14}</script><p>那么这时候，设行列式 $\displaystyle D_{2}=\begin{vmatrix} 9 &amp; 9 &amp; 9 &amp; 10\\ 0 &amp; 0 &amp; 8 &amp; 9\\ 2 &amp; 5 &amp; 5 &amp; 4\\ 9 &amp; 9 &amp; 9 &amp;10\end{vmatrix}$ ，并且观察可以得到，行列式 $D_{2}$ 第一行的代数余子式与 $D_{1}$ 第一行的代数余子式，分别对应相等。接下来行列式 $D_{2}$ 按照第一行展开，得到：</p><script type="math/tex; mode=display">\displaystyle D_{2}=\begin{vmatrix} 9 & 9 & 9 & 10\\ 0 & 0 & 8 & 9\\ 2 & 5 & 5 & 4\\ 9 & 9 & 9 &10\end{vmatrix}=9A_{11}+9A_{12}+9A_{13}+10A_{14}</script><p>而根据<strong>行列式性质中的推论3-1</strong>可得， $D_{2}=0$ （有两行对应相等），因此，得到：</p><script type="math/tex; mode=display">9A_{11}+9A_{12}+9A_{13}+10A_{14}=0</script><p>至此，<strong>异乘变零</strong>定理证毕。</p><h3 id="1-3-4-拉普拉斯"><a href="#1-3-4-拉普拉斯" class="headerlink" title="1.3.4 拉普拉斯"></a>1.3.4 拉普拉斯</h3><p><strong>$k$阶子式</strong> ：设行列式 $\begin{vmatrix}1  &amp; 2 &amp; 3 &amp; 4\\ 1 &amp; 1 &amp; 2 &amp; 5\\ 1 &amp; 1 &amp; 0 &amp; 8\\ 9 &amp; 9 &amp; 9 &amp;10\end{vmatrix}$ ，并且取第一二行，第一二列，那么，行列式 $\begin{vmatrix}1  &amp; 2 \\ 1 &amp; 1 \\\end{vmatrix}$ 就称为 <strong>2阶子式</strong>。形如上述方式，取 $k$ 个行列，那么得到的就称为<strong>$k$阶子式</strong>。</p><p><strong>$k$阶余子式</strong>：去掉 $k$ 个行与列的所有元素，剩余的行列式就是<strong>余子式</strong>。</p><p><strong>$k$阶代数余子式</strong>：$\displaystyle A = (-1)^{\sum i +\sum j} M$ 。</p><p><strong>定理（拉普拉斯展开定理）</strong> 取定 $k$ 行，由 $k$ 行元素组成的所有 <strong>$k$ 阶子式</strong>与代数余子式乘积之和，等于该行列式的值。</p><h3 id="1-3-5-行列式相乘定理"><a href="#1-3-5-行列式相乘定理" class="headerlink" title="1.3.5 行列式相乘定理"></a>1.3.5 行列式相乘定理</h3><p><strong>必须是同阶行列式才能进行矩阵形式相乘</strong>。行列式相乘的规则与矩阵相乘的规则类似。</p><p>$A\times B=C$ 就是分别用 $A$ 的行元素乘以 $B$ 的列元素并相加，得到 $C$ 的元素。</p><h2 id="1-4-行列式的计算"><a href="#1-4-行列式的计算" class="headerlink" title="1.4 行列式的计算"></a>1.4 行列式的计算</h2><p>方法一：化成上三角矩阵</p><p>方法二：是用代数余子式降阶计算</p><h3 id="1-4-1-“爪”型或者三叉型"><a href="#1-4-1-“爪”型或者三叉型" class="headerlink" title="1.4.1 “爪”型或者三叉型"></a>1.4.1 “爪”型或者三叉型</h3><h3 id="1-4-2-范德蒙得行列式"><a href="#1-4-2-范德蒙得行列式" class="headerlink" title="1.4.2 范德蒙得行列式"></a>1.4.2 范德蒙得行列式</h3><p>形如下面形式的行列式，称为<strong>范德蒙得行列式</strong></p><script type="math/tex; mode=display">\begin{vmatrix} 1 & 1 & \cdots  & 1\\ x_{1}  & x_{2} & \dots  & x_{n}\\x_{1}^{2}   & x_{2}^{2}  & \dots  & x_{n}^{2} \\\vdots    & \vdots & \dots  & \vdots\\x_{1}^{n-2}   & x_{2}^{n-2} & \dots  & x_{n}^{n-2}\\x_{1}^{n-1}   & x_{2}^{n-1} & \dots  & x_{n}^{n-1}\end{vmatrix} = \displaystyle \prod_{1\le j<i\le n}(x_{i}-x_{j}  )</script><p>证明：将上述行列式进行变换，每一行的 $-x_{1}$ 倍加到下一行上去，得到</p><script type="math/tex; mode=display">\begin{vmatrix} 1 & 1 & \cdots  & 1\\0  & x_{2}-x_{1} & \dots  & x_{n}-x_{1}\\0   & x_{2}^{2}-x_{1}x_{2}  & \dots  & x_{n}^{2} -x_{1}x_{n}\\\vdots    & \vdots & \dots  & \vdots\\0   & x_{2}^{n-2}-x_{1}x_{2}^{n-3} & \dots  & x_{n}^{n-2}-x_{1}x_{n}^{n-3}\\0   & x_{2}^{n-1} -x_{1}x_{2}^{n-2}& \dots  & x_{n}^{n-1}-x_{1}x_{n}^{n-2}\end{vmatrix}</script><p>然后按照第一列展开得：（$n-1$阶行列式）</p><script type="math/tex; mode=display">\begin{vmatrix}x_{2}-x_{1} & \dots  & x_{n}-x_{1}\\x_{2}^{2}-x_{1}x_{2}  & \dots  & x_{n}^{2} -x_{1}x_{n}\\\vdots & \dots  & \vdots\\x_{2}^{n-2}-x_{1}x_{2}^{n-3} & \dots  & x_{n}^{n-2}-x_{1}x_{n}^{n-3}\\x_{2}^{n-1} -x_{1}x_{2}^{n-2}& \dots  & x_{n}^{n-1}-x_{1}x_{n}^{n-2}\end{vmatrix}</script><p>此时，将上述行列式提取公因子得：</p><script type="math/tex; mode=display">(x_{2}-x_{1})(x_{3}-x_{1})\cdots (x_{n}-x_{1})\begin{vmatrix} 1 & 1 & 1 & \dots  & 1\\ x_{2}& x_{3} & x_{4} & \dots & x_{n}\\ x_{2}^{2}  & x_{3}^{2} & x_{4}^{2} & \dots & x_{n}^{2}\\ \vdots  & \vdots & \vdots & \ddots & \vdots\\ x_{2}^{n-2}  & x_{3}^{n-2} & x_{4}^{n-2} & \dots &x_{n}^{n-2}\end{vmatrix}</script><p>这时候，观察后面的行列式，这依旧是一个范德蒙得行列式，但是它是 $n-1$ 阶的。然后重复前面的步骤，就能得到题目中的证理。</p><h3 id="1-4-3-反对称行列式"><a href="#1-4-3-反对称行列式" class="headerlink" title="1.4.3 反对称行列式"></a>1.4.3 反对称行列式</h3><p><strong>对称行列式</strong>：$a_{ij}=a_{ji}$</p><ol><li>主对角线元素没有要求；</li><li>沿对角线成对称位置的元素对应相等。</li></ol><p><strong>反对称行列式</strong> ： $a_{ij}=-a_{ji}$ 。</p><ol><li>主对角线元素全为 0 ；</li><li>沿对角线成对称位置的元素互为相反数。</li></ol><p><strong>定理</strong> 奇数阶的反对称行列式等于0。</p><h2 id="1-5-克莱姆法则"><a href="#1-5-克莱姆法则" class="headerlink" title="1.5 克莱姆法则"></a>1.5 克莱姆法则</h2><blockquote><p><a name="克莱姆法则" alt="none"> </a>只适用于方程的个数等于未知量的个数</p></blockquote><p>设三元一次方程组：</p><script type="math/tex; mode=display">\left\{\begin{matrix} x_{1}  & + &  x_{2}& + & x_{3} & = &1 \\  x_{1}& -&  x_{2}& + & 5x_{3} & = & 6\\  -x_{1}& + & x_{2} & + &6x_{3}  & = &9\end{matrix}\right.</script><p>满足：</p><ol><li>$n$ 个方程， $n$ 个未知量；</li><li>$D\ne 0$ ；</li><li>那么， $\displaystyle x_{j}  = \frac{D_{j} }{D} $ 。</li></ol><p>其中：</p><script type="math/tex; mode=display">\begin{align}&D = \begin{vmatrix} 1 & 1 & 1\\ 1 & -1 & 5\\ -1 & 1 &6\end{vmatrix}& D_{1} = \begin{vmatrix} 1 & 1 & 1\\ 6 & -1 & 5\\9 & 1 &6\end{vmatrix} \\& D_{2} = \begin{vmatrix} 1 & 1 & 1\\ 1 & 6 & 5\\-1 & 9 &6\end{vmatrix} &D_{3} = \begin{vmatrix} 1 & 1 & 1\\ 1 & -1 & 6\\-1 & 1 &9\end{vmatrix} \end{align}</script><blockquote><p>缺点：计算量很大，不推荐使用。</p><p>比较适合计算机解题</p></blockquote><p><strong>定理 2</strong> 如果是一个齐次方程组，并且方程的个数等于未知量的个数，且 $D\ne0$ ，那么，该方程组只有零解。如果是一个齐次方程组，并且方程的个数等于未知量的个数，且 $D=0$ ，那么，该方程组有非零解。</p><h1 id="二、矩阵-Matrix"><a href="#二、矩阵-Matrix" class="headerlink" title="二、矩阵(Matrix)"></a>二、矩阵(Matrix)</h1><h2 id="2-1-矩阵的概念"><a href="#2-1-矩阵的概念" class="headerlink" title="2.1 矩阵的概念"></a>2.1 矩阵的概念</h2><p>形如下面形式的一组<strong>数表</strong>，称为 $m\times n$ 矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix} a_{11}  & a_{12} & \cdots  & a_{1n}\\ a_{21} & a_{22} & \cdots & a_{2n}\\ \vdots  & \vdots & \ddots  & \vdots\\ a_{m1} &a_{m2}  & \cdots &a_{mn}\end{bmatrix}</script><p>矩阵与行列式差异：</p><ul><li>矩阵是一组数表；行列式本质上是一个数。</li><li>行列式符号是 $|\cdots|$ ；矩阵符号是 $(\dots) or [\dots]$ 。</li><li>行列式的<strong>行权等于列权（地位相等）</strong>，行列数必须相等；矩阵行列数可以不相等。</li></ul><p><strong>零矩阵</strong>：元素全为 0 的<strong>矩阵</strong>称为零矩阵。</p><p><strong>单位矩阵</strong>：对于一个方阵，主对角线上全为 1 ，其余全为 0 的矩阵，称为 <strong>$n$ 阶单位矩阵</strong>。</p><script type="math/tex; mode=display">\begin{bmatrix}1  & &  &\\ & 1 &  & \\  &  & \ddots  &\\&  &  &1\end{bmatrix}</script><p><strong>同型矩阵</strong>：行列数对应相等的两个矩阵，称为同型矩阵。</p><div align="center">    <font color="red">两个矩阵相等的一个前提是同型矩阵</font></div><blockquote><ul><li>只有一个数的矩阵，可以不用写符号。</li><li>两个 0 矩阵不一定相等。</li></ul></blockquote><p>矩阵的属性：</p><ol><li>矩阵的秩</li><li>特征值</li><li>特征向量</li><li>行列式</li></ol><h2 id="2-2-矩阵的运算"><a href="#2-2-矩阵的运算" class="headerlink" title="2.2 矩阵的运算"></a>2.2 矩阵的运算</h2><h3 id="2-2-1-矩阵的加减法"><a href="#2-2-1-矩阵的加减法" class="headerlink" title="2.2.1 矩阵的加减法"></a>2.2.1 矩阵的加减法</h3><p>两个矩阵能够相加减，必须是<strong>同型矩阵</strong>。矩阵的加减法是将每一个元素对应相加减。</p><script type="math/tex; mode=display">\begin{align} &\begin{bmatrix} a_{11} &  a_{12} & \cdots  & a_{1n} \\ a_{21} &  a_{22} & \cdots  & a_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ a_{m1} &  a_{m2} & \cdots  & a_{mn} \\\end{bmatrix} \pm \begin{bmatrix} b_{11} &  b_{12} & \cdots  & b_{1n} \\ b_{21} &  b_{22} & \cdots  & b_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ b_{m1} &  b_{m2} & \cdots  & b_{mn} \\\end{bmatrix}\\ & = \begin{bmatrix} a_{11}\pm b_{11} &  a_{12}\pm b_{12} & \cdots  & a_{1n}\pm b_{1n} \\ a_{21}\pm b_{21} &  a_{22}\pm b_{22} & \cdots  & a_{2n}\pm b_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ a_{m1}\pm b_{m1} &  a_{m2}\pm b_{m2} & \cdots  & a_{mn}\pm b_{mn} \\\end{bmatrix}\end{align}</script><p> 运算律：</p><ol><li>$A\pm B=B\pm A$ ；</li><li>$(A+B)+C=A+(B+C)$ ；</li><li>$A+0=A$ ；</li></ol><h3 id="2-2-2-矩阵的数乘运算"><a href="#2-2-2-矩阵的数乘运算" class="headerlink" title="2.2.2 矩阵的数乘运算"></a>2.2.2 矩阵的数乘运算</h3><p>一个数 $k$ 乘以一个矩阵，就是把矩阵中的每个元素都乘以 $k$ 。</p><script type="math/tex; mode=display">k\begin{bmatrix} a_{11} &  a_{12} & \cdots  & a_{1n} \\ a_{21} &  a_{22} & \cdots  & a_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ a_{m1} &  a_{m2} & \cdots  & a_{mn} \\\end{bmatrix}=\begin{bmatrix} ka_{11} &  ka_{12} & \cdots  & ka_{1n} \\ ka_{21} &  ka_{22} & \cdots  & ka_{2n} \\ \vdots  & \vdots  &  \ddots & \vdots\\ ka_{m1} &  ka_{m2} & \cdots  & ka_{mn} \\\end{bmatrix}</script><p>矩阵提公因子：矩阵所有元素均有公因子，并且公因子<strong>外提一次</strong> </p><h3 id="2-2-3-矩阵的乘法"><a href="#2-2-3-矩阵的乘法" class="headerlink" title="2.2.3 矩阵的乘法"></a>2.2.3 矩阵的乘法</h3><p>有两个矩阵 $A_{ml}$ 和矩阵 $B_{ln}$ ，矩阵 $A\times B$ 就是将 $A$ 的行元素对应乘以 $B$ 的列元素之和，就是新的矩阵的元素。（和行列式的乘法类似）。</p><blockquote><p><strong>矩阵相乘的前提是：左边的列数等于右边的行数</strong>；矩阵相乘后的结果矩阵，其行数等于原左边矩阵的行数，其列数等于原右边矩阵的列数。</p></blockquote><div align="center">    <P>        ----------------------------------------    </P>    <P>        <strong>宋氏七字</strong>    </P>    <p>        中间相等，取两头    </p>    <P>        ----------------------------------------    </P></div><p>运算律：</p><ol><li>$AB\ne BA$ ，有时 $AB$ 有意义的时候， $BA$ 不一定有意义。</li><li>$AB=0$ ，那么<strong>推不出来</strong> $A=0\text{或}B=0$ 。</li><li>$AB=AC,A\ne0$ ，同样推不出来 $A=C$ 。</li><li>$A0=0$ 。</li><li>$AE=A,EB=B$ ，其中， $E$ 的单位矩阵。</li><li>$(AB)C=A(BC)$ 。</li><li>$(A+B)C=AC+BC,C(A+B)=CA+CB$ 。</li><li>$kAB = k(AB) = A(kB)$ 。</li></ol><h3 id="2-2-4-矩阵的幂运算"><a href="#2-2-4-矩阵的幂运算" class="headerlink" title="2.2.4 矩阵的幂运算"></a>2.2.4 矩阵的幂运算</h3><p>形如 $A^{k} = AA\cdots A$ 的运算，称为<strong>矩阵的幂运算</strong>。特别地。规定 $A^{0}=E$ 。</p><p>运算律：</p><ol><li>$A^{k_{1}}A^{k_{2}}=A^{k_{1}+k_{2}}$ ；</li><li>一般地， $(AB)^{k} \ne A^{k}B^{k}$ ；</li><li>一般情况下， $(A+B)^{2} \ne A^{2}+2AB+B^{2} $ ；<ol><li>$(A+B)^{2} = A^{2} +B^{2}+AB+BA $ ；</li><li>$(A-B)^{2} \ne A^{2}-2AB+B^{2}$</li><li>$(A+E)^{2} = A^{2} +E^{2}+2AE $ ；</li></ol></li></ol><h3 id="2-2-5-矩阵的转置"><a href="#2-2-5-矩阵的转置" class="headerlink" title="2.2.5 矩阵的转置"></a>2.2.5 矩阵的转置</h3><p>假设矩阵 $A=\begin{bmatrix} 1 &amp; 2 &amp; 3\\  1&amp; 1 &amp;1\end{bmatrix}$ ，那么，矩阵 $\begin{bmatrix} 1 &amp; 1 \\  2&amp; 1 \\ 3 &amp; 1 \end{bmatrix}$ 称为 $A$ 的转置矩阵。</p><p><strong>定义（矩阵转置）</strong> 设矩阵 $A_{mn}$ ，将对应的行换成列，对应的列换成行，得到的新矩阵称为 $A$ 的转置矩阵，记作 $A^{T}(\text{或者}A^{‘})$ 。显然，转置矩阵是 $n\times m$ 阶的矩阵。</p><p><strong>性质</strong>：</p><ol><li><p>$(A^{T} )^{T} =A$ ；</p></li><li><p>$(A+B)^{T} =A^{T} +B^{T}$ ；</p></li><li><p>$(kA)^{T}=kA^{T}$ ；</p></li><li><p>$(AB)^{T}=B^{T}A^{T}$ ；</p><p>​    推广：</p><ol><li>$(A_{1}A_{2}\cdots A_{n} )^{T}=A_{n} ^{T}\cdots A_{2} ^{T}A_{1} ^{T}$ ；</li></ol></li></ol><h2 id="2-3-特殊矩阵"><a href="#2-3-特殊矩阵" class="headerlink" title="2.3 特殊矩阵"></a>2.3 特殊矩阵</h2><h3 id="2-3-1-数量矩阵"><a href="#2-3-1-数量矩阵" class="headerlink" title="2.3.1 数量矩阵"></a>2.3.1 数量矩阵</h3><p>形如：</p><script type="math/tex; mode=display">\begin{bmatrix} a &  &  &  & \\  & a &  &  & \\  &  & a &  & \\  &  &  & \ddots  & \\  &  &  &  &a\end{bmatrix}</script><p>其中， $a$ 是常数。这样的矩阵称为<strong>数量矩阵</strong>。<strong>显然，数量矩阵都是方阵</strong>。</p><blockquote><p>单位阵和零矩阵都是特殊的单位矩阵。</p></blockquote><p><strong>一个数乘以一个数量矩阵、两个数量矩阵之和、两个数量矩阵相减、两个数量矩阵相减、两个数量矩阵相乘，结果都是数量矩阵</strong>。</p><h3 id="2-3-2-对角矩阵"><a href="#2-3-2-对角矩阵" class="headerlink" title="2.3.2 对角矩阵"></a>2.3.2 对角矩阵</h3><p>形如：</p><script type="math/tex; mode=display">\begin{bmatrix} a_{1}  &  &  &  & \\  & a_{2} &  &  & \\  &  & a_{3} &  & \\  &  &  & \ddots  & \\  &  &  &  &a_{n}\end{bmatrix}</script><p>的矩阵称为<strong>对角矩阵</strong>。</p><blockquote><p>数量矩阵是特殊的对角型矩阵</p></blockquote><h3 id="2-3-4-三角矩阵"><a href="#2-3-4-三角矩阵" class="headerlink" title="2.3.4 三角矩阵"></a>2.3.4 三角矩阵</h3><p>主对角线左下方全是 0 的矩阵是上三角矩阵；主对角线右上方全是 0 的矩阵是下三角矩阵。</p><blockquote><p>对角型矩阵是特殊的上三角矩阵和下三角矩阵。</p></blockquote><h3 id="2-3-5-对称和反对称"><a href="#2-3-5-对称和反对称" class="headerlink" title="2.3.5 对称和反对称"></a>2.3.5 对称和反对称</h3><p><strong>对称矩阵</strong>：满足 $a_{ij}=a_{ji}$ 的矩阵称为对称矩阵。<strong>$A^{T}=A$的矩阵称为对称矩阵</strong>。 </p><ol><li>$A,B$ 是对称矩阵，那么 $A\pm B$ 也是对称矩阵。</li><li>$A$ 是对称矩阵，那么 $(kA)^{T}$ 也是对称矩阵。</li><li>$AA^{T},A^{T}A$ 都是对称矩阵。</li></ol><p><strong>定义（反对称矩阵）</strong> 满足 $a_{ij}=-a_{ji}$ 的矩阵，称为反对称矩阵。</p><blockquote><p><strong>反对称矩阵的主对角线全为零；对称矩阵的主对角线无要求</strong>。</p></blockquote><h2 id="2-4-逆矩阵"><a href="#2-4-逆矩阵" class="headerlink" title="2.4 逆矩阵"></a>2.4 逆矩阵</h2><p>之前，我已经探讨过矩阵的加、减、数乘、乘，那么，矩阵有没有除法呢？这就引出一个新的概念：<strong>逆矩阵</strong>。</p><h3 id="2-4-1-方阵的行列式"><a href="#2-4-1-方阵的行列式" class="headerlink" title="2.4.1 方阵的行列式"></a>2.4.1 方阵的行列式</h3><p>设方阵 $A$ ，那么，将 $A$ 中所有元素构成一个行列式，这个行列式称为<strong>方阵的行列式</strong>，记作 $|A|$ 。</p><blockquote><p>注意：行列式是一个数，而矩阵是一个数表。二者有着本质上的区别。<strong>行列式是矩阵的一个属性</strong>。</p></blockquote><p><strong>性质</strong>：</p><ol><li>性质1： $|A^{T}|=|A|$ ，即行列式转置，值不变。</li><li>性质2： $|kA|=k^{n}|A|$ ，其中， $n$ 是方阵的阶。</li><li>性质3： $|AB|=|A|\cdot|B|$ 。<ol><li>性质3-1： $|A_{1}A_{2}\dots A_{n}|=|A_{1}||A_{2}|\cdots |A_{n}|$ 。</li></ol></li></ol><h3 id="2-4-2-伴随矩阵"><a href="#2-4-2-伴随矩阵" class="headerlink" title="2.4.2 伴随矩阵"></a>2.4.2 伴随矩阵</h3><p><strong>定义（伴随矩阵）</strong> 设矩阵 $\displaystyle \begin{bmatrix} a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n}\\ \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots \\ a_{m1} &amp; a_{m2} &amp; \cdots  &amp; a_{mn}\end{bmatrix}$ ，并且 $A_{ij}$ 是矩阵 $A$ 的<strong>代数余子式</strong> ，然后代数余子式按顺序组成的矩阵的<strong>转置矩阵</strong>，称为矩阵 $A$ 的伴随矩阵，记作 $A^{*}$：</p><script type="math/tex; mode=display">\displaystyle A ^{\ast }=\begin{bmatrix} A_{11} & A_{21} & \cdots  & A_{m1}\\ A_{12} & A_{22} & \cdots  & A_{m2}\\ \vdots  & \vdots  & \ddots  & \vdots \\ A_{1n} & A_{2n} & \cdots  & A_{nm}\end{bmatrix} =\begin{bmatrix} A_{11} & A_{12} & \cdots  & A_{1n}\\ A_{21} & A_{22} & \cdots  & A_{2n}\\ \vdots  & \vdots  & \ddots  & \vdots \\ A_{m1} & A_{m2} & \cdots  & A_{mn}\end{bmatrix}^{T}</script><div align="center">    <p>        --------------------    </p>    <p>        按行求，按列放    </p>    <p>        --------------------    </p></div><p><strong>定理1</strong>：任意方阵 $A$ ，那么 $AA^{\ast }=A^{\ast }A=|A|E$ 。</p><p>证明：</p><script type="math/tex; mode=display">\begin{align}AA^{\ast } & = \begin{bmatrix} a_{11} & a_{12} & \dots  & a_{1n}\\a_{21} & a_{22} & \dots & a_{2n}\\ \vdots  &  \vdots&  \ddots & \vdots\\ a_{m1} & a_{m2} & \dots &a_{mn}\end{bmatrix}\begin{bmatrix} A_{11} & A_{21} & \cdots  & A_{m1}\\ A_{12} & A_{22} & \cdots  & A_{m2}\\ \vdots  & \vdots  & \ddots  & \vdots \\ A_{1n} & A_{2n} & \cdots  & A_{nm}\end{bmatrix}\\&=\begin{bmatrix} |A| &  &  & \\  & |A| &  & \\  &  & |A| & \\  &  &  &|A|\end{bmatrix}=|A|E\end{align}</script><p><strong>推论1-1</strong>：当 $|A|\ne 0$ 时， $|A^{\ast}|=|A|^{n-1}$ 。（后续能够证明，当 $|A| =0$ ，该推论依旧成立）。</p><p>证明：</p><script type="math/tex; mode=display">\left | AA^{\ast} \right |  = \left | \left | A \right | E \right | =\left | A \right |^{n}</script><p>那么，上式左边可以化为：</p><script type="math/tex; mode=display">\left | A \right |^{n}  =\left | AA^{\ast} \right | =|A|\cdot |A^{\ast } |</script><p>移项化简可得：</p><script type="math/tex; mode=display">|A^{\ast } |=\left | A \right |^{n-1}</script><p>至此证毕。</p><h3 id="2-4-3-逆矩阵"><a href="#2-4-3-逆矩阵" class="headerlink" title="2.4.3 逆矩阵"></a>2.4.3 逆矩阵</h3><p><strong>定义（逆矩阵）</strong> 设矩阵 $A$ 为 $n$ 阶方阵，存在 $n$ 阶方阵 $B$ ，使得 $AB=BA=E$ ，那么，称矩阵 $B$ 为 $A$ 的逆矩阵，记作： $A^{-1}$ 。</p><blockquote><p>注意：不要写成 $\displaystyle \frac{1}{A} $ 样的形式，这样的表示是错误的。 $A^{-1}$ 表示的是逆矩阵，而不是矩阵 $A$ 的负一次方。</p></blockquote><p>结论：</p><ol><li>未必所有方阵均可逆；</li><li>如果矩阵 $A$ 可逆，那么逆矩阵一定唯一。</li></ol><h3 id="2-4-4-逆矩阵的判定"><a href="#2-4-4-逆矩阵的判定" class="headerlink" title="2.4.4 逆矩阵的判定"></a>2.4.4 逆矩阵的判定</h3><p>奇异矩阵和非奇异矩阵：</p><ul><li>如果矩阵 $A$ 满足 $|A|\ne 0$ ，那么矩阵 $A$ 称为非奇异矩阵、非退化矩阵、满秩矩阵；</li><li>如果矩阵 $A$ 满足 $|A|= 0$ ，那么矩阵 $A$ 称为奇异矩阵、退化矩阵、非满秩矩阵。</li></ul><p><strong>定理</strong>：矩阵 $A$ 可逆的<strong>充分必要条件</strong>是： $|A|\ne 0$ ，此时， $\displaystyle A^{-1}=\frac{1}{|A|} A^{\ast }$ 。</p><p><strong>推论</strong>：设 $A,B$ 都为 $n$ 阶方阵，如果 $AB=E\quad(BA=E)$ ，那么 $A$ 可逆，且 $A^{-1}=B$ 。♨️♨️♨️♨️♨️♨️</p><h3 id="2-4-5-逆矩阵的求法"><a href="#2-4-5-逆矩阵的求法" class="headerlink" title="2.4.5 逆矩阵的求法"></a>2.4.5 逆矩阵的求法</h3><p>方法</p><ol><li><p>方法一：伴随矩阵法</p><p> ​    （上面的内容已经证明过了）</p></li><li><p>方法二：初等变换法</p><p> ​    假设矩阵 $A$ 存在逆矩阵，将 $A$ 的</p></li></ol><h3 id="2-4-5-逆矩阵的性质"><a href="#2-4-5-逆矩阵的性质" class="headerlink" title="2.4.5 逆矩阵的性质"></a>2.4.5 逆矩阵的性质</h3><p><strong>性质 4</strong>：如果矩阵 $A$ 可逆，那么 $A^{-1}$ 也可逆，并且 $(A^{-1} )^{-1} $ 。</p><p><strong>性质 5</strong>：如果矩阵 $A,B$ 均可逆，那么 $AB$ 可逆，并且 $(AB)^{-1}=B^{-1} A ^{-1} $ 。</p><p><strong>性质 6</strong>：如果矩阵 $A$ 可逆，那么 $A^{T} $ 可逆，并且 $(A^{T} )^{-1}=(A^{-1} )^{T} $ 。</p><p><strong>性质 7</strong>：如果矩阵 $A$ 可逆，那么 $\displaystyle |A^{-1}| = |A|^{-1} = \frac{1}{|A|} $ 。</p><p><strong>性质 8</strong>：如果矩阵 $A$ 可逆，那么 $A^{\ast } $ 也可逆，并且 $\displaystyle (A^{\ast } )^{-1} = \frac{1}{|A|}A$ 。</p><h2 id="2-5-分块矩阵"><a href="#2-5-分块矩阵" class="headerlink" title="2.5 分块矩阵"></a>2.5 分块矩阵</h2><p>将一个高阶的矩阵进行分块（注意：分块的时候要按整行或者整列进行切割）</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 2 & 3 \vdots& 4\\\dots &\dots &\dots \vdots&\dots \\ 5 &  6& 7 \vdots&8 \\ 9 &  10& 11 \vdots& 12\\ 13 &  14&  15\vdots&16\end{bmatrix}=\begin{bmatrix} A_{11} & A_{12}\\ A_{21} &A_{22}\end{bmatrix}</script><p><strong>标准形</strong>： </p><script type="math/tex; mode=display">\begin{bmatrix} 1 &  &  &  &  & \\  &  \ddots &  &  &  & \\  &  & 1 &  &  & \\  &  &  & 0 &  & \\  &  &  &  & \ddots  & \\  &  &  &  &  &0\end{bmatrix}_{m\times n} =\begin{bmatrix} E & 0\\ 0 &0\end{bmatrix}</script><p>分块矩阵的运算与一般矩阵的运算基本相同。</p><p>分块矩阵的转置：</p><script type="math/tex; mode=display">\begin{bmatrix} A_{11} & A_{12}\\ A_{21} &A_{22}\end{bmatrix}^{T}= \begin{bmatrix} A_{11}^{T} & A{21}^{T}\\ A_{12}^{T} &A_{22}^{T}\end{bmatrix}</script><p>例题：设分块矩阵 $\displaystyle H=\begin{bmatrix} A_{m\times m}  &amp; C_{m\times n}\\  0&amp;B_{n\times n}\end{bmatrix}$ ， $A,B$ 是可逆矩阵，求证： $|H|=|A|\cdot |B|$ 。</p><p>证明：使用拉普拉斯定理得：</p><script type="math/tex; mode=display">\begin{bmatrix} A_{m\times m}  & C_{m\times n}\\  0&B_{n\times n}\end{bmatrix}=A\cdot (-1)^{m+m}\cdot B+C\cdot(-1)^{m+m+n}\cdot 0=AB</script><p>因此，可以得到：</p><script type="math/tex; mode=display">|H|=|A|\cdot|B|</script><h2 id="2-6-初等变换和初等矩阵"><a href="#2-6-初等变换和初等矩阵" class="headerlink" title="2.6 初等变换和初等矩阵"></a>2.6 初等变换和初等矩阵</h2><h3 id="2-6-1-初等变换"><a href="#2-6-1-初等变换" class="headerlink" title="2.6.1 初等变换"></a>2.6.1 初等变换</h3><p>初等行变换和初等列变换：</p><ol><li>交换矩阵得某两行（列）元素。</li><li>某一行（列）乘以 $k(k\ne 0)$ 。</li><li>某一行（列）的 $k$ 倍加到另一行（列）上去。</li></ol><script type="math/tex; mode=display">[\dots ]\to [\dots ]\to [\dots ]</script><blockquote><p>注意：初等变换后的矩阵与原矩阵不一定相等，这是一种等效变换，但是不是相等变换。</p><p>注意：初等变换是一种可逆变换。</p></blockquote><p><strong>定理</strong>：任何矩阵可以通过<strong>初等变换</strong>化为标准形。</p><h3 id="2-6-2-等价"><a href="#2-6-2-等价" class="headerlink" title="2.6.2 等价"></a>2.6.2 等价</h3><p><strong>定义</strong>：矩阵 $A$ 经过初等变换得到矩阵 $B$ ，那么称 $A,B$ 是等价的，记作 $A\cong B $ 。</p><p><strong>性质</strong>：</p><ol><li><strong>反身性</strong>： $A\cong A$ ；</li><li><strong>对称性</strong>：已知 $A\cong B $ 。那么 $B\cong A$ ；</li><li><strong>传递性</strong>：已知 $A\cong B,B\cong C$ ，那么 $A\cong C$ 。</li></ol><h3 id="2-6-3-初等方阵"><a href="#2-6-3-初等方阵" class="headerlink" title="2.6.3 初等方阵"></a>2.6.3 初等方阵</h3><p><strong>定义</strong>：对一个 $n$ 阶的单位矩阵做一次初等变换，得到的矩阵称为<strong>初等方阵</strong>。</p><blockquote><p>初等方阵均可逆。其逆矩阵也是初等方阵。初等方阵的转置矩阵也是初等矩阵。</p></blockquote><p><strong>定理</strong>：设 $A$ 是任意一个矩阵，并且存在一个进行第 $i$ 种初等变换得到的初等矩阵，初等矩阵<strong>左乘</strong>矩阵 $A$ ，相当于对矩阵 $A$ 实施了同种的第 $i$ 种初等行变换。如果是初等矩阵<strong>右乘</strong>矩阵 $A$ ，相当于对 $A$ 实施了同种的第 $i$ 种初等行变换</p><p><strong>初等变换的作用</strong>：——左行右列——</p><p><code>E(...)A = B</code> ，注意，<strong>这里是 <code>=</code> 号。我们在之前的学习中知道，初等变换后的矩阵与原矩阵，一般不相等，因此用 <code>→</code> 表示，但是，有时为了方便计算和证明，我们需要进行 <code>=</code> 的使用，那么，这时候就可以用左乘右乘，来建立一种相等的关系</strong>。</p><p><strong>定义 3</strong>：对于任意的矩阵 $A$ ，存在初等矩阵 $P_{1},P_{2},\dots ,P_{s}$ 和初等矩阵 $Q_{1},Q_{2},\dots ,Q_{t}$ ，使得 $P_{1}P_{2}\dots P_{s}AQ_{1}Q_{2}\dots Q_{t}$ 为标准形。</p><ul><li>解释：矩阵 $A$ 通过初等变换化为标准形，那么，在初等变换的过程中，可能有行变换（左乘），可能有列变换（右乘），那就相当于左乘和右乘若干矩阵。</li></ul><p><strong>推论 1</strong>：已知矩阵 $A,B$ 是等价的，那么存在可逆矩阵 $P,Q$ ，使得 $PAQ=B$ 。</p><ul><li>解释：因为 $A,B$ 是等价的，就是说 $A$ 可以通过若干次初等变换，得到矩阵 $B$ ，即<strong>相当于左乘和右乘对应的初等矩阵</strong>。此外，初等矩阵是可逆矩阵，那么初等矩阵的乘积也是可逆矩阵，将所有左乘的初等矩阵相乘，得到 $P$ ，右乘矩阵 $Q$ 同理，最终能得到 $PAQ=B$ 。</li></ul><p><strong>定义 4</strong>：已知矩阵 $A$ 是可逆矩阵，那么 $A$ 的标准形为单位矩阵 $E$ 。（ $\Leftrightarrow $ ）</p><ul><li>必要性：</li><li>充分性：</li></ul><p><strong>定义 5</strong>：矩阵 $A$ 是可逆矩阵 $\Leftrightarrow $  $A=P_{1}P_{2}\cdots P_{s}$ 。</p><h3 id="2-6-4-初等变换法求逆阵"><a href="#2-6-4-初等变换法求逆阵" class="headerlink" title="2.6.4 初等变换法求逆阵"></a>2.6.4 初等变换法求逆阵</h3><p>设矩阵 $A$ 可逆，那么 $A^{-1}$ 也是可逆的。所以，可以把 $A^{-1}$ 表示成：</p><script type="math/tex; mode=display">A^{-1}=Q_{1}Q_{2}\dots Q_{t}</script><p>上式同时右乘矩阵 $A$ 得：</p><script type="math/tex; mode=display">A^{-1}A=Q_{1}Q_{2}\dots Q_{t}A=E</script><p>而根据前面的学习，我们知道：$Q_{1}Q_{2}\dots Q_{t}E=A^{-1}$ 。</p><p>最终得到如下两个式子：</p><script type="math/tex; mode=display">\begin{align}& Q_{1}Q_{2}\dots Q_{t}A=E  &(1)\\& Q_{1}Q_{2}\dots Q_{t}E=A^{-1} &(1)\\\end{align}</script><p>式子 (1) 相当于将 $A$ 进行 $t$ 得初等行变换，最终化为单位矩阵 $E$ ，而单位矩阵 $E$ 进行<strong>一样</strong>的初等行变换，那么最终会化为 $A^{-1}$ 。</p><p>上述求解<strong>逆矩阵</strong>的方法，被称为<strong>初等行变换法</strong>，构造为 $\begin{bmatrix} A &amp; \vdots  &amp;E\end{bmatrix}$ ，经过初等行变换得到 $\begin{bmatrix} E &amp; \vdots  &amp;A^{-1} \end{bmatrix}$ 。（只做行变换，不能做列变换）</p><blockquote><p>同样的，还存在<strong>初等列变换</strong>求解逆矩阵，与行变换类似。构造的形式是 $\begin{bmatrix}A \\\dots  \\E\end{bmatrix}\to \begin{bmatrix}E \\\dots  \\A^{-1} \end{bmatrix}$ 。</p></blockquote><h2 id="2-7-矩阵的秩"><a href="#2-7-矩阵的秩" class="headerlink" title="2.7 矩阵的秩"></a>2.7 矩阵的秩</h2><h3 id="2-7-1-秩的定义"><a href="#2-7-1-秩的定义" class="headerlink" title="2.7.1 秩的定义"></a>2.7.1 秩的定义</h3><p><strong>定义（ $k$ 阶子式）</strong>：对于给定的矩阵 $A$ ，任取 $k$ 行 $k$ 列，<strong>组成的行列式</strong>，称为 $k$ 阶子式。</p><p>非零子式的最高阶数，就称为<strong>矩阵的秩</strong>，记作 $R(A)$ 。</p><hr><p>那么，矩阵的秩有什么含义吗？</p><p><font color='red'>行阶梯矩阵</font> 是指满足下面两个条件的矩阵：</p><ol><li>如果有零行（元素全为零的行），则零行位于非零行的下方；</li><li>非零行的首个非零元素（亦称为基准或主元素），前面零元的个数从上往下依次严格增加。</li></ol><p>当行阶梯矩阵进一步满足：非零行的首非零元均为 1 ，且所在列的其余元素均为 0 ，则称为 <font color='red'>最简行阶梯矩阵</font>（或称<font color='red'>行最简形</font>） 。</p><p><strong>矩阵的秩就是表示行阶梯矩阵非零行的个数</strong>。</p><p><strong>满秩</strong>：行阶梯矩阵没有非零行，即非零子式的最高阶数等于矩阵的阶数（行数、列数中的较小值）。</p><h3 id="2-7-2-秩的性质"><a href="#2-7-2-秩的性质" class="headerlink" title="2.7.2 秩的性质"></a>2.7.2 秩的性质</h3><p><strong>性质 1</strong>：已知矩阵 $A$ 是 $m\times n$ 矩阵，那么 $0\le R(A)\le \mathrm{min} \left \{ m,n \right \} $ 。</p><ul><li>行满秩： $R(A)=m$ 取所有行，行满秩；</li><li>列满秩： $R(A)=n$ 取所有列，列满秩；</li><li>行满秩与列满秩，都是满秩。</li><li>如果 $R(A)&lt; \mathrm{min} \left \{ m,n \right \} $ ，那么就称为<strong>降秩</strong>。</li><li>$A$ 是方阵，且 $A$ 是满秩 $\Leftrightarrow $ $A$ 是可逆矩阵  $\Leftrightarrow $  $|A|\ne 0$ 。</li></ul><p><strong>定理 1</strong>： $R(A)=r$  $\Leftrightarrow $ 有一个 $r$ 阶子式不为 0 ，所有的 $r+1$ 阶子式全为 0 .</p><p><strong>性质 2</strong>： $R(A)=R(A^{T})$ 。</p><p><strong>性质 3</strong>：$R(A)=0\iff A=O$ 。</p><p><strong>性质 4</strong>：若 $A\cong B$ ，则 $\displaystyle R(A) = R(B)$ 。</p><p><strong>性质 5</strong>：$\displaystyle R\begin{bmatrix}A &amp; O\\O &amp; B\end{bmatrix} = R(A) +R(B)$ 。</p><p><strong>性质 6</strong>：$\displaystyle R(A\pm B)\le R(A)+R(B)$ 。</p><ul><li>证明：<script type="math/tex; mode=display">  \begin{align}\displaystyle \begin{bmatrix} A & O\\ O &B\end{bmatrix}\cong  \displaystyle \begin{bmatrix} A & O\\ A &B\end{bmatrix}\cong  \displaystyle \begin{bmatrix} A & A\\ A &A+B\end{bmatrix}\end{align}</script>  ​    所以：<script type="math/tex; mode=display">  \displaystyle R(A)+R(B) = R\begin{bmatrix} A & A\\ A &A+B\end{bmatrix}\ge R(A+B)</script>  ​    同理可证：<script type="math/tex; mode=display">  \displaystyle R(A)+R(B)\ge R(A- B)</script></li></ul><p><strong>性质 7</strong>：${\color{Red} \displaystyle \text{max}\left \{ R(A),R(B) \right \} \le R(A,B)\le R(A)+R(B)} $ 。</p><p><strong>性质 8</strong>：若 $A$ 为 $n$ 阶方阵，则 $\displaystyle R(A)=n\Longleftrightarrow A $ 是可逆矩阵。</p><p><strong>性质 9</strong>：$\displaystyle R(AB)\le\text{min} \left \{ R(A),R(B) \right \} $ （<strong>乘法矩阵的秩在减小，只有都是满秩才取等</strong>）。</p><p><strong>性质 10</strong>：若 $P,Q$ 可逆，则 $\displaystyle R(A) = R(PA)=R(AQ)=R(PAQ)$ （可逆矩阵不影响矩阵的秩，可逆矩阵一定是满秩）；</p><p><strong>性质 11</strong>：若 $A,B$ 均为 $n$ 阶方阵，则 $\displaystyle R(AB)\ge R(A)+R(B)-n$ 。</p><p> （ $\displaystyle R(A)+R(B)-n\le R(AB)\le \text{min}\left \{ R(A),R(B) \right \} $ ，上式被称为<font color='red'>西尔维斯特不等式</font>）。</p><p><strong>性质 12</strong>：<strong><code>Frobenius</code></strong>不等式： $\displaystyle R(ABC)\ge R(AB)+R(BC)-R(B)$ ；</p><p><strong>性质 13</strong>：$\displaystyle R(A_{m\times n} )=n\Longleftrightarrow \text{齐次方程组}  Ax=0 \text{只有零解}$ 。</p><h1 id="三、向量-Vector"><a href="#三、向量-Vector" class="headerlink" title="三、向量(Vector)"></a>三、向量(Vector)</h1><h2 id="3-1-向量的定义"><a href="#3-1-向量的定义" class="headerlink" title="3.1 向量的定义"></a>3.1 向量的定义</h2><p><a name="star" alt="none"> </a><a name="第三章向量" alt="none"> </a><strong>定义</strong>： $n$ 个数 $a_{1},a_{2},\dots ,a_{n}$ 组成的有序数组，称为<strong>向量</strong>。其中， $a_{i}$ 称为分量。 $n$ 称为向量的<strong>维数</strong>。</p><p><strong>行向量</strong>：形如 $\begin{bmatrix} a_{1} &amp; a_{2} &amp; \dots  &amp;a_{n}\end{bmatrix}$ 的向量，称为<strong>行向量</strong>。</p><p><strong>列向量</strong>：形如 $\displaystyle \begin{bmatrix} a_{1} \\ a_{2} \\ \dots  \\ a_{n}\end{bmatrix}$ 的向量，称为<strong>列向量</strong>。</p><blockquote><p>在没有特殊说明的情况下，提到向量一律按照列向量的对待</p></blockquote><p><strong>零向量</strong>：向量的各分量都为 0 ，记作 $\mathbf{0} $ 。</p><h2 id="3-2-向量的线性关系"><a href="#3-2-向量的线性关系" class="headerlink" title="3.2 向量的线性关系"></a>3.2 向量的线性关系</h2><p><strong>线性组合</strong>：设向量组 $\beta ,\alpha _{1},\alpha _{2},\dots ,\alpha _{s}$ 都是 $n$ 维向量，若存在 $k_{1},k_{2},\cdots ,k_{s} $ ，使得</p><script type="math/tex; mode=display">\beta =k_{1}\alpha_{1}+k_{2}\alpha_{2}+\cdots+k_{s}\alpha_{s}</script><p>称该向量组是一个线性组合，或者线性表示。</p><blockquote><ul><li>零向量可以由任意向量组来表示。</li><li>向量组中的任一向量，都以可有向量组其余的向量表示。</li><li>任意向量可由 $\varepsilon_{1}  =\left [1,0,\cdots ,0  \right ] ^{T} ,\varepsilon_{1}  =\left [0,1,\cdots ,0  \right ] ^{T},\dots ,\varepsilon_{n}  =\left [0,0,\cdots ,1  \right ] ^{T}$ 表示。</li><li>不管向量是行向量还是列向量，都<strong>左乘</strong>系数。</li></ul></blockquote><p>上述线性组合可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix} \alpha _{1}  &\alpha _{2}  & \dots  &\alpha _{s}\end{bmatrix}\begin{bmatrix}k_{1}  \\k_{2} \\ \vdots \\k_{s}\end{bmatrix} = \beta</script><p><strong>向量组的等价</strong>：给定两给向量组 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{m}$ 和向量组 $\beta_{1} ,\beta_{2},\cdots ,\beta _{m}$ ，并且都是同维的，如果 $\alpha$ 向量组中的每个向量，都可以用 $\beta$ 向量组线性表示（或者 $\beta$ 向量组中的每个向量，都可以用 $\alpha$ 向量组线性表示）那么称<strong>这两个向量组是等价的</strong>，记作 $\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix}\cong\begin{bmatrix}\beta _{1}  &amp; \beta _{2} &amp;\cdots  &amp;\beta _{m}\end{bmatrix} $ 。</p><p>性质：</p><ol><li>反身性： $\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix}\cong\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix} $ ；</li><li>对称性：如果 $\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix}\cong\begin{bmatrix}\beta _{1}  &amp; \beta _{2} &amp;\cdots  &amp;\beta _{m}\end{bmatrix} $ ，那么 $\begin{bmatrix}\beta _{1}  &amp; \beta _{2} &amp;\cdots  &amp;\beta _{m}\end{bmatrix}\cong\begin{bmatrix}\alpha _{1}  &amp; \alpha _{2} &amp;\cdots  &amp;\alpha _{m}\end{bmatrix} $ 。</li><li>传递性： 如果 $\begin{bmatrix}\alpha \end{bmatrix}\cong\begin{bmatrix} \beta\end{bmatrix} $ ，且 $\begin{bmatrix} \beta\end{bmatrix}\cong\begin{bmatrix}\gamma \end{bmatrix} $ ，那么 $\begin{bmatrix}\alpha \end{bmatrix}\cong\begin{bmatrix}\gamma \end{bmatrix} $ 。</li></ol><p><strong>线性无关</strong>：已知 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 是 $n$ 个 $m$ 维向量，若存在一组不全为 0 的系数 $k_{1},k_{2},\cdots ,k_{n} $ 使得</p><script type="math/tex; mode=display">k_{1}\alpha_{1}+k_{2}\alpha_{2}+\cdots+k_{n}\alpha_{n}=0</script><p>成立，则称 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 是<strong>线性相关</strong>的；反之，则称为<strong>线性无关</strong>。</p><blockquote><ol><li>向量组中的两两向量成比例，则是线性相关的。</li><li>含零向量的任意向量组必定是线性相关的。</li><li>一个零向量必定线性相关的。</li><li>任意一个非零向量必定线性无关。</li></ol></blockquote><p><strong>定理</strong>：如果 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{r}$ 是线性相关的，那么 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{r},\alpha _{r+1},\cdots ,\alpha _{s}$ 必定也是线性相关的。</p><p><strong>定理</strong> 1： $\alpha _{1} ,\alpha _{2} ,\cdots  ,\alpha _{s} $ 线性相关 $\Longleftrightarrow $ 至少一个向量可有其余向量线性表示。</p><p><strong>定理 2</strong>： $\alpha _{1} ,\alpha _{2} ,\cdots  ,\alpha _{s} $ 线性无关，且 $\alpha _{1} ,\alpha _{2} ,\cdots  ,\alpha _{s}, \beta$ 线性相关，那么 $\beta $ 可由 $\alpha _{1},\alpha _{2},\cdots ,\alpha _{n}$ <strong>唯一线性表示</strong>。</p><blockquote><p> $n+1$ 个 $n$ 维向量一定是线性相关的。（相当于 $n$ 个未知量和 $n+1$ 个方程）。</p></blockquote><h2 id="3-3-向量组的秩"><a href="#3-3-向量组的秩" class="headerlink" title="3.3 向量组的秩"></a>3.3 向量组的秩</h2><p><strong>定义（极大线性无关组）</strong>：向量组 $\alpha _{1},\alpha _{2},\cdots ,\alpha _{m}$ ， 而 $\alpha  _{1},\alpha  _{2},\cdots ,\alpha _{s} $ 是向量组的一部分，并且子向量组是线性无关的，同时任意的 $s+1$ 个向量是线性相关的，那么称 $\alpha  _{1},\alpha  _{2},\cdots ,\alpha _{s} $ 是一个<strong>极大线性无关组</strong>。</p><p><strong>定理</strong>： $\alpha  _{1},\alpha  _{2},\cdots ,\alpha _{s} $ 线性无关，任意 $s+1$ 个向量是线性相关的。</p><p><strong>定义（向量组的秩）</strong>：极大线性无关组所含向量的个数，即为<strong>向量组的秩</strong>。</p><h1 id="四、线性方程组"><a href="#四、线性方程组" class="headerlink" title="四、线性方程组"></a>四、线性方程组</h1><h2 id="4-1-线性方程组"><a href="#4-1-线性方程组" class="headerlink" title="4.1 线性方程组"></a>4.1 线性方程组</h2><p>引例：（鸡兔同笼），共8只，腿共20只。</p><p>解：设鸡兔的个数分别为 $x_{1},x_{2}$ ，那么得到：</p><script type="math/tex; mode=display">\left\{\begin{matrix}x_{1}   & + & x_{2} & =&8\\x_{1}  & + & 2x_{2} & =&20\end{matrix}\right.</script><p>那么，上述方程组可以使用矩阵来表示：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 1\\ 1 &2\end{bmatrix}\cdot \begin{bmatrix} x_{1} \\ x_{2}\end{bmatrix}=\begin{bmatrix}8 \\20\end{bmatrix}</script><p>即 $AX=B$ ，矩阵 $A$ 称为系数矩阵，矩阵 $X$ 称为未知量矩阵（向量），矩阵 $B$ 称为结果矩阵（向量）。</p><h2 id="4-2-方程组有解判定"><a href="#4-2-方程组有解判定" class="headerlink" title="4.2 方程组有解判定"></a>4.2 方程组有解判定</h2><p>设方程组为：</p><script type="math/tex; mode=display">\left\{\begin{matrix} x_{1}  & + & x_{2}  & + & x_{3}  & = & 1\\ x_{1}  & - & x_{2}  & - & x_{3}  & = & -3\\ 2x_{1}  & + & 9x_{2}  & + & 10x_{3}  & = & 11\\\end{matrix}\right.</script><p>那么<strong>系数矩阵</strong>为：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 1 & 1\\ 1 & -1 &-1 \\ 2 &  9&10\end{bmatrix}</script><p>增广矩阵为：</p><script type="math/tex; mode=display">\widetilde{A} =\begin{bmatrix} 1 & 1 & 1&1\\ 1 & -1 &-1 &-3\\ 2 &  9&10&11\end{bmatrix}</script><p>方程组用向量表示为：</p><script type="math/tex; mode=display">x_{1}\begin{bmatrix} 1\\ 1\\2\end{bmatrix} +x_{2}\begin{bmatrix} 1\\ -1\\9\end{bmatrix}+x_{3}\begin{bmatrix} 1\\ -1\\10\end{bmatrix} =\begin{bmatrix} 1\\ -3\\11\end{bmatrix}</script><p>方程组 $n$ 解的判定</p><ul><li>唯一解：$R(A)=R(\widetilde{A}) = \mathrm{min}\left \{ \text{行数},\text{列数}  \right \}  $ ，即<strong>矩阵为满秩</strong>。</li><li>无穷多解： $R(A)=R(\widetilde{A}) &lt; \mathrm{min}\left \{ \text{行数},\text{列数}  \right \}  $ ，即为<strong>非满秩</strong> ，其中 $n-r$ 称为自由量的个数；</li><li>无解： $R(A)&lt; R(\widetilde{A})$ 。</li></ul><hr><p>解题的一般步骤：</p><ol><li>先写出方程组的系数矩阵 $A$ 以及增广矩阵 $\widetilde{A}$ ；</li><li>将上述矩阵化为<strong>行阶梯型矩阵</strong>；</li><li>观察系数矩阵以及增广矩阵的秩 $R(A)，R(\widetilde{A})$ 的关系</li><li>若 $R(A)=R(\widetilde{A})$ ，则方程有解<ol><li>如果矩阵为满秩（$r=n$），则有唯一解；</li><li>如果矩阵为非满秩（$r&lt;n$），则有无穷多解，并且有 $n-r$ 个自由量。</li></ol></li><li>若  $R(A)&lt; R(\widetilde{A})$ ，则方程无解。</li></ol><h2 id="4-3-齐次方程组的解"><a href="#4-3-齐次方程组的解" class="headerlink" title="4.3 齐次方程组的解"></a>4.3 齐次方程组的解</h2><p>结果矩阵为 0 的方程组，称为<strong>齐次方程组</strong>，即：</p><script type="math/tex; mode=display">Ax=0</script><p>此时， $R(A)\equiv R(\widetilde{A} )$ ，所以，<strong>齐次方程组必定是有解的（必定含零解）</strong>。</p><p>解的判定：</p><ol><li>齐次线性方程组有唯一零解 $\Longleftrightarrow $  $R(A)=n$ </li><li>齐次线性方程组有无穷多解 $\Longleftrightarrow$ $R(A)&lt;n$ ，且有 $n-r$ 个自由量。</li><li><strong>齐次线性方程组<font color="green">不存在</font>唯一非零解</strong>。</li><li>若方程组个数等于未知量个数（<a href="#克莱姆法则">克莱姆法则</a>）<ol><li>有非零解  $\Longleftrightarrow$  $|A|=0$ ；</li><li>只有零解  $\Longleftrightarrow$  $|A|\ne 0$ 。</li></ol></li></ol><h2 id="4-4-解的结构"><a href="#4-4-解的结构" class="headerlink" title="4.4 解的结构"></a>4.4 解的结构</h2><p>解的类型有：唯一解、无解、无穷解。其中，无穷多解描述是比较麻烦的，因此，使用解的结构来描述无穷多解的情况。</p><h3 id="4-4-1-齐次方程组"><a href="#4-4-1-齐次方程组" class="headerlink" title="4.4.1 齐次方程组"></a>4.4.1 齐次方程组</h3><p>设齐次方程组 $Ax=0$ 有无穷多解：</p><ul><li>假设 $\eta _{1} ,\eta _{2}$ 是方程组的解，那么 $\eta _{1}+\eta _{2}$ 也是方程组的解。</li><li>假设 $\eta$ 是方程组的解，那么 $c\eta$ 也是方程组的解（ $c$ 是常数 ）。</li></ul><p><strong>基础解系</strong>：解向量 $\eta _{1} ,\eta _{2},\cdots ,\eta _{s}$ 满足：</p><ol><li>$\eta _{1} ,\eta _{2},\cdots ,\eta _{s}$ 线性无关；</li><li>任意解都能用  $\eta _{1} ,\eta _{2},\cdots ,\eta _{s}$ 线性表示。</li></ol><blockquote><p><strong>基础解系就是方程组所有解向量中的一组极大线性无关组（注意：可能有多个极大无关组，也就是说有多个基础解系），并且方程组有多少个自由量，就代表着极大无关组有多少个解向量</strong>。</p></blockquote><p>求解基础解系的过程：</p><p><img src="https://imageshack.yuilexi.cn/University/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%AE%8B%E6%B5%A9%E7%89%88/%E6%B1%82%E8%A7%A3%E5%9F%BA%E7%A1%80%E8%A7%A3%E7%B3%BB%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="求解基础解系的过程"></p><p><strong>性质</strong>： 如果矩阵 $AB=0$ ，那么 $R(A)+R(B)\le n$ </p><h3 id="4-4-2-非齐次线性方程组"><a href="#4-4-2-非齐次线性方程组" class="headerlink" title="4.4.2 非齐次线性方程组"></a>4.4.2 非齐次线性方程组</h3><p>形如 $Ax=b$ 的方程组，称为<strong>非齐次线性方程组</strong>。</p><ol><li>$\alpha _{1} ,\alpha _{1}$ 是方程组 $Ax=b$ 的解，那么 $\alpha _{1} -\alpha _{1}$ 是方程 $Ax=0$ 的解；</li><li>$\alpha _{0} $ 是方程组 $Ax=b$ 的解，  $\eta $ 是 $Ax=0$ 的解，那么 $\alpha _{0}+ \eta $ 也是 $Ax=b$ 的解</li></ol><p>非齐次解的结构：</p><p><strong>定理</strong>：如果 $\alpha _{0} $ 是方程组 $Ax=b$ 的一个解（特解）， $\eta $ 是 $Ax=0$ 的通解。其中：</p><script type="math/tex; mode=display">\eta =c_{1}\eta _{1}+c_{2}\eta _{2}+\cdots +c_{n-r}\eta _{n-r}</script><p>是 $Ax=0$ 的一个基础解系。那么：</p><script type="math/tex; mode=display">\alpha _{0} +c_{1}\eta _{1}+c_{2}\eta _{2}+\cdots +c_{n-r}\eta _{n-r}</script><p>就是非齐次线性方程组 $Ax=b$ 的通解。</p><hr><p><strong>非齐次线性方程组的通解求解步骤</strong>：</p><ol><li>写出增广矩阵 $\widetilde{A}$ ，只进行初等行变换，化为<strong>最简行阶梯型矩阵</strong>；</li><li>非零行的首非零元的 1 留在左边，其余元素移到等号右边；</li><li>令自由未知量均取 0 ，得 $Ax=b$ 的一个特解；</li><li>令方程组右边的 $b=0$ ，得到 $Ax=0$ 的方程组，并且解出对应的一个基础解系</li><li>将齐次方程组的通解与非齐次方程组的特解相加，得到非齐次线性方程组的<strong>通解</strong>。</li></ol><h1 id="五、特征值与特征向量"><a href="#五、特征值与特征向量" class="headerlink" title="五、特征值与特征向量"></a>五、特征值与特征向量</h1><p><strong>特征值与特征向量</strong>是方阵才有的性质</p><h2 id="5-1-特征值和特征向量的概念"><a href="#5-1-特征值和特征向量的概念" class="headerlink" title="5.1 特征值和特征向量的概念"></a>5.1 特征值和特征向量的概念</h2><h3 id="5-1-1-定义"><a href="#5-1-1-定义" class="headerlink" title="5.1.1 定义"></a>5.1.1 定义</h3><p><strong>定义</strong>：设矩阵 $A$ 是 $n$ 阶方阵，存在非零列向量 $\alpha $ ，使得</p><script type="math/tex; mode=display">A\alpha =\lambda \alpha</script><p>成立，则称 $\lambda$ 是特征值，向量 $\alpha $ 为对应于 $\lambda$ 的特征向量。</p><blockquote><p>注意：</p><ul><li>特征向量一定是<strong>列向量</strong>，且一定是<strong>非零向量</strong>；</li><li>特征值 $\lambda$ 可以取 0 。</li></ul><p>本质上是向量空间的变换，可以把变换矩阵 $A$ 看作是一组列向量，而 $\alpha $ 相当于在原线性空间中的<strong>坐标</strong>，经变换后，其<strong>坐标值</strong>发生改变，而其余的性质不发生任何改变（长度、方向、形状、体积等所有性质）。</p></blockquote><p>将上述 $A\alpha =\lambda \alpha$ 进行移项处理，得到 $(\lambda E-A)\alpha =0$ ，根据定义可得 $\alpha \ne 0$ ，因此，就相当于求齐次方程组的非零解，而齐次方程有非零解的<strong>充分必要</strong>是 <strong>系数行列式等于 0 </strong> 。 $\lambda E-A$ 被称为<strong>特征矩阵</strong>， $|\lambda E-A|$ 被称为<strong>特征行列式</strong>， $|\lambda E-A|=0$ 被称为<strong>特征方程</strong>。</p><p><strong>定理</strong>：如果 $\lambda$ 是矩阵 $A$ 的特征值， $\alpha$ 是其对应的特征向量，那么 $k\alpha(k\ne 0)$ 也是其对应的特征向量。</p><ul><li><p>证明：</p><p>  ​    假设上述结论成立，即</p><script type="math/tex; mode=display">  Ak\alpha =\lambda k\alpha</script><p>  ​    根据矩阵数乘的运算律，可以得到：</p><script type="math/tex; mode=display">  k(A\alpha)=k(\lambda \alpha )</script><p>  ​    又因为 $k\ne 0$ ，所以，两边约掉常数 $k$ ，得到：</p><script type="math/tex; mode=display">  A\alpha =\lambda \alpha</script><p>  ​    假设成立，证毕。</p></li></ul><p><strong>定理</strong>： $\alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ 是 $ \lambda $ 对应的特征向量，那么 $k_{1} \alpha _{1}+k_{2}\alpha _{2}+\cdots+k_{s}\alpha _{s} $ 也是 $ \lambda $ 对应的特征向量。</p><h3 id="5-1-2-求特征值"><a href="#5-1-2-求特征值" class="headerlink" title="5.1.2 求特征值"></a>5.1.2 求特征值</h3><p>根据上一节的知识可得，求解 $|\lambda E-A|=0$ 的结果，就是求解特征值 $\lambda $ 。</p><hr><p>例题：求矩阵 $\displaystyle A=\begin{bmatrix} -1 &amp; 1 &amp; 0\\ -4 &amp; 3 &amp; 0\\ 1 &amp; 0 &amp;0\end{bmatrix}$ 的特征值。</p><p>解：</p><script type="math/tex; mode=display">\begin{align}&\lambda E -A=\begin{bmatrix} \lambda+1 & -1 & 0\\ 4 & \lambda-3 & 0\\ -1 & 0 &\lambda-2\end{bmatrix}\\&|\lambda E -A| = \begin{vmatrix} \lambda+1 & -1 & 0\\ 4 & \lambda-3 & 0\\ -1 & 0 &\lambda-2\end{vmatrix}=0\end{align}</script><p>然后将行列式展开可以得到：</p><script type="math/tex; mode=display">(\lambda -2) \left [ (\lambda+1)(\lambda -3) +4 \right ] =0</script><p>整理可得：</p><script type="math/tex; mode=display">(\lambda -2) (\lambda -1)^{2}  =0</script><p>那么，解出的特征值为：</p><script type="math/tex; mode=display">\lambda _{1} =1,\quad \lambda _{2} =1,\quad \lambda _{3}=2</script><blockquote><p>上三角、下三角、对角线矩阵的特征值就是主对角线元素。</p></blockquote><h3 id="5-1-3-性质"><a href="#5-1-3-性质" class="headerlink" title="5.1.3 性质"></a>5.1.3 性质</h3><p><strong>性质 1⭐⭐</strong>： $A$ 和 $A^{T}$ 的特征值相同。</p><ul><li>证明：<script type="math/tex; mode=display">  |\lambda E-A^{T} | = |\lambda E^{T} -A^{T} |=|(\lambda E -A)^{T}|=|\lambda E-A|</script></li></ul><p><strong>性质 2</strong>：</p><p><strong>性质 3⭐⭐⭐</strong>： $n$ 个特征值 $\lambda _{1},\lambda _{2},\cdots ,\lambda _{n} $ ，那么</p><ol><li><p>$\lambda _{1}+\lambda _{2}+\cdots +\lambda _{n} =\text{主对角线元素之和} $ ；<strong>主对角线元素之和也被称为矩阵的迹，记作 $\mathrm{tr} (A)$</strong> 。</p></li><li><p>$\lambda _{1}\lambda _{2}\cdots \lambda _{n} =|A|$ 。</p><p>证明：</p><p>​    已知特征值是 $\lambda _{1},\lambda _{2},\cdots ,\lambda _{n} $ ，那么行列式就可以化作：</p><script type="math/tex; mode=display">|\lambda E-A|=(\lambda -\lambda _{1})(\lambda -\lambda _{2})\cdots (\lambda -\lambda _{n})=0</script><p>​    上式进行展开，得：</p><script type="math/tex; mode=display">|\lambda E-A|=\lambda^{n}-(\lambda _{1}+\lambda _{2}+\cdots +\lambda _{n})\lambda ^{n-1} +\dots +(-1)^{n} \lambda _{1}\lambda _{2}\cdots \lambda _{n}</script><p>​    到这里需要关注 $\lambda ^{n-1} $ 项和常数项。</p><p>​    行列式按照第一行展开：</p><script type="math/tex; mode=display">\begin{align}|\lambda E-A| & = \begin{bmatrix}\lambda -a_{11}  & -a_{12} & \cdots  & -a_{1n}\\-a_{21} & \lambda -a_{22}  &   \cdots & -a_{2n}\\ \vdots  & \vdots  & \ddots  & \vdots \\ -a_{n1} & -a_{n2} & \cdots  & \lambda -a_{nn}\end{bmatrix}\\ & = (-1)^{1+1} (\lambda -a_{11})M_{11}+(-1)^{1+2}(-a_{12})M_{12}\\ & \quad +\cdots +(-1)^{1+n}(-a_{1n})M_{1n}\end{align}</script><p>​        观察上面的行列式展开式，不难发现，只有第一项 $(-1)^{1+1} (\lambda -a_{11})M_{11}$ 含有 $\lambda ^{n-1}$ ，因此，将第一项的代数余子式，再次按照第一行展开，发现还是第一项含有 $\lambda ^{n-1}$ ，以此类推，得到</p><script type="math/tex; mode=display">\begin{align}|\lambda E-A| & = (\lambda -a_{11})(\lambda -a_{22})\cdots (\lambda -a_{nn})+\cdots \\&=\lambda ^{n} -(a_{11}+a_{22}+\cdots +a_{nn}) \lambda ^{n-1} +\cdots \end{align}</script><p>​    然后，令 $\lambda =0$ ，那么除常数项以外，其余项都是 0 ，并且行列式变成 $|-A|$ ，因此常数项就是：</p><script type="math/tex; mode=display">|-A|=(-1)^{n}|A|</script><p>​    所以，整理可以得到：</p><script type="math/tex; mode=display">\begin{align}|\lambda E-A| & = \lambda^{n}-(\lambda _{1}+\lambda _{2}+\cdots +\lambda _{n})\lambda ^{n-1} +\dots +(-1)^{n} \lambda _{1}\lambda _{2}\cdots \lambda _{n}\\|\lambda E-A| & = \lambda ^{n} -(a_{11}+a_{22}+\cdots +a_{nn}) \lambda ^{n-1} +\cdots+ (-1)^{n}|A| \end{align}</script></li></ol><p><strong>性质 4</strong>：互不相同的特征值 $\lambda _{1},\lambda _{2},\cdots ,\lambda _{s} $ 对那个的特征向量 $\alpha _{1},\alpha _{2},\cdots ,\alpha _{s}$ 必定<strong>线性无关</strong>。</p><p><strong>性质 5</strong>： $k$ 重特征根，对应的线性无关的特征向量的个数是 $\le k$ 个。</p><p><strong>性质 6</strong>：如果一个特征值对应的特征向量之间是线性无关的，那么所有这些特征向量之间，也是线性无关的。</p><p><strong>其余性质</strong>：</p><ol><li>$\lambda $ 是矩阵 $A$ 的特征值，那么 $k\lambda $ 是矩阵 $kA$ 的特征值。</li><li>$\lambda $ 是矩阵 $A$ 的特征值，那么 $\lambda ^{n}$ 是矩阵 $A ^{n} $ 的特征值</li></ol><h2 id="5-2-相似矩阵与可对角化条件"><a href="#5-2-相似矩阵与可对角化条件" class="headerlink" title="5.2 相似矩阵与可对角化条件"></a>5.2 相似矩阵与可对角化条件</h2><h3 id="5-2-1-相似矩阵的定义"><a href="#5-2-1-相似矩阵的定义" class="headerlink" title="5.2.1 相似矩阵的定义"></a>5.2.1 相似矩阵的定义</h3><p><strong>定义（相似矩阵）</strong>：设 $A,B$ 是 $n$ 阶方阵，如果存在 $n$ 阶可逆矩阵 $P$ ，使得 $P^{-1} AP=B$ ，那么称矩阵 $A$ 是矩阵 $B$ 的相似矩阵，记作 $A\sim B$ 。</p><p><strong>相似的性质</strong>：</p><ul><li>反身性：$A\sim A$ ；</li><li>对称性： $A\sim B\Longrightarrow B\sim A$ ；</li><li>传递性： $A\sim B,B\sim C\Longrightarrow A\sim C$ 。</li></ul><h3 id="5-2-2-相似矩阵的性质"><a href="#5-2-2-相似矩阵的性质" class="headerlink" title="5.2.2 相似矩阵的性质"></a>5.2.2 相似矩阵的性质</h3><p><strong>性质 1</strong>：如果 $A\sim B$ ，那么矩阵 $A,B$ 有相同的特征值，且 $|A|=|B|$ ，且 $\mathrm{tr}(A)=\mathrm{tr}(B)  $ 。</p><ul><li>证明<script type="math/tex; mode=display">  \begin{align}  |\lambda E-B| & = |\lambda E-P^{-1} AP| = |\lambda P^{-1} EP-P^{-1} AP|\\  &=|P^{-1} ||\lambda E-A||P|=|\lambda E-A|  \end{align}</script></li></ul><p><strong>性质 2</strong>：如果 $A\sim B$ ，那么 $A$ 可逆 $\Longleftrightarrow $  $B$ 可逆，且 $A^{-1}\sim  B^{-1} $ </p><ul><li>如果 $A\sim B$ ，那么矩阵 $A,B$ 同时可逆或者同时不可逆。</li></ul><p><strong>性质 3</strong>：<strong>如果 $A\sim B$ ，那么 $A^{m}\sim  B^{m} $</strong> 。</p><ul><li>证明：<script type="math/tex; mode=display">  B^{m}= (P^{-1} AP)^{m} =P^{-1} APP^{-1} AP\cdots P^{-1} AP=P^{-1} A^{m} P</script></li></ul><h3 id="5-2-3-对角型相似"><a href="#5-2-3-对角型相似" class="headerlink" title="5.2.3 对角型相似"></a>5.2.3 对角型相似</h3><p>矩阵 $A$ 与一个对角型矩阵相似，即表示为：$P^{-1} AP=\Lambda $ ，与对角型形似的条件</p><p><a name="对角化矩阵的条件" alt="none"> </a><strong>定理</strong>： $A\sim \Lambda $  $\Longleftrightarrow $  $A$ 有 $n$ 个线性无关的特征向量。并且如果特征值为 $\lambda _{1} ,\lambda _{2},\cdots ,\lambda _{n}$ ，对应的对角矩阵为：</p><script type="math/tex; mode=display">\Lambda= \begin{bmatrix}\lambda _{1}   &  &  & \\  & \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  &\lambda _{n}\end{bmatrix}</script><ul><li><p>证明：</p><p>  ​    设可逆矩阵 $P$ 为</p><script type="math/tex; mode=display">  P=\begin{bmatrix} \alpha _{1} & \alpha _{2} & \cdots  &\alpha _{n}\end{bmatrix}</script><p>  ​    因为矩阵 $P$ 是可逆矩阵，所以 $|P|\ne 0$ ，即 $\alpha _{1} , \alpha _{2} , \cdots  ,\alpha _{n}$ 均为非零列向量。设设对角矩阵为</p><script type="math/tex; mode=display">  \Lambda = \begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script><p>  ​    那么， $P^{-1} AP=\Lambda $ 可以转化为 $ AP=P\Lambda $ ，即</p><script type="math/tex; mode=display">   A\begin{bmatrix} \alpha _{1} & \alpha _{2} & \cdots  &\alpha _{n}\end{bmatrix}=\begin{bmatrix} \alpha _{1} & \alpha _{2} & \cdots  &\alpha _{n}\end{bmatrix}\begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script><p>  ​    因此，对应相等，即可得到：</p><script type="math/tex; mode=display">  A\alpha _{i}=\lambda _{i} \alpha _{i}</script><p>  ​    因为 $\alpha _{i}\ne 0 $ ，所以 $\lambda _{i}$  是矩阵 $A$ 的特征值，向量 $\alpha _{i}$ 是 $\lambda _{i}$  对应的特征向量。</p></li><li><p>推论： $A$ 有 $n$ 个互不相同的特征值，那么 $A\sim \Lambda =\begin{bmatrix} \lambda _{1}  &amp;  &amp;  \\  &amp; \ddots  &amp;   \\  &amp;  &amp;   \lambda _{n}\end{bmatrix}$ 。（<strong>这是一个充分条件</strong>）</p></li></ul><blockquote><p>💎💎💎💎💎因此，如果证明一个矩阵相似与对角型矩阵，那么就需要证<strong>矩阵有 $n$ 个线性无关的特征向量</strong>。</p><p>并且特征方程中，互异的单根对应的特征向量必定是线性无关的；因此，要看<strong>重根对应的特征向量中线性无关的个数</strong>。</p></blockquote><p><strong>定理</strong>： $A\sim \Lambda $  $\Longleftrightarrow $ 每一个 $k$ 重根的基础解系有 $k$ 个。</p><h2 id="5-3-实对称矩阵的对角化"><a href="#5-3-实对称矩阵的对角化" class="headerlink" title="5.3 实对称矩阵的对角化"></a>5.3 实对称矩阵的对角化</h2><p>知识回顾：前面我们了解到，并不是所有的矩阵都能对角化，必须满足存在可逆矩阵 $P$ ，使得 $P^{-1}AP=\Lambda$ 成立，那么就需要矩阵 $A$ 有 $n$ 个线性无关的特征向量。</p><p>那么，这一节学习的实对称矩阵，总结为一句话：<strong>实对称矩阵都能对角化</strong></p><h3 id="5-3-1-定义"><a href="#5-3-1-定义" class="headerlink" title="5.3.1 定义"></a>5.3.1 定义</h3><p><strong>定义（<font color="red">内积</font>）</strong>：对于任意同维向量 $x = \begin{bmatrix} x_{1}  &amp; x_{2}  &amp; \cdots  &amp;x_{n} \end{bmatrix}^{T}$ 和 $y = \begin{bmatrix} y_{1}  &amp; y_{2}  &amp; \cdots  &amp;y_{n} \end{bmatrix}^{T}$ ，那么称</p><script type="math/tex; mode=display">\left \langle x,y \right \rangle =x^{T}y=x_{1} y_{1}+x_{2} y_{2}+\cdots +x_{n} y_{n}</script><p>为向量 $x,y$ 的<font color="red"><strong>内积</strong></font>。</p><blockquote><p><strong>注意：内积是一个数</strong>。</p></blockquote><p><strong>内积的性质</strong>：</p><ul><li>$\left \langle x,y \right \rangle =\left \langle y,x \right \rangle $ ;</li><li>$\left \langle x,ky \right \rangle =\left \langle kx,y \right \rangle =k\left \langle x,y \right \rangle $ ；</li><li>$\left \langle x+y,z \right \rangle =\left \langle x,z \right \rangle +\left \langle y,z \right \rangle $ ；</li><li>$\left \langle x,x \right \rangle \ge 0 \quad (\text{当且仅当} x=0 \text{时取等}  )$ 。</li></ul><p><strong>定义（<font color="red">范数</font>）</strong>：对于任意的（列）向量 $x = \begin{bmatrix} x_{1}  &amp; x_{2}  &amp; \cdots  &amp;x_{n} \end{bmatrix}^{T}$ ，那么称</p><script type="math/tex; mode=display">\left \| x \right \| =\sqrt{x^{T} x} =\sqrt{x_{1}^{2}+x_{2}^{2}+\cdots +x_{n}^{2}}</script><p>为向量 $x$ 的<font color="red"><strong>范数</strong></font>。（<strong>也称为向量的长度、模</strong>）</p><blockquote><p>特别地，<strong>范数</strong>为 1 的向量被称为<strong>单位向量</strong>；称 $\frac{1}{\left | x \right |} x(x\ne 0)$ 为向量 $x$ 的单位向量，也称将向量 $x$ 单位化，记作 $x^{\circ} =\frac{1}{\left | x \right |} x(x\ne 0)$ 。</p></blockquote><p><strong>向量的范数的性质</strong>：</p><ul><li>非负性： $\left | x \right | \ge 0\quad (\text{当且仅当} x=0 \text{时取等})$ ；</li><li>齐次性： $\left | kx \right |=k\left | x \right |$ ；</li><li>三角不等式： $\left | x+y \right |\le \left | x \right |+\left | y\right |$ ；</li><li>柯西-布涅柯夫斯基不等式不等式： $\left | \left \langle x,y \right \rangle  \right | \le \left | x \right |+\left | y \right | $ 。</li></ul><p><strong>定义（<font color="red">向量的夹角</font>）</strong>：设 $x,y$ 是 $n$ 维非零向量，称</p><script type="math/tex; mode=display">\displaystyle \theta  = \arccos \frac{\left \langle x^{T} y \right \rangle }{\left \| x \right \|+\left \| y \right \|  }</script><p>为向量 $x,y$ 的夹角。特别地，当 $\left \langle x,y \right \rangle = x^{T} y=0$ 时， <script type="math/tex">\displaystyle \theta  = \pm \frac{\pi }{2}</script> ，这时，称向量 $x$ 与 $y$ <font color='red'>正交（或垂直）</font>。<strong>显然，零向量与任何向量正交</strong>。</p><blockquote><ul><li>两两正交的向量组（<strong>不含零向量</strong>）称为<font color='red'><strong>正交向量组</strong></font>。</li><li>由单位向量构成的正交向量组称为标准（规范）正交向量组。</li></ul><p>正交的意义是：在 $n$ 维向量空间中，任意两个维度之间都是正交的（垂直的），且对应维度的方向向量都是单位向量（长度为 1 ）。（参考三维空间坐标系）</p></blockquote><p><strong>定理</strong>：如果向量组 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{s}$ 是正交向量组，那么 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{s}$ 必定是线性无关的。</p><hr><p><a name="施密特正交化方法" alt="none"> </a>⭐<font color='red'><strong>施密特（Schmidt）正交化方法</strong></font>：</p><p>给定一组线性无关的向量组 $\alpha _{1} ,\alpha _{2},\cdots ,\alpha _{s}$ ，求与之等价的正交向量组 $\beta  _{1} ,\beta _{2},\cdots ,\beta _{s}$ ：</p><script type="math/tex; mode=display">\begin{align}\beta _{1} & =\alpha _{1} \\\beta _{2} & =\alpha_{2} -\frac{\beta _{1}^{T}\alpha_{2}}{\beta _{1}^{T} \beta _{1}}\beta _{1}\\\beta _{3} & =\alpha_{3} -\frac{\beta _{1}^{T}\alpha_{3}}{\beta _{1}^{T} \beta _{1}}\beta _{1}-\frac{\beta _{2}^{T}\alpha_{3}}{\beta _{2}^{T} \beta _{2}}\beta _{2}\\&\dots \\\beta _{m} & =\alpha_{m} -\sum_{j=1}^{m-1} \frac{\beta _{j}^{T}\alpha_{m}}{\beta _{j}^{T} \beta _{j}}\beta _{j}\\\end{align}</script><p><strong>为什么要使用施密特正交化法</strong>：<a href="https://zhuanlan.zhihu.com/p/136627868">如何理解施密特（Schmidt）正交化 - 知乎 (zhihu.com)</a></p><ul><li>在一个平面，或者三维空间中，任意一点都可以被坐标系表示出来。而我们更喜欢的是单位直角坐标系，因为在一个单位直角坐标系中，任意一个向量的坐标分量，通过简单的投影就可以搞定。</li><li>因此，如何找到欧式空间的一个“直角坐标系”，变得非常重要。施密特正交化法就告诉我们了一种把“任意坐标系”变为“直角坐标系”的方法。</li></ul><p><strong>定义（正交矩阵）</strong>：设矩阵 $A$ 是 $n$ 阶方阵，如果 $A^{T}A=E$ ，那么称矩阵 $A$ 为<strong>正交矩阵</strong>。</p><blockquote><p> $n$ 线性空间中的<strong>正交基</strong>矩阵就是 $A$ 。</p><p> 正交矩阵一定是可逆的，且 $A^{-1} =A^{T} $ 。</p></blockquote><h3 id="5-3-2-性质"><a href="#5-3-2-性质" class="headerlink" title="5.3.2 性质"></a>5.3.2 性质</h3><p><strong>性质 1</strong>：如果 $A$ 是正交矩阵，那么 $|A|=\pm 1$ 。</p><p><strong>性质 2</strong>：如果 $A$ 是正交矩阵，那么 $A^{-1}=A^{T}$ ，且 $A^{-1}$ 和 $A^{T}$ 均是正交矩阵。</p><p><strong>性质 3</strong>：如果矩阵 $A,B$ 是正交矩阵，那么矩阵 $AB$ 也是正交矩阵。</p><p><strong>性质 4</strong>：如果矩阵 $A$ 是正交矩阵，且 $\alpha, \beta $ 是列向量，那么 $\left \langle A\alpha, A\beta  \right \rangle =\left \langle \alpha, \beta  \right \rangle $ 。</p><p><strong>定理</strong>：矩阵 $A$ 是正交矩阵 $\Longleftrightarrow $ 矩阵 $A$ 的列（行）向量是标准正交向量组。</p><h3 id="5-3-3-实对称矩阵的对角化"><a href="#5-3-3-实对称矩阵的对角化" class="headerlink" title="5.3.3 实对称矩阵的对角化"></a>5.3.3 实对称矩阵的对角化</h3><p><strong>定理</strong>： $n$ 阶是对称矩阵，那么 $n$ 个特征值都是实数，并且 $n$ 个特征向量都是实向量。</p><p><strong>定理</strong>：<strong>实对称矩阵 $n$ 的不同特征值对应的特征向量，必定正交</strong>。</p><ul><li><p>证明：</p><p>  ​    设实对称矩阵 $A$ ，则 $A=A^{T}$ ；设 $\lambda _{1} ,\lambda _{2}$ 是任意两个不同特征值，那么可以得到：</p><script type="math/tex; mode=display">  \begin{align}A\alpha _{1} & = \lambda _{1}\alpha _{1}\\A\alpha _{2} & = \lambda _{2}\alpha _{2}\end{align}</script><p>  ​    做内积，可以得到：</p><script type="math/tex; mode=display">  \begin{align}\left \langle A\alpha _{1} ,\alpha _{2}  \right \rangle &=\left \langle \lambda _{1} \alpha _{1} ,\alpha _{2} \right \rangle\\(A\alpha _{1})^{T}\alpha _{2}&= \lambda _{1} \alpha _{1}^{T}  \alpha _{2}\\\alpha _{1}^{T}A^{T}\alpha _{2}&= \lambda _{1} \alpha _{1}^{T}  \alpha _{2}\\\alpha _{1}^{T}A\alpha _{2}&= \lambda _{1} \alpha _{1}^{T}  \alpha _{2}\\\alpha _{1}^{T}\lambda _{2} \alpha _{2}&= \lambda _{1} \alpha _{1}^{T}  \alpha _{2}\\(\lambda _{2}-\lambda _{1})\alpha _{1}^{T}\alpha _{2}&=0\end{align}</script><p>  ​    又因为 $\lambda _{1}\ne \lambda _{2}$ ，所以：</p><script type="math/tex; mode=display">  \alpha _{1}^{T}\alpha _{2}=0</script><p>  ​    证毕。</p></li></ul><p><strong>正交相似</strong>：矩阵 $A,B$ 是同阶矩阵，存在正交矩阵 $P$ ，使得 $P^{-1} AP=B$ 成立，那么称 $A$ 是 $B$ 的正交相似矩阵。</p><p><strong>定理</strong>：设 $A$ 为 $n$ 阶实对称矩阵，则存在正交矩阵 $Q$ ，使得</p><script type="math/tex; mode=display">\displaystyle Q^{-1} AQ = Q^{T} AQ  =\Lambda =\begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script><p>其中 $\displaystyle \lambda _{1},\lambda _{2},\dots ,\lambda _{n} $ 为 $A$ 的特征值。</p><p><strong>推论</strong>：设 $A$ 为 $n$ 阶实对称矩阵， $\lambda$ 为 $A$ 的 $k$ 重特征值，则 $A$ 必有 $k$ 个对应于特征值 $\lambda$ 的线性无关的特征向量。</p><hr><p><font color="red"><strong>求解步骤</strong></font>：给定实对称矩阵 $A$ ，求正交矩阵 $Q$ ，使得 $Q^{-1} AQ=\Lambda $ 。</p><ol><li>求出矩阵 $A$ 的所有特征值；</li><li>求出矩阵 $A$ 的所有特征向量（对于 $k$ 重根，要求出对应的一个基础解系）；</li><li>将求出的所有特征向量正交化，单位化；</li><li>特征向量按照<strong>列向量</strong>依次排列成矩阵 $Q$ ，对应的对角矩阵的主对角线依次是对应的<strong>特征值</strong>。</li></ol><blockquote><p>注意：在进行特征向量正交化的时候要注意</p><ul><li>如果所有特征值都不相同，即没有重根，那么对应的特征向量就是正交的；</li><li>如果有 $k$ 重根，但是不同根之间依旧还是正交的，因此，只需要处理 $k$ 重根对应的 $k$ 个线性无关的特征向量，使其正交化就行了，即仅给 $k$ 重根对应的特征向量进行<a href="#施密特正交化">施密特正交化</a>。</li></ul></blockquote><h1 id="六、二次型"><a href="#六、二次型" class="headerlink" title="六、二次型"></a>六、二次型</h1><h2 id="6-1-二次型的定义"><a href="#6-1-二次型的定义" class="headerlink" title="6.1 二次型的定义"></a>6.1 二次型的定义</h2><p>顾名思义，二次型就是每一项全为<strong>二次</strong>的多项式。</p><p><strong>定义（<font color="red">二次型</font>）</strong>：已知 $n$ 个<strong>变量</strong> $\displaystyle x_{1},x_{2},\cdots ,x_{n} $ 的二次齐次多项式</p><script type="math/tex; mode=display">\begin{align}f(x_{1},x_{2},\cdots ,x_{n}) &=a_{11}x_{1}^{2}+2a_{12}x_{1}x_{2}+\dots + 2a_{1n}x_{1}x_{n}\\& \quad +a_{22}x_{2}^{2}+2a_{23}x_{2}x_{3}+\dots + 2a_{2n}x_{2}x_{n}\\&\quad +\cdots \\&\quad + a_{nn}x_{n}^{2}     \end{align}</script><p>称为 $n$ 元<font color='red'><strong>二次型</strong></font>。 $a_{ij}$ 称为二次型 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 的系数，当 $a_{ij}$ 为实数时，称 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 为<strong>实二次型</strong>；当 $a_{ij}$ 为复数时，称 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 为<strong>复二次型</strong>。其中含平方的称为<strong>平方项</strong>，其余的称为<strong>交叉项</strong></p><p>令 $\color{Red} \mathbf{a_{ij}=a_{ji}} $  ，通过这样将交叉项进行拆分，那么二次型可以表示为下面的形式：</p><script type="math/tex; mode=display">\begin{matrix} f(x)= & a_{11}x_{1}^{2}& + &  a_{12}x_{1}x_{2} & + & \dots  & + &  a_{1n}x_{1}x_{n} \\  & a_{21}x_{2}x_{1} & + & a_{22}x_{2}^{2} & + & \dots & + & a_{2n}x_{2}x_{n}\\  &  &  &  & \cdots  &  &  & \\  & a_{n1}x_{n}x_{1} & + & a_{n2}x_{n}x_{2} & + & \dots  & + &a_{nn}x_{n}^{2}\end{matrix}</script><p>令 $x=\begin{bmatrix} x_{1}  &amp; x_{2} &amp; \cdots  &amp;x_{n}\end{bmatrix}^{T} $ 和矩阵 $\displaystyle A=\begin{bmatrix} a_{11}  &amp; a_{12} &amp; \cdots  &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n}\\ \vdots  &amp; \vdots &amp; \ddots  &amp; \vdots\\ a_{n1} &amp; a_{n2} &amp; \cdots &amp;a_{nn}\end{bmatrix}$ ，那么二次型可以用矩阵形式表示为</p><script type="math/tex; mode=display">f(x)=x^{T}Ax</script><p>其中 $\displaystyle A = A^{T} $ 为<strong>对称矩阵</strong>，将上式称为二次型的矩阵形式，对称矩阵 $A$ 称为二次型的矩阵， $A$ 的秩称为<strong>二次型的秩</strong>。</p><p><strong>二次型矩阵化一般多项式的步骤</strong>：</p><ol><li>判断<strong>矩阵</strong>是否为对称矩阵（<strong>二次型矩阵一定是对称矩阵</strong>）；</li><li>主对角线元素直接作为平方项；</li><li>去主对角线右上角元素的 2 倍，所谓交叉项的系数。</li></ol><p><strong>标准型二次型</strong>：只含平方项的二次型，称为<strong>标准二次型</strong>，且对应的二次型矩阵为对角型矩阵。</p><blockquote><p>很显然，二次型 $\displaystyle x^{T} Ax$ 为标准形的<strong>充分必要</strong>条件是 $A$ 为对角矩阵。研究二次型的目的之一，就是寻找一个线性变化将其化为标准形。</p></blockquote><p><strong>二次型的标准化</strong>：已知二次型为 $f(x)=x^{T} Ax$ ，矩阵 $A$ 为一般对称矩阵，如果存在 $x=Cy$ ，使得</p><script type="math/tex; mode=display">f(y)=(Cy)^{T} ACy=y^{T}C^{T}ACy =y^{T}\Lambda y</script><p>成立，那么称此过程为二次型的标准化过程。</p><blockquote><p><a name="二次型标准化总结">总结</a>：二次型的标准化过程，就是看看能不能找到一个矩阵，使得 $C^{T} AC=\Lambda $ 成立。已知 $A$ 是<strong>对称矩阵</strong>，而在之前的学习中知道<strong>对称矩阵必定能够对角化</strong>，即 $C^{-1} AC=\Lambda $ （ $C$ 是由特征列向量依次排列组成的方阵， $\Lambda$ 是对角矩阵，主对角线依次是对应的特征值）。如果 $C^{-1} =C^{T} $ 即 $C^{-1}AC =C^{T}AC=\Lambda  $ ，那就找到了满足条件的矩阵。而满足 $C^{-1} =C^{T}$ 说明矩阵 $C$ 是正交矩阵，最终目的就是<strong>计算出矩阵 $A$ 的特征向量正交化、单位化之后，组成的正交矩阵 $C$ </strong>。</p></blockquote><h2 id="6-2-矩阵的合同"><a href="#6-2-矩阵的合同" class="headerlink" title="6.2 矩阵的合同"></a>6.2 矩阵的合同</h2><p><strong>定义（矩阵的合同）</strong> ：设 $A,B$ 为 $n$ 阶矩阵。如果存在可逆矩阵$C$ ，使 $\displaystyle C^{T} AC=B$ ，则称 $A$ 与 $B$ 是<font color='red'>合同的</font>，记作 $\displaystyle A\simeq B$ 。</p><p>合同的性质：</p><ul><li>自反性：对任意 $n$ 阶矩阵，有 $\displaystyle A\simeq A$ ；</li><li>对称性：若 $\displaystyle A\simeq B$ ，则$\displaystyle B\simeq A$ ；</li><li>传递性：若 $\displaystyle A\simeq B,B\simeq C$ ，则 $\displaystyle A\simeq C$ 。</li></ul><p><strong>定理</strong> ：设 $n$ 阶矩阵$A$ 与 $B$ 合同，且 $A$ 为对称矩阵，则 $B$ 也是对称矩阵，且秩相等</p><script type="math/tex; mode=display">\displaystyle R(A) = R(B)</script><p><strong>定理</strong>：如果 $\displaystyle A\simeq B$ ，且 $A,B$ 是可逆矩阵，那么 $A^{-1} \simeq B^{-1}$ 。</p><h2 id="6-3-化二次型为标准型"><a href="#6-3-化二次型为标准型" class="headerlink" title="6.3 化二次型为标准型"></a>6.3 化二次型为标准型</h2><p><strong>定理</strong> ：任何实二次型 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} ) = x^{T} Ax$ 总可以经过适当的<strong>可逆线性（非退化线性）</strong>变换化为规范形，而且规范形是唯一 的。</p><p><strong>定义</strong> ：实二次型 $\displaystyle f(x) = x^{T} Ax$ 的标准形中正平方项的个数 $p$ 称为二次型 $f$ 的<font color='red'>正惯性指数</font>；负平方项的个数 $q$ 称为二次型 $f$ 的<font color='red'>负惯性指数</font>；它们的差 $p-q$ 称为二次型 $f$ 的<font color='red'>符号差</font>。</p><h3 id="6-3-1-配方法"><a href="#6-3-1-配方法" class="headerlink" title="6.3.1 配方法"></a>6.3.1 配方法</h3><p>利用公式 $\displaystyle (a\pm b)^{2} = a^{2}\pm 2ab+b^{2} $ 和 $\displaystyle (a-b)(a+b) = a^{2}-b^{2}$ 将二次型配成标准形的方法，称为<strong>配方法</strong>。</p><blockquote><p>注意：最终是要求得线性变换得矩阵 $C$ ，即 $x=Cy$ 。</p></blockquote><h3 id="6-3-2-初等变换"><a href="#6-3-2-初等变换" class="headerlink" title="6.3.2 初等变换"></a>6.3.2 初等变换</h3><p>求解满足 $C^{T} AC=\Lambda $ 的矩阵 $C$ 。</p><p>设 $C=P_{1} P_{2} \cdots P_{s} $ ，那么能得到：</p><script type="math/tex; mode=display">\begin{align}EP_{1} P_{2} \cdots P_{s} & = C\\P^{T}_{s}\cdots P^{T}_{2}P^{T}_{1}  AP_{1} P_{2} \cdots P_{s} & = \Lambda \end{align}</script><p>那么，就能得到：</p><ol><li>对 $A,E$ 做同样的初等列变换</li><li>只对 $A$ 做相应的初等行变换（注：相应的初等行变换是指，列怎么变，行就怎么变）</li><li>当 $A$ 化为对角阵时，单位矩阵 $E$ 就能化成矩阵 $C$ 。</li></ol><h3 id="6-3-3-正交替换"><a href="#6-3-3-正交替换" class="headerlink" title="6.3.3 正交替换"></a>6.3.3 正交替换</h3><p>根据前面的<a href="#二次型标准化总结">二次型标准化总结</a>可知，化二次型为标准型，就是去求矩阵 $A$ 的特征向量正交化、单位化后，构成的正交矩阵，就是线性替换 $x=Cy$ 中的矩阵。下面用一个完整例题来进行正交替换得讲解。</p><hr><p><strong>例题（化二次型为标准型）</strong>：</p><h2 id="6-4-正定二次型"><a href="#6-4-正定二次型" class="headerlink" title="6.4 正定二次型"></a>6.4 正定二次型</h2><p>在数学、物理、力学领域中都有广泛应用的实二次型———<font color='red'>正定二次型</font>。</p><p><strong>定义</strong> ：设 $\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax$ 为 $n$ 个变量的实二次型。</p><p>（1）如果对任何非零向量 $x = (x_{1},x_{2},\dots ,x_{n} )$ ，都有</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax >0\quad(<0)</script><p>则称 $f = x^{T} Ax$ 为<strong>正定（负定）二次型</strong>，并称二次型矩阵 $A$ 为<strong>正定（负定）矩阵</strong>。</p><p>（2）如果对任何非零向量 $x = (x_{1},x_{2},\dots ,x_{n} )$ ，都有</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax \ge 0\quad(\le 0)</script><p>则称 $f = x^{T} Ax$ 为<strong>半正定（半负定）二次型</strong>，并称二次型矩阵 $A$ 为<strong>半正定（半负定）矩阵</strong>。</p><p>（3）如果二次型 $\displaystyle f(x_{1},x_{2},\dots ,x_{n} )$ 既不是半正定，也不是半负定的，就称 $f = x^{T} Ax$ 为不定的，矩阵 $A$ 称为<strong>不定矩阵</strong>。</p><p>将二次型化为标准型后，得 $f(y)=y^{T}\Lambda y$ ，那么</p><ol><li>主对角线元素全为正数，则是正定；</li><li>主对角线元素全为负数，则是负定；</li><li>主对角线元素全为非负数，则是半正定；</li><li>主对角线元素全为非正数，则是半负定；</li><li>主对角线元素有正有负可能有0，则是不定。</li></ol><blockquote><p>正定、负定、半正定、半负定都是<strong>有定的</strong>。</p></blockquote><hr><p><strong>定理</strong>：<strong>可逆的线性变换不改变二次型的正定性</strong>。</p><p><strong>推论</strong>：设 $n$ 阶实矩阵 $A$ 与 $B$ 合同，则 $A$ 正定的充分必要条件是 $B$ 也正定。</p><p><strong>定理</strong>：设 $\displaystyle f(x_{1},x_{2},\dots ,x_{n}) = x^{T} Ax$ 是 $n$ 元实二次型，则下面命题等价：</p><ol><li>$\displaystyle f = x^{T} Ax$ 是正定二次型，即矩阵 $A$ 是正定矩阵；</li><li>$A$ 的特征值均为正数；</li><li>$\displaystyle f = x^{T} Ax$ 的正惯性指数为 $n$ ；</li><li>$A$ 与单位矩阵 $E$ 合同；</li><li>存在可逆矩阵 $B$ ，使得 $\displaystyle A = B^{T} B$ 。</li></ol><p><strong>推论</strong>：设 $\displaystyle A = (a_{ij} )$ 是 $n$ 阶正定矩阵，则：</p><ol><li>矩阵 $A$ 的主对角线元 $\displaystyle a_{ij}&gt; 0$ ；</li><li>矩阵 $A$ 的行列式 $\displaystyle \left | A \right | &gt; 0$ 。</li></ol><p><strong>定义</strong>：设 $\displaystyle A = (a_{ij} )$ 是 $n$ 阶方阵，依次取 $A$ 的前 $k$ 行与前 $k$ 列所构成的子式</p><script type="math/tex; mode=display">\Delta _{k}  = \begin{bmatrix} a_{11}  & a_{12} & \dots  &a_{1k}\\ a_{21} & a_{22} & \dots  &a_{2k} \\\vdots   & \cdots  & \ddots  &\vdots  \\ a_{k1} &  a_{k2} & \dots  & a_{kk}\end{bmatrix},\quad k = 1,2,\dots ,n</script><p>称为矩阵 $A$ 的 <strong>$k$ 阶顺序主子式</strong>。</p><p><strong>定理</strong>： $n$ 元实二次型 $\displaystyle f(x_{1},x_{2},\dots ,x_{n}) = x^{T} Ax$ 正定的充要条件是 $A$ 的 $n$ 个顺序主子式均大于零，该定理也称为<strong>霍尔维茨定理</strong>。</p><p><strong>推论</strong>：对于 $n$ 元实二次型 $\displaystyle f = x^{T} Ax$ ，则下面命题等价：</p><ol><li>$f$ 是负定二次型；</li><li>$f$ 的负惯性指数为 $n$ ；</li><li>$A$ 的特征值全为负数；</li><li>$A$ 合同于 $-E$ ；</li><li>$A$ 的奇数阶顺序主子式全为负数，偶数阶顺序主子式全为正数。</li></ol><h1 id="七、线性空间"><a href="#七、线性空间" class="headerlink" title="七、线性空间"></a>七、线性空间</h1><h2 id="7-1-线性空间"><a href="#7-1-线性空间" class="headerlink" title="7.1 线性空间"></a>7.1 线性空间</h2><h3 id="7-1-1-数域和元素"><a href="#7-1-1-数域和元素" class="headerlink" title="7.1.1 数域和元素"></a>7.1.1 数域和元素</h3><p><strong>定义（数域）</strong>：设 $F$ 是一个至少包含数 0 和 1 的集合，如果 $F$ 中任意两个数的和、差、积、商（除数不为 0 ）都在 $F$ 中，则称 $F$ 是一个<strong><font color='red'>数域</font></strong>。</p><blockquote><p>有理数集 $Q$ 、实数集 $R$、复数集 $C$ 都是数域，他们分别称为<strong>有理数域</strong>、<strong>实数域</strong>、<strong>复数域</strong>。</p></blockquote><p>若集合 $V$ 中定义了某种运算， $V$ 中的任意元素进行运算所得到的结果均在 $V$ 中，则称这种运算是<strong>封闭的</strong>。</p><h3 id="7-1-2-线性空间的定义"><a href="#7-1-2-线性空间的定义" class="headerlink" title="7.1.2 线性空间的定义"></a>7.1.2 线性空间的定义</h3><p><strong>定义</strong>：设 $V$ 是一个非空集合。其元素用 $\displaystyle \alpha ,\beta, \gamma ,\delta ,\dots $ <strong>向量</strong>表示，$F$ 是一个数域，其元素用 $\displaystyle k,l,m,n,\dots $ 表示。并且满足下面条件：</p><ol><li>在集合 $V$ 的元素之间定义了一种运算，叫做<strong>加法</strong>。即对于 $V$ 中任意两个元素 $\alpha$ 和 $\beta  $  ，在 $V$ 中都有唯一的元素 $\gamma $ 与之对应，称为 $\alpha$ 和 $\beta $ 的和，记作 $\gamma = \alpha +\beta $ 。</li><li>在数域 $F$ 的数与集合 $V$ 的元素之间定义了一种运算，叫做<strong>数量乘法</strong>，也就是说，对于 $F$ 任意一个数 $k$ 与 $V$ 中任一元素 $\alpha$ ，在 $V$ 中都有唯一的元素 $\delta $ 与之对应，$\delta = k\alpha $ 称为 $k$ 与 $\alpha$ 的数量积。</li><li>$V$ 中定义的加法与数量乘法满足下列运算律：<ol><li>$\alpha +\beta = \beta +\alpha $ ；</li><li>$(\alpha +\beta)+ \gamma  = \alpha +(\beta +\gamma )$ ；</li><li>在 $V$ 中有一个元素 <strong>0</strong> ，对 $V$ 中任一元素 $\alpha$ ，都有 $\alpha +0 = \alpha $ （具有这性质的元素称为零元素）；</li><li>对于 $V$ 中任一元素 $\alpha$ ，都存在 $V$ 中元素 $\beta $ ，使 $\alpha +\beta =0$ ，称 $\beta $ 为 $\alpha$ 的负元素；</li><li>$k(\alpha +\beta ) = k\alpha +k\beta $ ；</li><li>$(k+l)\alpha = k\alpha +l\alpha $ ；</li><li>$k(l\alpha ) = (kl)\alpha $ ；</li><li>$1\alpha = \alpha $ ；</li></ol></li></ol><p>则称 $V$ 为数域 $F$ 上的<font color='red'><strong>线性空间（或向量空间）</strong></font>，简称 $V$ 的<strong>线性空间</strong>或<strong>向量空间</strong>。</p><p>$V$ 中所定义的加法以及数量乘法运算统称为 $V$ 的<strong>线性运算</strong>。 $V$ 中的元素也称为向量， $F$ 中的元素也称为<strong>数量</strong>或<strong>标量</strong>。当 $F$ 为实数域 $R$ 时，称 $V$ 为<strong>实线性空间</strong>；当 $F$ 为复数域 $C$ 时，称 $V$ 为<strong>复线性空间</strong>。</p><h3 id="7-1-3-线性空间的性质"><a href="#7-1-3-线性空间的性质" class="headerlink" title="7.1.3 线性空间的性质"></a>7.1.3 线性空间的性质</h3><p><strong>性质</strong>：零向量是唯一的。</p><p><strong>性质</strong>：向量空间 $V$ 中的每个向量的复向量是唯一的。</p><p><strong>性质</strong>：对向量空间 $V$ 中任一向量 $\alpha $ 与任一数 $k$ ，有 $0\alpha =0$ ；$k0=0$ ；$(-1)\alpha =\alpha $ 。</p><h3 id="7-1-4-线性子空间"><a href="#7-1-4-线性子空间" class="headerlink" title="7.1.4 线性子空间"></a>7.1.4 线性子空间</h3><p><strong>定义</strong>：若 $W$ 为数域 $F$ 上的线性空间 $V$ 的非空子集，且 $W$ 满足如下条件：</p><ol><li>对任意的 $k\in F$ ，$a\in W$ ，则 $k\alpha \in W$ ；</li><li>对任意的 $\alpha ,\beta \in W$ ，则 $\alpha+\beta \in W$ ；</li></ol><p>则称 $W$ 为 $V$ 的<font color='red'>线性子空间</font>，简称<strong>子空间</strong>。换句话说，当且仅当 $W$ 对 $V$ 中的加法与数乘运算是封闭的，$W$ 是向量空间 $V$ 的子空间。</p><p>若 $W$ 是线性空间 $V$ 的子空间，由定义不难得出，它也是线性空间。</p><h2 id="7-2-线性空间的基与向量坐标"><a href="#7-2-线性空间的基与向量坐标" class="headerlink" title="7.2 线性空间的基与向量坐标"></a>7.2 线性空间的基与向量坐标</h2><h3 id="7-2-1-基、维数、坐标"><a href="#7-2-1-基、维数、坐标" class="headerlink" title="7.2.1 基、维数、坐标"></a>7.2.1 基、维数、坐标</h3><p><strong>定义</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 是数域 $F$ 上的线性空间 $V$ 中的 $m$ 个向量， $k_{1} ,k_{2} ,\cdots ,k_{m} $ 是 $F$ 中的数，则称 $k_{1}a_{1}+k_{2}a_{2}+\cdots +k_{m}a_{m} = \beta $ 为向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 的一个线性组合，或者 $\beta $ 可由向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 线性表示。</p><p><strong>定义</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 是数域 $F$ 上的线性空间 $V$ 中向量，若存在 $F$ 中不全为零的数 $k_{1},k_{2},\dots ,k_{m}$ ，使 $k_{1}a_{1}+k_{2}a_{2}+\cdots +k_{m}a_{m} = 0$ ，则称向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ <strong>线性相关</strong>；否则称向量组<strong>线性无关</strong>。</p><p><strong>定义</strong>：设 $V$ 是数域 $F$ 上的线性空间， $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 是 $V$ 中 $n$ 个线性无关的向量，若 $V$ 中任一向量 $a$ 均可由 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 线性表示，则称线性空间 $V$ 是 <strong>$n$ 维线性空间</strong>， $n$ 称为 $V$ 的<strong>维数</strong>，记作： $\text{dim} V = n$ ，而称 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 为 $V$ 的一组<strong>基</strong>。如果 $V$ 中有任意多个线性无关向量，则称 <script type="math/tex">V</script> 是<strong>无限维线性空间</strong>。</p><p><strong>定义</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 是 $n$ 维线性空间 $V$ 的一组基，$\beta \in V$ 且有</p><script type="math/tex; mode=display">\beta = x_{1}a_{1}+x_{2}a_{2} +\dots  +x_{n}a_{n}</script><p>则称 $\begin{bmatrix} x_{1} &amp; x_{2} &amp; \cdots &amp;x_{n}\end{bmatrix}^{T}$ 为 $\beta $ 在基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 下的<strong>坐标向量</strong>。并且令 $x=\begin{bmatrix} x_{1} &amp; x_{2} &amp; \cdots &amp;x_{n}\end{bmatrix}^{T}$ ，且令矩阵 $A= \begin{bmatrix} \alpha _{1}  &amp;  \alpha _{2} &amp; \cdots  &amp; \alpha _{n}\end{bmatrix}$ ，那么上述等式就转化为</p><script type="math/tex; mode=display">\beta =Ax</script><p>即：</p><ul><li>左边：线性空间 $V$ 中的任一向量（元素）；</li><li>右边：线性空间 $V$ 的一组<strong>基</strong>构成的<strong>基矩阵</strong>乘以<strong>向量在该基下的坐标</strong>。</li></ul><h3 id="7-2-2-基变换与坐标变换"><a href="#7-2-2-基变换与坐标变换" class="headerlink" title="7.2.2 基变换与坐标变换"></a>7.2.2 基变换与坐标变换</h3><p>设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 与 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 为 $n$ 维线性空间 $V$ 的两组基，则 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 可由 $V$ 的基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 表示：</p><script type="math/tex; mode=display">\left\{\begin{matrix} \beta _{1}  & = & b_{11}a _{1}   & + & b_{21}a _{2} & + & \dots  & + & b_{n1}a _{n}\\ \beta _{2} & = & b_{12}a _{1} & + & b_{22}a _{2} & + & \dots  & + & b_{n2}a _{n}\\  &  & \vdots  &  &  &  &  &  & \\ \beta _{n} & = & b_{1n}a _{1}   & + & b_{2n}a _{2}   & + & \dots  & + &b_{nn}a _{n}  \end{matrix}\right.</script><p>或者写成矩阵形式</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) \begin{bmatrix} b_{11}  & b_{12}  &  \cdots &  b_{1n}\\ b_{21}  &  b_{22} &  \cdots  &  b_{2n}\\ \vdots  &  \vdots& \ddots  & \vdots\\  b_{n1} &  b_{n2} &  \cdots & b_{nn}\end{bmatrix}</script><p>若记 $B = (b_{ij} )_{n\times n} $ ，那么就可以简写为：</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) B</script><p>则称 $n$ 阶矩阵 $B$ 为由基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 到基 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 的<strong>过渡矩阵</strong>。</p><p>过渡矩阵有以下性质：</p><ol><li>过渡矩阵 $B$ 的第 $j$ 列恰为 $\beta _{j} $ 在基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 下的坐标；</li><li>过渡矩阵 $B$ 可逆。事实上，因为 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 线性无关，则 $A$ 的列向量组线性无关，故 $B$ 为可逆矩阵。</li></ol><p><strong>定理</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 与 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 为 $n$ 维线性空间 $V$ 的两组基，由 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 到基 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 的过渡矩阵为 $B = (b_{ij} )_{n\times n} $ ，即</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) B</script><p>若向量 $\eta $ 在这两组基下的坐标分别为 $x = (x_{1},x_{2},\dots ,x_{n} )^{T} $ 和 $y = (y_{1},y_{2},\dots ,y_{n} )^{T} $ ，那么</p><script type="math/tex; mode=display">\mathbf{x}  = \mathbf{Ay} \text{或者} \mathbf{y}  =\mathbf{ A^{-1}x }</script><p>上式被称为<strong>坐标变换公式</strong>。</p><blockquote><p>在向量不变的前提下，线性空间的<strong>基</strong>发生变化，那么向量的<strong>坐标</strong>也会发生对应的变化</p></blockquote><h2 id="7-3-线性变换"><a href="#7-3-线性变换" class="headerlink" title="7.3 线性变换"></a>7.3 线性变换</h2><h3 id="7-3-1-映射"><a href="#7-3-1-映射" class="headerlink" title="7.3.1 映射"></a>7.3.1 映射</h3><p><strong>定义 5.8</strong>：设 $M$ 与 $N$ 是两个非空集合，如果有一个法则 $f$ ，使得对 $M$ 中的每个元素 $a$ 都有 $N$ 中唯一确定的 $b$ 与之对应，那么就称 $f$ 是 $M$ 到 $N$ 的一个<strong>映射</strong>，记作</p><script type="math/tex; mode=display">f:\mathbf{M} \to \mathbf{N}</script><p>并称 $b$ 为 $a$ 在 $f$ 下的<strong>像</strong>，而 $a$ 称为 $b$ 在映射 $f$ 下的一个<strong>原像</strong>，记作</p><script type="math/tex; mode=display">f:a\to b\quad \textbf{或} f(a) = b</script><p>集合 $M$ 称为映射 $f$ 的<strong>定义域</strong>。如果对于任意的 $\displaystyle a,b\in M$ ，都有 $f(a)\ne f(b)\quad (a\ne b)$ ，则称 $f$ 是<strong>单射</strong>；如果对于任意的 $b\in N,a\in M$ ，都有 $f(a)=b$ ，则称 $f$ 是<strong>满射</strong>；如果 $f$ 既是单射又是满射，则称 $f$ 是<strong>双射</strong>（或称为<strong>一一映射</strong>）。</p><h3 id="7-3-2-线性变换的定义"><a href="#7-3-2-线性变换的定义" class="headerlink" title="7.3.2 线性变换的定义"></a>7.3.2 线性变换的定义</h3><p><strong>定义</strong>：设数域 $F$ 上的线性空间 $V_{1} $ 和 $V_{2} $ 分别是 $n$ 和 $m$ 维的。 $T$ 是 $V_{1} $ 到 $V_{2} $ 的一个映射，且满足：</p><ol><li>对任意的 $\alpha ,\beta \in V_{1} $ ，有 $T(\alpha +\beta )=T(\alpha )+T(\beta )$ ；</li><li>对任意的 $\alpha \in V,k\in F$ ，有 $T( k\alpha)=kT(\alpha )$ ；</li></ol><p>则称 $T$ 是从线性空间 $V_{1} $ 到 $V_{2} $ 的<strong>线性映射</strong>。若 $V_{2} =F$ ，则称该线性映射为<strong>线性函数</strong>；若 $V_{1} =V_{2} $ ，则称该线性映射为线性空间$V_{1}$ 上的线性变换，简称<strong>线性变换</strong>。</p><blockquote><p>只有<strong>高维空间投影到低维空间</strong>，而不能从<strong>低维空间或投影到高维空间</strong>，也就是说，只能有<strong>高维观测低位而不能有低维观测高维</strong>。</p></blockquote><h3 id="7-3-3-线性变换的性质"><a href="#7-3-3-线性变换的性质" class="headerlink" title="7.3.3 线性变换的性质"></a>7.3.3 线性变换的性质</h3><p><strong>性质</strong>： $T(0) = 0$ 。</p><p><strong>性质</strong>： $T(-\alpha ) = -T(\alpha )$ 。</p><p><strong>性质</strong>：若 $\beta = k_{1}\alpha _{1}+k_{2}\alpha _{2}+\dots +k_{m}\alpha _{m} $ ，则</p><script type="math/tex; mode=display">T(\beta ) = k_{1}T\left ( \alpha_{1} \right )+k_{2}T\left ( \alpha _{2} \right ) +\dots +k_{m}T\left ( \alpha _{m}   \right )</script><p><strong>性质</strong>：若向量组 $\alpha _{1},\alpha _{2},\dots ,\alpha _{m}  $ 线性相关，则向量组 $T\left ( \alpha _{1}\right ),T\left ( \alpha _{2} \right ) ,\dots,T\left ( \alpha _{m}   \right )$ 也线性相关。</p><h2 id="5-4-线性变换的矩阵表示"><a href="#5-4-线性变换的矩阵表示" class="headerlink" title="5.4 线性变换的矩阵表示"></a>5.4 线性变换的矩阵表示</h2><h3 id="5-4-1-线性变换的矩阵"><a href="#5-4-1-线性变换的矩阵" class="headerlink" title="5.4.1 线性变换的矩阵"></a>5.4.1 线性变换的矩阵</h3><p>设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 是 $n$ 维线性空间 $V$ 的一组基，$T$ 是 $V$ 上的线性变换，那么对 $V$ 中的向量</p><script type="math/tex; mode=display">{\color{Red}  \xi =x_{1} \alpha _{1}+x_{2} \alpha _{2}+\dots +x_{n} \alpha _{n}}</script><p>由线性变换的性质，有</p><script type="math/tex; mode=display">{\color{blue} T\left ( \xi \right )  =x_{1} T\left ( \alpha _{1} \right ) +x_{2} T\left ( \alpha _{2} \right ) +\dots +x_{n} T\left ( \alpha _{n} \right ) }</script><p>因此，对于线性变换 $T$ ，如果知道 $T$ 关于基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 的像 $T\left ( \alpha _{1} \right ) , T\left ( \alpha _{2} \right ),\dots ,T\left ( \alpha _{n} \right )$ ，则 $V$ 中任一向量 $\xi $ 的像 $T\left ( \xi \right ) $ 就完全确定。</p><p>由于 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 的像 $T\left ( \alpha _{1} \right ) , T\left ( \alpha _{2} \right ),\dots ,T\left ( \alpha _{n} \right )$ 可由 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 线性表示，即有：</p><script type="math/tex; mode=display">\left\{\begin{matrix} T(\alpha _{1} ) & = & {\color{Violet} a_{11}} \alpha _{1} & + &  {\color{Violet} a_{21}} \alpha _{2}  & + & \dots  & + &  {\color{Violet} a_{n1}} \alpha _{n} \\  T(\alpha _{2} ) & = &  {\color{Violet} a_{12}} \alpha _{1}  & + &  {\color{Violet} a_{22}} \alpha _{2}  & + & \dots & + &  {\color{Violet} a_{n2}} \alpha _{n} \\  &  &  & \vdots  &  &  &  &  & \\  T(\alpha _{n} ) & = &  {\color{Violet} a_{1n}} \alpha _{1}  & + &  {\color{Violet} a_{2n}} \alpha _{2}  & + & \dots & + & {\color{Violet} a_{nn}} \alpha _{n} \end{matrix}\right.</script><p>若记</p><script type="math/tex; mode=display">\begin{align}T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} ) & = T(\alpha _{1})+T(\alpha _{2})+\dots +T(\alpha _{n})\\ \displaystyle & = (\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\begin{bmatrix}{\color{Violet}  a_{11}}   & {\color{Violet}  a_{12}} & \dots  & {\color{Violet}  a_{1n}}\\ {\color{Violet}  a_{121}} & {\color{Violet}  a_{22}} & \cdots  & {\color{Violet}  a_{2n}}\\ \vdots  & \vdots  &  \ddots &\vdots  \\ {\color{Violet}  a_{n1}} & {\color{Violet}  a_{n2}} & \dots  &{\color{Violet}  a_{nn}}\end{bmatrix}\end{align}</script><p>或者</p><script type="math/tex; mode=display">T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )  =(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\mathbf{A}</script><p><strong>定义</strong>：设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 为 $n$ 维线性空间 $V$ 的一组基， $T$ 为 $V$ 的一个线性变换。若 $n$ 阶矩阵 $A$ 满足</p><script type="math/tex; mode=display">T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )  =(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\mathbf{A}</script><p>则称 $n$ 阶矩阵 $A$ 为线性变换 $T$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的<strong>表示矩阵</strong>。</p><p><strong>定理 </strong>：设 $T$ 是 $n$ 维线性空间 $V$ 上的线性变换， $T$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，向量 $\xi$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标为 $\mathbf{x} =(x_{1},x_{2},\dots ,x_{n})^{T} $ ， $T(\xi )$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标为 $\mathbf{y} =(y<em>{1},y</em>{2},\dots ,y_{n})^{T} $ ，则</p><script type="math/tex; mode=display">\mathbf{y = Ax}</script><h3 id="7-4-2-线性变换在不同矩阵基下矩阵的关系"><a href="#7-4-2-线性变换在不同矩阵基下矩阵的关系" class="headerlink" title="7.4.2 线性变换在不同矩阵基下矩阵的关系"></a>7.4.2 线性变换在不同矩阵基下矩阵的关系</h3><p><strong>定理 5.3</strong>：设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 和 $\beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 是 $n$ 维线性空间 $V$ 的两组基， $V$ 上的线性变换 $T$ 在这两种基下的矩阵分别为 $A$ 和 $B$ ，且从基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 到基 $\beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 的过渡矩阵为  $P$ ，那么</p><script type="math/tex; mode=display">\mathbf{B = P^{-1} AP}</script><h2 id="7-5-线性变换的特征值与特征向量"><a href="#7-5-线性变换的特征值与特征向量" class="headerlink" title="7.5 线性变换的特征值与特征向量"></a>7.5 线性变换的特征值与特征向量</h2><h3 id="7-5-1-特征值与特征向量"><a href="#7-5-1-特征值与特征向量" class="headerlink" title="7.5.1 特征值与特征向量"></a>7.5.1 特征值与特征向量</h3><p><strong>定义</strong>：设 $T$ 是数域 $F$ 上线性空间 $V$ 的线性变换，若存在数 $\lambda \in \mathbf{F} $ 和非零向量 $\alpha \in V$ ，使得</p><script type="math/tex; mode=display">T(\alpha ) = \lambda \alpha</script><p>则称 $ \lambda$ 为 $T$ 的一个特征值，而 $\alpha $ 称为 $T$ 属于特征值 $\lambda $ 的特征向量。</p><p><strong>定理 </strong>：设 $T$ 是 $n$ 维线性空间 $V$ 上的线性变换，$T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，则：</p><ol><li>$\lambda $ 是 $T$ 的特征值得充要条件是$\lambda $ 为 $A$ 的特征值；</li><li>$\alpha \in V$ 是 $T$ 的属于特征值 $\lambda $ 的特征向量的充要条件是 $\alpha $ 在基  $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标是矩阵 $A$ 的属于特征值 $\lambda $ 的特征向量。</li></ol><h3 id="7-5-2-值域与核"><a href="#7-5-2-值域与核" class="headerlink" title="7.5.2 值域与核"></a>7.5.2 值域与核</h3><p><strong>定义</strong>：设 $T$ 是线性空间 $V$ 中的线性变换，$V$ 中所有元素在 $T$ 下的像所组成的集合。</p><script type="math/tex; mode=display">\left \{ \beta |\beta  = T(\alpha ) ,\alpha \in V\right \}</script><p>称为 $T$ 的<strong>值域</strong>，记作 $\text{Im} T\quad \text{或者} T(V)$ 。零向量的所有原像的集合：</p><script type="math/tex; mode=display">\left \{ \alpha | T(\alpha )=0 ,\alpha \in V\right \}</script><p>称为 $T$ 的<strong>核</strong>，记作 $\text{Ker} T\quad \text{或者} T^{-1} (V)$ 。</p><p>关于线性变换的值域与核有以下性质：</p><ol><li>线性变换 $T$ 的值域 $\text{Im} T$ 是 $V$ 的子空间；</li><li>线性变换 $T$ 的核 $\text{Ker} T$ 是 $V$ 的子空间。</li></ol><p><strong>定理</strong>：设 $V$ 是 $n$ 维线性空间， $V$ 上的线性变换 $T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵 $A$ ，则</p><ol><li>$\text{Im} T$ 的维数等于向量组 $T(\alpha_{1}  ),T(\alpha_{2}  ),\dots ,T(\alpha_{n}  )$ 的<strong>秩</strong>，也等于矩阵 $A$ 的秩；</li><li>$\text{Im} T$ 的基是向量组 $T(\alpha_{1}  ),T(\alpha_{2}  ),\dots ,T(\alpha_{n}  )$ 的一个极大无关组。</li></ol><p><strong>定理</strong>：设 $V$ 是 $n$ 维线性空间， $V$ 上的线性变换 $T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，则</p><ul><li>$T$ 的核 $\text{Ker} T$ 的维数等于 $n-R(A)$ ；</li><li>$V$ 中齐次线性方程组 $Ax = 0$ 的基础解系构成 $T$ 的核 $\text{Ker} T$的基。</li></ul><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-21</p></div></div><div class='timeline-item-content'><ol><li>完成所有内容的整理</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-20</p></div></div><div class='timeline-item-content'><ol><li>完成<a href="#五、特征值与特征向量">五、特征值与特征向量</a>的整理</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-19</p></div></div><div class='timeline-item-content'><ol><li>完成<a href="#四、线性方程组">四、线性方程组</a>的整理</li><li>第五章部分内容整理。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-18</p></div></div><div class='timeline-item-content'><ol><li>完成<a href="#第三章向量">三、向量</a>的整理</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-13</p></div></div><div class='timeline-item-content'><ol><li>完成<a href="#一、行列式">一、行列式</a>的完善整理</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-12</p></div></div><div class='timeline-item-content'><ol><li>创建该文档</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先算法-BFS</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寻路算法是计算机科学中重要的算法之一，它被广泛应用于各种领域，包括游戏开发、机器人导航、路线规划等。寻路算法的目标是在给定的地图或图形结构中找到从起点到目标的最短路径。无论是追求游戏胜利，还是实现高效的路径规划，寻路算法都将成为你最可靠的导航助手。</p><p>特点：</p><ol><li>多样化的算法选择：寻路算法提供了多种不同的解决方案，包括广度优先搜索、迪杰斯特拉算法、A*算法等。每种算法都有其独特的特点和适用场景，你可以根据具体需求选择最合适的算法来解决问题。</li><li>快速、高效的路径计算：寻路算法通过智能的搜索策略，能够快速计算出最短路径。它们利用启发式信息、权重值和图形结构等因素，帮助你在最短的时间内找到目标位置。</li><li>可定制化的参数和设置：寻路算法允许你根据具体情况进行参数和设置的调整，以适应不同的需求。你可以调整地图的复杂度、路径优先级以及障碍物的影响等，来获得更符合期望的路径结果。</li><li>可视化展示与交互：寻路算法通常提供直观的可视化展示，让你清晰地看到算法是如何搜索和探索路径的过程。一些算法还支持交互操作，让你能够实时调整参数、添加障碍物，以及观察路径的变化。</li><li>广泛应用的实用性：寻路算法在游戏开发中广泛应用，能够实现 NPC 的导航、怪物追踪玩家等功能。此外，在实际生活中，它们也可以帮助规划最佳路线、优化运输路径、指导机器人移动等，提高效率和节省时间成本。</li></ol><blockquote><p>-</p></blockquote><h1 id="广度优先算法-BFS-介绍"><a href="#广度优先算法-BFS-介绍" class="headerlink" title="广度优先算法(BFS)介绍"></a>广度优先算法(BFS)介绍</h1><p>简介： 广度优先搜索（BFS）算法是一种经典的寻路算法。BFS 算法以一种系统的方式探索图形结构，并找到从起点到目标的最短路径。在游戏、路径规划和网络分析等领域，BFS 算法被广泛使用，它的简单直观性和可靠性使其成为一个强大的工具。</p><p>BFS 的基本思想是首先访问起始节点，然后依次访问与起始节点直接相邻的所有节点，接着访问与这些相邻节点相邻的节点，以此类推。换句话说，它按照距离起始节点的距离逐层进行搜索。</p><p>BFS 通常使用一个<strong>队列</strong>来辅助实现，通过将待访问节点加入队列尾部，再从队列头部取出节点进行访问。这种方式保证了节点的访问顺序是按照层级逐个展开的。</p><p>BFS 算法可以用于解决许多问题，如寻找图中两个节点之间的最短路径、查找图中的连通组件、生成最小生成树等。由于其特点是先广后深，因此 BFS 也常被用于无权图的最短路径搜索。</p><p><img src="https://imageshack.yuilexi.cn/Unity3D/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/BFS/DFS%E4%B8%8EBFS.gif" alt="DFS与BFS"></p><h1 id="Unity-中算法实现"><a href="#Unity-中算法实现" class="headerlink" title="Unity 中算法实现"></a>Unity 中算法实现</h1><p>Unity 中有不同的瓦片，下面以矩形瓦片来构建。</p><h2 id="1-先构造对应的结点"><a href="#1-先构造对应的结点" class="headerlink" title="1 先构造对应的结点"></a>1 先构造对应的结点</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-9</p></div></div><div class='timeline-item-content'><ol><li>创建文档</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 经典功能实现 </category>
          
          <category> 寻路算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 经典功能实现 </tag>
            
            <tag> 最短路径 </tag>
            
            <tag> 广度优先算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规则瓦片</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Unity%E5%BC%95%E6%93%8E/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/%E8%A7%84%E5%88%99%E7%93%A6%E7%89%87.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Unity%E5%BC%95%E6%93%8E/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/%E8%A7%84%E5%88%99%E7%93%A6%E7%89%87.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="一、规则瓦片"><a href="#一、规则瓦片" class="headerlink" title="一、规则瓦片"></a>一、规则瓦片</h1><h2 id="1-1-什么是规则瓦片"><a href="#1-1-什么是规则瓦片" class="headerlink" title="1.1 什么是规则瓦片"></a>1.1 什么是规则瓦片</h2><h2 id="1-2-规则瓦片的创建"><a href="#1-2-规则瓦片的创建" class="headerlink" title="1.2 规则瓦片的创建"></a>1.2 规则瓦片的创建</h2><p><img src="https://imageshack.yuilexi.cn/Unity3D/Unity引擎/瓦片地图/规则瓦片/规则瓦片的创建.png" alt="规则瓦片的创建.png"></p><h2 id="1-3-规则瓦片详解"><a href="#1-3-规则瓦片详解" class="headerlink" title="1.3 规则瓦片详解"></a>1.3 规则瓦片详解</h2><h1 id="二、瓦片面积大小-lt-单元格大小"><a href="#二、瓦片面积大小-lt-单元格大小" class="headerlink" title="二、瓦片面积大小&lt;= 单元格大小"></a>二、瓦片面积大小<code>&lt;=</code> 单元格大小</h1><blockquote><p>即：每个瓦片的像素点均在单个单元格内，不会超出单元格</p></blockquote><p>根据前面的计算，只考虑 <code>3*3</code> 的情况下，规则瓦片的所有情况一共有：256（$2^{8}$）种 。</p><p>但是，规定<strong>瓦片面积大小<code>&lt;=</code> 单元格大小</strong>时，有些情况下，瓦片使用的图片是一样的，因此，在该情况下，需要： 种精灵图像。</p><p>再将旋转或者翻转考虑进去时，最少仅仅需要 <strong><code>15张</code></strong> 精灵贴图，就能满足 256 种不同的情况</p><h1 id="三、瓦片面积大小-gt-单元格大小"><a href="#三、瓦片面积大小-gt-单元格大小" class="headerlink" title="三、瓦片面积大小 &gt; 单元格大小"></a>三、瓦片面积大小 <code>&gt;</code> 单元格大小</h1><blockquote><p>即：存在瓦片的像素点超出单个单元格，像素长宽大小大于单元格的长宽</p></blockquote><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-6-14</p></div></div><div class='timeline-item-content'><ol><li>创建文档</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Unity引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity3D </tag>
            
            <tag> Unity引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5基础</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0/01.%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6/1_HTML5/HTML5%E5%9F%BA%E7%A1%80.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0/01.%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6/1_HTML5/HTML5%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文章主要是介绍 HTML5 基础，包含 HTML5 的基本结构，标签，属性，以及一些常用的标签和属性的使用方法。</p><blockquote><p>快速到达</p></blockquote><h1 id="第一章-HTML-基础"><a href="#第一章-HTML-基础" class="headerlink" title="第一章 HTML 基础"></a>第一章 HTML 基础</h1><h2 id="1-1-HTML-的基本概念"><a href="#1-1-HTML-的基本概念" class="headerlink" title="1.1 HTML 的基本概念"></a>1.1 HTML 的基本概念</h2><p>www（world wide web，万维网）是一种建立在 Internet 上的、全球性的、交互的、多平台的、分布式的信息资源网络。</p><p>WWW 有 3 个基本的组成部分，分别是：</p><ul><li>URL：统一资源定位器，也就是我们常说的网址</li><li>HTTP：超文本传输协议</li><li>HTML：标记语言</li></ul><h2 id="1-2-HTML-发展史与-HTML5"><a href="#1-2-HTML-发展史与-HTML5" class="headerlink" title="1.2 HTML 发展史与 HTML5"></a>1.2 HTML 发展史与 HTML5</h2><h2 id="1-6-HTML-的基本结构"><a href="#1-6-HTML-的基本结构" class="headerlink" title="1.6 HTML 的基本结构"></a>1.6 HTML 的基本结构</h2><h3 id="1-6-1-HTML-文件的编写方法"><a href="#1-6-1-HTML-文件的编写方法" class="headerlink" title="1.6.1 HTML 文件的编写方法"></a>1.6.1 HTML 文件的编写方法</h3><ol><li><p>HTML 标签</p><p>一个 HTML 文件是由一系列的元素和标签组成。元素是 HTML 文件的重要组成部分，<strong>元素名不区分大小写</strong>。HTML 用标签来规定元素的属性和它在文件中的位置。</p><p>HTML 的标签分<strong>单独出现的标签</strong>和<strong>成对出现的标签</strong>两种。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名称</span>&gt;</span>要控制的元素<span class="tag">&lt;/<span class="name">标签名称</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在每个 HTML 标签，大写、小写和混写均可。</p></blockquote><p>在每个 HTML 标签中，还可以设置一些属性，控制 HTML 标签所建立的元素。这些属性将位于所建立元素的首标签，因此，首标签的基本语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名称</span> <span class="attr">属性1</span>=<span class="string">&quot;值1&quot;</span> <span class="attr">属性2</span>=<span class="string">&quot;值2&quot;</span> &gt;</span>要控制的元素<span class="tag">&lt;/<span class="name">标签名称</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>元素的概念</p><p>一组标签，再加上标签包含的内容，被称之为一个元素。</p></li><li><p>HTML 文件结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-6-2-文件开始标签-lt-html-gt"><a href="#1-6-2-文件开始标签-lt-html-gt" class="headerlink" title="1.6.2 文件开始标签&lt;html&gt;"></a>1.6.2 文件开始标签<code>&lt;html&gt;</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  文件的全部内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="第二章-HTML-文件基本标记"><a href="#第二章-HTML-文件基本标记" class="headerlink" title="第二章 HTML 文件基本标记"></a>第二章 HTML 文件基本标记</h1><h2 id="2-1-HTML-头部标记"><a href="#2-1-HTML-头部标记" class="headerlink" title="2.1 HTML 头部标记"></a>2.1 HTML 头部标记</h2><p>在 HTML 语言的头元素中，一般要包括标题、基地信息、元信息等。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">.....</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>一般情况下，CSS 和 JavaScript 都定义在头元素中的，而<strong>定义在 HTML 语言头部文件的内容往往不会在网页上直接显示</strong>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">标记</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;base&gt;</code></td><td style="text-align:center">当前文档的 URL 全称（基地网址）</td></tr><tr><td style="text-align:center"><code>&lt;basefont&gt;</code></td><td style="text-align:center">设定基准的文字字体、字号和颜色</td></tr><tr><td style="text-align:center"><code>&lt;title&gt;</code></td><td style="text-align:center">设定显示在浏览器左上方的标题内容</td></tr><tr><td style="text-align:center"><code>&lt;isindex&gt;</code></td><td style="text-align:center">表明该文档是一个可用于检索的网关脚本，由服务器建立</td></tr><tr><td style="text-align:center"><code>&lt;meta&gt;</code></td><td style="text-align:center">有关文档本身的元信息。例如：用于查询的关键字、该文档的有效日期等</td></tr><tr><td style="text-align:center"><code>&lt;style&gt;</code></td><td style="text-align:center">设定 CSS 层叠样式表的内容</td></tr><tr><td style="text-align:center"><code>&lt;link&gt;</code></td><td style="text-align:center">设定外部文件的连接</td></tr><tr><td style="text-align:center"><code>&lt;script&gt;</code></td><td style="text-align:center">设定页面程序脚本的内容</td></tr></tbody></table></div><h2 id="2-2-标题标签-lt-title-gt"><a href="#2-2-标题标签-lt-title-gt" class="headerlink" title="2.2 标题标签 &lt;title&gt;"></a>2.2 标题标签 <code>&lt;title&gt;</code></h2><p>HTML 文件的标题信息会显示在浏览器的标题栏，用以说明文件的用途。每个 HTML 文件都应该有标题，在 HTML 文档中，标题文字位于 <code>&lt;title&gt;</code>和 <code>&lt;/title&gt;</code> 之间，并且 <code>&lt;title&gt;</code> 标签位于文档的头部。</p><p>实例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我是标题君<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    我是网页主体</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-元信息标签-lt-meta-gt"><a href="#2-3-元信息标签-lt-meta-gt" class="headerlink" title="2.3 元信息标签 &lt;meta&gt;"></a>2.3 元信息标签 <code>&lt;meta&gt;</code></h2><p>​ meta 元素提供的信息是用户不可见的，它不显示在页面中，<strong>一般用于定义页面信息的名称、关键字、作者等</strong>。在 HTML 中， meta 标签不需要设置结束标签，一个尖括号就是一个 meta 内容 ，并且一个 HTML 头部可以有多个 meta 标签。</p><ol><li><p>页面关键字</p><p>​ 设置页面关键字是为了向搜索引擎说明这一网页的关键字，从而帮助搜索引擎对该网页进行查找和分类，可以提高被搜索到的概率。<strong>一般可以设置不止一个关键字，之间用逗号隔开，但是不要设置太多</strong>。</p><p>​ 语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的关键字，用逗号隔开&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>​ 语法解释：</p><p>​ 在该语法中， name 为属性名称，这里是 keyword ，也就是说设置网页的关键字属性，而在 content 中，则定义了具体的关键字。</p><p>​ 实例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">content</span>=<span class="string">&quot;html,元信息,关键字&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>元信息标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    我是内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>页面描述</p><p>​ 设置页面描述也是为了便于搜索引擎的查找，它用来描述网页的主题等。</p><p>​ 语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;对页面的具体描述&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>​ 语法解释：</p><p>​ 在该语法中， name 为属性名称，这里是 description ，也就是说将元信息属性设置为页面描述，而在 content 中，则定义了具体的描述内容。</p><p>​ 实例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keyneme&quot;</span> <span class="attr">content</span>=<span class="string">&quot;html,元信息,关键字&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这是一个关于元信息的网页&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>元信息标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    我是内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>设置编辑器</p><p>​ 语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;编辑软件的名称&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>​ 语法解释：</p><p>​ 在该语法中， name 为属性名称，这里是 generator ，也就是说将元信息属性设置为编辑器信息，而在 content 中，则定义了具体的编辑器。</p><p>​ 实例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keyneme&quot;</span> <span class="attr">content</span>=<span class="string">&quot;html,元信息,关键字&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这是一个关于元信息的网页&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;vscode&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>元信息标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    我是内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>设置作者信息</p><p>​ 语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;作者&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>​ 语法解释：</p><p>​ 在该语法中， name 为属性名称，这里是 author ，也就是说将元信息属性设置为作者信息，而在 content 中，则定义了具体的作者名字。</p><p>​ 实例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keyneme&quot;</span> <span class="attr">content</span>=<span class="string">&quot;html,元信息,关键字&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这是一个关于元信息的网页&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;vscode&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;YuiLexi&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>元信息标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    我是内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>限制搜索方式</p><p>​ 语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;搜索方式&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">搜索方式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">All</td><td style="text-align:center">表示能搜到当前网页及其链接的网页</td></tr><tr><td style="text-align:center">Index</td><td style="text-align:center">表示能搜到当前网页</td></tr><tr><td style="text-align:center">Nofollow</td><td style="text-align:center">表示不能搜到与当前网页链接的网页</td></tr><tr><td style="text-align:center">Noindex</td><td style="text-align:center">表示不能搜到当前网页</td></tr><tr><td style="text-align:center">None</td><td style="text-align:center">表示不能搜到当前网页及其链接的网页</td></tr></tbody></table></div><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-31</p></div></div><div class='timeline-item-content'></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub入门</title>
      <link href="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Github.html"/>
      <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Github.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文章主要讲解 Github 的认识和使用，不包含<strong>如何注册 Github 账号</strong>。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="https://imageshack.yuilexi.cn/版本控制/Github/Github仓库总览.png" alt="Github仓库总览"></p><ul><li>左上角为 Github 的用户名 + 仓库名</li><li>右上角<ul><li>眼睛图标+Watch 字样，点击这个按钮就可以 Watch 该仓库，今后该仓库的更新信息会显示在用户的公开活动中。</li><li>Star 旁边的数组表示给这个仓库添加 Star 的人数，这个数越高，代表该仓库越受关注。</li><li>Watch 与 Star 不同的地方在于，Watch 之后该仓库的相关信息会在您的个人 Notifications 中显示，让用户可以追踪仓库的内容，而 Star 更像是书签，让用户将来可以在 Star 标记的列表中找到该仓库。</li><li>另外，Star 数还是 GitHub 上判断仓库热门程度的标志之一。</li><li>fork 就是被人 copy 的次数。</li></ul></li><li>中间从左到右依次是：<ol><li>Code：显示该仓库的文件列表，以及该仓库的各种操作</li><li>Issues：关于此项目的问题讨论处，遇到的问题可以在这里谈论</li><li>Pull Request（PR）：发起 pull request 给原仓库，让他看到你修改的内容(需要先 fork 一份原仓库，然后修复里面的内容，再 pull request 给原仓库)</li><li>GitHub Discussions：是一个围绕开源或内部项目为社区提供协作沟通的论坛。 不像 GitHub Issues，讨论用于需要透明和可访问的对话，但不需要在项目板上进行跟踪，并且与代码无关。 讨论使公共论坛中能够进行流畅、公开的对话。通过连接和提供更集中的区域来连接和查找信息，讨论为更多协作对话提供了空间。</li><li>GitHub Actions：在 GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程。 您可以发现、创建和共享操作以执行您喜欢的任何作业（包括 CI/CD），并将操作合并到完全自定义的工作流程中。</li><li>Projects：GitHub 新推出的项目管理工具 Projects。协助开发者在开发流程中整合项目管理，让开发者可以直接在 GitHub 程序代码储存库中管理工作流程，而 Projects 的介面就像看板系统，能够图像化开发流程，用户可以根据团队使用需求建立工作流程架构，如“开发中”、“已完成”、“尚未开始进行”等，且能通过拖拉的方式，来调整工作流程栏位的顺序</li><li>Wiki：我们可以用它来实现项目信息管理，为项目提供更加完善的文档</li><li>Insignts：<ol><li>Pulse：显示该仓库最近的活动信息，该仓库中软件是无人问津还是在热火朝天的开发之中，从这里可以一目了然。</li><li>Graphs：以图表的形式显示该仓库的各项指标，让用户轻松了解该仓库的活动倾向。</li></ol></li></ol></li></ul><h1 id="Code-页"><a href="#Code-页" class="headerlink" title="Code 页"></a>Code 页</h1><p><img src="https://imageshack.yuilexi.cn/版本控制/Github/Github的Code页_1.png" alt="Github的Code页_1"></p><p><img src="https://imageshack.yuilexi.cn/版本控制/Github/Github的Code页_2.png" alt="Github的Code页_2"></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-31</p></div></div><div class='timeline-item-content'><ol><li>更新了 Code 页相关内容</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-30</p></div></div><div class='timeline-item-content'><ol><li>创建文件</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> Github </tag>
            
            <tag> Git </tag>
            
            <tag> 团队协作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity坐标系</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Unity%E5%BC%95%E6%93%8E/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/Unity%E5%9D%90%E6%A0%87%E7%B3%BB.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Unity%E5%BC%95%E6%93%8E/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/Unity%E5%9D%90%E6%A0%87%E7%B3%BB.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一篇文章，主要介绍 Unity 中的各种坐标系，并且介绍如何使用 C# 脚本，实现不同坐标系之间的转换。</p><blockquote><p>快速导航</p><p><a href="https://blog.yuilexi.cn/2023/05/11/Unity3D/Unity组件/组件-Transforms/">Unity 组件-Transform | 🪐 星空鸟 🪐 (yuilexi.cn)</a></p></blockquote><h1 id="一、世界坐标系"><a href="#一、世界坐标系" class="headerlink" title="一、世界坐标系"></a>一、世界坐标系</h1><p>在 Unity 中，世界坐标系是指一个三维空间中的坐标系，可以用来描述场景中物体的位置和方向。它是由 X 轴、Y 轴和 Z 轴组成的，其中 X 轴表示水平方向（从左向右），Y 轴表示垂直方向（从下向上），Z 轴表示深度方向（从屏幕内向外）。默认情况下，原点位于场景的中心点。</p><p>在 Unity 中，所有的对象都有它们自己的坐标系，包括世界坐标系和本地坐标系。世界坐标系是所有对象的公共坐标系，因此可以用来描述整个场景中的对象位置和方向。</p><p>如果你想在代码中使用<strong>世界坐标系</strong>，可以使用 <strong>Transform 组件的 position 属性</strong>，它表示对象在世界坐标系中的位置。</p><p>但是，<strong>Transform 组件</strong> 面板中的 Position ，确表示的是本地（局部）坐标。</p><blockquote><p>需要注意的是，Unity 中的坐标系默认使用左手坐标系。这意味着 X 轴向右，Y 轴向上，Z 轴向屏幕内。如果你想使用右手坐标系，可以在项目设置中进行修改。</p></blockquote><p><img src="https://imageshack.yuilexi.cn/Unity3D/Unity引擎/坐标系系/Unity坐标系/左手系和右手系.svg" alt="左手系和右手系"></p><p>在世界坐标系中，还有两个其他的描述对象空间状态的属性：旋转与缩放。这两个属性在 <code>Transform</code> 组件面板中，表示的是相对于父级的状态。如果想要获得世界坐标系中的状态，需要将每一级父对象的属性叠加（注意：这里是叠加，而不是相加）。</p><h1 id="二、本地坐标系"><a href="#二、本地坐标系" class="headerlink" title="二、本地坐标系"></a>二、本地坐标系</h1><p>在 Unity 中，本地坐标系（Local Coordinates System）或局部坐标系（Local Coordinate System）是指相对于某个物体自身的坐标系。每个物体都有其自己的本地坐标系，该坐标系以物体的位置、旋转和缩放为基准。</p><p>在 <code>Transform</code> 组件面板中的 <code>Position</code> 属性，表示的是该对象的相对于父级的本地坐标系的坐标位置。</p><blockquote><p>一个游戏对象，想要获得世界坐标系，那么就需要将所有的父级以及祖级的本地坐标系相加。如果一个游戏对象在场景中没有父级，那么它的 <code>Transform</code> 中属性值，就是世界坐标下的属性值。</p></blockquote><p><strong>旋转</strong>（Rotation）：物体的本地坐标系的旋转是基于物体的转换。例如，当一个物体绕 Y 轴旋转时，其本地坐标系的 X 和 Z 轴也会随之改变方向。</p><p><strong>缩放</strong>（Scale）：物体的本地坐标系的缩放取决于物体的缩放变换。如果一个物体被缩放了，那么其本地坐标系的轴的长度也会相应地进行缩放。</p><h1 id="三、屏幕坐标系"><a href="#三、屏幕坐标系" class="headerlink" title="三、屏幕坐标系"></a>三、屏幕坐标系</h1><p><img src="https://imageshack.yuilexi.cn/Unity3D/Unity引擎/坐标系系/Unity坐标系/屏幕坐标系.svg" alt="屏幕坐标系"></p><p>屏幕坐标系就是把屏幕看作一个坐标系，从左下角开始计算，也就是(0,0)，而右上角则是<code>(Screen.widht-1,Screen.height-1)</code>，所以又叫做像素坐标系。可以通过下面的代码获得屏幕的分辨率。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetScreenCoordinate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;当前窗口的分辨率为：&quot;</span> + Screen.width + <span class="string">&quot;X&quot;</span> + Screen.height);</span><br><span class="line">    Debug.Log(<span class="string">&quot;当前屏幕的分辨率为：&quot;</span> + Screen.currentResolution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标位置坐标就是属于屏幕坐标系，通过屏幕坐标和世界坐标互转，可得到鼠标在 Unity3D 中的实际交互位置，然后就可以通过逻辑做出反馈。</p><p>获取鼠标的当前坐标，代码逻辑为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetMouseCoordinate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取鼠标在屏幕坐标系中的位置</span></span><br><span class="line">    Vector3 mouseScreenPosition = Input.mousePosition;</span><br><span class="line">    <span class="comment">// 输出鼠标的屏幕坐标和世界坐标</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;Mouse Screen Position: &quot;</span> + mouseScreenPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、视口坐标系"><a href="#四、视口坐标系" class="headerlink" title="四、视口坐标系"></a>四、视口坐标系</h1><p><img src="https://imageshack.yuilexi.cn/Unity3D/Unity引擎/坐标系系/Unity坐标系/视口坐标系.svg" alt="视口坐标系"></p><p>视口坐标系可以理解为单位化的屏幕坐标系，该坐标系计算方式和屏幕坐标系类似，只不过把其参数标准化了，更加适用于比例计算。左下角为 <code>(0,0)</code> 右上角为 <code>(1,1)</code> 。</p><p>将屏幕坐标单位化后，就可以挣脱分辨率不同的限制，通过相对位置来确定在屏幕中的位置。</p><h1 id="五、瓦片地图坐标系"><a href="#五、瓦片地图坐标系" class="headerlink" title="五、瓦片地图坐标系"></a>五、瓦片地图坐标系</h1><p>在 2D 游戏对象中，我们可以通过创建 <code>TileMap</code> ，轻松地搭建出不同地游戏场景地图，因此，就会存在一种特殊的坐标系——<strong>瓦片地图坐标系</strong>。</p><p>由于瓦片的网格大小可以进行设置，因此，每个瓦片在世界坐标系中位置不尽相同。但是可以确定的是，<strong>瓦片地图坐标系</strong>的坐标，是一个整型的三元数。</p><p>我们可以通过自定义一个 C# 脚本笔刷，来显示当前的瓦片坐标。在 <code>Asset/TileMap/Custom Brush Scripts/Coordinate Brush/Editor/</code> 路径下，创建一个 <code>CoordinateBrush.cs</code> 脚本，并且将下列代码粘贴复制到脚本中，然后等待 Unity 引擎编译结束，就能在 <code>Tile Palette</code> 面板中，找到该笔刷。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Tilemaps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEditor</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">CustomGridBrush(true, false, false, <span class="string">&quot;Coordinate Brush&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;New Coordinate Brush&quot;</span>, menuName = <span class="string">&quot;Brushes/Coordinate Brush&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoordinateBrush</span> : <span class="title">GridBrush</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Paint</span>(<span class="params">GridLayout grid, GameObject brushTarget, Vector3Int position</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> zPosition = <span class="keyword">new</span> Vector3Int(position.x, position.y, z);</span><br><span class="line">            <span class="keyword">base</span>.Paint(grid, brushTarget, zPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Erase</span>(<span class="params">GridLayout grid, GameObject brushTarget, Vector3Int position</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> zPosition = <span class="keyword">new</span> Vector3Int(position.x, position.y, z);</span><br><span class="line">            <span class="keyword">base</span>.Erase(grid, brushTarget, zPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">FloodFill</span>(<span class="params">GridLayout grid, GameObject brushTarget, Vector3Int position</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> zPosition = <span class="keyword">new</span> Vector3Int(position.x, position.y, z);</span><br><span class="line">            <span class="keyword">base</span>.FloodFill(grid, brushTarget, zPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BoxFill</span>(<span class="params">GridLayout gridLayout, GameObject brushTarget, BoundsInt position</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> zPosition = <span class="keyword">new</span> Vector3Int(position.x, position.y, z);</span><br><span class="line">            position.position = zPosition;</span><br><span class="line">            <span class="keyword">base</span>.BoxFill(gridLayout, brushTarget, position);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">CustomEditor(typeof(CoordinateBrush))</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoordinateBrushEditor</span> : <span class="title">GridBrushEditor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> CoordinateBrush coordinateBrush &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> target <span class="keyword">as</span> CoordinateBrush; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PaintPreview</span>(<span class="params">GridLayout grid, GameObject brushTarget, Vector3Int position</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> zPosition = <span class="keyword">new</span> Vector3Int(position.x, position.y, coordinateBrush.z);</span><br><span class="line">            <span class="keyword">base</span>.PaintPreview(grid, brushTarget, zPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPaintSceneGUI</span>(<span class="params">GridLayout grid, GameObject brushTarget, BoundsInt position, GridBrushBase.Tool tool, <span class="built_in">bool</span> executing</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnPaintSceneGUI(grid, brushTarget, position, tool, executing);</span><br><span class="line">            <span class="keyword">if</span> (coordinateBrush.z != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> zPosition = <span class="keyword">new</span> Vector3Int(position.min.x, position.min.y, coordinateBrush.z);</span><br><span class="line">                BoundsInt newPosition = <span class="keyword">new</span> BoundsInt(zPosition, position.size);</span><br><span class="line">                Vector3[] cellLocals = <span class="keyword">new</span> Vector3[]</span><br><span class="line">                &#123;</span><br><span class="line">                    grid.CellToLocal(<span class="keyword">new</span> Vector3Int(newPosition.min.x, newPosition.min.y, newPosition.min.z)),</span><br><span class="line">                    grid.CellToLocal(<span class="keyword">new</span> Vector3Int(newPosition.max.x, newPosition.min.y, newPosition.min.z)),</span><br><span class="line">                    grid.CellToLocal(<span class="keyword">new</span> Vector3Int(newPosition.max.x, newPosition.max.y, newPosition.min.z)),</span><br><span class="line">                    grid.CellToLocal(<span class="keyword">new</span> Vector3Int(newPosition.min.x, newPosition.max.y, newPosition.min.z))</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Handles.color = Color.blue;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = cellLocals.Length - <span class="number">1</span>; i &lt; cellLocals.Length; j = i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Handles.DrawLine(cellLocals[j], cellLocals[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> labelText = <span class="string">&quot;Pos: &quot;</span> + <span class="keyword">new</span> Vector3Int(position.x, position.y, coordinateBrush.z);</span><br><span class="line">            <span class="keyword">if</span> (position.size.x &gt; <span class="number">1</span> || position.size.y &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                labelText += <span class="string">&quot; Size: &quot;</span> + <span class="keyword">new</span> Vector2Int(position.size.x, position.size.y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GUIStyle myStyle = <span class="keyword">new</span> GUIStyle();</span><br><span class="line">            myStyle.normal.textColor = Color.white;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Handles.Label(grid.CellToWorld(<span class="keyword">new</span> Vector3Int(position.x, position.y, coordinateBrush.z)), labelText, myStyle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://imageshack.yuilexi.cn/Unity3D/Unity引擎/坐标系系/Unity坐标系/自定义笔刷-显示坐标.png" alt="自定义笔刷-显示坐标"></p><p><img src="https://imageshack.yuilexi.cn/Unity3D/Unity引擎/坐标系系/Unity坐标系/Scene中显示瓦片的坐标.png" alt="Scene中显示瓦片的坐标"></p><hr><div align="center" color="red" font-weight="blod">坐标的计算与转换</div><p>以正方形的瓦片为例，单元格的大小为 $M\cdot M$ ，那么世界坐标的转换方式为：<code>（x,y,z）➗ M ，然后向下取整</code> 。</p><h1 id="六、坐标系的转换"><a href="#六、坐标系的转换" class="headerlink" title="六、坐标系的转换"></a>六、坐标系的转换</h1><p>第一个启用的相机组件，标记为“主相机”（只读）。如果没有启用带有“主相机”标记的相机组件，则此属性为 null。</p><p>在内部，Unity 使用“主摄像机”标签缓存所有游戏对象。访问此属性时，Unity 会从其缓存中返回第一个有效结果。访问此属性的 CPU 开销很小，与调用 <a href="https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html">GameObject.GetComponent</a> 相当。</p><p>屏幕坐标转世界坐标：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">ScreenToWorldPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br><span class="line"><span class="comment">//屏幕坐标为三元数，z = 0</span></span><br><span class="line">Vector3 Camera.ScreenToWorldPoint(<span class="keyword">new</span> Vector3(screenPos.x , screenPos.y , zInfo));</span><br><span class="line">Vector3 Camera.main.ScreenToWorldPoint(<span class="keyword">new</span> Vector3(screenPos.x , screenPos.y , zInfo));</span><br></pre></td></tr></table></figure><p>世界坐标转屏幕坐标：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">WorldToScreenPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br><span class="line"><span class="comment">//世界坐标转屏幕坐标后，z = 0</span></span><br><span class="line">Vector3 Camera.WorldToScreenPoint(<span class="keyword">new</span> Vector3(worldPos.x , worldPos.y , worldPos.z));</span><br><span class="line">Vector3 Camera.main.WorldToScreenPoint(<span class="keyword">new</span> Vector3(worldPos.x , worldPos.y , worldPos.z));</span><br></pre></td></tr></table></figure><p>世界坐标转视口坐标</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">WorldToViewportPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br><span class="line">Vector3 Camera.WorldToViewportPoint(Vector3 position);</span><br><span class="line">Vector3 Camera.main.WorldToViewportPoint(Vector3 position);</span><br></pre></td></tr></table></figure><p>视口坐标转世界坐标</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">ViewportToWorldPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br><span class="line">Vector3 Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(viewPortPos.x , viewPortPos.y , zInfo));</span><br><span class="line">Vector3 Camera.main.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(viewPortPos.x , viewPortPos.y , zInfo));</span><br></pre></td></tr></table></figure><p>屏幕坐标转视口坐标</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">ScreenToViewportPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br><span class="line">Vector3 ScreenCoordinate = Camera.main.ScreenToViewportPoint(Vector3 Position);</span><br></pre></td></tr></table></figure><p>视口坐标转屏幕坐标</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">ViewportToScreenPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br><span class="line">Vector3 ScreenCoordinate = Camera.main.ViewportToScreenPoint(Vector3 Position);</span><br></pre></td></tr></table></figure><p>区别：</p><p>在 Unity 中，<code>Camera.ScreenToWorldPoint</code>和<code>Camera.main.ScreenToWorldPoint</code>都是用于将屏幕坐标系中的点转换为世界坐标系中的点的方法。它们的区别在于：</p><ul><li><code>Camera.ScreenToWorldPoint</code>是摄像机对象的实例方法，需要使用特定的摄像机对象来进行转换；</li><li><code>Camera.main.ScreenToWorldPoint</code>是静态方法，可以直接使用全局的主摄像机来进行转换。</li></ul><p>因此，当需要将屏幕坐标系中的点转换为世界坐标系中的点时，可以根据不同的场景需求选择使用这两个方法。</p><p>如果场景中只有一个主摄像机，并且需要频繁地进行屏幕坐标系和世界坐标系之间的转换，可以考虑使用<code>Camera.main.ScreenToWorldPoint</code>方法，以避免频繁地获取和传递摄像机对象。</p><p>如果场景中有多个摄像机对象，并且需要对不同的摄像机进行不同的转换操作，或者需要对屏幕坐标系进行自定义的转换操作，可以使用<code>Camera.ScreenToWorldPoint</code>方法，并传递相应的摄像机对象或自定义的参数。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-6-5</p></div></div><div class='timeline-item-content'><ol><li>补充了第五部分：瓦片地图坐标系</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-6-5</p></div></div><div class='timeline-item-content'><ol><li>完善二、三、四、六部分</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-28</p></div></div><div class='timeline-item-content'><ol><li>创建文档</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Unity引擎 </category>
          
          <category> 坐标系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Unity引擎 </tag>
            
            <tag> 坐标系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门到精通</title>
      <link href="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git.html"/>
      <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、认识-Git"><a href="#一、认识-Git" class="headerlink" title="一、认识 Git"></a>一、认识 Git</h1><h2 id="1-1-版本控制"><a href="#1-1-版本控制" class="headerlink" title="1.1 版本控制"></a>1.1 版本控制</h2><p><del>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的软件工具。版本控制系统（VCS）是一种管理源代码的软件工具，它可以追踪文件的每一次修改，以便随时恢复早期版本。</del></p><p>版本控制是一种管理和控制软件开发中版本变化的方法，通常用于跟踪代码修改和协作开发。版本控制系统（VCS）是一种通过记录和跟踪文件修改历史的软件工具，用于帮助开发人员在团队中协同工作，并保留先前的代码版本以防止代码丢失或错误。它们还可用于跟踪单个文件和整个项目中的更改，以及管理并发访问到项目文件的冲突。</p><h3 id="1-1-1-为什么要使用版本控制？"><a href="#1-1-1-为什么要使用版本控制？" class="headerlink" title="1.1.1 为什么要使用版本控制？"></a>1.1.1 为什么要使用版本控制？</h3><p>如果我们在做项目的时候，可能会对项目文件不断进行修改，并且我们需要保留之前的版本文件。在没有<strong>版本控制的系统</strong>的时代，可以通过备份旧文件，来达到版本的控制，例如下面：</p><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/手动版本控制.png" alt="手动版本控制"></p><p>但是这样的方式，不仅占用更大的存储空间，并且极为不便。每一次保存版本时，也不知道修改的内容。</p><h3 id="1-1-2-版本控制的作用"><a href="#1-1-2-版本控制的作用" class="headerlink" title="1.1.2 版本控制的作用"></a>1.1.2 版本控制的作用</h3><p>版本控制在软件开发和其他领域中广泛应用。它的主要作用是<strong>帮助团队协作开发软件，并保证每个人对代码的修改都是可追溯的</strong>。</p><p>以下是版本控制的几个主要作用：</p><ol><li><strong>协作开发</strong>：版本控制允许多个开发者一起在同一个代码库中对代码进行修改和提交，并且可以随时查看彼此的修改记录。</li><li><strong>追溯历史</strong>：版本控制能够记录每一次代码修改并生成相应的历史记录，可以随时查看代码的修订历史，并恢复到任意历史版本。</li><li><strong>回退操作</strong>：在修复 bug 或者发现问题版本时，可以快速回退到之前的某个历史版本。</li><li><strong>分支与合并</strong>：版本控制允许用户创建分支，这使得用户可以在单独的分支上开发新特性，而不会影响主分支的稳定性。之后可以将分支合并到主分支中。</li><li><strong>备份与恢复</strong>：版本控制在本地或远程存储中备份代码，并可以随时恢复到以前的版本，这保证了代码在各个阶段的可靠性。</li></ol><p>总之，版本控制的作用非常重要。它可以提高开发团队的效率和协作能力，并保证了代码的质量和可追溯性。</p><h3 id="1-1-3、常用的版本控制器"><a href="#1-1-3、常用的版本控制器" class="headerlink" title="1.1.3、常用的版本控制器"></a>1.1.3、常用的版本控制器</h3><p>目前使用最广泛的是<strong>Git</strong>与<strong>SVN</strong>。</p><p><strong>它们主要的区别</strong>:</p><ul><li><p>SVN是<strong>集中式</strong>版本控制系统，<strong>版本库</strong>是集中放在中央服务器的。工作时，首先要从中央服务器得到最新的版本，然后编辑项目文件，之后，需要把编辑完成的项目，推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就会影响工作速度，并且如果中央服务器出现问题，所有的用户均不能正常工作。</p><p>  <img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/SVN的结构图.png" alt="SVN的结构图"></p></li><li><p>Git是<strong>分布式</strong>版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Git的结构图.png" alt="Git的结构图"></p></li></ul><h2 id="1-2-Git-的历史"><a href="#1-2-Git-的历史" class="headerlink" title="1.2 Git 的历史"></a>1.2 Git 的历史</h2><p>Linux 内核开源项目有着为数众多的参与者。在 1991-2002 年间，绝大多数的 Linux 维护工作都花在了提交补丁和保存归档的繁琐事务上。到 2002 年，整个项目组开始使用一个叫做 BitKeeper 的分布式版本控制系统，来维护和管理代码。在 Git 诞生之前，许多版本控制系统普遍存在的问题包括效率低下、容易丢失数据、难以管理分支等。特别是在 Linux 内核开发中，Linus Torvalds 对于 BitKeeper 这个专有的版本控制系统的使用遭遇了一些限制，这也促使他开始考虑自己开发一款全新的版本控制系统。</p><p>2005 年，一位 Linux 开发成员 Andrew（Samba 协议之父）写了一个可以连接 BitKeeper 仓库的外挂，因此 BitMover 公司（BitKeeper 持有者）认为他反编译了 BitKeeper。BitMover 决定中止 Linux 免费使用 BitKeeper 的授权。最终 Linux 团队与 BitMover 磋商无果，Torvalds 决定开发自己的版本管理系统。</p><p>Linus Torvalds 这位天才，仅仅用了<strong>十天</strong>时间，就诞生了目前<strong>世界最先进</strong>的版本控制系统—— Git 。</p><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Linux之父.png" alt="Linux之父"></p><h1 id="二、Git-的安装与配置"><a href="#二、Git-的安装与配置" class="headerlink" title="二、Git 的安装与配置"></a>二、Git 的安装与配置</h1><h2 id="2-1-Git-安装"><a href="#2-1-Git-安装" class="headerlink" title="2.1 Git 安装"></a>2.1 Git 安装</h2><p>首先去到官网<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Git官网.png" alt="Git官网"></p><p>选择对应系统的文件，进行安装（例如：以 Window 系统为例）</p><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Git的windows安装.png" alt="Git的windows安装"></p><p>选择对应的安装程序，之后，会出现安装程序界面，一路向下就行。</p><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Git安装程序.png" alt="Git安装程序"></p><p>安装成功后，就会出现下面的文件</p><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Git程序.png" alt="Git程序"></p><p><strong>Git Bash</strong>：Unix与Linux风格的命令行，使用最多，推荐使用</p><p><strong>Git CMD</strong>：Windows风格的命令行</p><p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用</p><h2 id="2-2-Git-配置"><a href="#2-2-Git-配置" class="headerlink" title="2.2 Git 配置"></a>2.2 Git 配置</h2><ol><li><p><strong>用户信息</strong>（必须要配置）：配置个人的用户名称和电子邮件地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;galen&quot;</span></span><br><span class="line">git config --global user.email 4981292+galen_2019@user.noreply.gitee.com</span><br></pre></td></tr></table></figure><p>​    如果用了 <strong>—global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，路径为 <code>&quot;C:/Users/&lt;用户名&gt;/.gitconfig&quot;</code> ，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>​    如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 —global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p><p>​    这里的用户名以及邮箱，是为了记录修改文件的用户信息，并不是登录的账号，Git 不需要登陆账号。</p></li><li><p><strong>查看配置信息</strong>：要检查已有的配置信息，可以使用 git config —list 命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li></ol><h1 id="三、-Git-理论"><a href="#三、-Git-理论" class="headerlink" title="三、 Git 理论"></a>三、 Git 理论</h1><h2 id="3-1、工作区域"><a href="#3-1、工作区域" class="headerlink" title="3.1、工作区域"></a>3.1、工作区域</h2><p>基本概念：</p><ul><li><strong>工作区</strong>：平时存放项目代码的地方。</li><li><strong>暂存区(Stage/Index)：</strong>暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列 表信息。</li><li><strong>版本库：</strong>又称本地仓库，<strong>这个不算工作区</strong>，而是 Git 的版本库，里面有你提交到所有版本的数据，一般是 <code>.git</code> 文件。</li><li><strong>远程仓库</strong>：托管代码的服务器。</li></ul><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Git区域.png" alt="Git区域"></p><h2 id="3-2、工作流程"><a href="#3-2、工作流程" class="headerlink" title="3.2、工作流程"></a>3.2、工作流程</h2><p>一般是这样的：</p><ol><li>新建仓库或者克隆远程仓库；</li><li>在工作目录中添加、修改文件；</li><li>将需要进行版本管理的文件放入暂存区域；</li><li>将暂存区域的文件<strong>提交</strong>到git仓库。</li></ol><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)。</p><h2 id="3-3-分支"><a href="#3-3-分支" class="headerlink" title="3.3 分支"></a>3.3 分支</h2><p>在Git中，<strong>分支</strong>是指代码库中独立存在的一个代码版本。它可以将代码库的历史分割成不同的线路，每个分支上可以进行独立的开发工作。</p><p>分支在Git中有以下作用：</p><ol><li><strong>并行开发</strong>：使用分支可以让团队成员在独立的分支上并行地进行开发工作，而不会互相干扰。每个分支可以独立地修改、提交和推送代码，不会影响其他分支上的代码。</li><li><strong>版本管理</strong>：通过创建分支，你可以在不影响主线（通常是主分支）的情况下，为特定功能、修复bug或实验性功能创建自己的代码版本。这样可以确保主线代码的稳定性，同时允许其他人在各自的分支上工作。</li><li><strong>特性开发与测试</strong>：创建新分支后，你可以专注于特定功能的开发。这使得你可以在该分支上进行实验、编写和测试代码，而不会影响其他分支上的代码。一旦特性开发完成并经过测试，可以将其合并到主线或其他适当的分支中。</li><li><strong>故障排除与修复</strong>：如果你在主线上发现了一个bug，你可以创建一个修复bug的分支，进行相关的修改和测试，然后将修复合并回主线。这样可以确保修复bug的过程不会干扰其他功能的开发。</li><li><strong>版本回退与分支合并</strong>：分支还可以用于版本回退和合并操作。如果你在某个分支上的开发出现问题，可以简单地放弃该分支并切换回之前的分支或提交。同时，当你在一个分支上完成特性开发后，可以将其合并回主线或其他适当的分支，以保持代码库的整洁和有序。</li></ol><p>总之，分支在Git中提供了一种有效的方式来组织、管理和并行开发代码，使得团队成员可以独立地工作，并将各自的工作成果整合到主线或其他分支中。</p><h2 id="3-4-SSH"><a href="#3-4-SSH" class="headerlink" title="3.4 SSH"></a>3.4 SSH</h2><p>SSH代表Secure Shell，是一种网络协议和加密技术，用于在不安全的网络上安全地进行远程登录和数据传输。</p><p>具体来说，SSH提供了一种<strong>通过加密通道进行安全通信的方式，以防止敏感数据在传输过程中被窃听或篡改</strong>。它使用公钥加密和对称密钥加密的组合，确保数据的机密性和完整性。</p><p>SSH可以用于以下方面：</p><ol><li><strong>远程登录</strong>：通过SSH，用户可以从本地计算机安全地远程登录到远程服务器或其他计算机。这对于系统管理员和远程开发人员来说特别有用，他们可以通过SSH协议在远程计算机上执行命令和管理操作，而无需物理接触该计算机。</li><li><strong>远程文件传输</strong>：SSH还提供了安全的文件传输功能。用户可以使用SCP（Secure Copy）或SFTP（SSH File Transfer Protocol）等工具，通过SSH协议在本地计算机和远程服务器之间传输文件。这种方式比传统的FTP更安全，因为数据在传输过程中进行了加密。</li><li><strong>安全通信隧道</strong>：SSH可以创建安全的通信隧道，将其他协议（如HTTP、SMTP、数据库连接等）通过加密通道传输，以防止数据泄露或篡改。这对于通过不可信的网络连接访问敏感数据或服务的情况非常有用。</li></ol><p>总结起来，SSH是一种安全的远程登录和文件传输协议，通过加密和认证机制保护敏感数据的安全性和完整性。它在许多领域中被广泛使用，特别是在远程管理和安全通信方面。</p><p>SSH KEY 生成步骤如下：</p><ol><li><p>检查一下用户名和邮箱是否配置</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure></li><li><p>生成 SSH KEY</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -c <span class="string">&quot;&lt;邮箱&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>进入文件夹 <code>C:/Users/&lt;用户名&gt;/.ssh</code> 可以看到</p><ul><li>id_rsa文件是私钥，要保存好，放在本地，私钥可以生产公钥，反之不行。</li><li>id_rsa.pub文件是公钥，可以用于发送到其他服务器，或者git上</li></ul></li><li><p>用记事本之类的软件打开id_rsa.pub文件，并且复制全部内容</p></li><li><p>进入 Github 找到 Settings，再找到 SSH keys，将复制的的内容放到 key立即可，Title随便起</p></li></ol><h1 id="四、Git-基本操作"><a href="#四、Git-基本操作" class="headerlink" title="四、Git 基本操作"></a>四、Git 基本操作</h1><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Git工作流程.png" alt="Git工作流程"></p><p><img src="http://imageshack.yuilexi.cn/版本控制/Git/Git入门到精通/Git常用指令大全.png" alt="Git常用指令大全"></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-26</p></div></div><div class='timeline-item-content'></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> Git </tag>
            
            <tag> 团队协作 </tag>
            
            <tag> 分布式版本控制 </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#代码规范</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/02.Csharp%E8%A7%84%E8%8C%83.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/02.Csharp%E8%A7%84%E8%8C%83.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在实际的代码开发中，经常会遇到代码的命名以及规范问题。而不同的人有不同的风格，因此，这篇文章主要讲述<strong>本人 C#代码的规范</strong>，仅作个人以及愿意参与本人项目中人使用。</p><blockquote><p>注意：大可不必争论，代码的命名是否合理，选择一套自己最喜欢的风格，并将其养成习惯，才是最重要的。</p><p>C#系列教程：</p><ol><li><a href="https://blog.yuilexi.cn/2023/04/26/编程/Csharp知识库/Csharp基础/Csharp基础语法/">C#基础语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a></li><li><a href="https://blog.yuilexi.cn/2023/04/30/编程/Csharp知识库/Csharp基础/Csharp高级语法/">C#高级语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a></li><li><a href="https://blog.yuilexi.cn/2023/05/19/编程/Csharp知识库/Csharp基础/Csharp规范/">C#代码规范 | 🪐 星空鸟 🪐 (yuilexi.cn)</a>⬅️ 当前的位置 °꒰๑’ꀾ’๑꒱°</li></ol></blockquote><h1 id="一、标识符规则"><a href="#一、标识符规则" class="headerlink" title="一、标识符规则"></a>一、标识符规则</h1><ul><li><code>Pascal</code>命名规范：标志符中，所有单词的首字母均大写，其余字母小写。</li><li><code>camel</code>命名规范：标志符中，<strong>首字母小写</strong>，其余<strong>单词的首字母</strong>大写，<strong>其余字母</strong>小写。</li><li>标识符命名的字符选择：<code>[a-zA-Z0-9_]</code>中的字符任意搭配，并且不能<strong>以数字作为开头</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">命名规范</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">类： <code>class</code></td><td style="text-align:center"><code>Pascal</code></td><td style="text-align:center"><code>PlayerControl</code></td></tr><tr><td style="text-align:center">私有非静态字段</td><td style="text-align:center"><code>camel</code>，并且必须以<strong>单下划线</strong><code>_</code>开头</td><td style="text-align:center"><code>_workerQueue</code></td></tr><tr><td style="text-align:center">私有静态字段</td><td style="text-align:center"><code>camel</code>，并且必须以<code>s_</code>开头</td><td style="text-align:center"><code>s_workerQueue</code></td></tr><tr><td style="text-align:center">属性和公共字段</td><td style="text-align:center"><code>Pascal</code>，不能以<strong>下划线</strong>或者<code>s_</code>开头</td><td style="text-align:center"><code>WorkerQueue</code></td></tr><tr><td style="text-align:center">方法</td><td style="text-align:center"><code>Pascal</code></td><td style="text-align:center"><code>PascalCasing()</code></td></tr><tr><td style="text-align:center">局部变量</td><td style="text-align:center"><code>camel</code>，并且不能以<strong>下划线</strong>或者<code>s_</code>开头</td><td style="text-align:center"><code>workerQueue</code></td></tr><tr><td style="text-align:center">结构体：<code>struct</code></td><td style="text-align:center"><code>Pascal</code></td><td style="text-align:center"><code>PascalCasing</code></td></tr><tr><td style="text-align:center">接口<code>interface</code></td><td style="text-align:center"><code>Pascal</code>，并在开头加上<code>I</code></td><td style="text-align:center"><code>IWorkerQueue</code></td></tr></tbody></table></div><h1 id="C-语言命名空间"><a href="#C-语言命名空间" class="headerlink" title="C#语言命名空间"></a>C#语言命名空间</h1><ol><li>命名空间名称采用<code>Pascal</code>规则，且首字符大写。</li><li>命名空间名称尽量反映其内容所提供的整体功能。</li></ol><p>对于引用的命名空间：</p><ul><li>每一条命名空间的引用，独占一行</li><li>按照：<code>系统的命名空间 -&gt; 第三方库的命名空间 -&gt; 自定义的命名空间</code> 进行排序</li><li>每一大类的命名空间，<strong>按照字母排序</strong></li></ul><h1 id="三、类"><a href="#三、类" class="headerlink" title="三、类"></a>三、类</h1><ol><li>使用<code>Pascal</code>规则命名类名，即首字母要大写。</li><li>使用能够反映类功能的名词或名词短语命名类。</li><li><strong>不要使用 “I”、“C”、“_” 等特定含义前缀</strong>。</li><li>自定义异常类应以 Exception 结尾。</li><li>文件名要能反映类的内容，最好是和类同名。</li></ol><h1 id="四、字段"><a href="#四、字段" class="headerlink" title="四、字段"></a>四、字段</h1><ol><li>用<code>camel</code>规则来命名类成员变量名称，即首单词（或单词缩写）小写。</li><li>类字段变量名前加 “_” 前缀，静态字段变量名前加 “s_” 前缀。</li><li>坚决禁止在普通变量前加“m_”（这是 VC 老命名规则）。</li><li>公共的字段采用<code>Pascal</code>规则</li></ol><h1 id="五、属性"><a href="#五、属性" class="headerlink" title="五、属性"></a>五、属性</h1><ol><li>使用名词定义属性</li><li>属性使用<code>Pascal</code>规则，首字符大写。</li><li><strong>属性和相应字段名称要关联</strong>，可以使用“重构”菜单来生成属性。</li></ol><h1 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h1><ol><li>方法名采用<code>Pascal</code>规则，第一个字符要大写。</li><li>方法名应使用动词或动词短语。</li><li>类中访问修饰符或功能相同的方法应该放在一起</li><li>通常情况下，类中方法的排序为：实现接口的方法 -&gt; 私有方法 -&gt; 公共方法</li></ol><h1 id="七、参数（局部变量）"><a href="#七、参数（局部变量）" class="headerlink" title="七、参数（局部变量）"></a>七、参数（局部变量）</h1><ol><li>参数采用<code>camel</code>规则命名，且首字符小写。</li><li>使用描述性参数名称，<strong>参数名称应当具有最够的说明性</strong>。</li><li>不要给参数加匈牙利语类型表示法的前缀，即不能添加 “_” 、 “s_” 等前缀。</li><li>检查方法所有输入参数的有效性，即<strong>不能定义不使用的参数</strong>。</li></ol><h1 id="八、常量"><a href="#八、常量" class="headerlink" title="八、常量"></a>八、常量</h1><ol><li>只读常量使用<code>Pascal</code>命名规则，即首字母大写。</li><li>枚举名使用<code>Pascal</code>规则命名，枚举成员本质属于常量，命名规则同上。</li><li>枚举值从小到大顺序定义。</li><li>静态字段或属性采用<code>Pascal</code>规则，即首字符大写。</li></ol><h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><ol><li>接口定义使用<code>Pascal</code>规则，且必须以大写“I”开头。</li><li>接口名称要有意义，中间不要有下划线“_”等字符。</li><li>如果类实现了接口，名称<strong>尽量</strong>和接口相同，只是省掉“I”字符。</li></ol><h1 id="十、委托与事件"><a href="#十、委托与事件" class="headerlink" title="十、委托与事件"></a>十、委托与事件</h1><ol><li>委托名称采用<code>Pascal</code>规则，即首字符大写。</li><li>定义事件的委托要使用<code>EventHandler</code>后缀，且包括<code>sender</code>和<code>e</code>两个参数。</li><li>事件用到的参数类，名称要带<code>EventArgs</code>后缀。</li><li>事件建议使用<code>Event</code>后缀</li></ol><h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><ol><li>代码块的大括号 <code>&#123; &#125;</code> 独占一行，不要使用 <code>Java</code> 习惯</li><li>接口、类、结构体、枚举、字段、属性、方法等必须添加<strong>访问修饰符</strong></li><li><strong>不写注释是流氓，乱写注释是混蛋</strong></li></ol><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-23</p></div></div><div class='timeline-item-content'><ol><li>在 “前言” 部分，增加对 ① ② 文章的引用链接</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-19</p></div></div><div class='timeline-item-content'><ol><li>创建该文档，并规范了常用的代码</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp </category>
          
          <category> Unity3D基础 </category>
          
          <category> Csharp基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> Csharp基础 </tag>
            
            <tag> Unity3D基础 </tag>
            
            <tag> Csharp规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#中数组、ArrayList和List三者的区别</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/%E6%95%B0%E7%BB%84-ArrayList-List.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/%E6%95%B0%E7%BB%84-ArrayList-List.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文章主要讲解，C#中数组、ArrayList 和 List 三者的区别。</p><p>&gt;</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>在这三者之中，数组最早出现的。数组在<strong>内存中是连续存储的</strong>，所以它的索引速度非常快，而且赋值与修改元素也很简单。</p><p>创建数组的方法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="built_in">string</span>[] str = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span>[] number = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>但是数组存在一些不足的地方。数组在声明的时候，必须指定数组的长度，数组创建后在增加长度是十分困难的。并且，在数组的两个数据间插入数据也是很麻烦的。</p><p>数组的长度过长，会造成内存浪费；数组的长度过短，无法添加更多的数据</p><p>如果在声明数组时我们不清楚数组的长度，就会变得很麻烦。</p><h1 id="ArrayList（动态列表）"><a href="#ArrayList（动态列表）" class="headerlink" title="ArrayList（动态列表）"></a>ArrayList（动态列表）</h1><p>动态列表的使用，请参考<a href="https://blog.yuilexi.cn/2023/04/30/Programming/Csharp知识库/Csharp基础/Csharp高级语法/#动态数组（ArrayList）">C#高级语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a></p><p><code>ArrayList</code>是属于命名空间<code>System.Collections</code>下，在使用该类时必须进行引用，同时继承了<code>IList</code>的接口，提供了数据存储和检索。</p><p><code>ArrayList</code>对象的大小是按照其中存储的数据来动态扩充与收缩的。所以，在声明<code>ArrayList</code>对象时并不需要指定它的长度。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增数据</span></span><br><span class="line">list1.Add(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">list1.Add(<span class="number">1314</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改数据</span></span><br><span class="line">list[<span class="number">2</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除数据</span></span><br><span class="line">list.Remove(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>在<code>ArrayList</code>中，可以插入不同类型的数据。因为<code>ArrayList</code>会把所有插入其中的数据，装箱为<code>Object</code>类型来处理，在我们使用<code>ArrayList</code>处理数据时，很可能会报类型不匹配的错误，也就是<code>ArrayList</code>不是类型安全的，因此，为了正确使用数据，我们还需要进行拆箱操作。在存储或检索值类型时通常发生装箱和取消装箱操作，带来很大的性能耗损。</p><h1 id="泛型-List"><a href="#泛型-List" class="headerlink" title="泛型 List"></a>泛型 List</h1><p>因为 <code>ArrayList</code> 存在不安全类型与装箱拆箱的缺点，所以出现了泛型的概念。<code>List</code> 类是 <code>ArrayList</code> 类的<strong>泛型等效类</strong>，它的大部分用法都与 <code>ArrayList</code> 相似，因为 <code>List</code> 类也继承了 <code>IList</code> 接口。最关键的区别在于，在声明 <code>List</code> 集合时，我们同时需要为其声明 <code>List</code> 集合内数据的对象类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增数据</span></span><br><span class="line">list.Add(<span class="number">4</span>);</span><br><span class="line">list.Add(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改数据</span></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除数据</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>数组：</li></ol><ul><li>数组是一种含有相同类型元素的集合，长度固定且不可更改。</li><li>数组直接存储在内存中，可以快速访问。</li><li>数组的元素可以通过索引访问，索引从 0 开始。</li><li>数组可以是多维的，例如二维数组，三维数组等。</li></ul><ol><li>ArrayList：</li></ol><ul><li>ArrayList 是 C#中的一个类，可以用来存储任意类型的元素。</li><li>ArrayList 的长度是可变的，可以动态地添加、删除或修改元素。</li><li><strong>ArrayList 不直接存储在内存中，而是存储对元素的引用，因此访问元素比数组慢</strong>。</li><li>ArrayList 的元素可以通过索引访问。</li></ul><ol><li>List：</li></ol><ul><li>List 是 C#中的一个泛型类，与 ArrayList 类似，也可以存储任意类型的元素。</li><li>List 的长度是可变的，可以动态地添加、删除或修改元素。</li><li>List 与 ArrayList 不同的是，List 直接存储在内存中，可以快速访问元素。</li><li>List 的元素可以通过索引访问。</li></ul><p>综上所述，数组、<code>ArrayList</code> 和 <code>List</code> 都有自己的优缺点和适用场景，具体使用时需要根据实际情况来选择。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-30</p></div></div><div class='timeline-item-content'><ol><li>更新文档中的 List 部分</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-19</p></div></div><div class='timeline-item-content'><ol><li>创建文档</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Csharp </category>
          
          <category> Csharp提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Csharp提升 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 动态列表 </tag>
            
            <tag> 列表 </tag>
            
            <tag> ArrayList </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#中数组、ArrayList和List三者的区别</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/Csharp%E6%8F%90%E5%8D%87/%E6%95%B0%E7%BB%84-ArrayList-List.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/Csharp%E6%8F%90%E5%8D%87/%E6%95%B0%E7%BB%84-ArrayList-List.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文章主要讲解，C#中数组、ArrayList 和 List 三者的区别。</p><p>&gt;</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>在这三者之中，数组最早出现的。数组在<strong>内存中是连续存储的</strong>，所以它的索引速度非常快，而且赋值与修改元素也很简单。</p><p>创建数组的方法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="built_in">string</span>[] str = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span>[] number = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>但是数组存在一些不足的地方。数组在声明的时候，必须指定数组的长度，数组创建后在增加长度是十分困难的。并且，在数组的两个数据间插入数据也是很麻烦的。</p><p>数组的长度过长，会造成内存浪费；数组的长度过短，无法添加更多的数据</p><p>如果在声明数组时我们不清楚数组的长度，就会变得很麻烦。</p><h1 id="ArrayList（动态列表）"><a href="#ArrayList（动态列表）" class="headerlink" title="ArrayList（动态列表）"></a>ArrayList（动态列表）</h1><p>动态列表的使用，请参考<a href="https://blog.yuilexi.cn/2023/04/30/Programming/Csharp知识库/Csharp基础/Csharp高级语法/#动态数组（ArrayList）">C#高级语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a></p><p><code>ArrayList</code>是属于命名空间<code>System.Collections</code>下，在使用该类时必须进行引用，同时继承了<code>IList</code>的接口，提供了数据存储和检索。</p><p><code>ArrayList</code>对象的大小是按照其中存储的数据来动态扩充与收缩的。所以，在声明<code>ArrayList</code>对象时并不需要指定它的长度。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增数据</span></span><br><span class="line">list1.Add(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">list1.Add(<span class="number">1314</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改数据</span></span><br><span class="line">list[<span class="number">2</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除数据</span></span><br><span class="line">list.Remove(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>在<code>ArrayList</code>中，可以插入不同类型的数据。因为<code>ArrayList</code>会把所有插入其中的数据，装箱为<code>Object</code>类型来处理，在我们使用<code>ArrayList</code>处理数据时，很可能会报类型不匹配的错误，也就是<code>ArrayList</code>不是类型安全的，因此，为了正确使用数据，我们还需要进行拆箱操作。在存储或检索值类型时通常发生装箱和取消装箱操作，带来很大的性能耗损。</p><h1 id="泛型-List"><a href="#泛型-List" class="headerlink" title="泛型 List"></a>泛型 List</h1><p>因为 <code>ArrayList</code> 存在不安全类型与装箱拆箱的缺点，所以出现了泛型的概念。<code>List</code> 类是 <code>ArrayList</code> 类的<strong>泛型等效类</strong>，它的大部分用法都与 <code>ArrayList</code> 相似，因为 <code>List</code> 类也继承了 <code>IList</code> 接口。最关键的区别在于，在声明 <code>List</code> 集合时，我们同时需要为其声明 <code>List</code> 集合内数据的对象类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增数据</span></span><br><span class="line">list.Add(<span class="number">4</span>);</span><br><span class="line">list.Add(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改数据</span></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除数据</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>数组：</li></ol><ul><li>数组是一种含有相同类型元素的集合，长度固定且不可更改。</li><li>数组直接存储在内存中，可以快速访问。</li><li>数组的元素可以通过索引访问，索引从 0 开始。</li><li>数组可以是多维的，例如二维数组，三维数组等。</li></ul><ol><li>ArrayList：</li></ol><ul><li>ArrayList 是 C#中的一个类，可以用来存储任意类型的元素。</li><li>ArrayList 的长度是可变的，可以动态地添加、删除或修改元素。</li><li><strong>ArrayList 不直接存储在内存中，而是存储对元素的引用，因此访问元素比数组慢</strong>。</li><li>ArrayList 的元素可以通过索引访问。</li></ul><ol><li>List：</li></ol><ul><li>List 是 C#中的一个泛型类，与 ArrayList 类似，也可以存储任意类型的元素。</li><li>List 的长度是可变的，可以动态地添加、删除或修改元素。</li><li>List 与 ArrayList 不同的是，List 直接存储在内存中，可以快速访问元素。</li><li>List 的元素可以通过索引访问。</li></ul><p>综上所述，数组、<code>ArrayList</code> 和 <code>List</code> 都有自己的优缺点和适用场景，具体使用时需要根据实际情况来选择。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-30</p></div></div><div class='timeline-item-content'><ol><li>更新文档中的 List 部分</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-19</p></div></div><div class='timeline-item-content'><ol><li>创建文档</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Csharp </category>
          
          <category> Csharp提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Csharp提升 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 动态列表 </tag>
            
            <tag> 列表 </tag>
            
            <tag> ArrayList </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity之UGUI框架(优化版)</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/UGUI%E6%A1%86%E6%9E%B6-%E4%BC%98%E5%8C%96%E7%89%88.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/UGUI%E6%A1%86%E6%9E%B6-%E4%BC%98%E5%8C%96%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>此文章主要是针对之前的 UGUI 框架，进行优化和改进。</p><ul><li><a href="https://blog.yuilexi.cn/2023/05/02/Unity3D/功能框架/UGUI框架/">Unity 之 UGUI 框架 | 🪐 星空鸟 🪐 (yuilexi.cn)</a></li><li><a href="https://blog.yuilexi.cn/2023/05/16/Unity3D/功能框架/UGUI框架-优化版/">Unity 之 UGUI 框架(优化版) | 🪐 星空鸟 🪐 (yuilexi.cn)</a>🔫🧬 当前位置 🧬</li></ul></blockquote><h1 id="一、框架设计"><a href="#一、框架设计" class="headerlink" title="一、框架设计"></a>一、框架设计</h1><p>由于之前的 UGUI 框架，采用的 UI 模板是 <code>Panel</code> 对象，并将所有的 <code>UI</code> 置于一个 <code>Canvas</code> 下，这样会对性能的影响很大。 <code>Canvas</code> 的<a href="https://zhuanlan.zhihu.com/p/343524911">渲染模式</a>，简单说明就是， <code>Canvas</code> 会把所有子类的 <code>UI</code> 合并到一个 <code>Mesh</code> 里面去，然后再提交渲染后的 <code>UI</code> 数据，因此，当某一个子对象改变时，都要重新绘制<code>Mesh</code> ，这样会大大增加运算时间。</p><p>解决方案如下：</p><ul><li>不用的 <code>UI</code> 直接使用独立的 <code>Canvas</code> 作为面板</li><li>资源使用动态加载，并且已关闭的 <code>UI</code> 面板不缓存</li><li><code>Canvas</code> 之间，尽量避免嵌套</li></ul><p><img src="https://imageshack.yuilexi.cn/Unity3D/功能框架/UGUI/新版UI框架.svg" alt="新版UI框架"></p><h1 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h1><h2 id="2-1-UIType"><a href="#2-1-UIType" class="headerlink" title="2.1 UIType"></a>2.1 <code>UIType</code></h2><p>这是一个枚举类，用于描述所有 <code>UICanvas</code> 的类型（以 <code>UICanvas</code> 的名字作为它的类型），下面只写了两个例子。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UIType</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    MainMenuCanvas,</span><br><span class="line">    SettingsCanvas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求：</p><ul><li>添加一个 <code>None</code> 作为空类型</li><li>必须以 <code>Canvas</code> 结尾，</li><li><code>UI</code> 资源文件命名要和该枚举中一一对应</li></ul><h2 id="2-2-UIlnfo"><a href="#2-2-UIlnfo" class="headerlink" title="2.2 UIlnfo"></a>2.2 <code>UIlnfo</code></h2><p>该脚本下，只有一个类，用于描述 <code>UICanvas</code> 的类型以及对应模板文件的路径。将该类标记为<strong>可序列化类</strong>，以方便其他解析<code>Json</code>文件方法能够使用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> UIType _type;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _path;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIInfo</span>()</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIInfo</span>(<span class="params">UIType uiType, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._type = uiType;</span><br><span class="line">        <span class="keyword">this</span>._path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UIType Type &#123; <span class="keyword">get</span> =&gt; _type; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Path &#123; <span class="keyword">get</span> =&gt; _path; <span class="keyword">set</span> =&gt; <span class="keyword">this</span>._path = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用属性器进行封装， <code>UICanvas</code> 的路径信息可以更新，但是其类型不可以更新。</p><h2 id="2-3-BaseUI"><a href="#2-3-BaseUI" class="headerlink" title="2.3 BaseUI"></a>2.3 <code>BaseUI</code></h2><p><code>BaseUI</code>里的方法用来描述所有面板共同的一些基本行为。面板的四个行为：进入场景<code>OnEnter</code>、暂停<code>OnPause</code>、继续<code>OnResume</code>（解除暂停）、退出场景<code>OnClose</code>，也是属于这个类的四个方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseUI</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CanvasGroup _canvasGroup;</span><br><span class="line">    <span class="keyword">private</span> UIType _type;</span><br><span class="line">    <span class="keyword">public</span> UIType Type &#123; <span class="keyword">get</span> =&gt; _type;<span class="keyword">protected</span> <span class="keyword">set</span> =&gt; _type = <span class="keyword">value</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gameObject.GetComponent&lt;Canvas&gt;() == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.AddComponent&lt;Canvas&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        _canvasGroup = gameObject.GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">        <span class="keyword">if</span> (_canvasGroup == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnClose</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-UIManager"><a href="#2-4-UIManager" class="headerlink" title="2.4 UIManager"></a>2.4 <code>UIManager</code></h2><p><code>UIManager</code>类的该 UI 框架的核心，它负责的工作如下：</p><ol><li>自动更新 <code>Json</code> 文件中记载 <code>UICanvas</code> 的 <code>UIType</code> 与路径</li><li>获取所有的 <code>UIPanel</code> 信息，并将数据加载到脚本中</li><li>使用字典储存所有 <code>UIPanel</code> 的游戏对象信息</li><li>使用栈储存场景中已加载的 <code>UIPanel</code></li></ol><h3 id="2-4-1-单例模式"><a href="#2-4-1-单例模式" class="headerlink" title="2.4.1 单例模式"></a>2.4.1 单例模式</h3><p>把<code>UIManager</code>做成单例模式，使其在游戏中，只有一个<code>UIManager</code>类去管理 UI 。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UIManager _instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            _instance = <span class="keyword">new</span> UIManager();</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-初始化并自动更新Json信息"><a href="#2-4-2-初始化并自动更新Json信息" class="headerlink" title="2.4.2 初始化并自动更新Json信息"></a>2.4.2 初始化并自动更新<code>Json</code>信息</h3><p>这里使用<code>Litjson</code>库来解析<code>Json</code>文件，把<code>Litjson.dll</code>文件添加到<code>Plugins</code>下，并且在代码编辑器中添加对应的引用。脚本中引入命名空间，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LitJson;</span><br></pre></td></tr></table></figure><p>配置<code>UIpanel</code>预制件文件夹的路径以及<code>Json</code>文件路径，如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放 UIPanel 预制件的文件夹路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _canvasPrefabFolder = Application.dataPath + <span class="string">@&quot;/Resources/UICanvasPrefab/&quot;</span>;</span><br><span class="line"><span class="comment">//存放UIPanel信息的Json文件的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFolderPath = Application.dataPath + <span class="string">@&quot;/Json/UIJson/&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFileName = <span class="string">&quot;UIPanelInfo.json&quot;</span>;</span><br></pre></td></tr></table></figure><p>并且使用列表，用来获取所有的 <code>UIInfo</code> 数据，其中也包括未加载到场景中的 <code>UIInfo</code> 。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;UIInfo&gt; _uIInfoList;<span class="comment">//该列表是存放所有的UIPanelInfo信息，包括未加载到游戏场景中的</span></span><br></pre></td></tr></table></figure><p>构造一个方法：传入<code>Json</code>路径和数据，就能将数据写入<code>Json</code>文件，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WriteToJsonFile</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName, T t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> json = JsonMapper.ToJson(t);</span><br><span class="line">    <span class="comment">//如果文件夹不存在，就创建文件夹</span></span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">        Directory.CreateDirectory(folderPath);</span><br><span class="line">    <span class="comment">//如果文件不存在，就创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">        File.Create(folderPath + fileName).Dispose();</span><br><span class="line">    <span class="comment">//将数据写入到文件中</span></span><br><span class="line">    File.WriteAllText(folderPath + fileName, json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个方法：传入<code>Json</code>路径，将对应路径下的<code>Json</code>文件中的数据读取到内存（脚本）中，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">ReadFromJsonFIle</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName</span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">        Directory.CreateDirectory(folderPath);</span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">        File.WriteAllText(folderPath + fileName, <span class="string">&quot;[]&quot;</span>);</span><br><span class="line">    List&lt;T&gt; t = JsonMapper.ToObject&lt;List&lt;T&gt;&gt;(File.ReadAllText(folderPath + fileName));</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个方法：自动更新 <code>Json</code>文件，并获取全部的模板信息，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitUIInfo</span>()()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先获取当前Json文件中的UIPanelInfo数据</span></span><br><span class="line">    _uIInfoList = ReadFromJsonFIle&lt;UIInfo&gt;(_jsonFolderPath, _jsonFileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建UIPanel的文件夹对象</span></span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(_canvasPrefabFolder))</span><br><span class="line">        Directory.CreateDirectory(_canvasPrefabFolder);</span><br><span class="line">    DirectoryInfo directoryInfo = <span class="keyword">new</span> DirectoryInfo(_canvasPrefabFolder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历文件夹下的每一个prefab文件。</span></span><br><span class="line">    <span class="comment">//如果当前UIPanelInfo列表中有对应类型的模板信息，就更新路径；没有，就添加对应信息到UIPanelInfo列表</span></span><br><span class="line">    <span class="keyword">foreach</span> (FileInfo fileInfo <span class="keyword">in</span> directoryInfo.GetFiles(<span class="string">&quot;*Canvas.prefab&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将对应UIPanel模板的名字转换为UIPanel类型</span></span><br><span class="line">        <span class="comment">//UIType type = (UIType)Enum.Parse(typeof(UIType), fileInfo.Name.Replace(&quot;.prefab&quot;, &quot;&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的代码不能处理&quot;UIType中不存在对应类型&quot;的情况，因此改为下面的代码(修改时间2023-6-23-21:58)</span></span><br><span class="line">        UIType type;</span><br><span class="line">        <span class="keyword">if</span> (!Enum.TryParse(fileInfo.Name.Replace(<span class="string">&quot;.prefab&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="keyword">out</span> type))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;UIManager.InitInfo() -&gt; TryParse UIType Error!&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">@&quot;UICanvasPrefab/&quot;</span> + Convert.ToString(type); <span class="comment">//基址+对应模板文件名，组成完整地址（不要后缀）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试在列表中寻找UIpanelInfo对象，如果有，则返回对应的对象；如果没有，则返回null</span></span><br><span class="line">        UIInfo uIInfo = _uIInfoList.TrySearchUI(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uIInfo == <span class="literal">null</span>)    <span class="comment">//UIPanel不在该List中</span></span><br><span class="line">        &#123;</span><br><span class="line">            uIInfo = <span class="keyword">new</span> UIInfo(type, path);</span><br><span class="line">            _uIInfoList.Add(uIInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//UIPanel在该List中,更新path值</span></span><br><span class="line">        &#123;</span><br><span class="line">            uIInfo.Path = path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteToJsonFile&lt;List&lt;UIInfo&gt;&gt;(_jsonFolderPath, _jsonFileName, _uIInfoList); <span class="comment">//将更新后的模板信息写入Json文件中去</span></span><br><span class="line">    AssetDatabase.Refresh(); <span class="comment">//刷新资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在<code>UIManager</code>的构造方法中调用<code>InitUIPanelInfo()</code>方法，以便于在该管理类创建时，就进行<code>Json</code>文件的更新。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UIManager</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitUIInfo()();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-实例化游戏Canvas对象"><a href="#2-4-3-实例化游戏Canvas对象" class="headerlink" title="2.4.3 实例化游戏Canvas对象"></a>2.4.3 实例化游戏<code>Canvas</code>对象</h3><p>首先，先获取当前场景的<code>UISysterm</code>的 <code>Transform</code>组件，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Transform _canvasTransform;<span class="comment"><span class="doctag">///</span>/存放当前场景中的所有Canvas对象的父级对象的Transform属性</span></span><br><span class="line"><span class="keyword">public</span> Transform CanvasTransform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_canvasTransform == <span class="literal">null</span>)</span><br><span class="line">            _canvasTransform = GameObject.Find(<span class="string">&quot;UISysterm&quot;</span>).transform;</span><br><span class="line">        <span class="keyword">if</span> (_canvasTransform == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _canvasTransform = <span class="keyword">new</span> GameObject(<span class="string">&quot;UISysterm&quot;</span>).transform;</span><br><span class="line">            _canvasTransform.position = Vector3.zero;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _canvasTransform;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> =&gt; _canvasTransform = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个方法：传入<code>UI</code>的类型，就能返回对应的<code>Canvas</code>游戏对象，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BaseUI <span class="title">GetUIPanel</span>(<span class="params">UIType type</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_uIInfoList == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">string</span> path = _uIInfoList.TrySearchUIPanel(type).Path;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Resources.Load(path) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">    GameObject insUIPanel = GameObject.Instantiate(Resources.Load(path)) <span class="keyword">as</span> GameObject; <span class="comment">//创建游戏实例对象</span></span><br><span class="line">    insUIPanel.transform.SetParent(CanvasTransform, <span class="literal">false</span>); <span class="comment">//设置父级对象</span></span><br><span class="line">    <span class="keyword">return</span> insUIPanel.GetComponent&lt;BaseUI&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-4-保存当前场景中的-UIPanel-对象"><a href="#2-4-4-保存当前场景中的-UIPanel-对象" class="headerlink" title="2.4.4 保存当前场景中的 UIPanel 对象"></a>2.4.4 保存当前场景中的 <code>UIPanel</code> 对象</h3><p>一般情况下，不同的<code>UI</code>是先打开的后关闭，后打开的先关闭，这符合<strong>栈</strong>的性质。因此使用栈来存放当前的已打开的<code>Canvas</code>对象。</p><p>首先，创建一个栈的字段，用于存放已打开的<code>Canvas</code>对象，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushUIPanel</span>(<span class="params">UIType type</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果当前栈为空</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">        _currentUIPanels = <span class="keyword">new</span> Stack&lt;BaseUI&gt;();</span><br><span class="line">    <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel暂停</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BaseUI topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">        topUIPanel.OnPause();</span><br><span class="line">    &#125;</span><br><span class="line">    BaseUI newUIPanel = GetUIPanel(type);</span><br><span class="line">    _currentUIPanels.Push(newUIPanel);</span><br><span class="line">    newUIPanel.OnEnter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈算法：构造一个方法，输入顶级<code>UI</code>的类型，就能弹出对应的<code>Canvas</code>，并调用<code>OnExit</code>方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PopUIPanel</span>(<span class="params">UIType type</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果当前栈为空，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果当前栈中没有UIPanel，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出栈顶的UIPanel，并调用OnExit方法</span></span><br><span class="line">    BaseUI topUIPanel = _currentUIPanels.Pop();</span><br><span class="line">    <span class="keyword">if</span> (topUIPanel.Type != type)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;弹出的UIPanel类型不匹配&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    topUIPanel.OnClose();</span><br><span class="line">    <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel恢复</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">    topUIPanel.OnResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-5-初始化并删除场景旧的UIPanel"><a href="#2-4-5-初始化并删除场景旧的UIPanel" class="headerlink" title="2.4.5 初始化并删除场景旧的UIPanel"></a>2.4.5 初始化并删除场景旧的<code>UIPanel</code></h3><p>如果场景中残留有旧的<code>Canvas</code>，那么就先删除当前场景中所有的<code>Canvas</code>，然后再加载<code>UIManager</code>，以便于向场景中添加新的<code>UI</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckUICanvasWhenGameBegin</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Transform child <span class="keyword">in</span> CanvasTransform)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject.DestroyImmediate(child.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在构造方法中添加这个方法，以便于在游戏运行开始就执行该方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitUIPanelInfo(); <span class="comment">//初始化UIPanelInfo</span></span><br><span class="line">    CheckUICanvasWhenGameBegin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-UILoader"><a href="#2-5-UILoader" class="headerlink" title="2.5 UILoader"></a>2.5 <code>UILoader</code></h2><p>这个类负责在游戏开始的时候加载所有需要的游戏配置。在该 UI 框架里，<code>UILoader</code>负责在游戏刚开始运行时，提供给<code>Manager</code>类中的<code>Canvas</code>信息，并加载主菜单面板<code>MainMenuCanvas</code>。由于这个类需要挂在场景中的物体上，所以需要继承自<code>MonoBehaviour</code>。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UILoader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.CanvasTransform = <span class="keyword">this</span>.transform;</span><br><span class="line">        UIManager.Instance.PushUIPanel(UIType.BackgroundCanvas);</span><br><span class="line">        UIManager.Instance.PushUIPanel(UIType.MainMenuCanvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-完善BaseUIPanel类"><a href="#2-6-完善BaseUIPanel类" class="headerlink" title="2.6 完善BaseUIPanel类"></a>2.6 完善<code>BaseUIPanel</code>类</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnClose</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line">    _canvasGroup.alpha = <span class="number">0</span>;</span><br><span class="line">    gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、拓展"><a href="#三、拓展" class="headerlink" title="三、拓展"></a>三、拓展</h1><h2 id="3-1-列表操作的扩展"><a href="#3-1-列表操作的扩展" class="headerlink" title="3.1 列表操作的扩展"></a>3.1 列表操作的扩展</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ListExtesion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 尝试在列表中查找指定的元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelInfos&quot;&gt;</span>当前操作的列表<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span>定的元素<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果列表中由指定的元素，就返回该元素；如果没有，就返回null<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UIInfo <span class="title">TrySearchUI</span>(<span class="params"><span class="keyword">this</span> List&lt;UIInfo&gt; uIInfos, UIType uIType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (UIInfo uIInfo <span class="keyword">in</span> uIInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (uIInfo.Type == uIType)</span><br><span class="line">                <span class="keyword">return</span> uIInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、事件响应"><a href="#四、事件响应" class="headerlink" title="四、事件响应"></a>四、事件响应</h1><p>与旧版的基本一样。</p><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-6-23</p></div></div><div class='timeline-item-content'><ol><li>在上述 2.4.2 中，“将文件名的字符串转化为对应枚举值”进行优化，能够处理“转换后的枚举值不存在”的问题</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-6-9</p></div></div><div class='timeline-item-content'><ol><li>在列表的扩展中，修复一个错误。</li><li>修复图片显示异常的问题</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-16</p></div></div><div class='timeline-item-content'><ol><li>完成对 UGUI 优化版的整理</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 功能框架 </category>
          
          <category> Csharp </category>
          
          <category> GUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 功能框架 </tag>
            
            <tag> GUI </tag>
            
            <tag> UGUI </tag>
            
            <tag> Json </tag>
            
            <tag> Litjson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity组件-Transform</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Unity%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6-Transforms.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Unity%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6-Transforms.html</url>
      
        <content type="html"><![CDATA[<h1 id="Transform-组件"><a href="#Transform-组件" class="headerlink" title="Transform-组件"></a>Transform-组件</h1><p><strong><code>Transform</code></strong> 用于存储<strong>游戏对象</strong>的位置、旋转、缩放和父级状态，因此非常重要。游戏对象将始终附加 <code>Transform</code> 组件。如果没有变换组件，则无法移除变换或创建游戏对象。</p><h2 id="Transform组件"><a href="#Transform组件" class="headerlink" title="Transform组件"></a><code>Transform</code>组件</h2><p><code>Transform</code> 组件确定对象在场景中的<strong>位置和姿态</strong>。<strong>每个游戏对象都有一个变换</strong>。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-TransformTransform组件视图.png" alt="Transform组件视图"></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Position</strong></td><td style="text-align:left">相对于父级（本地坐标系），在 X、Y 和 Z 坐标中的位置。</td></tr><tr><td style="text-align:center"><strong>Rotation</strong></td><td style="text-align:left">相对于父级，围绕 X、Y 和 Z 轴的旋转，以度为单位。</td></tr><tr><td style="text-align:center"><strong>Scale</strong></td><td style="text-align:left">沿 X、Y 和 Z 轴的变换比例。值“1”是原始大小（导入对象的大小）。选择值旁边的链接图标以切换比例缩放。比例缩放按比例调整刻度值。</td></tr></tbody></table></div><blockquote><p>注意：每个<code>Transform</code>组件面板中的<strong>Position</strong>，指的是相对于父级的位置，一般游戏对象在场景中的位置是世界坐标，因此需要将子级的<strong>Position</strong>以及对应的每一级父级的<strong>Position</strong>相加，才能得到<strong>世界坐标</strong>。而脚本中的<code>Transform</code>对象下的<strong>Position</strong>属性，就是世界坐标。这一点很重要</p><p>为了说明这一点，请看下面例子。</p><p>首先设置父级坐标为 <code>(-2,0,0)</code> ，子级坐标 <code>(0,0,0)</code> ，然后打印出子级 <code>Transform</code> 脚本对象的<strong>Position</strong>属性。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform父级坐标.png" alt="父级坐标"></p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform子级坐标.png" alt="子级坐标"></p><p>将下面测试脚本挂载到子级上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="keyword">this</span>.transform.position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果为：</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform输出的结果.png" alt="输出的结果"></p></blockquote><h2 id="编辑转换"><a href="#编辑转换" class="headerlink" title="编辑转换"></a>编辑转换</h2><p><code>Transform</code> 在 X、Y 和 Z 轴的 3D 空间中或在 X 和 Y 轴的 2D 空间中进行操作。在 Unity 中，这些轴分别由红色、绿色和蓝色表示。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform左手坐标系.png" alt="左手坐标系"></p><p>在场景中，您可以使用移动、旋转和缩放工具修改<code>Transform</code>。这些工具位于 Unity 编辑器的左上角。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform转换-平移.png" alt="转换"></p><h2 id="Parenting——父级"><a href="#Parenting——父级" class="headerlink" title="Parenting——父级"></a>Parenting——父级</h2><p><code>Parenting</code> 是使用 Unity 时要了解的最重要的概念之一。当游戏对象是另一个游戏对象的<strong>父级</strong>，<strong>子游戏对象将完全按照其父游戏对象的方式移动、旋转和缩放</strong>。</p><p>可以把 <code>Parenting</code> 想象成手臂和身体之间的关系：每当你的身体移动时，你的手臂也会随之移动。子对象也可以有自己的子对象，依此类推。所以你的手可以被视为你手臂的“孩子”，然后每只手都有几根手指，等等。任何对象都可以有多个子对象，但只能有一个父对象。这些多层次的父子关系构成了转换<em>层次结构</em>。</p><p>层次结构最顶端的对象（即层次结构中唯一没有父对象的对象）称为<strong>根</strong>。</p><p>可以通过将<strong>层次结构视图中</strong>的任何游戏对象拖动到另一个游戏对象上来创建父级。这将在两个游戏对象之间创建父子关系。</p><h2 id="使用-Transform-的小提示"><a href="#使用-Transform-的小提示" class="headerlink" title="使用 Transform 的小提示"></a>使用 <code>Transform</code> 的小提示</h2><ul><li>在父级转换时，在添加子级之前将父级的位置设置为 <0，0，0> 非常有用。这意味着子项的本地坐标将与全局坐标相同，从而更容易确保子项处于正确的位置。</li><li>如果您正在使用<strong>刚体</strong>，对于物理仿真，请务必阅读<a href="https://docs.unity3d.com/Manual/class-Rigidbody.html">刚体</a>组件参考页面上的 Scale 属性。</li><li>您可以从首选项（<strong>菜单：Unity &gt;首选项</strong>）更改变换轴（和其他 UI 元素）的颜色，然后选择<strong>颜色和键</strong>面板）。</li><li>更改比例会影响子变换的位置。例如，将父项缩放为 （0，0，0） 会将所有子项定位为相对于父项的 （0，0，0）。</li></ul><h1 id="Transform——脚本"><a href="#Transform——脚本" class="headerlink" title="Transform——脚本"></a>Transform——脚本</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>对象的位置、旋转和缩放。场景中的每个对象都有一个变换。 它用于存储和操作对象的位置，旋转和缩放。 每个变换都可以有一个父级，它允许您分层应用位置、旋转和缩放。这是在“层次结构”窗格中看到的层次结构。 它们还支持<strong>枚举器</strong>，因此您可以使用以下方法循环遍历子项：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform transform = gameObject.GetComponent&lt;Transform&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (Transform child <span class="keyword">in</span> transform)</span><br><span class="line">        &#123;</span><br><span class="line">            child.position += Vector3.up * <span class="number">10.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>下面只罗列在游戏开发中，最常用的属性，完整属性列表请参看<a href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity - Scripting API: Transform (unity3d.com)</a>官方文档</p><div class="table-container"><table><thead><tr><th><a href="https://docs.unity3d.com/ScriptReference/Transform-childCount.html">childCount</a></th><th>父级 <code>Transform</code> 有的子级数。（注意：这里是一级子级数）。</th></tr></thead><tbody><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-localPosition.html">localPosition</a></td><td>相对于父级的位置。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-localRotation.html">localRotation</a></td><td>相对于父级的旋转。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-localScale.html">localScale</a></td><td>相对于父级的缩放。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-parent.html">parent</a></td><td>当前 <code>Transform</code> 的父级的 <code>Transform</code> 对象。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-position.html">position</a></td><td>世界坐标空间位置。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-rotation.html">rotation</a></td><td>一个四元数，用于存储在世界空间中的旋转。</td></tr></tbody></table></div><h2 id="常用公共方法"><a href="#常用公共方法" class="headerlink" title="常用公共方法"></a>常用公共方法</h2><p>下面只罗列在游戏开发中，最常用的公共方法，完整公共方法列表请参看<a href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity - Scripting API: Transform (unity3d.com)</a>官方文档</p><div class="table-container"><table><thead><tr><th><a href="https://docs.unity3d.com/ScriptReference/Transform.DetachChildren.html">DetachChildren</a></th><th>取消所有孩子的父母。如果要在不销毁子层次结构的情况下销毁层次结构的根，则很有用。</th></tr></thead><tbody><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.Find.html">Find</a></td><td><strong>按名称查找</strong>子项并将其返回。注意：只会在一级子级中查找。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.GetChild.html">GetChild</a></td><td>按索引返回转换子项。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.IsChildOf.html">IsChildOf</a></td><td>返回一个布尔值，该值指示转换是否为给定转换的子级。 如果此转换是子转换，则为真，深度子项（子项的子项）或与此转换相同，否则为假。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.Rotate.html">Rotate</a></td><td>使用 Transform.Rotate 以多种方式旋转游戏对象。旋转通常以欧拉角而不是四元数的形式提供。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.RotateAround.html">RotateAround</a></td><td>围绕在世界坐标中通过点的轴按角度旋转变换。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.SetParent.html"><strong>SetParent</strong></a></td><td><strong>设置转换的父级</strong>。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.Translate.html">Translate</a></td><td>沿平移方向和距离移动变换。（世界坐标的封装）</td></tr></tbody></table></div><h3 id="Find-方法"><a href="#Find-方法" class="headerlink" title="Find() 方法"></a><code>Find()</code> 方法</h3><p>下面进行测试：</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-TransformFind方法测试-1.png" alt="Find方法测试-1"></p><p>挂载的脚本如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform transform = gameObject.GetComponent&lt;Transform&gt;();</span><br><span class="line">        Transform transform1 = transform.Find(<span class="string">&quot;www&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (transform1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(transform1.gameObject.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的控制台输出的结果为：</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-TransformFind方法测试-结果.png" alt="Find方法测试-结果"></p><blockquote><p>总结：上面的结果可以看出， <code>Find()</code> 方法，并不能找到二级子级</p></blockquote><h3 id="SetParent（）-方法"><a href="#SetParent（）-方法" class="headerlink" title="SetParent（） 方法"></a><code>SetParent（）</code> 方法</h3><p>声明</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetParent</span>(<span class="params">Transform parent</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetParent</span>(<span class="params">Transform parent, <span class="built_in">bool</span> worldPositionStays</span>)</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>parent</code> ：要使用的父转换。</li><li><code>worldPositionStays</code><ul><li><code>true</code> ：修改相对于父级的位置、缩放和旋转，<strong>以使对象保持与以前相同的世界空间位置、旋转和缩放</strong>。</li><li><code>false</code> ：设置相对于父级的位置、缩放和旋转，为默认值。（此举可能会改变世界坐标系空间的状态）</li></ul></li></ul><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-12</p></div></div><div class='timeline-item-content'><ol><li>添加了 <code>Find()</code> 方法的测试</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-11</p></div></div><div class='timeline-item-content'><ol><li>创建文档，介绍 Transform 组件的使用</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Unity组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Unity组件 </tag>
            
            <tag> Transform变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity之UGUI框架</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/UGUI%E6%A1%86%E6%9E%B6.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/UGUI%E6%A1%86%E6%9E%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>UI</code>是一个游戏必不可少的一部分。对于一个游戏系统而言，它的<code>UI</code>也是多种多样的。经常地，因为要满足不同的需求，当前场景中的<code>UI</code>也会频繁切换。因此，为了更方便的管理这些<code>UI</code>的状态和行为，开发一个基于<code>UGUI</code>系统的<strong><code>UI</code>管理框架</strong>。</p><h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><ol><li>进入游戏时，首先会加载<strong>主 UI </strong>，<strong>主 UI </strong>随着游戏的进入和退出而加载和销毁。</li><li>通过一些按钮，我们可以打开其他的 UI 界面，同时主 UI 不会消失</li><li>当前场景可以同时存在多级 UI ，只有处于顶级的 UI 才能被选中并进行操作</li><li>除了主 UI 外的其他 UI 均可以在游戏场景未关闭下，手动关闭</li></ol><h1 id="二、框架设计"><a href="#二、框架设计" class="headerlink" title="二、框架设计"></a>二、框架设计</h1><p><img src="http://imageshack.yuilexi.cn/Unity3D/功能框架/UGUI/UIFramework.svg" alt="UIFramework"></p><h1 id="三、功能实现"><a href="#三、功能实现" class="headerlink" title="三、功能实现"></a>三、功能实现</h1><h2 id="3-1-UIPanel"><a href="#3-1-UIPanel" class="headerlink" title="3.1 UIPanel"></a>3.1 <code>UIPanel</code></h2><p>这一部分是用于描述 UI 面板属性的一些脚本。</p><h3 id="3-1-1-UIPanelType脚本"><a href="#3-1-1-UIPanelType脚本" class="headerlink" title="3.1.1 UIPanelType脚本"></a>3.1.1 <code>UIPanelType</code>脚本</h3><p>这是一个枚举类，用于描述所有<code>UIPanel</code>的类型（以<code>UIPanel</code>的名字作为它的类型），下面只写了两个例子。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UIPanelType</span><br><span class="line">&#123;</span><br><span class="line">    MainMenuUIPanel,</span><br><span class="line">    SettingUIPanel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-UIPanelInfo脚本"><a href="#3-1-2-UIPanelInfo脚本" class="headerlink" title="3.1.2 UIPanelInfo脚本"></a>3.1.2 <code>UIPanelInfo</code>脚本</h3><p>该脚本下，只有一个类，用于描述<code>UIPanel</code>的类型以及对应模板文件的路径，并且使用属性器进行封装。将该类标记为<strong>可序列化类</strong>，以方便其他解析<code>Json</code>文件方法能够使用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPanelInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> UIPanelType _type;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _path;       <span class="comment">//注意，脚本使用Rescources.load()动态加载，这里的文件路径不需要后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIPanelInfo</span>()</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIPanelInfo</span>(<span class="params">UIPanelType type, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _type = type;</span><br><span class="line">        _path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UIPanelType Type</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _type; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _type = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Path</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _path; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _path = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-BaseUIPanel脚本"><a href="#3-1-3-BaseUIPanel脚本" class="headerlink" title="3.1.3 BaseUIPanel脚本"></a>3.1.3 <code>BaseUIPanel</code>脚本</h3><p><del>由于<code>BaseUIPanel</code>脚本需要挂载到所有面板对象上，因此需要继承<code>MonoBehaviour</code> 。</del> <code>BasePanel</code>里的方法用来描述所有面板共同的一些基本行为，面板的四个状态：进入场景<code>OnEnter</code>、暂停<code>OnPause</code>、继续<code>OnResume</code>（解除暂停）、退出场景<code>OnExit</code>，也是属于这个类的四个方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseUIPanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Manager"><a href="#3-2-Manager" class="headerlink" title="3.2 Manager"></a>3.2 <code>Manager</code></h2><p><code>UIManager</code>类的该 UI 框架的核心，它负责的工作如下：</p><ol><li>自动更新<code>Json</code>文件中记载<code>UIPanel</code>的<code>UIPanelType</code>与路径</li><li>获取所有的<code>UIPanel</code>信息，并将数据加载到脚本中</li><li>使用字典储存所有<code>UIPanel</code>的游戏对象信息</li><li>使用栈储存场景中已加载的<code>UIPanel</code></li></ol><h3 id="3-2-1-单例模式"><a href="#3-2-1-单例模式" class="headerlink" title="3.2.1 单例模式"></a>3.2.1 单例模式</h3><p>把<code>UIManager</code>做成单例模式，使其在游戏中，只有一个<code>UIManager</code>类去管理 UI 。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UIManager s_instance;</span><br><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_instance == <span class="literal">null</span>)</span><br><span class="line">            s_instance = <span class="keyword">new</span> UIManager();</span><br><span class="line">        <span class="keyword">return</span> s_instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-初始化并自动更新Json信息"><a href="#3-2-2-初始化并自动更新Json信息" class="headerlink" title="3.2.2 初始化并自动更新Json信息"></a>3.2.2 初始化并自动更新<code>Json</code>信息</h3><p>这里使用<code>Litjson</code>库来解析<code>Json</code>文件，把<code>Litjson.dll</code>文件添加到对应路径下，并且在代码编辑器中添加对应的引用。脚本中引入命名空间，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LitJson;</span><br></pre></td></tr></table></figure><p>配置<code>UIpanel</code>预制件文件夹的路径以及<code>Json</code>文件路径，如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放 UIPanel 预制件的文件夹路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _basePahtUIPanelPrefabFolder = Application.dataPath + <span class="string">@&quot;/Resources/UIPanelPrefab/&quot;</span>;</span><br><span class="line"><span class="comment">//存放UIPanel信息的Json文件的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFolderPath = Application.dataPath + <span class="string">@&quot;/Json/UIJson/&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFileName = <span class="string">&quot;UIPanelInfo.json&quot;</span>;</span><br></pre></td></tr></table></figure><p>并且创建一个列表，用来获取所有的<code>UIPanelInfo</code>数据，其中也包括未加载到场景中的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;UIPanelInfo&gt; _uIPanelInfos;<span class="comment">//该列表是存放所有的UIPanelInfo信息，包括未加载到游戏场景中的</span></span><br></pre></td></tr></table></figure><p>构造一个方法：传入<code>Json</code>路径和数据，并且将数据写入<code>Json</code>文件，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WriteToJsonFile</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName, T t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> json = JsonMapper.ToJson(t);</span><br><span class="line">    <span class="comment">//如果文件夹不存在，就创建文件夹</span></span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">        Directory.CreateDirectory(folderPath);</span><br><span class="line">    <span class="comment">//如果文件不存在，就创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">        File.Create(folderPath + fileName).Dispose();</span><br><span class="line">    <span class="comment">//将数据写入到文件中</span></span><br><span class="line">    File.WriteAllText(folderPath + fileName, json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个方法：传入<code>Json</code>路径，将对应路径下的<code>Json</code>文件中的数据读取到内存（脚本）中，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">ReadFromJsonFIle</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName</span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">        Directory.CreateDirectory(folderPath);</span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">        File.WriteAllText(folderPath + fileName, <span class="string">&quot;[]&quot;</span>);</span><br><span class="line">    List&lt;T&gt; t = JsonMapper.ToObject&lt;List&lt;T&gt;&gt;(File.ReadAllText(folderPath + fileName));</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个方法：自动更新 <code>Json</code>文件，并获取全部的模板信息，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitUIPanelInfo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先获取当前Json文件中的UIPanelInfo数据</span></span><br><span class="line">    _uIPanelInfos = ReadFromJsonFIle&lt;UIPanelInfo&gt;(_jsonFolderPath, _jsonFileName);</span><br><span class="line">    <span class="comment">//创建UIPanel的文件夹对象</span></span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(_basePahtUIPanelPrefabFolder))</span><br><span class="line">        Directory.CreateDirectory(_basePahtUIPanelPrefabFolder);</span><br><span class="line">    DirectoryInfo directoryInfo = <span class="keyword">new</span> DirectoryInfo(_basePahtUIPanelPrefabFolder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历文件夹下的每一个prefab文件。</span></span><br><span class="line">    <span class="comment">//如果当前UIPanelInfo列表中有对应类型的模板信息，就更新路径；没有，就添加对应信息到UIPanelInfo列表</span></span><br><span class="line">    <span class="keyword">foreach</span> (FileInfo fileInfo <span class="keyword">in</span> directoryInfo.GetFiles(<span class="string">&quot;*prefab&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将对应UIPanel模板的名字转换为UIPanel类型</span></span><br><span class="line">        UIPanelType type = (UIPanelType)Enum.Parse(<span class="keyword">typeof</span>(UIPanelType), fileInfo.Name.Replace(<span class="string">&quot;.prefab&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">@&quot;UIPanelPrefab/&quot;</span> + Convert.ToString(type); <span class="comment">//基址+对应模板文件名，组成完整地址（不要后缀）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试在列表中寻找UIpanelInfo对象，如果有，则返回对应的对象；如果没有，则返回null</span></span><br><span class="line">        UIPanelInfo uIPanelInfo = _uIPanelInfos.TrySearchUIPanel(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uIPanelInfo == <span class="literal">null</span>)    <span class="comment">//UIPanel不在该List中</span></span><br><span class="line">        &#123;</span><br><span class="line">            uIPanelInfo = <span class="keyword">new</span> UIPanelInfo(type, path);</span><br><span class="line">            _uIPanelInfos.Add(uIPanelInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//UIPanel在该List中,更新path值</span></span><br><span class="line">        &#123;</span><br><span class="line">            uIPanelInfo.Path = path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteToJsonFile&lt;List&lt;UIPanelInfo&gt;&gt;(_jsonFolderPath, _jsonFileName, _uIPanelInfos); <span class="comment">//将更新后的模板信息写入Json文件中去</span></span><br><span class="line">    AssetDatabase.Refresh(); <span class="comment">//刷新资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在<code>UIManager</code>的构造方法中调用<code>InitUIPanelInfo()</code>方法，以便于在该管理类创建时，就进行<code>Json</code>文件的更新。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UIManager</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitUIPanelInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-实例化游戏UIPanel对象"><a href="#3-2-3-实例化游戏UIPanel对象" class="headerlink" title="3.2.3 实例化游戏UIPanel对象"></a>3.2.3 实例化游戏<code>UIPanel</code>对象</h3><p>首先，先获取当前场景的<code>Canvas</code>的 <code>Transform</code>组件，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Transform _canvasTransform;<span class="comment">//存放当前场景中的Canvas对象的Transform属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Transform</span></span><br><span class="line"><span class="keyword">public</span> Transform CanvasTransform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_canvasTransform == <span class="literal">null</span>)</span><br><span class="line">            _canvasTransform = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line">        <span class="keyword">return</span> _canvasTransform;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; _canvasTransform = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述存在一个问题，使用<code>GameObject.Find(&quot;Canvas&quot;)</code>方法，性能很低，会占用更多的时间。改进方法中包含<code>set&#123;&#125;</code>部分，后续会讲解原因。</p><p>构造一个方法：传入<code>UIPanel</code>的类型，就能返回对应的<code>Panel</code>游戏对象，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BaseUIPanel <span class="title">GetUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_uIPanelInfos == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> path = _uIPanelInfos.TrySearchUIPanel(uIPanelType).Path;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Resources.Load(path) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">    GameObject insUIPanel = GameObject.Instantiate(Resources.Load(path)) <span class="keyword">as</span> GameObject; <span class="comment">//创建游戏实例对象</span></span><br><span class="line">    insUIPanel.transform.SetParent(CanvasTransform, <span class="literal">false</span>); <span class="comment">//设置父级对象</span></span><br><span class="line">    <span class="keyword">return</span> insUIPanel.GetComponent&lt;BaseUIPanel&gt;(); <span class="comment">//返回BaseUIPanel脚本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-保存当前场景中的-UIPanel-对象"><a href="#3-2-4-保存当前场景中的-UIPanel-对象" class="headerlink" title="3.2.4 保存当前场景中的 UIPanel 对象"></a>3.2.4 保存当前场景中的 UIPanel 对象</h3><p>一般情况下，不同的<code>UI</code>是先打开的后关闭，后打开的先关闭，这符合<strong>栈</strong>的性质。因此使用栈来存放当前的已打开的<code>UIPanel</code>对象。</p><p>首先，创建一个栈的字段，用于存放已打开的<code>UIPanel</code>对象，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;BaseUIPanel&gt; _currentUIPanels;<span class="comment">//存放当前场景中已加载的UIPanel对象</span></span><br></pre></td></tr></table></figure><p>入栈算法：构造一个方法，将对应的<code>UIPanel</code>压入栈中，并调用<code>OnEnter</code>方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果当前栈为空</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">        _currentUIPanels = <span class="keyword">new</span> Stack&lt;BaseUIPanel&gt;();</span><br><span class="line">    <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel暂停</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BaseUIPanel topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">        topUIPanel.OnPause();</span><br><span class="line">    &#125;</span><br><span class="line">    BaseUIPanel newUIPanel = GetUIPanel(uIPanelType);</span><br><span class="line">    _currentUIPanels.Push(newUIPanel);</span><br><span class="line">    newUIPanel.OnEnter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈算法：构造一个方法，输入顶级<code>UIPanel</code>的类型，就能弹出对应的<code>UIPanel</code>，并调用<code>OnExit</code>方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PopUIPanel</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果当前栈为空，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果当前栈中没有UIPanel，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出栈顶的UIPanel，并调用OnExit方法</span></span><br><span class="line">    BaseUIPanel topUIPanel = _currentUIPanels.Pop();</span><br><span class="line">    topUIPanel.OnEixt();</span><br><span class="line">    <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel恢复</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">    topUIPanel.OnResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-初始化并删除场景已存在的UIPanel"><a href="#3-2-5-初始化并删除场景已存在的UIPanel" class="headerlink" title="3.2.5 初始化并删除场景已存在的UIPanel"></a>3.2.5 初始化并删除场景已存在的<code>UIPanel</code></h3><p>如果场景中残留有旧的<code>UIPanel</code>，那么就先删除当前场景中所有的<code>UIPanel</code>，然后再加载<code>UIManager</code>，以便于向场景中添加新的<code>UI</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckUIPanelWhenGameBegin</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;CanvasTransform.childCount&gt; i;)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject.DestroyImmediate(CanvasTransform.GetChild(i).gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：上述方法中，for 循环并没有将循环因子<code>i</code>进行自增处理，这是由于<code>CanvasTransform.childCount</code>是在动态变化的，因此我们判断的条件是<code>CanvasTransform.childCount&lt;=0</code>，终止循环。</p></blockquote><p>并在构造方法中添加这个方法，以便于在游戏运行开始就执行该方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitUIPanelInfo(); <span class="comment">//初始化UIPanelInfo</span></span><br><span class="line">    CheckUIPanelWhenGameBegin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-UIManagerLoader脚本"><a href="#3-3-UIManagerLoader脚本" class="headerlink" title="3.3 UIManagerLoader脚本"></a>3.3 <code>UIManagerLoader</code>脚本</h2><p>这个类负责在游戏开始的时候加载所有需要的游戏配置。在该 UI 框架里，<code>UIManagerLoader</code>负责在游戏刚开始运行时，提供给<code>Manager</code>类中的<code>Canvas</code>信息，并加载主菜单面板<code>MainMenuPanel</code>。由于这个类需要挂在场景中的物体上，所以需要继承自<code>MonoBehaviour</code>。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先把当前场景中的Canvas对象的Transform属性赋值给UIManager的CanvasTransform属性</span></span><br><span class="line"><span class="comment">//游戏一开始就加载MainMenuUIPanel</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    UIManager.Instance.CanvasTransform = <span class="keyword">this</span>.transform;</span><br><span class="line">    UIManager.Instance.PushUIPanel(UIPanelType.MainMenuUIPanel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="#3-2-3-实例化游戏UIPanel对象">3.2.3 实例化游戏<code>UIPanel</code>对象</a>中，我们提到了使用<code>GameObject.Find(&quot;Canvas&quot;)</code>方法寻找到当前的 UI 画布，但是<code>GameObject.Find(&quot;&quot;)</code>的性能较低，可能会占用较长的时间。因此，改进方法中包含<code>set&#123;&#125;</code>部分，那么可以在<code>UIManagerLoader</code>脚本中，向<code>Manager</code>类传入对应的画布对象，能更快的获取到<code>Canvas</code>对象，此举需要将该脚本挂载到 <code>Canvas</code> 游戏对象上。</p><h2 id="3-4-完善BaseUIPanel类"><a href="#3-4-完善BaseUIPanel类" class="headerlink" title="3.4 完善BaseUIPanel类"></a>3.4 完善<code>BaseUIPanel</code>类</h2><h3 id="3-4-1-获取CanvasGroup"><a href="#3-4-1-获取CanvasGroup" class="headerlink" title="3.4.1 获取CanvasGroup"></a>3.4.1 获取<code>CanvasGroup</code></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CanvasGroup _canvasGroup;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _canvasGroup = GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">    <span class="keyword">if</span> (_canvasGroup == <span class="literal">null</span>)</span><br><span class="line">        _canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后完善四个方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 打开时需要执行的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">    _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 暂停时需要执行的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line">    _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重新启动时需要执行的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">    _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 关闭时需要执行的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    Destroy(<span class="keyword">this</span>.gameObject, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-扩展"><a href="#3-5-扩展" class="headerlink" title="3.5 扩展"></a>3.5 扩展</h2><h3 id="3-5-1-列表操作的扩展"><a href="#3-5-1-列表操作的扩展" class="headerlink" title="3.5.1 列表操作的扩展"></a>3.5.1 列表操作的扩展</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ListExtesion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 尝试在列表中查找指定的元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelInfos&quot;&gt;</span>当前操作的列表<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span>定的元素<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果列表中由指定的元素，就返回该元素；如果没有，就返回null<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UIPanelInfo <span class="title">TrySearchUIPanel</span>(<span class="params"><span class="keyword">this</span> List&lt;UIPanelInfo&gt; uIPanelInfos, UIPanelType uIPanelType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (UIPanelInfo uIPanelInfo <span class="keyword">in</span> uIPanelInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (uIPanelInfo.Type == uIPanelType)</span><br><span class="line">                <span class="keyword">return</span> uIPanelInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、事件响应"><a href="#四、事件响应" class="headerlink" title="四、事件响应"></a>四、事件响应</h1><p>首先创建新的文件夹<code>UIEvents</code>，然后再该文件夹下创建对应的脚本。例如：对于<code>MainMenuUIPanel</code>面板，创建<code>MainMenuUIPanel</code>类，并继承自<code>BaseUIPanel</code>。并对父类<code>BaseUIPanel</code>中的虚方法进行重写和调用，并构造该面板独有的事件响应函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainMenuUIPanel</span> : <span class="title">BaseUIPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnter();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnEnter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnPause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnResume();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnResume&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEixt();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnEixt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开设置界面的按钮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSettingClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.PushUIPanel(UIPanelType.SettingUIPanel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将此脚本，挂载到对应的游戏对象上，然后再对应的按钮上设置点击响应事件。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/功能框架/UGUI/Panel添加脚本.png" alt="Panel添加脚本"></p><p><img src="http://imageshack.yuilexi.cn/Unity3D/功能框架/UGUI/添加响应事件.png" alt="添加响应事件"></p><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><details class="folding-tag" ><summary> 完整代码 </summary>              <div class='content'>              <ul><li><p>UIFramework</p><ul><li><p>UIPanel</p><ul><li><p>UIPanelType.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 枚举，用于标识UIPanel的类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UIPanelType</span><br><span class="line">&#123;</span><br><span class="line">    MainMenuUIPanel,</span><br><span class="line">    SettingUIPanel,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UIPanelInfo.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 描述UIPanel的信息，包括类型和路径</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPanelInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> UIPanelType _type;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _path;       <span class="comment">//注意，脚本使用Rescources.load()动态加载，这里的文件路径不需要后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIPanelInfo</span>()</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIPanelInfo</span>(<span class="params">UIPanelType type, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _type = type;</span><br><span class="line">        _path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UIPanelType Type</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _type; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _type = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Path</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _path; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _path = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BasePanel.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">    </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 该类需要挂载到每一个Panel的预制件上，因此继承MonoBehaviour</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseUIPanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CanvasGroup _canvasGroup;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _canvasGroup = GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">        <span class="keyword">if</span> (_canvasGroup == <span class="literal">null</span>)</span><br><span class="line">            _canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 打开时需要执行的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">        _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 暂停时需要执行的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _canvasGroup.blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line">        _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 重新启动时需要执行的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">        _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 关闭时需要执行的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject, <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Manager</p><ul><li><p>UIManager.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LitJson;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UIElements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 单例模式</span></span><br><span class="line">    <span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UIManager s_instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s_instance == <span class="literal">null</span>)</span><br><span class="line">                s_instance = <span class="keyword">new</span> UIManager();</span><br><span class="line">            <span class="keyword">return</span> s_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span> 单例模式</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 文件路径</span></span><br><span class="line">    <span class="comment">//存放 UIPanel 预制件的文件夹路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _basePahtUIPanelPrefabFolder = Application.dataPath + <span class="string">@&quot;/Resources/UIPanelPrefab/&quot;</span>;</span><br><span class="line">    <span class="comment">//存放UIPanel信息的Json文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFolderPath = Application.dataPath + <span class="string">@&quot;/Json/UIJson/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFileName = <span class="string">&quot;UIPanelInfo.json&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span> 文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;UIPanelInfo&gt; _uIPanelInfos;   <span class="comment">//该列表是存放所有的UIPanelInfo信息，包括未加载到游戏场景中的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform _canvasTransform; <span class="comment">//存放当前场景中的Canvas对象的Transform属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;BaseUIPanel&gt; _currentUIPanels; <span class="comment">//使用栈，存放当前场景中的所有UIPanel</span></span><br><span class="line">      <span class="comment">//获取Transform</span></span><br><span class="line">      <span class="keyword">public</span> Transform CanvasTransform</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">get</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (_canvasTransform == <span class="literal">null</span>)</span><br><span class="line">                  _canvasTransform = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line">              <span class="keyword">return</span> _canvasTransform;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">set</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">value</span>.name == <span class="string">&quot;Canvas&quot;</span>)</span><br><span class="line">                  _canvasTransform = <span class="keyword">value</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          InitUIPanelInfo(); <span class="comment">//初始化UIPanelInfo</span></span><br><span class="line">          CheckUIPanelWhenGameBegin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 传入路径和对应的数据，把该数据写入到对应路径的Json文件里</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;folderPath&quot;&gt;</span>文件夹路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fileName&quot;&gt;</span>文件名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>写入的数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>数据类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WriteToJsonFile</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName, T t</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">string</span> json = JsonMapper.ToJson(t);</span><br><span class="line">          <span class="comment">//如果文件夹不存在，就创建文件夹</span></span><br><span class="line">          <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">              Directory.CreateDirectory(folderPath);</span><br><span class="line">          <span class="comment">//如果文件不存在，就创建文件</span></span><br><span class="line">          <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">              File.Create(folderPath + fileName).Dispose();</span><br><span class="line">          <span class="comment">//将数据写入到文件中</span></span><br><span class="line">          File.WriteAllText(folderPath + fileName, json);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 传入文件的路径，就能读取到该文件的数据</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;folderPath&quot;&gt;</span>文件夹路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fileName&quot;&gt;</span>文件名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">ReadFromJsonFIle</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName</span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">              Directory.CreateDirectory(folderPath);</span><br><span class="line">          <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">              File.WriteAllText(folderPath + fileName, <span class="string">&quot;[]&quot;</span>);</span><br><span class="line">          List&lt;T&gt; t = JsonMapper.ToObject&lt;List&lt;T&gt;&gt;(File.ReadAllText(folderPath + fileName));</span><br><span class="line">          <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 自动更新Json文件，并获取到所有的UIPanelInfo数据</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitUIPanelInfo</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//先获取当前Json文件中的UIPanelInfo数据</span></span><br><span class="line">          _uIPanelInfos = ReadFromJsonFIle&lt;UIPanelInfo&gt;(_jsonFolderPath, _jsonFileName);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//创建UIPanel的文件夹对象</span></span><br><span class="line">          <span class="keyword">if</span> (!Directory.Exists(_basePahtUIPanelPrefabFolder))</span><br><span class="line">              Directory.CreateDirectory(_basePahtUIPanelPrefabFolder);</span><br><span class="line">          DirectoryInfo directoryInfo = <span class="keyword">new</span> DirectoryInfo(_basePahtUIPanelPrefabFolder);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//遍历文件夹下的每一个prefab文件。</span></span><br><span class="line">          <span class="comment">//如果当前UIPanelInfo列表中有对应类型的模板信息，就更新路径；没有，就添加对应信息到UIPanelInfo列表</span></span><br><span class="line">          <span class="keyword">foreach</span> (FileInfo fileInfo <span class="keyword">in</span> directoryInfo.GetFiles(<span class="string">&quot;*.prefab&quot;</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//将对应UIPanel模板的名字转换为UIPanel类型</span></span><br><span class="line">              UIPanelType type = (UIPanelType)Enum.Parse(<span class="keyword">typeof</span>(UIPanelType), fileInfo.Name.Replace(<span class="string">&quot;.prefab&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">              <span class="built_in">string</span> path = <span class="string">@&quot;UIPanelPrefab\&quot;</span> + Convert.ToString(type); <span class="comment">//基址+对应模板文件名，组成完整地址（不要后缀）</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">//尝试在列表中寻找UIpanelInfo对象，如果有，则返回对应的对象；如果没有，则返回null</span></span><br><span class="line">              UIPanelInfo uIPanelInfo = _uIPanelInfos.TrySearchUIPanel(type);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (uIPanelInfo == <span class="literal">null</span>)    <span class="comment">//UIPanel不在该List中</span></span><br><span class="line">              &#123;</span><br><span class="line">                  uIPanelInfo = <span class="keyword">new</span> UIPanelInfo(type, path);</span><br><span class="line">                  _uIPanelInfos.Add(uIPanelInfo);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="comment">//UIPanel在该List中,更新path值</span></span><br><span class="line">              &#123;</span><br><span class="line">                  uIPanelInfo.Path = path;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          WriteToJsonFile&lt;List&lt;UIPanelInfo&gt;&gt;(_jsonFolderPath, _jsonFileName, _uIPanelInfos); <span class="comment">//将更新后的模板信息写入Json文件中去</span></span><br><span class="line">          AssetDatabase.Refresh(); <span class="comment">//刷新资源</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 根据对应的UIPanel类型，创建游戏实例对象，并返回该对象的BaseUIPanel脚本</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span>UIPanlel的类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;Exception&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> BaseUIPanel <span class="title">GetUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (_uIPanelInfos == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">string</span> path = _uIPanelInfos.TrySearchUIPanel(uIPanelType).Path;</span><br><span class="line"></span><br><span class="line">          <span class="meta">#<span class="keyword">region</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (path == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (Resources.Load(path) == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="meta">#<span class="keyword">endregion</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">          GameObject insUIPanel = GameObject.Instantiate(Resources.Load(path)) <span class="keyword">as</span> GameObject; <span class="comment">//创建游戏实例对象</span></span><br><span class="line">          insUIPanel.transform.SetParent(CanvasTransform, <span class="literal">false</span>); <span class="comment">//设置父对象</span></span><br><span class="line">          <span class="keyword">return</span> insUIPanel.GetComponent&lt;BaseUIPanel&gt;(); <span class="comment">//返回BaseUIPanel脚本</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 将对应的UIPanel压入栈中，并调用OnEnter方法</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//如果当前栈为空</span></span><br><span class="line">          <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">              _currentUIPanels = <span class="keyword">new</span> Stack&lt;BaseUIPanel&gt;();</span><br><span class="line">          <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel暂停</span></span><br><span class="line">          <span class="keyword">if</span> (_currentUIPanels.Count &gt; <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              BaseUIPanel topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">              topUIPanel.OnPause();</span><br><span class="line">          &#125;</span><br><span class="line">          BaseUIPanel newUIPanel = GetUIPanel(uIPanelType);</span><br><span class="line">          _currentUIPanels.Push(newUIPanel);</span><br><span class="line">          newUIPanel.OnEnter();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 输入顶级UIPanel的类型，就能弹出对应的UIPanel，并调用OnExit方法</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PopUIPanel</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//如果当前栈为空，就返回</span></span><br><span class="line">          <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">//如果当前栈中没有UIPanel，就返回</span></span><br><span class="line">          <span class="keyword">if</span> (_currentUIPanels.Count &lt;= <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//弹出栈顶的UIPanel，并调用OnExit方法</span></span><br><span class="line">          BaseUIPanel topUIPanel = _currentUIPanels.Pop();</span><br><span class="line">          topUIPanel.OnEixt();</span><br><span class="line">          <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel恢复</span></span><br><span class="line">          <span class="keyword">if</span> (_currentUIPanels.Count == <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">          topUIPanel.OnResume();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 摧毁场景中原来已经存在的UIPanel</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckUIPanelWhenGameBegin</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; CanvasTransform.childCount &gt; i;)</span><br><span class="line">          &#123;</span><br><span class="line">              GameObject.DestroyImmediate(CanvasTransform.GetChild(i).gameObject);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>UIManagerLoader.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManagerLoader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先把当前场景中的Canvas对象的Transform属性赋值给UIManager的CanvasTransform属性</span></span><br><span class="line">    <span class="comment">//游戏一开始就加载MainMenuUIPanel</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.CanvasTransform = <span class="keyword">this</span>.transform;</span><br><span class="line">        UIManager.Instance.PushUIPanel(UIPanelType.MainMenuUIPanel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Extension</p><ul><li><p>ListExtension.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ListExtesion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 尝试在列表中查找指定的元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelInfos&quot;&gt;</span>当前操作的列表<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span>定的元素<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果列表中由指定的元素，就返回该元素；如果没有，就返回null<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UIPanelInfo <span class="title">TrySearchUIPanel</span>(<span class="params"><span class="keyword">this</span> List&lt;UIPanelInfo&gt; uIPanelInfos, UIPanelType uIPanelType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (UIPanelInfo uIPanelInfo <span class="keyword">in</span> uIPanelInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (uIPanelInfo.Type == uIPanelType)</span><br><span class="line">                <span class="keyword">return</span> uIPanelInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>UIEvents</p><ul><li><p>MainMenuUIPanel.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainMenuUIPanel</span> : <span class="title">BaseUIPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnter();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnEnter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnPause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnResume();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnResume&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEixt();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnEixt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSettingClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.PushUIPanel(UIPanelType.SettingUIPanel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SettingUIPanel.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SettingUIPanel</span> : <span class="title">BaseUIPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnter();</span><br><span class="line">        Debug.Log(<span class="string">&quot;SettingUIPanel OnEnter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">        Debug.Log(<span class="string">&quot;SettingUIPanel OnPause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnResume();</span><br><span class="line">        Debug.Log(<span class="string">&quot;SettingUIPanel OnResume&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEixt();</span><br><span class="line">        Debug.Log(<span class="string">&quot;SettingUIPanel OnEixt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCloseClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.PopUIPanel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>              </div>            </details><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-8</p></div></div><div class='timeline-item-content'><ol><li>添加了<strong>事件响应</strong>功能，以及将<code>BaseUIPanel</code>类调整为抽象类，因此<code>UIPanel</code>上将会挂载<code>BaseUIPanel</code>的子类，而不是<code>BaseUIPanel</code>。</li><li>更新了 <strong>框架设计</strong> 部分的图示。</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 功能框架 </category>
          
          <category> Csharp </category>
          
          <category> GUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 功能框架 </tag>
            
            <tag> GUI </tag>
            
            <tag> UGUI </tag>
            
            <tag> Json </tag>
            
            <tag> Litjson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏对象的移动以及碰撞基础（2D）</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E7%A7%BB%E5%8A%A8%E5%8F%8A%E7%A2%B0%E6%92%9E2D.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E7%A7%BB%E5%8A%A8%E5%8F%8A%E7%A2%B0%E6%92%9E2D.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>此文将主要讲解有关 unity 游戏对象的移动，包含相关的 Unity 设置与 C# 脚本代码。</p></blockquote><h1 id="一、2D-对象移动"><a href="#一、2D-对象移动" class="headerlink" title="一、2D 对象移动"></a>一、2D 对象移动</h1><h2 id="1-1-相关的组件以及内置代码介绍"><a href="#1-1-相关的组件以及内置代码介绍" class="headerlink" title="1.1 相关的组件以及内置代码介绍"></a>1.1 相关的组件以及内置代码介绍</h2><h3 id="1-1-1-Transform-组件（转换）"><a href="#1-1-1-Transform-组件（转换）" class="headerlink" title="1.1.1 Transform 组件（转换）"></a>1.1.1 Transform 组件（转换）</h3><p><strong><code>Transform</code></strong> ：用于存储一个游戏对象的位置、旋转、比例和父级状态。一个 <code>GameObject</code> 将始终附加一个<strong><code>Transform</code> 组件</strong>，不可能删除一个 <code>Transform</code> 或创建一个没有 Transform 的 <code>GameObject</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">name</th><th style="text-align:left">Function</th></tr></thead><tbody><tr><td style="text-align:left">Position</td><td style="text-align:left">在 X、Y 和 Z 坐标中的位置。（此坐标是游戏坐标，且子对象以父对象为基准）</td></tr><tr><td style="text-align:left">Rotation</td><td style="text-align:left">围绕 X、Y 和 Z 轴的旋转，以度为单位</td></tr><tr><td style="text-align:left">Scale</td><td style="text-align:left">沿 X、Y 和 Z 轴的比例。值“1”是原始大小（导入对象的大小）。如果任何刻度值为零，它将变灰并且在启用比例刻度时不会自动调整。</td></tr></tbody></table></div><h3 id="1-1-2-Rigidbody-2D-组件（刚体）"><a href="#1-1-2-Rigidbody-2D-组件（刚体）" class="headerlink" title="1.1.2 Rigidbody 2D 组件（刚体）"></a>1.1.2 <code>Rigidbody 2D</code> 组件（刚体）</h3><p><a href="https://docs.unity3d.com/Manual/class-Rigidbody2D.html">官方手册</a></p><h3 id="1-1-3Time-delteTime-参数"><a href="#1-1-3Time-delteTime-参数" class="headerlink" title="1.1.3Time.delteTime 参数"></a>1.1.3<code>Time.delteTime</code> 参数</h3><p>公共静态浮动<strong>增量时间</strong>。</p><p>描述：从上一帧到当前帧的间隔（以秒为单位）（只读）。</p><p>详细说明：<a href="https://docs.unity3d.com/ScriptReference/Time-deltaTime.html"><code>Time.delteTime</code></a> 。</p><h2 id="1-2-对象移动功能实现"><a href="#1-2-对象移动功能实现" class="headerlink" title="1.2 对象移动功能实现"></a>1.2 对象移动功能实现</h2><h3 id="1-2-1-方法-Ⅰ：直接改变世界坐标"><a href="#1-2-1-方法-Ⅰ：直接改变世界坐标" class="headerlink" title="1.2.1 方法 Ⅰ：直接改变世界坐标"></a>1.2.1 方法 Ⅰ：直接改变世界坐标</h3><p>游戏对象在场景中的世界坐标，是 <code>Transform</code> 组件中的 <code>Position</code> 属性来记录的。通过改变<code>Position</code>属性的值，<strong>强制</strong>改变对象的世界坐标，以达到游戏对象移动的目的。在 Unity 中，对象的 Transform 组件的 Position 属性在 c# 脚本中是一个<font color='red'>三元数</font>。</p><p>优点：</p><ul><li>使用该方法简单</li></ul><p>缺点：</p><ul><li>对象移动不平滑（实际 Unity 对移动进行平滑调整）</li><li>对于有碰撞体积的对象，如果移动速度过快，会穿过碰撞体积</li><li>每执行一次代码，就会改变一次坐标，对于 <code>Updata()</code> 函数来说，帧数的改变会影响移动速度；对 <code>FixedUpdate()</code> 函数没有影响。</li></ul><p>具体的代码如下：</p><ol><li><p>类型 Ⅰ ：</p><p><code>Position</code> 属性可以通过以下方式进行设置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.Position = newPosition</span><br></pre></td></tr></table></figure></li><li><p>类型 Ⅱ：</p><p>除了直接赋值外，<code>Position</code> 属性还可以进行增量设置，即将当前位置增加一个向量值，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 distance = <span class="keyword">new</span> Vertor3(<span class="number">0.01f</span>,<span class="number">0f</span>,<span class="number">0f</span>);<span class="comment">//创建移动向量的三元数</span></span><br><span class="line">transform.Position += distance;<span class="comment">//当前坐标加上移动移动向量，得到移动后的坐标</span></span><br></pre></td></tr></table></figure></li><li><p>类型 Ⅲ：</p><p>官方推荐使用下面的函数用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 distance = <span class="keyword">new</span> Vertor3(<span class="number">0.01f</span>,<span class="number">0f</span>,<span class="number">0f</span>);<span class="comment">//创建移动向量的三元数</span></span><br><span class="line">transform.Translate(distance);<span class="comment">//这个函数其实是对类型Ⅱ代码的封装</span></span><br></pre></td></tr></table></figure></li><li><p>类型 Ⅳ：移动速度单位时间化，与帧数无关</p><p>其中，<code>velocity</code> 是一个 Vector3 类型的速度向量，<code>Time.deltaTime</code> 表示上一帧的时间间隔，这里使用它是为了使运动平滑。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.position += velocity * Time.deltaTime;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，<code>Position</code> 属性所表示的是游戏对象在世界坐标系中的位置，而不是相对于它的父级对象或本地坐标系的位置。因此，在进行赋值或增量设置时，应该考虑该游戏对象的当前所处位置，而不是相对位置。</p><p>同时，需要注意的是，在游戏对象使用物理引擎进行运动时，应该使用 <code>Rigidbody</code> 组件来控制它的运动，而不是直接修改 <code>Position</code> 属性。</p><h3 id="1-2-2-固定速度到达某位置"><a href="#1-2-2-固定速度到达某位置" class="headerlink" title="1.2.2 固定速度到达某位置"></a>1.2.2 固定速度到达某位置</h3><p><code>Vector3.MoveTowards()</code> 是 Unity 引擎中一个用于控制向量移动的函数，该函数会返回从一个位置开始朝着目标位置移动一定距离的向量。这个函数通常用于实现许多游戏中的效果，如角色寻路、平滑移动、相机跟随等。函数的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">MoveTowards</span>(<span class="params">Vector3 current, Vector3 target, <span class="built_in">float</span> maxDistanceDelta</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>current</code> 表示当前位置，</li><li><code>target</code> 表示目标位置，</li><li><code>maxDistanceDelta</code> 表示最大的距离变化量。</li></ul><p>函数会沿着从 <code>current</code> 到 <code>target</code> 的方向移动一个距离，该距离不会超过 <code>maxDistanceDelta</code>。</p><p>因此在 Unity 中，可以设置好目标位置以及移动速度（移动距离单位时间化），并且不<strong>断运行该函数同时，不断刷新对象的当前位置为函数的初位置</strong>。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.Position = Vertor3.MoveTowards(transform.Position,targetPosition,speed*Time.delteTime);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>初位置：因为对象不断进行移动，所以初位置就设置当前位置</li><li>末位置：要移动的目标位置</li><li>移动距离：速度 X 时间 = 每次移动的距离</li></ul><blockquote><p>上述函数为了能重复执行，直到对象移动到目标位置，需要把该函数放在 <code>Updata()</code> 函数或 <code>FixedUpdata()</code> 中</p></blockquote><p>例如下面的具体代码实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerMovement</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">5f</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector3 targetPos;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            targetPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);</span><br><span class="line">            targetPos.z = transform.position.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transform.position = Vector3.MoveTowards(transform.position, targetPos, moveSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们用 <code>Input.GetMouseButton(0)</code> 来检测玩家是否点击了鼠标左键。如果是，则将 <code>targetPos</code> 的位置设置为鼠标点击位置。然后，我们将对象的当前位置和目标位置作为参数来调用 <code>Vector3.MoveTowards()</code> 函数来实现平滑移动。</p><h3 id="1-2-3-平滑移动"><a href="#1-2-3-平滑移动" class="headerlink" title="1.2.3 平滑移动"></a>1.2.3 平滑移动</h3><p><code>Vector3.SmoothDamp()</code> 是 Unity 引擎中用于平滑移动物体的函数，与 <code>Vector3.MoveTowards()</code> 不同，它可以模拟物理动力学，使得移动更加平滑自然，同时可以避免突变和振荡等不良效果。该函数通常用于实现角色控制、相机跟随、特效等等。</p><p><code>Vector3.SmoothDamp()</code> 函数的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">SmoothDamp</span>(<span class="params">Vector3 current, Vector3 target, <span class="keyword">ref</span> Vector3 currentVelocity, <span class="built_in">float</span> smoothTime, <span class="built_in">float</span> maxSpeed = Mathf.Infinity, <span class="built_in">float</span> deltaTime = Time.deltaTime</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>current</code> 表示当前位置；</li><li><code>target</code> 表示目标位置；</li><li><code>currentVelocity</code> 是一个引用参数，表示当前速度；</li><li><code>smoothTime</code> 表示平滑时间。该值越小，平滑速度越快；</li><li><code>maxSpeed</code> 表示最大速度限制；</li><li><code>deltaTime</code> 是可选参数，表示时间增量；</li></ul><p>在使用 <code>Vector3.SmoothDamp()</code> 函数时，需要特别注意以下几点：</p><ul><li>该函数可以模拟物理动力学，提供了平滑运动的效果，但没有进行碰撞检测。如果需要避免障碍物，应该使用其他算法，例如 A* 算法等。</li><li><code>smoothTime</code> 的值越小，平滑速度越快；反之，平滑速度越慢，过渡时间也会越长。</li><li><code>maxSpeed</code> 设置最大速度可以有效地避免移动速度过快，但过快的移动速度也可能会导致震荡和不稳定的效果。</li><li><code>currentVelocity</code> 参数是一个引用参数，需要在每一帧中传入函数进行更新。</li></ul><p>下面是一个简单的示例，演示如何使用 <code>Vector3.SmoothDamp()</code> 函数实现相机的平滑跟随：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraFollow</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> smoothTime = <span class="number">0.3f</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector3 currentVelocity = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> targetPos = target.position;</span><br><span class="line">            targetPos.z = transform.position.z;</span><br><span class="line">            transform.position = Vector3.SmoothDamp(transform.position, targetPos, <span class="keyword">ref</span> currentVelocity, smoothTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将摄像机的位置设置为玩家的位置。我们将 <code>targetPos</code> 的位置设置为玩家的位置，然后使用 <code>Vector3.SmoothDamp()</code> 函数来实现平滑跟随。我们使用 <code>LateUpdate()</code> 来确保摄像机移动在对象移动后更新。</p><h3 id="1-2-4-固定时间到达某位置"><a href="#1-2-4-固定时间到达某位置" class="headerlink" title="1.2.4 固定时间到达某位置"></a>1.2.4 固定时间到达某位置</h3><p><code>Vector3.Lerp()</code> 函数是 Unity 引擎中的一个线性插值函数。它可以在两个 <code>Vector3</code> 之间进行插值，并返回一个介于它们之间的值。函数定义如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Lerp</span>(<span class="params">Vector3 a, Vector3 b, <span class="built_in">float</span> t</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>a</code> 和 <code>b</code> 是两个 <code>Vector3</code>，<code>t</code> 是表示插值系数的 <code>float</code> 值。<code>t</code> 的取值范围是 0 到 1，插值的结果为 <code>a</code> 和 <code>b</code> 的线性组合。当 <code>t</code> 为 0 时，结果为 <code>a</code>；当 <code>t</code> 为 1 时，结果为 <code>b</code>；当 <code>t</code> 为 0.5 时，结果为 <code>a</code> 和 <code>b</code> 的平均值。</p><p>例如下面简单实现了游戏中的以固定时间进行移动：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TMP</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 _start;</span><br><span class="line">    <span class="keyword">public</span> Vector3 _end;</span><br><span class="line">    <span class="keyword">public</span> Transform _cube;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _time = <span class="number">3.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> _timer = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 valueToLerp;</span><br><span class="line">        _timer += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span>(_timer &lt; _time)</span><br><span class="line">        &#123;</span><br><span class="line">            valueToLerp = Vector3.Lerp(_start, _end, _timer / _time);</span><br><span class="line">            _cube.position = valueToLerp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _timer = <span class="number">0.0f</span>;</span><br><span class="line">            valueToLerp = _start;</span><br><span class="line">            _start = _end;</span><br><span class="line">            _end = valueToLerp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Vector3.Lerp()</code> 函数在游戏开发中非常实用，常用于实现平滑移动、颜色渐变、相机跟随等效果。</p><h3 id="1-2-5-增加力迫使对象移动"><a href="#1-2-5-增加力迫使对象移动" class="headerlink" title="1.2.5 增加力迫使对象移动"></a>1.2.5 增加力迫使对象移动</h3><p>前三种移动方式，都是直接改变对象的坐标来进行移动。但是在 unity 引擎下，可能会出现以下情况：移动速度过快，穿过碰撞体积；刚体的移动没有物理规则（如：有重力的情况）；对于需要进行移动碰撞检测时，会出现先移动到碰撞体积内部，然后被碰撞体积弹开，如次反复，就会导致一直碰撞的对象产生剧烈抖动。</p><p>因此，为了使碰撞合乎真实物理，那么使用刚体的移动属性。使用刚体，必须先获取到游戏对象的刚体组件。</p><p>可以用于给刚体物体施加一个力或者瞬间的加速度。如果您想要给人物模型施加一个力，可以将 <code>Rigidbody</code> 组件添加到人物模型上，并使用 <code>AddForce()</code> 函数进行使用。下面是一个简单的示例，演示如何使用 <code>AddForce()</code> 函数使人物模型跳跃：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce = <span class="number">10f</span>;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody rb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先在 <code>Start()</code> 函数中获取 <code>Rigidbody</code> 组件，并将其保存在 <code>rb</code> 变量中。在 <code>Update()</code> 函数中检测玩家是否按下了跳跃键（默认为空格键），如果按下了，我们就使用 <code>AddForce()</code> 函数给人物模型施加一个向上的力，使其跳跃。我们使用 <code>ForceMode.Impulse</code> 参数来表示施加瞬时的力。</p><p>需要注意的是，当我们使用 <code>Rigidbody</code> 组件时，需要注意以下几点：</p><ul><li><code>Rigidbody</code> 组件只能添加到物体上，而不能添加到空的游戏对象上。</li><li>需要在物体的初始位置上添加一个刚体物理效果。</li><li>由于是物理效果，所以需要在 <code>FixedUpdate()</code> 中调用 <code>AddForce()</code> 函数；而不是在 <code>Update()</code> 中调用。具体原因可以参考<a href="https://blog.yuilexi.cn/2023/05/03/Unity3D/Unity引擎/Unity生命周期/">Unity 生命周期 | 🪐 星空鸟 🪐 (yuilexi.cn)</a>这篇文章</li></ul><h3 id="1-2-6-改变刚体的速度向量"><a href="#1-2-6-改变刚体的速度向量" class="headerlink" title="1.2.6 改变刚体的速度向量"></a>1.2.6 改变刚体的速度向量</h3><p>游戏对象中刚体组件的速度属性，在 C# 脚本中，用一组三元数进行表示。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Rigidbody _rb;<span class="comment">//存放刚体组件</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 _direction;<span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _rb = GetComponent&lt;Rigidbody&gt;();<span class="comment">//获取刚体组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _rb.velocity = _direction*_speed;<span class="comment">//改变刚体的速度向量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-7-改变刚体的位置坐标"><a href="#1-2-7-改变刚体的位置坐标" class="headerlink" title="1.2.7 改变刚体的位置坐标"></a>1.2.7 改变刚体的位置坐标</h3><p>刚体有三种状态：<strong><code>Dynamic</code></strong>、 <strong><code>Kinematic</code></strong>、<strong><code>Static</code></strong>，（动态、运动学、静态）。当刚体为： <strong><code>Kinematic</code></strong> 时，刚体不受重力等因素影响，也就没有办法使用<strong>增加力或速度</strong>来使对象移动。</p><p><code>Kinematic</code> 刚体设计为<strong>在模拟下移动</strong>，但只能在非常明确的用户控制下移动。<code>Dynamic</code> 受重力和力的影响，而 <code>Kinematic</code> 则不受。因此， <code>Kinematic</code> 比 <code>Dynamic</code> 访问计算的速度更快，对系统资源的需求也更低。 <code>Kinematic</code> 旨在通过<a href="http://docs.unity3d.com/ScriptReference/Rigidbody2D.MovePosition.html">Rigidbody2D.MovePosition</a>或<a href="http://docs.unity3d.com/ScriptReference/Rigidbody2D.MoveRotation.html">Rigidbody2D.MoveRotation</a>明确重新定位。使用物理查询来检测碰撞，并使用脚本来决定 <code>Rigidbody 2D</code> 应该移动到哪里以及如何移动。</p><p>刚体中，也内置了 <code>Position</code> 属性，并且使用 <code>Rigidbody.MovePosition()</code> 方法来改变该属性。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Rigidbody _rb;<span class="comment">//获取刚体组件</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 _distance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _rb = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _rb.MovePosition(transform.position+_distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法的使用根 Transform 相似，不过因为是刚体的属性，所以碰撞的更加自然、合乎物理。</li></ul><h1 id="二、2D-碰撞"><a href="#二、2D-碰撞" class="headerlink" title="二、2D 碰撞"></a>二、2D 碰撞</h1><h2 id="2-1-移动并碰撞的过程"><a href="#2-1-移动并碰撞的过程" class="headerlink" title="2.1 移动并碰撞的过程"></a>2.1 移动并碰撞的过程</h2><p>首先，假设存在两个对象 $A,B$ ，它们之间存在间距， $A$ 对象移动且 $B$ 对象不移动，二者都是刚体和碰撞体。游戏每帧或一定时间，运行游戏脚本中的移动函数，下列按每帧计算处理。那么当前帧， $A$ 对象进行位置移动计算；下一帧 $A$ 对象才会移动到对应位置，并且计算下一帧的位置，与此同时进行碰撞检测（只是进行碰撞检测计算）；再下一帧 $A$ 发生碰撞行为（例如弹开等）。</p><p>那么上述可能存在几种情况：</p><ol><li>当 $A,B$ 的碰撞体积足够大， 且移动速度适中，那么 $A$ 与 $B$ 的碰撞体积会重叠极小一部分再弹开，发生抖动（与 Transform 不同，因为是刚体，所以 Unity 内部优化移动，基本感受不到抖动，<strong>存在抖动但是可以忽略</strong>）</li><li>当 $A$ 的碰撞体积很小， $B$ 的碰撞体积很大，移动速度较快时， $A$ 移动到 $B$ 的内部，并不断发生碰撞，而 $A$ 无法弹出 $B$ 的体内（这里有个碰撞之后弹开方向的判定，如果 $A$ 在 $B$ 的内部，就可以认为 $A$ 四面八方都受到力，但是相互抵消，因此 $A$ 无法从 $B$ 内部弹出）</li><li>当 $A,B$ 的碰撞体积很小，且移动速度很快时，可能会出现<strong>移动一次</strong>的距离大于 $B$ 的宽度，就会穿过 $B$ 而不发生碰撞，这与物理相悖（不存在穿墙术吧）</li></ol><h2 id="2-2-碰撞优化方案"><a href="#2-2-碰撞优化方案" class="headerlink" title="2.2 碰撞优化方案"></a>2.2 碰撞优化方案</h2><p>为了解决碰撞过程中的问题，使用以下方法：</p><ul><li><p>刚体组件的属性：<code>Collision Detection</code>（碰撞检测）</p><ul><li><code>Discrete</code>（离散的）：当您将 <strong><code>Collision Detection</code></strong> 设置为 <strong><code>Discrete</code></strong> 时，具有 <code>Rigidbody 2D</code> 和 <code>Collider 2D</code> 的游戏对象可以在物理更新期间<strong>相互重叠或穿过</strong>，前提是它们移动得足够快。碰撞接触仅在新位置生成。</li><li><p><code>Continuous</code>（连续的）：当<strong><code>Collision Detection</code></strong>设置为<strong><code>Continuous</code></strong>时，具有 <code>Rigidbody 2D</code> 和 <code>Collider 2D</code> 的 <code>GameObjects</code> 在更新期间不会相互通过。相反，Unity 计算任何 Collider 2D 的第一个撞击点，并将 <code>GameObject</code> 移动到那里。</p><blockquote><p>请注意，这比<strong>Discrete</strong>需要更多的 CPU 时间。</p></blockquote></li></ul></li><li><p>刚体组件的属性：<code>Interpolate</code>（插值）</p><ul><li><code>None</code>：不应用运动平滑。</li><li><code>Interpolate</code>（插值）：根据游戏对象在前一帧中的位置对运动进行平滑处理。</li><li><code>Extrapolate</code>（外推）：根据对下一帧中其位置的估计来平滑运动。</li></ul></li></ul><p>在不考虑 CPU 速度的情况下：首选：Continuous 和 Extrapolate。但是默认情况基本适用很多场景。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 经典功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 经典功能实现 </tag>
            
            <tag> 2D游戏对象移动 </tag>
            
            <tag> 2D碰撞 </tag>
            
            <tag> 2D刚体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A星寻路算法</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Astar%E5%AF%BB%E8%B7%AF.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Astar%E5%AF%BB%E8%B7%AF.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 经典功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 经典功能实现 </tag>
            
            <tag> A星寻路算法 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity单列模式</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Csharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Csharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是单例模式"><a href="#一、什么是单例模式" class="headerlink" title="一、什么是单例模式"></a>一、什么是单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，也同样适用于其他的语言和场景。这种类型的设计模式属于创建型模式，<strong>它提供了一种创建对象的最佳方式</strong>。23 种设计模式之一。</p><p>这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意</strong>：</p><ol><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol><h1 id="二、为什么要用单列模式"><a href="#二、为什么要用单列模式" class="headerlink" title="二、为什么要用单列模式"></a>二、为什么要用单列模式</h1><p>在 Unity 脚本开发中，有时我们希望某些游戏对象在游戏中只有一个实例，例如：玩家角色等；或者我们构造了一个对游戏的某些功能进行管理的类，例如：UI 管理类等。上述情况，我们只希望存在一个玩家角色或者由<strong>一个管理类的实例</strong>管理 UI 系统，因此，就需要使用单例模式。</p><h1 id="三、单例模式实现方法"><a href="#三、单例模式实现方法" class="headerlink" title="三、单例模式实现方法"></a>三、单例模式实现方法</h1><h2 id="3-1-Unity-游戏对象的处理方法"><a href="#3-1-Unity-游戏对象的处理方法" class="headerlink" title="3.1 Unity 游戏对象的处理方法"></a>3.1 Unity 游戏对象的处理方法</h2><p>由于控制 Unity 游戏对象的脚本类全部继承于 MonoBehaviour 这个父类，因此我们可以构造一个单例模式的类，该类继承于 MonoBehaviour ，而游戏对象的脚本类继承于<strong>该单例模式类</strong>，就能做到多层级继承。</p><h3 id="3-1-1-方法-①：简单方法"><a href="#3-1-1-方法-①：简单方法" class="headerlink" title="3.1.1 方法 ①：简单方法"></a>3.1.1 方法 ①：简单方法</h3><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonPatten</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPatten _instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPatten Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> SingletonPatten();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li>首先这个类是公共类，其他脚本可以调用该类。</li><li>该类里面有一个静态成员：该类的实例化对象，使用静态成员表示该成员在内存中只有一份数据。</li><li>静态的成员：存放的是实例化对象，使用属性器进行访问，因为只有 get 模块，因此外部只能访问不能修改，</li><li>get 模块内部，就是单例模式的核心：如果当前字段中存在实例对象，那就返回这个对象；如果没有，就新创建一个实例化对象在返回。</li></ul><h3 id="3-1-2-方法-②：完整方法——构造单例基类"><a href="#3-1-2-方法-②：完整方法——构造单例基类" class="headerlink" title="3.1.2 方法 ②：完整方法——构造单例基类"></a>3.1.2 方法 ②：完整方法——构造单例基类</h3><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//abstract 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">SingletonMonobehavior</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T _instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//virtual 虚方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：首先把单例类定义为一个抽象类，因此该类必须被继承，不能直接实例化。该类使用了泛型的方法，可以使多个子类单独工作，降低耦合性，使其互不影响，并且提高代码利用率。然后再将 Awake() 方法定义为一个虚方法。</p><p>虚方法：</p><ul><li>必须有方法体，哪怕是一个分号</li><li>子类直接继承父类的非私有虚方法，子类可以重写(overwrite)或者选择不重写<ul><li>这与抽象方法不同，抽象方法必须重写才能使用</li><li>因此，每个单例类共同的功能——单例算法，写在虚方法 Awake() 中，并在子类中重写这个方法，并且调用父类方法</li><li>还可以在子类重写的方法中，定义子类的特有的算法代码。</li></ul></li></ul><h2 id="3-2-其他类的处理方法"><a href="#3-2-其他类的处理方法" class="headerlink" title="3.2 其他类的处理方法"></a>3.2 其他类的处理方法</h2><h3 id="3-2-1-方法-①：简单方法"><a href="#3-2-1-方法-①：简单方法" class="headerlink" title="3.2.1 方法 ①：简单方法"></a>3.2.1 方法 ①：简单方法</h3><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonPatten</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPatten _instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPatten Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> SingletonPatten();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp脚本基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 单列模式 </tag>
            
            <tag> 脚本开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程-线程-协程</title>
      <link href="/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Csharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B.html"/>
      <url>/02.Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/Csharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h1><h2 id="1-1-进程的概念和特征"><a href="#1-1-进程的概念和特征" class="headerlink" title="1.1 进程的概念和特征"></a>1.1 进程的概念和特征</h2><h3 id="1-1-1-进程的定义"><a href="#1-1-1-进程的定义" class="headerlink" title="1.1.1 进程的定义"></a>1.1.1 进程的定义</h3><p>进程是程序的一次执行过程。进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p><p>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单元。<strong>每个进程都有自己的独立内存空间</strong>，<strong>不同进程间可以进行进程间通信</strong>。进程<strong>重量级比较大</strong>，占据独立内存，上下文进程间的切换开销（栈寄存器、虚拟内存、文件句柄）比较大，但相对稳定安全。进程的上级为操作系统，有自己固定的堆栈。</p><h3 id="1-1-2-进程的特征"><a href="#1-1-2-进程的特征" class="headerlink" title="1.1.2 进程的特征"></a>1.1.2 进程的特征</h3><p><strong>动态性</strong>：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。<strong>动态性是进程最基本的特征</strong>。</p><p><strong>并发性</strong>：指多个进程实体同时存于内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。</p><p><strong>独立性</strong>：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单元。凡未建立 PCB 的程序都不能作为一个独立的单元参与运行。</p><p><strong>异步性</strong>：由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。</p><p><strong>结构性</strong>：每个进程都配置一个 PCB 对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制块三部分组成的。</p><h2 id="1-2-进程的状态和转换"><a href="#1-2-进程的状态和转换" class="headerlink" title="1.2 进程的状态和转换"></a>1.2 进程的状态和转换</h2><p><strong>运行态</strong>：进程正在处理机上运行。在单机处理机环境下，每个时刻最多只有一个进程处于运行态。</p><p><strong>就绪态</strong>：进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，通常将他们排成一个队列，成为<strong>就绪队列</strong>。</p><p><strong>阻塞态</strong>：又称等待态。进程正在等待某一事件而暂定运行，如等待某资源为可用或等待输入/输出完成。<strong>即使处理机空闲，该进程也不能运行</strong>。</p><p><strong>创建态</strong>：进程正在被创建，尚未转到就绪态。创建进程通常需要多个步骤：首先申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，然后由系统为该进程分配运行时所必须的资源，最后把该进程转入就绪态。</p><p><strong>结束态</strong>：进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。进程需要结束运行时，系统首先必须置该进程为结束态，然后再进一步处理资源释放和回收等工作。</p><p><img src="https://imageshack.yuilexi.cn/Unity3D/Csharp-Unity脚本开发/进程-线程-协程/进程的状态转换.svg" alt="进程的状态转换"></p><h3 id="1-3-进程的通信"><a href="#1-3-进程的通信" class="headerlink" title="1.3 进程的通信"></a>1.3 进程的通信</h3><p>进程间通信通常有以下几种方式：</p><p><strong>管道（Pipe）</strong>：管道是 Unix 中最古老的进程间通信的形式，我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”。其本质是内核中固定大小的缓冲区。</p><p><strong>命名管道（Named Pipes）</strong>：“命名管道”又名“命名管线”（Named Pipes），命名管道支持可靠的、单向或双向的数据通信。不同于匿名管道的是：命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</p><p><strong>消息队列（MQ，Message Quene）</strong>：消息队列用于在进程间通信的过程中将消息按照队列存储起来，常见的 MQ 有 ActiveMQ、RocketMQ、RabbitMQ、Kafka 等。</p><p><strong>信号量（Semaphore）</strong>：有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前,线程必须获取一个信号量。</p><p><strong>共享内存（Share Memory）</strong>：共享内存是三个 IPC 机制中的一个。它允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在进行的进程之间传递数据的一种非常有效的方式。</p><p><strong>套接字（Socket）</strong>：就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。</p><p>对于游戏开发者来说，最为常用的是 Socket，这是长连接网络游戏的核心。</p><h1 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h1><h2 id="2-1-线程的概念"><a href="#2-1-线程的概念" class="headerlink" title="2.1 线程的概念"></a>2.1 线程的概念</h2><p><img src="https://imageshack.yuilexi.cn/Unity3D/Csharp-Unity脚本开发/进程-线程-协程/进程与线程的关系.svg" alt="进程与线程的关系"></p><p>线程也被称为轻量级进程，是操作系统调度（CPU 调度）执行的最小单位，是进程的子集，是进程中实际运作单位。一个线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程并行执行不同的任务。</p><p>线程本身基本不拥有资源，而是访问隶属于进程的资源，一个进程拥有至少一个或多个线程，线程间共享进程的地址空间。</p><p>由于线程是阻塞式的，如果想要同步执行 IO，每个 IO 都必须开启一个新线程，多线程开销较大，适合多任务处理，进程崩溃不影响其他进程，而线程只是一个进程的不同执行路线。</p><p>线程有自己的堆栈，却没有单独的地址空间，进程死就等于所有线程死，所以多进程要比多线程健壮。但在进程切换时，消耗资源较大，效率较差。</p><p>线程是并发的，且是阻塞式同步的，一旦资源死锁，线程将陷入混乱。在同步线程的执行过程中，线程的执行切换是由 CPU 轮转时间片的分配来决定的。</p><p><img src="https://imageshack.yuilexi.cn/Unity3D/Csharp-Unity脚本开发/进程-线程-协程/线程的运行状态.svg" alt="线程的运行状态"></p><h1 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h1><h2 id="3-1-协程的概念"><a href="#3-1-协程的概念" class="headerlink" title="3.1 协程的概念"></a>3.1 协程的概念</h2><p>协程是比线程更轻量级的存在，协程不由操作系统内核所管理，而是完全由程序所控制（也就是在用户态执行）。</p><p><strong>协程的好处是性能大幅提升，不会像线程切换那样消耗资源</strong>。同一时间只能执行某个协程，开辟多个协程开销不大。适合对任务进行分时处理。</p><p>协程有自己的寄存器和上下文栈。协程调度切换时，将寄存器和上下文栈保存到其他地方，并在协程切换回来时恢复之前保存的寄存器和上下文栈。由于直接对栈进行操作，基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文切换非常快。</p><p>一个线程可以有多个协程，一个进程也可以单独拥有多个协程。线程和进程都是同步机制，而协程是异步机制，无需阻塞。协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用时的状态。多协程间对 CPU 的使用是依次进行的，每次只有一个协程工作，而其他协程处于休眠状态。</p><p><strong>实际上多个协程是在一个线程中的，只不过每个协程对 CPU 进行分时</strong>。协程可以访问和使用 Unity 的所有方法和 <code>Component</code>。</p><p>函数（子程序）的调用是通过栈实现的，一个线程就是执行一个函数，函数调用总是一个入口，一个返回，调用顺序是明确的，而协程在函数内部是可以中断的，然后转而执行其他函数，在适当的时候再返回来继续执行。</p><p>函数（子程序）的切换不是由线程切换，而是程序自身控制，因此没有线程切换开销。和多线程相比，线程越多，协程的性能优势就越明显，并且协程因为依次执行，不存在线程安全问题，变量访问不会冲突，共享资源也无需加锁，只需要判断状态即可，所以执行效率比线程高很多。</p><h2 id="3-2-协程的原理和作用"><a href="#3-2-协程的原理和作用" class="headerlink" title="3.2 协程的原理和作用"></a>3.2 协程的原理和作用</h2><p><strong>协程</strong>在<code>Unity</code>中是一个很重要的概念，我们知道，在使用<code>Unity</code>进行游戏开发时，一般（注意是一般）不考虑<strong>多线程</strong>，那么如何处理一些在主任务之外的需求呢，<code>Unity</code>给我们提供了协程这种方式。</p><blockquote><p><strong>在 Unity 中一般不考虑多线程的原因是</strong>：因为在<code>Unity</code>中，只能在主线程中获取物体的组件、方法、对象，如果脱离这些，<code>Unity</code>的很多功能无法实现，那么多线程的存在与否意义就不大了</p></blockquote><p>线程与协程有什么区别呢：</p><ul><li>对于协程而言，同一时间只能执行一个协程，而线程则是并发的，可以同时有多个线程在运行</li><li>两者在内存的使用上是相同的，共享堆，不共享栈</li></ul><p>其实对于两者最关键，最简单的区别是微观上线程是并行（对于多核 CPU）的，而协程是串行的</p><h3 id="3-2-1-关于协程"><a href="#3-2-1-关于协程" class="headerlink" title="3.2.1 关于协程"></a>3.2.1 关于协程</h3><p>从字面意义上理解就是协助程序的意思，我们在主任务进行的同时，需要一些分支任务配合工作来达到最终的效果。例如，在进行主任务的过程中我们需要一个对资源消耗极大的操作（比如存档）时候，如果在一帧中实现这样的操作，游戏就会变得十分卡顿，这个时候，我们就可以通过协程，在一定的帧内完成该工作的处理，同时不影响主任务的进行</p><h3 id="3-2-2-协程的原理"><a href="#3-2-2-协程的原理" class="headerlink" title="3.2.2 协程的原理"></a>3.2.2 协程的原理</h3><p>首先需要了解协程不是线程，协程依旧是在主线程中进行。其次是，协程是通过迭代器来实现功能的，通过关键字<code>IEnumerator</code> 来定义一个迭代方法</p><blockquote><ul><li><code>IEnumerator</code>：是一个实现迭代器功能的接口</li><li><code>IEnumerable</code>：是在<code>IEnumerator</code>基础上的一个封装接口，有一个<code>GetEnumerator()</code>方法返回<code>IEnumerator</code></li></ul></blockquote><p>在迭代器中呢，最关键的是 yield 的使用，这是实现我们协程功能的主要途径，通过该关键方法，可以使得协程的运行暂停、记录下一次启动的时间与位置等。</p><h3 id="3-2-3-协程的使用"><a href="#3-2-3-协程的使用" class="headerlink" title="3.2.3 协程的使用"></a>3.2.3 协程的使用</h3><p>首先通过一个迭代器定义一个返回值为 <code>IEnumerator</code> 的方法，然后在程序中通过 <code>StartCoroutine</code> 来开启一个协程即可：</p><p><code>StartCoroutine</code> 的两种重载方式：</p><ol><li><code>StartCoroutine(string methodName)</code>：这种是没有参数的情况，直接通过方法名（字符串形式，不加括号）来开启协程</li><li><code>StartCoroutine(string methodName，object values)</code>：带参数的通过方法名和参数进行调用</li><li><code>StartCoroutine(IEnumerator routine)</code>：通过<strong>调用方法</strong>的形式开启协程</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过迭代器定义一个方法</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">First</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">Second</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在程序种调用协程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    StartCoroutine(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    StartCoroutine(<span class="string">&quot;Second&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//方法三</span></span><br><span class="line">    StartCoroutine(First());</span><br><span class="line">    StartCoroutine(Second(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个协程开始后，同样会对应一个结束协程的方法<code>StopCoroutine</code>与<code>StopAllCoroutines</code>两种方式，但是需要注意的是，两者的使用需要遵循一定的规则，在介绍规则之前，同样介绍一下关于<code>StopCoroutine</code>重载：</p><ul><li><code>StopCoroutine（string methodName）</code>：通过方法名（字符串）来进行</li><li><code>StopCoroutine（IEnumerator routine）</code>:通过方法形式来调用</li><li><code>StopCoroutine(Coroutine routine)</code>：通过指定的协程来关闭</li></ul><p>如果我们是使用<code>StartCoroutine（string methodName）</code>来开启一个协程的，那么结束协程就只能使用<code>StopCoroutine（string methodName）</code>和<code>StopCoroutine(Coroutine routine)</code>来结束协程，</p><h3 id="3-2-4-yield-关键字-🧠🧠"><a href="#3-2-4-yield-关键字-🧠🧠" class="headerlink" title="3.2.4 yield 关键字 🧠🧠"></a>3.2.4 yield 关键字 🧠🧠</h3><p>要想理解协程，就要理解<code>yield</code>。在<code>Unity</code>的脚本的生命周期，<code>yield</code> 也是脚本生命周期的一些执行方法，不同的<code>yield</code> 的方法处于生命周期的不同位置。</p><p>在协程函数中，<code>yield</code> 之前的代码会在协程开启后一次运行完毕，而<code>yield</code> 之后的代码，需要满足特定的条件才会运行。</p><ul><li><code>yield return null</code>; 暂停协程等待下一帧继续执行</li><li><code>yield return 0或其他数字</code>; 暂停协程等待下一帧继续执行</li><li><code>yield return new WairForSeconds(时间)</code>; 等待规定时间后继续执行</li><li><code>yield return StartCoroutine(&quot;协程方法名&quot;)</code>;开启一个协程（嵌套协程）</li></ul><p>接下来看几个特殊的<code>yield</code>，他们是用在一些特殊的区域，一般不会有机会去使用，但是对于某些特殊情况的应对会很方便</p><ul><li><code>yield return GameObject</code>：当游戏对象被获取到之后执行</li><li><code>yield return new WaitForFixedUpdate()</code>：等到下一个固定帧数更新</li><li><code>yield return new WaitForEndOfFrame()</code>：等到所有相机画面被渲染完毕后更新</li><li><code>yield break</code>; 跳出协程对应方法，其后面的代码不会被执行</li></ul><p>通过上面的一些<code>yield</code>一些用法以及其在脚本生命周期中的位置，我们也可以看到关于协程不是线程的概念的具体的解释，所有的这些方法都是在主线程中进行的，只是有别于我们正常使用的<code>Update</code>与<code>LateUpdate</code>这些可视的方法</p><h3 id="3-2-5-协程的内核：迭代器-🧠🧠"><a href="#3-2-5-协程的内核：迭代器-🧠🧠" class="headerlink" title="3.2.5 协程的内核：迭代器 🧠🧠"></a>3.2.5 协程的内核：迭代器 🧠🧠</h3><p>从程序的角度讲，协程的核心就是迭代器。</p><p>想要定义一个协程方法有两个因素，</p><ol><li>方法的返回值为 <code>IEnumerator</code></li><li>方法中有 yield 关键字。</li></ol><p>当代码满足以上两个条件时，此方法的执行就具有了迭代器的特质，其核心就是 <code>MoveNext</code> 方法。方法内的内容将会被分成两部分：yield 之前的代码和 yield 之后的代码。yield 之前的代码会在第一次执行<code>MoveNext</code>时执行， yield 之后的代码会在第二次执行<code>MoveNext</code>时执行。</p><p>在 Unity 中，<code>MoveNext</code>的执行时机是以帧为单位的，无论你是设置了延迟时间，还是通过按钮调用<code>MoveNext</code>，亦或是根本没有设置执行条件，Unity 都会在每一帧的生命周期中判断当前帧是否满足协程所定义的条件，一旦满足，当前帧就会抽出 CPU 时间执行你所定义的协程迭代器的<code>MoveNext</code>（即 yield 后面部分）。注意，只要方法中有 yield 语句，那么方法的返回值就必须是 <code>IEnumerator</code> ，不然无法通过编译。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Windows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IEnumerator _objects;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _objects = Function();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (UnityEngine.Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            _objects.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Function</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;我是<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每执行一次 <code>MoveNext()</code>方法，就会使对应的协程<strong>往下执行一步</strong>。而使用 <code>StartCoroutine()</code>函数，相当于把 <code>MoveNext()</code>的使用权，交给 <code>Unity</code>编辑器，通过 <code>yield</code> 后面的条件，来确定何时往下执行。</p><h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp脚本基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 协程 </tag>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 游戏优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#高级语法</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/03.Csharp%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/03.Csharp%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文章主要包含特性、反射、属性、索引器、委托、事件、集合、泛型、匿名方法、不安全代码、多线程等 C#的高级用法。</p><p>C#系列教程：</p><ol><li><a href="https://blog.yuilexi.cn/2023/04/26/编程/Csharp知识库/Csharp基础/Csharp基础语法/">C#基础语法 | 🪐星空鸟🪐 (yuilexi.cn)</a></li><li><a href="https://blog.yuilexi.cn/2023/04/30/编程/Csharp知识库/Csharp基础/Csharp高级语法/">C#高级语法 | 🪐星空鸟🪐 (yuilexi.cn)</a>⬅️ 当前的位置 °꒰๑’ꀾ’๑꒱°</li><li><a href="https://blog.yuilexi.cn/2023/05/19/编程/Csharp知识库/Csharp基础/Csharp规范/">C#代码规范 | 🪐星空鸟🪐 (yuilexi.cn)</a></li></ol></blockquote><h1 id="特性（Attribute）"><a href="#特性（Attribute）" class="headerlink" title="特性（Attribute）"></a>特性（Attribute）</h1><h1 id="属性（Property）"><a href="#属性（Property）" class="headerlink" title="属性（Property）"></a>属性（Property）</h1><p><strong>属性（Property）</strong> 是类、结构和接口的命名（named）成员。类或结构中的成员变量或方法称为 <strong>域（Field）</strong>。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 <strong>访问器（accessors）</strong> 让私有域的值可被读写或操作。</p><p>属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 <strong>访问器（accessors）</strong>。</p><h2 id="访问器（Accessors）"><a href="#访问器（Accessors）" class="headerlink" title="访问器（Accessors）"></a>访问器（Accessors）</h2><p><font color='red'>属性</font>的<strong>访问器</strong>包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器声明可包含一个 <code>get</code> 访问器、一个 <code>set</code> 访问器，或者同时包含二者。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/ 声明类型为 <span class="built_in">string</span> 的 Code 属性</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> code;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Code</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> code;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类型为 string 的 Name 属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">     name = <span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类型为 int 的 Age 属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">      age = <span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code> 访问器和<code>set</code> 访问器尽管写法奇怪，但它们实际上是两个方法。在访问属性的值时，执行的是<code>get</code> 方法；在给属性赋值时，执行的是<code>set</code> 方法。因此，我们不仅能够对属性进行访问和修改，还可以在<code>get</code> 和<code>set</code> 内部书写逻辑，以便于规范访问和修改。</p><h2 id="抽象属性（Abstract-Properties）"><a href="#抽象属性（Abstract-Properties）" class="headerlink" title="抽象属性（Abstract Properties）"></a>抽象属性（Abstract Properties）</h2><p>抽象类可拥有抽象属性，这些属性应在派生类中被实现。下面的程序说明了这点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述抽象类中的抽象属性，必须在继承的子类中使用<code>override</code>进行重写：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _name = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _age = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="索引器（Indexer）"><a href="#索引器（Indexer）" class="headerlink" title="索引器（Indexer）"></a>索引器（Indexer）</h1><p><strong>索引器（Indexer）</strong> 允许一个对象可以像数组一样使用下标的方式来访问。当您为类定义一个索引器时，该类的行为就会像一个 <strong>虚拟数组（virtual array）</strong> 一样。您可以使用数组访问运算符 <strong>[ ]</strong> 来访问该类的的成员。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>一维索引器的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">element-type <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// get 访问器</span></span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 返回 index 指定的值</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// set 访问器</span></span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 设置 index 指定的值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引器的用途"><a href="#索引器的用途" class="headerlink" title="索引器的用途"></a>索引器的用途</h2><p><strong>索引器</strong>的行为的声明在某种程度上类似于<strong>属性</strong>。就像属性一样，您可使用 <strong>get</strong> 和 <strong>set</strong> 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 索引器</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> _size = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>[] _name = <span class="keyword">new</span> <span class="built_in">string</span>[_size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数，进行初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _name[i] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//索引器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _size)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引超出范围&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _name[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _size)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引超出范围&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                _name[index] = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主程序入口</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person persons = <span class="keyword">new</span> Person();</span><br><span class="line">            persons[<span class="number">0</span>] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            persons[<span class="number">1</span>] = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            persons[<span class="number">2</span>] = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">            persons[<span class="number">3</span>] = <span class="string">&quot;赵六&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Person._size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(persons[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line">赵六</span><br><span class="line">a</span><br></pre></td></tr></table></figure><h2 id="重载索引器"><a href="#重载索引器" class="headerlink" title="重载索引器"></a>重载索引器</h2><p><strong>索引器</strong>可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型。C# 允许索引器可以是其他类型。例如下面的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">string</span> name]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="委托（Delegate）"><a href="#委托（Delegate）" class="headerlink" title="委托（Delegate）"></a>委托（Delegate）</h1><p>C# 中的<strong>委托</strong>类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类。</p><h2 id="声明委托（Delegate）"><a href="#声明委托（Delegate）" class="headerlink" title="声明委托（Delegate）"></a>声明委托（Delegate）</h2><p>委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">MyDelegate</span> (<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br></pre></td></tr></table></figure><p>上面的委托可被用于引用任何一个带有一个单一的 <code>string</code> 参数的方法，并返回一个 <code>string</code> 类型变量。声明委托的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="built_in">delegate</span> 返回类型 委托名([参数列表])</span><br></pre></td></tr></table></figure><h2 id="实例化委托（Delegate）"><a href="#实例化委托（Delegate）" class="headerlink" title="实例化委托（Delegate）"></a>实例化委托（Delegate）</h2><p>一旦声明了委托类型，委托对象必须使用 <strong>new</strong> 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 <strong>new</strong> 语句的参数就像方法调用一样书写，但是不带有参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;</span><br><span class="line"><span class="keyword">namespace</span> 委托</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">First</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你输入的是&quot;</span> + str + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Second</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str + str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Third</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str + str + str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyDelegate myDelegate1 = <span class="keyword">new</span> MyDelegate(First);</span><br><span class="line">            MyDelegate myDelegate2 = <span class="keyword">new</span> MyDelegate(Second);</span><br><span class="line">            myDelegate2 += Third;</span><br><span class="line">            Console.WriteLine(myDelegate1(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line">            Console.WriteLine(myDelegate2(<span class="string">&quot;Hello,C#\n&quot;</span>));</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加到委托变量内的方法，<strong>必须和委托有相同的返回值和参数列表</strong>，同时在<code>new</code>时，必须向委托变量中传入一个方法作为参数，而且只能传入一个方法，这是因为委托这种特殊的类不含无参的构造方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是错误的语法，会报错</span></span><br><span class="line">MyDelegate myDelegate1 = <span class="keyword">new</span> MyDelegate();</span><br><span class="line"><span class="comment">//这是正确的写法</span></span><br><span class="line">MyDelegate myDelegate2 = <span class="keyword">new</span> MyDelegate(Second);</span><br></pre></td></tr></table></figure><h2 id="委托的多播（Multicasting-of-a-Delegate）"><a href="#委托的多播（Multicasting-of-a-Delegate）" class="headerlink" title="委托的多播（Multicasting of a Delegate）"></a>委托的多播（Multicasting of a Delegate）</h2><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。</p><p>使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 <strong>多播（multicasting）</strong>，也叫组播。</p><p>例如上面的代码中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDelegate2 += Third;</span><br></pre></td></tr></table></figure><h1 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h1><p><strong>事件（Event）</strong> 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。</p><p>C# 中使用事件机制实现线程间的通信。</p><h2 id="通过事件使用委托"><a href="#通过事件使用委托" class="headerlink" title="通过事件使用委托"></a>通过事件使用委托</h2><p><strong>事件在类中声明且生成</strong>，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 <strong>发布器（publisher）</strong> 类。其他接受该事件的类被称为 <strong>订阅器（subscriber）</strong> 类。事件使用 <strong>发布-订阅（publisher-subscriber）</strong> 模型。</p><p><strong>发布器（publisher）</strong> 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p><p><strong>订阅器（subscriber）</strong> 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。</p><h2 id="声明事件（Event）"><a href="#声明事件（Event）" class="headerlink" title="声明事件（Event）"></a>声明事件（Event）</h2><p>在类的内部声明事件，首先必须声明该事件的委托类型。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后，声明事件本身，使用 <strong>event</strong> 关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 基于上面的委托定义事件</span><br><span class="line">public event MyDelegate MyEvent;</span><br></pre></td></tr></table></figure><p>例如下面实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel.Design;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 事件</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//发布器类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个整型变量，模拟当前数据</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明事件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> MyDelegate MyEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发事件的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MyEvent(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;没有订阅者\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果值改变，就调用“触发事件的函数”</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="keyword">this</span>.<span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                OnMyEvent(<span class="string">&quot;已经修改了value的值&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅器</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show1</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;小明收到了：“&#123;0&#125;”的消息&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show2</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;小红收到了：“&#123;0&#125;”的消息&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show3</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;小刚收到了：“&#123;0&#125;”的消息&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//实例化一个发布器类的对象</span></span><br><span class="line">            EventTest eventTest = <span class="keyword">new</span> EventTest();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//订阅事件</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第一次尝试&quot;</span>);</span><br><span class="line">            eventTest.MyEvent += Show1;</span><br><span class="line">            eventTest.MyEvent += Show2;</span><br><span class="line">            eventTest.SetValue(<span class="number">10</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第二次尝试&quot;</span>);</span><br><span class="line">            eventTest.SetValue(<span class="number">10</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第三次尝试&quot;</span>);</span><br><span class="line">            eventTest.MyEvent += Show3;</span><br><span class="line">            eventTest.SetValue(<span class="number">20</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第四次尝试&quot;</span>);</span><br><span class="line">            eventTest.MyEvent -= Show1;</span><br><span class="line">            eventTest.SetValue(<span class="number">30</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次尝试</span><br><span class="line">小明收到了：“已经修改了value的值”的消息</span><br><span class="line">小红收到了：“已经修改了value的值”的消息</span><br><span class="line">第二次尝试</span><br><span class="line">第三次尝试</span><br><span class="line">小明收到了：“已经修改了value的值”的消息</span><br><span class="line">小红收到了：“已经修改了value的值”的消息</span><br><span class="line">小刚收到了：“已经修改了value的值”的消息</span><br><span class="line">第四次尝试</span><br><span class="line">小红收到了：“已经修改了value的值”的消息</span><br><span class="line">小刚收到了：“已经修改了value的值”的消息</span><br></pre></td></tr></table></figure><h1 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection）</h1><p><strong>集合类</strong>是专门用于数据存储和检索的类。这些类提供了<strong>对栈</strong>、<strong>队列</strong>、<strong>列表</strong>和<strong>哈希表</strong>的支持。大多数集合类实现了相同的接口。</p><p><strong>集合类</strong>服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 <code>Object</code> 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。</p><h2 id="动态数组（ArrayList）"><a href="#动态数组（ArrayList）" class="headerlink" title="动态数组（ArrayList）"></a>动态数组（ArrayList）</h2><p><strong>动态数组</strong>代表了可被单独索引的对象的有序集合。它基本上可以替代一个数组。但是，与数组不同的是，您可以使用<strong>索引</strong>在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。</p><h3 id="ArrayList-类的属性"><a href="#ArrayList-类的属性" class="headerlink" title="ArrayList 类的属性"></a>ArrayList 类的属性</h3><p>下表列出了 <strong>ArrayList</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Capacity</td><td style="text-align:left">获取或设置 ArrayList 可以包含的元素个数。</td></tr><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 ArrayList 中实际包含的元素个数。</td></tr><tr><td style="text-align:left">IsFixedSize</td><td style="text-align:left">获取一个值，表示 ArrayList 是否具有固定大小。</td></tr><tr><td style="text-align:left">IsReadOnly</td><td style="text-align:left">获取一个值，表示 ArrayList 是否只读。</td></tr><tr><td style="text-align:left">IsSynchronized</td><td style="text-align:left">获取一个值，表示访问 ArrayList 是否同步（线程安全）。</td></tr><tr><td style="text-align:left">Item[Int32]</td><td style="text-align:left">获取或设置指定索引处的元素。</td></tr><tr><td style="text-align:left">SyncRoot</td><td style="text-align:left">获取一个对象用于同步访问 ArrayList。</td></tr></tbody></table></div><h3 id="ArrayList-类的方法"><a href="#ArrayList-类的方法" class="headerlink" title="ArrayList 类的方法"></a>ArrayList 类的方法</h3><p><strong>ArrayList</strong> 类的一些常用的 <strong>方法</strong>：详情请看<a href="https://www.runoob.com/csharp/csharp-arraylist.html">C# 动态数组（ArrayList） | 菜鸟教程 (runoob.com)</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:left"><strong>public virtual int Add( object value )</strong></td><td><strong>在 ArrayList 的末尾添加一个对象</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">public virtual void AddRange( ICollection c )</td><td>在 ArrayList 的末尾添加 ICollection 的元素。</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong>从 ArrayList 中移除所有的元素</strong></td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:left"><strong>public virtual bool Contains( object item )</strong></td><td><strong>判断某个元素是否在 ArrayList 中</strong></td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">public virtual ArrayList GetRange( int index, int count )</td><td>返回一个 ArrayList，表示源 ArrayList 中元素的子集</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">public virtual int IndexOf(object)</td><td>返回某个值在 ArrayList 中第一次出现的索引，索引从零开始</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">public virtual void Insert( int index, object value )</td><td>在 ArrayList 的指定索引处，插入一个元素</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">public virtual void InsertRange( int index, ICollection c )</td><td>在 ArrayList 的指定索引处，插入某个集合的元素。</td></tr><tr><td style="text-align:center"><strong>9</strong></td><td style="text-align:left"><strong>public virtual void Remove( object obj )</strong></td><td><strong>从 ArrayList 中移除第一次出现的指定对象</strong></td></tr><tr><td style="text-align:center">10</td><td style="text-align:left">public virtual void RemoveAt( int index )</td><td>移除 ArrayList 的指定索引处的元素。</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">public virtual void RemoveRange( int index, int count )</td><td>从 ArrayList 中移除某个范围的元素</td></tr><tr><td style="text-align:center">12</td><td style="text-align:left">public virtual void Reverse()</td><td>逆转 ArrayList 中元素的顺序</td></tr><tr><td style="text-align:center">13</td><td style="text-align:left">public virtual void SetRange( int index, ICollection c )</td><td>复制某个集合的元素到 ArrayList 中某个范围的元素上</td></tr><tr><td style="text-align:center">14</td><td style="text-align:left">public virtual void Sort()</td><td>对 ArrayList 中的元素进行排序</td></tr><tr><td style="text-align:center">15</td><td style="text-align:left">public virtual void TrimToSize()</td><td>设置容量为 ArrayList 中元素的实际个数</td></tr></tbody></table></div><h2 id="哈希表（Hashtable）"><a href="#哈希表（Hashtable）" class="headerlink" title="哈希表（Hashtable）"></a>哈希表（Hashtable）</h2><p><code>Hashtable</code> 类代表了一系列基于键的哈希代码组织起来的<strong>键/值</strong>对。它使用<strong>键</strong>来访问集合中的元素。</p><p>当您使用<strong>键</strong>访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个<strong>键/值</strong>对。键用于访问集合中的项目。</p><h3 id="Hashtable-类的属性"><a href="#Hashtable-类的属性" class="headerlink" title="Hashtable 类的属性"></a>Hashtable 类的属性</h3><p>下表列出了 <strong>Hashtable</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 Hashtable 中包含的键值对个数。</td></tr><tr><td style="text-align:left">IsFixedSize</td><td style="text-align:left">获取一个值，表示 Hashtable 是否具有固定大小。</td></tr><tr><td style="text-align:left">IsReadOnly</td><td style="text-align:left">获取一个值，表示 Hashtable 是否只读。</td></tr><tr><td style="text-align:left">Item</td><td style="text-align:left">获取或设置与指定的键相关的值。</td></tr><tr><td style="text-align:left">Keys</td><td style="text-align:left">获取一个 ICollection，包含 Hashtable 中的键。</td></tr><tr><td style="text-align:left">Values</td><td style="text-align:left">获取一个 ICollection，包含 Hashtable 中的值。</td></tr></tbody></table></div><h3 id="Hashtable-类的方法"><a href="#Hashtable-类的方法" class="headerlink" title="Hashtable 类的方法"></a>Hashtable 类的方法</h3><p>下表列出了 <strong>Hashtable</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>1</strong></td><td style="text-align:left"><strong>public virtual void Add( object key, object value )</strong></td><td><strong>向 Hashtable 添加一个带有指定的键和值的元素</strong></td></tr><tr><td style="text-align:left"><strong>2</strong></td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong>从 Hashtable 中移除所有的元素</strong></td></tr><tr><td style="text-align:left"><strong>3</strong></td><td style="text-align:left"><strong>public virtual bool ContainsKey( object key )</strong></td><td><strong>判断 Hashtable 是否包含指定的键</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public virtual bool ContainsValue( object value )</strong></td><td><strong>判断 Hashtable 是否包含指定的值</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public virtual void Remove( object key )</strong></td><td><strong>从 Hashtable 中移除带有指定的键的元素</strong></td></tr></tbody></table></div><h2 id="排序列表（SortedList）"><a href="#排序列表（SortedList）" class="headerlink" title="排序列表（SortedList）"></a>排序列表（SortedList）</h2><p>SortedList 类代表了一系列按照键来排序的<strong>键/值</strong>对，这些键值对可以通过键和索引来访问。</p><p>排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。</p><h3 id="SortedList-类的属性"><a href="#SortedList-类的属性" class="headerlink" title="SortedList 类的属性"></a>SortedList 类的属性</h3><p>下表列出了 <strong>SortedList</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Capacity</td><td style="text-align:left">获取或设置 SortedList 的容量。</td></tr><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 SortedList 中的元素个数。</td></tr><tr><td style="text-align:left">IsFixedSize</td><td style="text-align:left">获取一个值，表示 SortedList 是否具有固定大小。</td></tr><tr><td style="text-align:left">IsReadOnly</td><td style="text-align:left">获取一个值，表示 SortedList 是否只读。</td></tr><tr><td style="text-align:left">Item</td><td style="text-align:left">获取或设置与 SortedList 中指定的键相关的值。</td></tr><tr><td style="text-align:left">Keys</td><td style="text-align:left">获取 SortedList 中的键。</td></tr><tr><td style="text-align:left">Values</td><td style="text-align:left">获取 SortedList 中的值。</td></tr></tbody></table></div><h3 id="SortedList-类的方法"><a href="#SortedList-类的方法" class="headerlink" title="SortedList 类的方法"></a>SortedList 类的方法</h3><p>下表列出了 <strong>SortedList</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public virtual void Add( object key, object value )</strong></td><td><strong>向 SortedList 添加一个带有指定的键和值的元素</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong>从 SortedList 中移除所有的元素</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public virtual bool ContainsKey( object key )</strong></td><td><strong>判断 SortedList 是否包含指定的键</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public virtual bool ContainsValue( object value )</strong></td><td><strong>判断 SortedList 是否包含指定的值</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">public virtual object GetByIndex( int index )</td><td>获取 SortedList 的指定索引处的值</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">public virtual object GetKey( int index )</td><td>获取 SortedList 的指定索引处的键</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">public virtual IList GetKeyList()</td><td>获取 SortedList 中的键</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">public virtual IList GetValueList()</td><td>获取 SortedList 中的值</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">public virtual int IndexOfKey( object key )</td><td>返回 SortedList 中的指定键的索引，索引从零开始</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">public virtual int IndexOfValue( object value )</td><td>返回 SortedList 中的指定值第一次出现的索引，索引从零开始</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong>public virtual void Remove( object key )</strong></td><td><strong>从 SortedList 中移除带有指定的键的元素</strong></td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong>public virtual void RemoveAt( int index )</strong></td><td><strong>移除 SortedList 的指定索引处的元素</strong></td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">public virtual void TrimToSize()</td><td>设置容量为 SortedList 中元素的实际个数</td></tr></tbody></table></div><h2 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h2><p>堆栈（Stack）代表了一个<strong>后进先出</strong>的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为<strong>推入</strong>元素，当您从列表中移除一项时，称为<strong>弹出</strong>元素。</p><h3 id="Stack-类的属性"><a href="#Stack-类的属性" class="headerlink" title="Stack 类的属性"></a>Stack 类的属性</h3><p>下表列出了 <strong>Stack</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 Stack 中包含的元素个数。</td></tr></tbody></table></div><h3 id="Stack-类的方法"><a href="#Stack-类的方法" class="headerlink" title="Stack 类的方法"></a>Stack 类的方法</h3><p>下表列出了 <strong>Stack</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong> 从 Stack 中移除所有的元素</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public virtual bool Contains( object obj )</strong></td><td><strong>判断某个元素是否在 Stack 中</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public virtual object Peek()</strong></td><td><strong>返回在 Stack 的顶部的对象，但不移除它</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public virtual object Pop()</strong></td><td><strong>返回并移除在 Stack 的顶部的对象</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public virtual void Push( object obj )</strong></td><td><strong>向 Stack 的顶部添加一个对象</strong></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">public virtual object[] ToArray()</td><td>复制 Stack 到一个新的数组中</td></tr></tbody></table></div><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列（Queue）代表了一个<strong>先进先出</strong>的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为<strong>入队</strong>，当您从列表中移除一项时，称为<strong>出队</strong>。</p><h3 id="Queue-类的属性"><a href="#Queue-类的属性" class="headerlink" title="Queue 类的属性"></a>Queue 类的属性</h3><p>下表列出了 <strong>Queue</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 Queue 中包含的元素个数。</td></tr></tbody></table></div><h3 id="Queue-类的方法"><a href="#Queue-类的方法" class="headerlink" title="Queue 类的方法"></a>Queue 类的方法</h3><p>下表列出了 <strong>Queue</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong>从 Queue 中移除所有的元素</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public virtual bool Contains( object obj )</strong></td><td><strong>判断某个元素是否在 Queue 中</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public virtual object Dequeue()</strong></td><td><strong>移除并返回在 Queue 的开头的对象</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public virtual void Enqueue( object obj )</strong></td><td><strong>向 Queue 的末尾添加一个对象</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">public virtual object[] ToArray()</td><td>复制 Queue 到一个新的数组中</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">public virtual void TrimToSize()</td><td>设置容量为 Queue 中元素的实际个数</td></tr></tbody></table></div><h2 id="点阵列（BitArray）"><a href="#点阵列（BitArray）" class="headerlink" title="点阵列（BitArray）"></a>点阵列（BitArray）</h2><p>BitArray 类管理一个紧凑型的位值数组，它使用布尔值来表示，其中 true 表示位是开启的（1），false 表示位是关闭的（0）。</p><p>当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用<strong>整型索引</strong>从点阵列集合中访问各项，索引从零开始。</p><h3 id="BitArray-类的属性"><a href="#BitArray-类的属性" class="headerlink" title="BitArray 类的属性"></a>BitArray 类的属性</h3><p>下表列出了 <strong>BitArray</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 BitArray 中包含的元素个数。</td></tr><tr><td style="text-align:left">IsReadOnly</td><td style="text-align:left">获取一个值，表示 BitArray 是否只读。</td></tr><tr><td style="text-align:left">Item</td><td style="text-align:left">获取或设置 BitArray 中指定位置的位的值。</td></tr><tr><td style="text-align:left">Length</td><td style="text-align:left">获取或设置 BitArray 中的元素个数。</td></tr></tbody></table></div><h3 id="BitArray-类的方法"><a href="#BitArray-类的方法" class="headerlink" title="BitArray 类的方法"></a>BitArray 类的方法</h3><p>下表列出了 <strong>BitArray</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">public BitArray And( BitArray value )</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位与操作</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">public bool Get( int index )</td><td>获取 BitArray 中指定位置的位的值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">public BitArray Not()</td><td>把当前的 BitArray 中的位值反转，以便设置为 true 的元素变为 false，设置为 false 的元素变为 true</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">public BitArray Or( BitArray value )</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位或操作</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">public void Set( int index, bool value )</td><td>把 BitArray 中指定位置的位设置为指定的值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">public void SetAll( bool value )</td><td>把 BitArray 中的所有位设置为指定的值</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">public BitArray Xor( BitArray value )</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位异或操作</td></tr></tbody></table></div><h1 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h1><p><strong>泛型（Generic）</strong> 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。</p><p>例如下面例子，来说明泛型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 泛型</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Number</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> T _number1;</span><br><span class="line">        <span class="keyword">public</span> T _number2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Number&lt;<span class="built_in">int</span>&gt; number = <span class="keyword">new</span> Number&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            number._number1 = <span class="number">1</span>;</span><br><span class="line">            number._number2 = <span class="number">2</span>;</span><br><span class="line">            Console.WriteLine(number._number1 + number._number2);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型（Generic）的特性"><a href="#泛型（Generic）的特性" class="headerlink" title="泛型（Generic）的特性"></a>泛型（Generic）的特性</h2><p>使用泛型是一种增强程序功能的技术，具体表现在以下几个方面：</p><ul><li>它有助于您最大限度地重用代码、保护类型的安全以及提高性能。</li><li>您可以创建泛型集合类。</li><li>您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。</li><li>您可以对泛型类进行约束以访问特定数据类型的方法。</li><li>关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。</li></ul><p>在声明泛型方法/泛型类的时候，可以给泛型加上一定的约束来满足我们特定的一些条件。泛型限定条件：</p><ul><li>T：结构（类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型）</li><li>T：类 （类型参数必须是引用类型，包括任何类、接口、委托或数组类型）</li><li>T：new() （类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时 new() 约束必须最后指定）</li><li>T：&lt;基类名&gt; 类型参数必须是指定的基类或派生自指定的基类</li><li>T：&lt;接口名称&gt; 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</li></ul><h1 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h1><p>我们已经提到过，委托是用于引用与其具有相同标签的方法。换句话说，您可以使用委托对象调用可由委托引用的方法。</p><p><strong>匿名方法（Anonymous methods）</strong> 提供了一种传递代码块作为委托参数的技术。匿名方法是没有名称只有主体的方法。</p><p>在匿名方法中您不需要指定返回类型，它是从方法主体内的 return 语句推断的。</p><h2 id="编写匿名方法的语法"><a href="#编写匿名方法的语法" class="headerlink" title="编写匿名方法的语法"></a>编写匿名方法的语法</h2><p>匿名方法是通过使用 <strong>delegate</strong> 关键字创建委托实例来声明的。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delegate void NumberChanger(int n);</span><br><span class="line">...</span><br><span class="line">NumberChanger nc = delegate(int x)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;Anonymous Method: &#123;0&#125;&quot;, x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码块 <strong>Console.WriteLine(“Anonymous Method: {0}”, x);</strong> 是匿名方法的主体。</p><p>委托可以通过匿名方法调用，也可以通过命名方法调用，即，通过向委托对象传递方法参数。</p><blockquote><p><strong>注意:</strong> 匿名方法的主体后面需要一个 <strong><code>;</code></strong></p></blockquote><h1 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h1><p>当一个代码块使用 <strong>unsafe</strong> 修饰符标记时，C# 允许在函数中使用指针变量。<strong>不安全代码</strong>或非托管代码是指使用了<strong>指针</strong>变量的代码块。</p><h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h2><p><strong>指针</strong> 是值为另一个变量的地址的变量，即内存位置的直接地址。就像其他变量或常量，您必须在使用指针存储其他变量地址之前声明指针。</p><p>指针变量声明的一般形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* var-name;</span><br></pre></td></tr></table></figure><p>下面是指针类型声明的实例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">实例</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int* p</code></td><td style="text-align:left"><code>p</code> 是指向整数的指针。</td></tr><tr><td style="text-align:left"><code>double* p</code></td><td style="text-align:left"><code>p</code> 是指向双精度数的指针。</td></tr><tr><td style="text-align:left"><code>float* p</code></td><td style="text-align:left"><code>p</code> 是指向浮点数的指针。</td></tr><tr><td style="text-align:left"><code>int** p</code></td><td style="text-align:left"><code>p</code> 是指向整数的指针的指针。</td></tr><tr><td style="text-align:left"><code>int*[] p</code></td><td style="text-align:left"><code>p</code> 是指向整数的指针的一维数组。</td></tr><tr><td style="text-align:left"><code>char* p</code></td><td style="text-align:left"><code>p</code> 是指向字符的指针。</td></tr><tr><td style="text-align:left"><code>void* p</code></td><td style="text-align:left"><code>p</code> 是指向未知类型的指针。</td></tr></tbody></table></div><h2 id="编译不安全代码"><a href="#编译不安全代码" class="headerlink" title="编译不安全代码"></a>编译不安全代码</h2><p>为了编译不安全代码，您必须切换到命令行编译器指定 <strong>/unsafe</strong> 命令行。</p><p>例如，为了编译包含不安全代码的名为 prog1.cs 的程序，需在命令行中输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csc /unsafe prog1.cs</span><br></pre></td></tr></table></figure><h2 id="fixed-关键字"><a href="#fixed-关键字" class="headerlink" title="fixed 关键字"></a>fixed 关键字</h2><p>由于 C#中声明的变量在内存中的存储受垃圾回收器管理；因此一个变量（例如一个大数组）有可能在运行过程中被移动到内存中的其他位置。如果一个变量的内存地址会变化，那么指针也就没有意义了。</p><p>解决方法就是使用 fixed 关键字来固定变量位置不移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static unsafe void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">  fixed(int *ptr = int[5])  &#123;//...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stackalloc"><a href="#stackalloc" class="headerlink" title="stackalloc"></a>stackalloc</h3><p>在 unsafe 不安全环境中，我们可以通过 stackalloc 在堆栈上分配内存，因为在堆栈上分配的内存不受内存管理器管理，因此其相应的指针不需要固定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static unsafe void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">  int *ptr = stackalloc int[1] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><strong>线程</strong> 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。</p><p>线程是<strong>轻量级进程</strong>。一个使用线程的常见实例是现代操作系统中并行编程的实现。使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。</p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程生命周期开始于 System.Threading.Thread 类的对象被创建时，结束于线程被终止或完成执行时。</p><p>下面列出了线程生命周期中的各种状态：</p><ul><li><strong>未启动状态</strong>：当线程实例被创建但 Start 方法未被调用时的状况。</li><li><strong>就绪状态</strong>：当线程准备好运行并等待 CPU 周期时的状况。</li><li>不可运行状态<ul><li>已经调用 Sleep 方法</li><li>已经调用 Wait 方法</li><li>通过 I/O 操作阻塞</li></ul></li><li><strong>死亡状态</strong>：当线程已完成执行或已中止时的状况。</li></ul><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在 C# 中，<strong>System.Threading.Thread</strong> 类用于线程的工作。它允许创建并访问多线程应用程序中的单个线程。进程中第一个被执行的线程称为<strong>主线程</strong>。</p><p>当 C# 程序开始执行时，主线程自动创建。使用 <strong>Thread</strong> 类创建的线程被主线程的子线程调用。您可以使用 Thread 类的 <strong>CurrentThread</strong> 属性访问线程。</p><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-23</p></div></div><div class='timeline-item-content'><ol><li>在 “前言” 部分，新增了对代码规范的链接</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-10</p></div></div><div class='timeline-item-content'><ol><li>更新了 <strong>线程</strong> 更详细的用法</li><li>在文章前面添加 <strong>前言</strong> 部分</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp </category>
          
          <category> Unity3D基础 </category>
          
          <category> Csharp基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Unity3D </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> Csharp基础 </tag>
            
            <tag> Unity3D基础 </tag>
            
            <tag> Csharp高级语法 </tag>
            
            <tag> 面型对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p><strong>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>。<strong>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性</strong>。 毫无疑问，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h2 id="什么是-GOF（四人帮，全拼-Gang-of-Four）？"><a href="#什么是-GOF（四人帮，全拼-Gang-of-Four）？" class="headerlink" title="什么是 GOF（四人帮，全拼 Gang of Four）？"></a>什么是 GOF（四人帮，全拼 Gang of Four）？</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p><p>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承。</li></ul><h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><p>设计模式在软件开发中的两个主要用途。</p><ul><li><p>开发人员的共同平台</p><p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</p></li><li><p>最佳的实践</p><p>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p></li></ul><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><ol><li><p><strong>创建型模式</strong></p><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul></li><li><p><strong>结构型模式</strong></p><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>过滤器模式（Filter、Criteria Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ul></li><li><p><strong>行为型模式</strong></p><p>这些设计模式特别关注对象之间的通信。</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>观察者模式（Observer Pattern）</li><li>状态模式（State Pattern）</li><li>策略模式（Strategy Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul></li></ol><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ol><li><p><strong>开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p>简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>（父类变量里面装载子类对象）。</p><p>LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。</p><p>里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，<strong>它强调降低依赖，降低耦合</strong>。</p></li><li><p><strong>迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p></li></ol><h2 id="采用的语言"><a href="#采用的语言" class="headerlink" title="采用的语言"></a>采用的语言</h2><p>设计模式是针对针对编程的一种思想和解决方法，和使用哪种语言无关。为了更直观地反映设计模式的好处与作用，此文章采用 C# 的语法进行展示。C# 的基本用法，可以参照<a href="https://blog.yuilexi.cn/2023/04/26/Programming/Csharp知识库/Csharp基础/Csharp基础语法/">C#基础语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a>这篇文章。</p><h1 id="简单工厂模式（创造型）"><a href="#简单工厂模式（创造型）" class="headerlink" title="简单工厂模式（创造型）"></a>简单工厂模式（创造型）</h1><p>工厂模式是 最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式<strong>。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li><li><strong>主要解决：</strong>主要解决接口选择的问题。</li><li><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</li><li><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</li><li><strong>关键代码：</strong>创建过程在其子类执行。</li><li><strong>优点：</strong></li><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li><li><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li></ol><p><img src="http://imageshack.yuilexi.cn/Programming/设计模式/简单工厂模式.svg" alt="简单工厂模式"></p><p>当存在多个子类时，我们可以创建一个父类。每当需要子类对象时，我们都给它一个父类对象，而父类对象中具体装载哪个子类对象，就需要根据用户的需求而定。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面例子将实现一个简单的工厂模式。情景想象：一个工厂可以生产三种笔记本电脑，分别是：联想、惠普和戴尔。工厂事先不知道用户要选择哪种品牌的电脑，但是无论选什么品牌，必定是“电脑”这一物品。</p><p>第一步，先创建一个接口，以便于子类能够继承这个接口。也可以使用抽象类、一般父类实现。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建一个接口：电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintComputer</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建三个笔记本电脑的具体品牌的子类：联想、惠普、戴尔，这三个子类继承上面的<code>IComputer</code>接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建三个类，分别是：联想、惠普、戴尔</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lenovo</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;联想笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HP</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;惠普笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dell</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;戴尔笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个工厂类，用于实现具体的电脑。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个简单工厂类，用来创建电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComputerFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IComputer computer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Lenovo&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> Lenovo();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HP&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> HP();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dell&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> Dell();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，作为顾客，要去购买电脑。具体代码在主函数里面实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建电脑对象，返回一个接口实例，而接口中转载不同需求的电脑品牌</span></span><br><span class="line">        IComputer computer1 = ComputerFactory.CreateComputer(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">        computer1.PrintComputer();</span><br><span class="line">        IComputer  computer2 = ComputerFactory.CreateComputer(<span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        computer2.PrintComputer();</span><br><span class="line">        IComputer computer3 = ComputerFactory.CreateComputer(<span class="string">&quot;Dell&quot;</span>);</span><br><span class="line">        computer3.PrintComputer();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管顾客想买什么品牌的电脑，可以直接给他一个<code>电脑</code>（基类），<code>电脑</code>具体是什么品牌（基类里面装什么子类），根据顾客的需求，就能实现对应的品牌（<code>public static IComputer CreateComputer(string type)</code>实现）。这样，就能向用户隐藏内部的逻辑，因为用户接收的是一个基类，而子类的实现与装载已经封装起来。</p><h1 id="抽象工厂模式（创造型）"><a href="#抽象工厂模式（创造型）" class="headerlink" title="抽象工厂模式（创造型）"></a>抽象工厂模式（创造型）</h1><p>抽象工厂模式是围绕一个超级工厂创建其他工厂。<strong>该超级工厂又称为其他工厂的工厂</strong>。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p><p><strong>关键代码：</strong> <strong>在一个工厂里聚合多个同类产品</strong>。</p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p><p><img src="https://imageshack.yuilexi.cn/Programming/设计模式/设计模式.svg" alt="设计模式"></p><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><p>基于<a href="#具体实现-1">简单工厂模式</a>进行扩展。我们不仅可以选择笔记本的品牌，还可以选择手机的品牌。笔记本和手机之间没有任何关联，都有单独的工厂。而电脑与手机的生产购买逻辑是一样的，因此先创建一个工厂，在选择是哪种工厂，最后选择该工厂的哪个产品。</p><p>基于上面的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再创建一个接口：手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintPhone</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后构造三个手机的品牌的子类：苹果、三星、OPPO，这三个子类继承上面的<code>IPhone</code>接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建三个类，分别是：苹果、三星、OPPO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;苹果手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Samsung</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;三星手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OPPO</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;OPPO手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着构造一个超级工厂的抽象类，用于<strong>具体的工厂的继承</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个抽象的超级工厂类，用于实现某个工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IComputer <span class="title">CreateComputer</span>()</span>&#123;<span class="keyword">return</span> <span class="literal">null</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IColor <span class="title">CreateColor</span>()</span>&#123;<span class="keyword">return</span> <span class="literal">null</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着构造电脑品牌和手机品牌的两个工厂，继承于<code>AbstractFactory</code>这个抽象类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造“电脑品牌”的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComputerFactort</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Lenovo&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Lenovo();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HP&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HP();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dell&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dell();</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造“手机品牌”的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhoneFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Apple&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Samsung&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Samsung();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;OPPO&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OPPO();</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着构造一个工厂生成器，通过对输入的需求信息分析，进行选择对应的工厂。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个工厂创造器/生成器类，通过传递品牌或颜色信息来获取工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FactoryProducer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">GetFactory</span>(<span class="params"><span class="built_in">string</span> choice</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Computer&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ComputerFactort();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Phone&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PhoneFactory();</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在主函数中，创建上述工厂，并获得对应的产品。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建电脑工厂</span></span><br><span class="line">        AbstractFactory factoryComputer = FactoryProducer.GetFactory(<span class="string">&quot;Computer&quot;</span>);</span><br><span class="line">        <span class="comment">//创建联想电脑</span></span><br><span class="line">        IComputer computer1 = factoryComputer.CreateComputer(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">        computer1.PrintComputer();</span><br><span class="line">        <span class="comment">//创建惠普电脑</span></span><br><span class="line">        IComputer computer2 = factoryComputer.CreateComputer(<span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        computer2.PrintComputer();</span><br><span class="line">        <span class="comment">//创建戴尔电脑</span></span><br><span class="line">        IComputer computer3 = factoryComputer.CreateComputer(<span class="string">&quot;Dell&quot;</span>);</span><br><span class="line">        computer3.PrintComputer();</span><br><span class="line">        <span class="comment">//创建手机工厂</span></span><br><span class="line">        AbstractFactory factoryPhone = FactoryProducer.GetFactory(<span class="string">&quot;Phone&quot;</span>);</span><br><span class="line">        <span class="comment">//创建苹果手机</span></span><br><span class="line">        IPhone phone1 = factoryPhone.CreateColor(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        phone1.PrintPhone();</span><br><span class="line">        <span class="comment">//创建三星手机</span></span><br><span class="line">        IPhone phone2 = factoryPhone.CreateColor(<span class="string">&quot;Samsung&quot;</span>);</span><br><span class="line">        phone2.PrintPhone();</span><br><span class="line">        <span class="comment">//创建OPPO手机</span></span><br><span class="line">        IPhone phone3 = factoryPhone.CreateColor(<span class="string">&quot;OPPO&quot;</span>);</span><br><span class="line">        phone3.PrintPhone();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;程序结束!&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">联想笔记本</span><br><span class="line">惠普笔记本</span><br><span class="line">戴尔笔记本</span><br><span class="line">苹果手机</span><br><span class="line">三星手机</span><br><span class="line">OPPO手机</span><br><span class="line">程序结束!</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个接口：电脑品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintComputer</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再创建一个接口：手机品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintPhone</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个抽象的超级工厂类，用于实现某个工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建电脑工厂</span></span><br><span class="line">        AbstractFactory factoryComputer = FactoryProducer.GetFactory(<span class="string">&quot;Computer&quot;</span>);</span><br><span class="line">        <span class="comment">//创建联想电脑</span></span><br><span class="line">        IComputer computer1 = factoryComputer.CreateComputer(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">        computer1.PrintComputer();</span><br><span class="line">        <span class="comment">//创建惠普电脑</span></span><br><span class="line">        IComputer computer2 = factoryComputer.CreateComputer(<span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        computer2.PrintComputer();</span><br><span class="line">        <span class="comment">//创建戴尔电脑</span></span><br><span class="line">        IComputer computer3 = factoryComputer.CreateComputer(<span class="string">&quot;Dell&quot;</span>);</span><br><span class="line">        computer3.PrintComputer();</span><br><span class="line">        <span class="comment">//创建手机工厂</span></span><br><span class="line">        AbstractFactory factoryPhone = FactoryProducer.GetFactory(<span class="string">&quot;Phone&quot;</span>);</span><br><span class="line">        <span class="comment">//创建苹果手机</span></span><br><span class="line">        IPhone phone1 = factoryPhone.CreateColor(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        phone1.PrintPhone();</span><br><span class="line">        <span class="comment">//创建三星手机</span></span><br><span class="line">        IPhone phone2 = factoryPhone.CreateColor(<span class="string">&quot;Samsung&quot;</span>);</span><br><span class="line">        phone2.PrintPhone();</span><br><span class="line">        <span class="comment">//创建OPPO手机</span></span><br><span class="line">        IPhone phone3 = factoryPhone.CreateColor(<span class="string">&quot;OPPO&quot;</span>);</span><br><span class="line">        phone3.PrintPhone();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;程序结束!&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在创建三个类，分别是：联想、惠普、戴尔</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lenovo</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;联想笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HP</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;惠普笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dell</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;戴尔笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建三个类，分别是：苹果、三星、OPPO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;苹果手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Samsung</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;三星手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OPPO</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;OPPO手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造“电脑品牌”的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComputerFactort</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Lenovo&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Lenovo();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HP&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HP();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dell&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dell();</span><br><span class="line"></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> color</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造“手机品牌”的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhoneFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Apple&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Samsung&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Samsung();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;OPPO&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OPPO();</span><br><span class="line"></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个工厂创造器/生成器类，通过传递品牌或颜色信息来获取工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FactoryProducer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">GetFactory</span>(<span class="params"><span class="built_in">string</span> choice</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Computer&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ComputerFactort();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Phone&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PhoneFactory();</span><br><span class="line"></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式（创造型）"><a href="#单例模式（创造型）" class="headerlink" title="单例模式（创造型）"></a>单例模式（创造型）</h1><p>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ul><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong>构造函数是私有的。</p><p><strong>应用实例：</strong></p><ul><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ul><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><img src="https://imageshack.yuilexi.cn/Programming/设计模式/单例模式.svg" alt="单例模式"></p><h2 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="单线程，懒汉式"><a href="#单线程，懒汉式" class="headerlink" title="单线程，懒汉式"></a>单线程，懒汉式</h3><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个单例类的对象，用于存放当前类的唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">    <span class="comment">//构造函数私有化，防止外界创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用属性的访问器来生成单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当前类的实例为空，则创建一个新的实例，否则返回当前实例</span></span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅可以用访问器，还可以使用方法来进行访问实例化的对象。例如将上面代码改写为下面的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个单例类的对象，用于存放当前类的唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">    <span class="comment">//构造函数私有化，防止外界创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前对象的方法，修饰为静态方法，以便于直接能“类名.方法”进行调用，而不是使用“对象名.方法”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断当前类的唯一实例是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果为空，则创建一个新的实例</span></span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不为空，则直接返回当前实例</span></span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全，加锁"><a href="#线程安全，加锁" class="headerlink" title="线程安全，加锁"></a>线程安全，加锁</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个标识确保线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span></span><br><span class="line">        <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">        <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span></span><br><span class="line">        <span class="keyword">lock</span> (locker)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全，双重锁定"><a href="#线程安全，双重锁定" class="headerlink" title="线程安全，双重锁定"></a>线程安全，双重锁定</h3><p>上面代码对于每个线程都会对线程辅助对象<code>locker</code>加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（<code>uniqueInstance==null</code>）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能。</p><p>为了改进上面实现方式的缺陷，我们只需要在<code>lock</code>语句前面加一句（<code>uniqueInstance==null</code>）的判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它<strong><font color='red'>双重锁定</font></strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 定义一个标识确保线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span></span><br><span class="line">        <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">        <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span></span><br><span class="line">        <span class="comment">// 双重锁定只需要一句判断就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (locker)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="建造者模式（创造型）"><a href="#建造者模式（创造型）" class="headerlink" title="建造者模式（创造型）"></a>建造者模式（创造型）</h1><p><strong>建造者模式</strong>使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决：</strong>将变与不变分离开。</p><p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</p><p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。</p><p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p><p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><h2 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="https://imageshack.yuilexi.cn/Programming/设计模式/建造者模式.svg" alt="建造者模式"></p><p>情景如下：我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 _Item_ 接口和实现 _Item_ 接口的实体类，以及一个表示食物包装的 _Packing_ 接口和实现 _Packing_ 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>首先，构造两个接口，分别是包装和食物，其中食物里面包含有包装的实现。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个食物的接口，方便后面继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line">    <span class="function">IPacking <span class="title">GetFoodPacking</span>()</span>;</span><br><span class="line">    <span class="function"><span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造一个包装的接口，方便后面继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetPackingType</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后构造两个具体的包装类，并继承自<code>IPacking</code>接口。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装：纸盒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Wrapper</span> : <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPackingType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wrapper&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包装：瓶子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bottle</span> : <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPackingType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bottle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于食物有两大类：汉堡和饮料，因此，这里不直接构造具体食物的类，而是先构造两个抽象类：汉堡和冷饮，然后再构造它们的子类：素食汉堡、鸡肉汉堡、可口可乐、百事可乐。在抽象类中，会具体实现包装类型的选择，而不是在具体的某一食物类中实现选择。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//食物：抽象汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Burger</span> : <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPacking <span class="title">GetFoodPacking</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//食物：抽象冷饮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ColdDrink</span> : <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPacking <span class="title">GetFoodPacking</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造实现四种具体的食物类：素食汉堡类、鸡肉汉堡类、可口可乐类、百事可乐类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//素食汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VegBurger</span> : <span class="title">Burger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Veg Burger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鸡肉汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChickenBurger</span> : <span class="title">Burger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chicken Burger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可口可乐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coke</span> : <span class="title">ColdDrink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Coke&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//百事可乐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pepsi</span> : <span class="title">ColdDrink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pepsi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，构造一个菜单管理的类<code>Meal</code>，该类可以实现的功能有：</p><ul><li>向菜单中添加具体的食物</li><li>计算出食物的价格</li><li>打印输出当前菜单的所有情况</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个套餐类，用于组合食物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Meal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IFood&gt; _foodList = <span class="keyword">new</span> List&lt;IFood&gt;();  <span class="comment">//创建一个列表，用于存储当前所有食物</span></span><br><span class="line">    <span class="comment">//向列表中添加食物的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFood</span>(<span class="params">IFood food</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._foodList.Add(food);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前套餐的总价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetCost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">this</span>._foodList)</span><br><span class="line">        &#123;</span><br><span class="line">            cost += food.GetFoodPrice();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示当前套餐的所有食物</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowFood</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你的食物如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">this</span>._foodList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">&quot;食物: &#123;0&#125; ；&quot;</span>, food.GetFoodName());</span><br><span class="line">            Console.Write(<span class="string">&quot;包装: &#123;0&#125;；&quot;</span>, food.GetFoodPacking().GetPackingType());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;单价: &#123;0&#125;；&quot;</span>, food.GetFoodPrice());</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;总价：&#123;0&#125;&quot;</span>, GetCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的所有过程，均由售卖方执行，而作为顾客，只需要点餐就能获得对应的食物。这一部分在函数中进行，用于最终实现点餐的过程。具体代码如下;</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Meal meal1 = <span class="keyword">new</span> Meal(); <span class="comment">//先生成一个菜单管理器实例</span></span><br><span class="line">        meal1.AddFood(<span class="keyword">new</span> VegBurger()); <span class="comment">//向菜单管理器中添加食物</span></span><br><span class="line">        meal1.AddFood(<span class="keyword">new</span> Coke()); <span class="comment">//向菜单管理器中添加食物</span></span><br><span class="line">        meal1.ShowFood();</span><br><span class="line">        Meal meal2 = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> Pepsi());</span><br><span class="line">        meal2.ShowFood();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，结果如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你的食物如下：</span><br><span class="line">食物: Veg Burger ；包装: Wrapper；单价: <span class="number">25</span>；</span><br><span class="line">食物: Coke ；包装: Bottle；单价: <span class="number">30</span>；</span><br><span class="line">总价：<span class="number">55</span></span><br><span class="line">你的食物如下：</span><br><span class="line">食物: Chicken Burger ；包装: Wrapper；单价: <span class="number">50.5</span>；</span><br><span class="line">食物: Chicken Burger ；包装: Wrapper；单价: <span class="number">50.5</span>；</span><br><span class="line">食物: Pepsi ；包装: Bottle；单价: <span class="number">35</span>；</span><br><span class="line">总价：<span class="number">136</span></span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Meal meal1 = <span class="keyword">new</span> Meal(); <span class="comment">//先生成一个菜单管理器实例</span></span><br><span class="line">        meal1.AddFood(<span class="keyword">new</span> VegBurger()); <span class="comment">//向菜单管理器中添加食物</span></span><br><span class="line">        meal1.AddFood(<span class="keyword">new</span> Coke()); <span class="comment">//向菜单管理器中添加食物</span></span><br><span class="line">        meal1.ShowFood();</span><br><span class="line">        Meal meal2 = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> Pepsi());</span><br><span class="line">        meal2.ShowFood();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个食物的接口，方便后面继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IPacking <span class="title">GetFoodPacking</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个包装的接口，方便后面继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetPackingType</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个套餐类，用于组合食物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Meal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IFood&gt; _foodList = <span class="keyword">new</span> List&lt;IFood&gt;();  <span class="comment">//创建一个列表，用于存储当前所有食物</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//像列表中添加食物的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFood</span>(<span class="params">IFood food</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._foodList.Add(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前套餐的总价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetCost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">this</span>._foodList)</span><br><span class="line">        &#123;</span><br><span class="line">            cost += food.GetFoodPrice();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示当前套餐的所有食物</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowFood</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你的食物如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">this</span>._foodList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">&quot;食物: &#123;0&#125; ；&quot;</span>, food.GetFoodName());</span><br><span class="line">            Console.Write(<span class="string">&quot;包装: &#123;0&#125;；&quot;</span>, food.GetFoodPacking().GetPackingType());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;单价: &#123;0&#125;；&quot;</span>, food.GetFoodPrice());</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;总价：&#123;0&#125;&quot;</span>, GetCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 构造两个具体的包装类，并继承自`IPacking`接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包装：纸盒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Wrapper</span> : <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPackingType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wrapper&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包装：瓶子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bottle</span> : <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPackingType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bottle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span> 构造两个具体的包装类，并继承自`IPacking`接口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 构造两个抽象的食物类，并继承自`IFood`接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//食物：抽象汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Burger</span> : <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPacking <span class="title">GetFoodPacking</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//食物：抽象冷饮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ColdDrink</span> : <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPacking <span class="title">GetFoodPacking</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span> 构造两个抽象的食物类，并继承自`IFood`接口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 具体的食物类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//素食汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VegBurger</span> : <span class="title">Burger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Veg Burger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡肉汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChickenBurger</span> : <span class="title">Burger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chicken Burger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可口可乐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coke</span> : <span class="title">ColdDrink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Coke&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//百事可乐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pepsi</span> : <span class="title">ColdDrink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pepsi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span> 具体的食物类</span></span><br></pre></td></tr></table></figure><h1 id="原型模式（创造型）"><a href="#原型模式（创造型）" class="headerlink" title="原型模式（创造型）"></a>原型模式（创造型）</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>原型模式是一种创建型设计模式，<strong>它允许我们通过复制现有对象来创建新的对象，而不必从头开始编写代码</strong>。在原型模式中，我们使用一个现有的对象作为原型，并通过克隆该对象来创建新的对象。</p><ol><li>意图：用<strong>原型实例</strong>指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li><li>主要解决：在运行期建立和删除原型。</li><li>如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。</li><li>关键代码：<ol><li>实现克隆操作。</li><li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</li></ol></li><li>优点： 性能提高，逃避构造函数的约束。</li><li>缺点：<ol><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li><li>必须实现 Cloneable 接口。</li><li>逃避构造函数的约束。</li></ol></li></ol><h2 id="具体实现-4"><a href="#具体实现-4" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="https://imageshack.yuilexi.cn/Programming/设计模式/原型模式.svg" alt="原型模式"></p><p>首先定义一个可以克隆的接口 <code>ICloneable</code>，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">Clone</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个具体的原型类 <code>Prototype</code> ，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个具体的原型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Prototype</span> : <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prototype</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现ICloneable接口的Clone方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Clone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Prototype(Id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后测试原型，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试原型模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个原型对象</span></span><br><span class="line">        <span class="keyword">var</span> prototype = <span class="keyword">new</span> Prototype(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆原型对象</span></span><br><span class="line">        <span class="keyword">var</span> clone = (Prototype)prototype.Clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较两个对象的Id属性</span></span><br><span class="line">        Console.WriteLine(prototype.Id == clone.Id); <span class="comment">// 输出 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们首先定义了一个 <code>ICloneable</code> 接口，然后创建了一个具体的原型类 <code>Prototype</code> 。该类实现了<code>ICloneable</code> 接口，并在 <code>Clone()</code> 方法中返回一个新的 <code>Prototype</code> 对象，该对象与当前对象具有相同的 <code>Id</code> 属性。</p><p>接下来，我们在 <code>Main()</code> 方法中创建了一个原型对象，然后克隆了它，最后比较了两个对象的 Id 属性。由于克隆对象是从原型对象复制而来的，因此它们的 Id 属性是相同的。</p><p>这就是原型模式的基本实现方式。通过使用 <code>ICloneable</code> 接口和 <code>Clone()</code> 方法，我们可以轻松地实现对象的克隆，从而避免了从头开始编写代码的麻烦。</p><h1 id="适配器模式（结构型）"><a href="#适配器模式（结构型）" class="headerlink" title="适配器模式（结构型）"></a>适配器模式（结构型）</h1><p>适配器模式是一种结构型设计模式，<strong>它允许我们将不兼容的对象包装在一个适配器中，以便它们可以相互协作</strong>。适配器模式<strong>通常用于将现有类的接口转换为另一个接口，以便它们可以在不修改原始代码的情况下协同工作</strong>。</p><p>适配器模式由三个主要组件组成：客户端、适配器和适配者。</p><ul><li>客户端是使用适配器的对象，</li><li>适配器是将适配者转换为所需接口的对象，</li><li>适配者是要转换的对象。</li></ul><p>适配器通过实现目标接口并包装适配者来实现适配。</p><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>如何解决：</strong>继承或依赖（推荐）。</p><p><strong>优点：</strong>可以让任何两个没有关联的类一起运行。提高了类的复用。增加了类的透明度。灵活性好。</p><p><strong>缺点：</strong> 过多地使用适配器，会让系统非常零乱，不易整体进行把握。</p><h2 id="具体实现-5"><a href="#具体实现-5" class="headerlink" title="具体实现"></a>具体实现</h2><p>我们有一个音频播放的接口 <code>IMediaPlayer</code> ，并且还有一个实现了上述接口的类 <code>AudioPlayer</code> 。默认情况下，<code>AudioPlayer</code> 只能播放 mp3 格式的音频文件。</p><p>现在，我们需要让 <code>AudioPlayer</code> （目标/客户端）支持 vlc 和 mp4 格式的文件。</p><p>因此，我们先定义一个新的音频播放的<del>接口 <code>INewMediaPlayer</code></del> <strong>抽象类</strong> <code>NewMediaPlayer</code> ，并且还有两个实现了上述<del>接口</del><strong>抽象类</strong>的类： <code>VlcPlayer</code> 和 <code>Mp4Player</code></p><p>我们想要让 <code>AudioPlayer</code> 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 <code>IMediaPlayer</code> 接口的适配器类 <code>MediaAdapter</code>，并使用 <code>NewMediaPlayer</code> 的子对象（适配者）来播放所需的格式。</p><p><code>AudioPlayer</code>（目标/客户端） 使用适配器类 <code>MediaAdapter</code> 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。</p><p>首先定义出上述的接口<code>IMediaPlayer</code> 代码如下：</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-31</p></div></div><div class='timeline-item-content'><ol><li>添加原型模式</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Csharp </category>
          
          <category> 设计模式 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九章 查找【数据结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/09.%E6%9F%A5%E6%89%BE.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/09.%E6%9F%A5%E6%89%BE.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>快速导航：</p><ul><li><a href="./01.绪论">第一章 绪论【数据结构】</a></li><li><a href="./02.线性表">第二章 线性表【数据结构】</a></li><li><a href="./03.栈和队列">第三章 栈和队列【数据结构】</a></li><li><a href="./04.串">第四章 串【数据结构】</a></li><li><a href="./05.数组和广义表">第五章 数组和广义表【数据结构】</a></li><li><a href="./06.数和二叉树">第六章 数和二叉树【数据结构】</a></li><li><a href="./07.图Graph">第七章 图(Graph)【数据结构】</a></li><li><a href="./09.查找">第九章 查找【数据结构】</a></li></ul></blockquote><p><strong>查找表(Search Table)</strong>是由同一类型的数据元素(或记录)构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构。</p><p>对查找表经常进行的操作有：</p><ol><li>查询数据元素是否在查找表中</li><li>检索数据元素的各种属性</li><li>在查找表中插人一个数元素</li><li>从表中某个删去数据元素。</li></ol><p>若对查找表只作前两种统称为“查找”的操作，则称此类查找表为<strong>静态查找表(Static Search Table)</strong>。若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为<strong>动态查找表(Dynamic Search Table)</strong>。</p><p><strong>关键字(Key)</strong>是数据元素（或记录）中某个数据项的值，用它可以标识（识别）一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为<strong>主关键字（Primary Key）</strong>。反之，称用以识别若于记录的关键字为<strong>次关键字（Secondary Key）</strong>。当数据元素只有一个数据项时，其关键字即为该数据元素的值。</p><p><strong>查找(Searching)</strong>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。</p><ul><li>若表中存在这样的一个记录，则称<strong>查找是成功的</strong>，此时查找的结果为给出整个记录的信息，或指示该记录在查找表中的位置；</li><li>若表中不存在关键字等于给定值的记录，则称<strong>查找不成功</strong>，此时查找的结果可给出一个“空”记录或“空”指针。</li></ul><h1 id="一、静态查找表"><a href="#一、静态查找表" class="headerlink" title="一、静态查找表"></a>一、静态查找表</h1><h2 id="1-1-顺序表的查找"><a href="#1-1-顺序表的查找" class="headerlink" title="1.1 顺序表的查找"></a>1.1 顺序表的查找</h2><p><strong>顺序查找</strong>的过程：从表中最后一个记录开始，逐个进行比较<strong>给定值</strong>和<strong>访问的记录的关键字</strong>，如果二者相等，则查找成功；反之，如果直至第一个记录，其关键字和给定值比较都不相等，则查找不成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在顺序表 ST 中，顺序查找关键字等于 key 的数据元素</span></span><br><span class="line">    <span class="comment">// 返回该元素在表中的位置，否则为 0</span></span><br><span class="line">    ST.elem[<span class="number">0</span>].key = key; <span class="comment">// 把要找的元素放在 0 位置；如果表中找不到其他对应的数据，那么找到的只有 0 位置元素，返回的结果是 0 ；表示：查找失败</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = ST.length; !EQ(ST.elem[i].key, key); i--) &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法的思想和第2章中的函数 <code>LocateElbm_Sq</code>一致。只是在 <code>Search_Seq</code> 中查找之前，先对 <code>ST.elem[0]</code> 的关键字赋值 <code>key</code>，<strong>目的在于免去查找过程中每一步都要检测整个表是否查找完毕</strong>。</p><p>其改进形式的算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = ST.length;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (EQ(ST.elem[i].key, key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>EQ(a,b)</code> 函数是判断两个关键字是否相等的函数。</p><h2 id="1-1-5-查找的性能分析"><a href="#1-1-5-查找的性能分析" class="headerlink" title="1.(1.5) 查找的性能分析"></a>1.(1.5) 查找的性能分析</h2><p><strong>定义</strong>：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的<strong>平均查找长度(Average Search Length)</strong>。</p><p>对于含有 $n$ 个记录的表，查找成功时的平均查找长度为：</p><script type="math/tex; mode=display">\displaystyle \mathrm{ASL} = \sum_{i=1}^{n}  P_{i} C_{i}</script><p>其中： $\displaystyle P_{i} $ 为查找表中第 $i$ 个记录的概率，并且 $\displaystyle \mathrm{ASL} = \sum_{i=1}^{n}  P_{i} =1$ 。</p><h2 id="1-2-有序表的查找"><a href="#1-2-有序表的查找" class="headerlink" title="1.2 有序表的查找"></a>1.2 有序表的查找</h2><p><strong>折半查找</strong>的过程是：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或者找不到记录位置。</p><p>假设指针 $\displaystyle \mathrm{low} $ 和 $\displaystyle \mathrm{high} $ 分别指示待查元素，所在范围的下界和上界，指针 $\displaystyle \mathrm{mid} $ 指示区间的中间位置，即 $\displaystyle \mathrm{mid} =\left \lfloor \frac{(\mathrm{low}+\mathrm{high}  )}{2}  \right \rfloor $ 。</p><ul><li>如果 $\displaystyle \mathrm{ST.elem}\left [ \mathrm{mid}  \right ]  .\mathrm{key } &lt; \mathrm{key } $ ，则令 $\displaystyle \mathrm{low} = \mathrm{mid}+1  $ ；</li><li>如果 $\displaystyle \mathrm{ST.elem}\left [ \mathrm{mid}  \right ]  .\mathrm{key } &gt; \mathrm{key } $ ，则令 $\displaystyle \mathrm{high} = \mathrm{mid}-1  $ ；直至找到或者找不到对应的记录。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high = ST.length;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (EQ(ST.elem[mid].key, key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (LT(ST.elem[mid].key, key))</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：平均查找长度：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \mathrm{ASL} &=\sum_{i=1}^{n}P_{i} C _{i} \\&=\frac{1}{n} \sum_{j=1}^{h}j\cdot 2^{j-1}  \\&=\frac{n+1}{n} \log_{2}{(n+1)}-1 \end{align}</script><p>对任意的 $n$ ，当 $n$ 比较大时（  $n&gt;50$  ），可由下列近似结果：</p><script type="math/tex; mode=display">\displaystyle \mathrm{ASL}_{bs}  = \log_{2}{(n+1)}-1</script><h2 id="1-3-静态树的查找"><a href="#1-3-静态树的查找" class="headerlink" title="1.3 静态树的查找"></a>1.3 静态树的查找</h2><p>前面的对有序表的查找性能的讨论，是在<strong>等概率</strong>的前提下进行的。如果有序表中个记录的查找概率不相等，该如何呢？</p><p>如果只考虑查找成功的话，则是查找性能达到最佳的判定树，是其带权路径长度之和 $\displaystyle \mathrm{PH}$ 值：</p><script type="math/tex; mode=display">\displaystyle \mathrm{PH}=\sum_{i=1}^{n}w_{i} h _{i}</script><p>取最小的二叉树。其中： $\displaystyle n$ 为二叉树上结点的个数（即：有序表的长度）； $\displaystyle h_{i} $ 为第 $\displaystyle i$ 个结点的在二叉树上的层次树；结点的权 $\displaystyle w_{i} =cp_{i} $ ，其中 $\displaystyle p_{i} $ 为结点的查找概率， $\displaystyle c$ 为某个常量。并且称 $\displaystyle \mathrm{PH}$ 值取最小的二叉树为<strong>静态最优查找树</strong>。</p><p>由于构造静态最优查找树所花费的时间代价较高，因此不做详细讨论。在此介绍一种构造近似最优查找树的有效算法。</p><p>已知一个按关键字有序的记录序列</p><script type="math/tex; mode=display">\displaystyle (r_{a},r_{a+1},\cdots ,r_{h})</script><p>其中： $\displaystyle r_{a}.key &lt; r_{a+1}.key &lt; \cdots  &lt; r_{h}.key &lt; $ ；与每个记录相应的权值为： $\displaystyle w_{a} ,w_{a+1} ，\cdots ，w_{h} $ 。现构造一棵二叉树，使得这棵二叉树的带权路径长度 $\displaystyle \mathrm{PH} $ 值在所有具有同样权值的二叉树中，近似最小，称这类二叉树为<strong>次优查找树</strong>。</p><p><strong>构造次优查找树的递归算法</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SecondOptimal</span><span class="params">(BiTree &amp;T, ElemType R[], <span class="type">float</span> sw[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = low; <span class="comment">// 用于记录最小值的下标</span></span><br><span class="line">    <span class="type">float</span> min = <span class="built_in">fabs</span>(sw[high] - sw[low]); <span class="comment">// 用于记录最小值</span></span><br><span class="line">    <span class="type">float</span> dw = sw[high] + sw[low - <span class="number">1</span>]; <span class="comment">// 用于记录当前的权值和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low + <span class="number">1</span>; j &lt;= high; j++) <span class="comment">// 从low+1开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> temp = <span class="built_in">fabs</span>(dw - sw[j] - sw[j - <span class="number">1</span>]); <span class="comment">// 计算当前的权值和</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = temp;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode)); <span class="comment">// 生成结点</span></span><br><span class="line">    T-&gt;data = R[i]; <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (i == low)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SecondOptimal(T-&gt;lchild, R, sw, low, i - <span class="number">1</span>); <span class="comment">// 递归生成左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == high)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SecondOptimal(T-&gt;rchild, R, sw, i + <span class="number">1</span>, high); <span class="comment">// 递归生成右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/构造次优二叉查找树的简单示例.png" alt="构造次优二叉查找树的简单示例" style="zoom: 100%"></p><h2 id="1-4-分块查找"><a href="#1-4-分块查找" class="headerlink" title="1.4 分块查找"></a>1.4 分块查找</h2><p>如果以索引表表示静态查找表，则可用<strong>分块查找</strong>来实现。</p><p><strong>分块查找</strong>又称为索引顺序查找，这是顺序查找的一种改进方法。在此查找方法中，除了表本身以外，尚需建立一个“索引表”。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/分块查找的表及其索引表.png" alt="分块查找的表及其索引表" style="zoom: 100%"></p><p>分块查找的平均查找长度为：</p><script type="math/tex; mode=display">\displaystyle \mathrm{ASL}_{bs} = L_{b}+L_{w}</script><p>其中： $\displaystyle L_{b}$ 为查找索引表确定所在块的平均查找长度， $\displaystyle L_{w}$ 为在块中查找元素的平均查找长度。如果用顺序表查找确定所在块，则分块查找的平均查找长度为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \mathrm{ASL}_{bs} & = L_{b}+L_{w}  = \frac{1}{b}\sum_{j=1}^{b}j+\frac{1}{s} \sum_{i=1}^{s}i\\&=\frac{b+1}{2}+\frac{s+1}{2} = \frac{1}{2} (\frac{n}{s} +s)+1    \end{align}</script><p>如果用折半查找确定所在块，则分块查找的平局查找长度为:</p><script type="math/tex; mode=display">\displaystyle {\mathrm{ASL}_{bs} }'   \approx \log_{2}{(\frac{n}{s} +s)}+\frac{s}{2}</script><h1 id="二、动态表的查找"><a href="#二、动态表的查找" class="headerlink" title="二、动态表的查找"></a>二、动态表的查找</h1><h2 id="2-1-二叉排序树"><a href="#2-1-二叉排序树" class="headerlink" title="2.1 二叉排序树"></a>2.1 二叉排序树</h2><p><strong>二叉排序树</strong>是具有下列性质的二叉树：</p><ol><li>如果它的左子树不为空，则左子树上<strong>所有结点</strong>的值<strong>均小于</strong>他的根节点的值；</li><li>如果它的右子树不为空，则右子树上<strong>所有结点</strong>的值<strong>均大于</strong>他的根节点的值；</li><li>它的左右子树也分别为二叉排序树；</li><li>二叉排序树也可能是一棵空树。</li></ol><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/二叉排序树的简单示例.png" alt="二叉排序树的简单示例" style="zoom: 100%"></p><p><strong>二叉排序树又称二叉查找树</strong>，根据上述定义的结构特点可见，它的查找过程和次优二叉树类似。即：当二叉排序树不空时，首先将给定值和根结点的关键字比较；若相等，则查找成功；否则，将依据给定值和根结点的关键字之间的大小关系，分别在左子树或右子树上继续进行查找。</p><p>二叉排序树的查找算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BiTree <span class="title function_">SearchBST</span><span class="params">(BiTree T, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span> || EQ(key, T-&gt;data.key)) <span class="comment">// 如果为空或者相等，返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key); <span class="comment">// 在左子树中继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key); <span class="comment">// 在右子树中继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉排序树是一种动态树表。其特点是：树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时，再进行插入。<strong>新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或者右孩子结点</strong>。</p><p>改进的查找插入算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Statue <span class="title function_">SearchBST</span><span class="params">(BiTree T, KeyType key, BiTree f, BiTree &amp;p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="comment">// 如果为空，返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = f;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (EQ(key, T-&gt;data.key)) <span class="comment">// 如果相等，返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p); <span class="comment">// 在左子树中继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p); <span class="comment">// 在右子树中继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，二叉排序树的插入算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Statue <span class="title function_">InsertBST</span><span class="params">(BiTree &amp;T, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">if</span> (!SearchBST(T, e.key, <span class="literal">NULL</span>, p)) <span class="comment">// 如果不存在，插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        BiTree s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">// 如果为空，直接插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            T = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (LT(e.key, p-&gt;data.key))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = s; <span class="comment">// 插入左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = s; <span class="comment">// 插入右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若从空树出发，经过一系列的查找插入操作之后，可生成一棵二叉树。设查找的关键字序列为 (45,24,53,45,12,24,90) ，则生成的二叉排序树如下图所示：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/二叉排序树的构造过程.png" alt="二叉排序树的构造过程" style="zoom: 100%"></p><p>在二叉查找树中，删除一个结点，有三种情况讨论：</p><ol><li>如果 <code>指针p</code> 结点为叶子结点，那么只需要修改双亲结点的指针即可；</li><li>如果 <code>指针p</code> 结点只有左子树或者只有右子树，那么直接让子树成为其双亲结点的左子树（或者右子树）即可；</li><li>如果 <code>指针p</code> 结点仅有左子树，又有右子树。<ol><li>方法一：令 <code>指针p</code> 结点的左子树（右子树）为其双亲的左子树（右子树），而结点的左子树（右子树）为其双亲的左子树（右子树），而 <code>指针p</code> 的右子树（左子树）为的右子树（左子树）为的右子树（左子树）；</li><li>方法二：令 <code>指针p</code> 的直接前驱或者直接后继替代的直接前驱或者直接后继替代 <code>指针p</code> ，然后再从二叉排序树中删去它的直接前驱或者直接后继；</li></ol></li></ol><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/二叉排序树删除对应的结点元素.png" alt="二叉排序树删除对应的结点元素" style="zoom: 100%"></p><p>在二叉排序树上删除一个结点的算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Staute <span class="title function_">DeleteBSF</span><span class="params">(BiTree &amp;T, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="comment">// 如果为空，返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (EQ(key, T-&gt;data.key)) <span class="comment">// 如果相等，删除</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;lchild, key); <span class="comment">// 在左子树中继续查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;rchild, key); <span class="comment">// 在右子树中继续查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Statue <span class="title function_">Delete</span><span class="params">(BiTree &amp;p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree q, s;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rchild == <span class="literal">NULL</span>) <span class="comment">// 如果右子树为空，直接删除</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) <span class="comment">// 如果左子树为空，直接删除</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;rchild != <span class="literal">NULL</span>) <span class="comment">// 找到左子树的最右结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data; <span class="comment">// 用最右结点的值替换</span></span><br><span class="line">        <span class="keyword">if</span> (q != p)</span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild; <span class="comment">// 用最右结点的左子树替换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild; <span class="comment">// 用最右结点的左子树替换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉排序树的查找分析：</p><p><strong>含有 $\displaystyle n$ 个结点的二叉排序树的平均查找长度和树的形态有关</strong>。树的深度为 $\displaystyle n$ ，其平均查找长度为 $\displaystyle \frac{n+1}{2} $ ，这是最差的情况。显然，最好的情况是二叉排序树和折半查找的判定树相同，这是最差的情况。</p><h2 id="2-2-平衡二叉树"><a href="#2-2-平衡二叉树" class="headerlink" title="2.2 平衡二叉树"></a>2.2 平衡二叉树</h2><p><strong>平衡二叉树（Balanced Binay Tree 或者 Height-Balanced Tree）</strong>又称 AVL 树（<code>Adelson-Velskii and Landis</code>）。它的特点是：</p><ul><li>它可能是一棵空树；</li><li>它的左子树和右子树都是平衡二叉树；</li><li>左子树和右子树的深度只差绝对值不超过 1 。</li></ul><p>如果将二叉树上结点的平衡因子 $\displaystyle \mathrm{BF(Balance\quad Factor)} $ 定义为该结点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是 -1、 0 、 1。</p><blockquote><p>只要二叉树上有一个结点的平衡因子的绝对值大于 1，则该二叉树就是不平衡的。</p></blockquote><p>在一般情况下，假设由于在二叉排序树上插入结点，而失去平衡的最小子树根结点为 $A$ ，则失去平衡后进行调整的规律可归纳为下列四种情况：</p><ol><li>单向右旋平衡处理：如果在 <code>A</code> 的左子树的根结点的左侧插入结点， <code>A</code> 的平衡因子由 1 变为 2 ，则需要进行一次向右的顺时针旋转操作；</li><li>单向左旋平衡处理：如果在 <code>A</code> 的右子树的根结点的右侧插入结点， <code>A</code> 的平衡因子由 -1 变为 -2 ，则需要进行一次向左的逆时针旋转操作；（图 c）</li><li>双向旋转（先左后右）平衡处理：如果在 <code>A</code> 的左子树的根结点的右子树上插入结点， <code>A</code> 的平衡因子由 1 变为 2 ，则需要进行两次旋转操作（先左旋后右旋）；（图 b）</li><li>双向旋转（先右后左）平衡处理：由于在 <code>A</code> 的右子树的根结点的左子树上插入结点， <code>A</code> 的平衡因子由 -1 变为 -2 ，则需要进行两次旋转操作（先右旋后左旋）。（图 d）</li></ol><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/平衡旋转问题.png" alt="平衡旋转问题" style="zoom: 100%"></p><p>在平衡的二叉排序树 BBST上插人一个新的数据元素 $\displaystyle e$ 的递归算法可描述如下：</p><ol><li><p>若BBST为空树，则插人一个数据元素为 $\displaystyle e$ 的新结点作为 BBST 的根结点，树的深度增 1 ；</p></li><li><p>若 $\displaystyle e$ 的关键字和 BBST的根结点的关键字相等，则不进行插入</p></li><li><p>若 $\displaystyle e$ 的关键字小于BBST的根结点的关键字，而且在 BBST 的左子树中，不存在和 $\displaystyle e$ 有相同关键字的结点，则将 e 插人在 BBST的左子树上，并且当插之后的左子树深度增加 (+1) 时，分别就下列不同情况处理之：</p><ol><li><p>BBST 的根结点的平衡因子为-1（右子树的深度大于左子树的深度）：则将根结点的平很椅子改为 0 ，BBST 的深度不变；</p></li><li><p>BBST 的根结点的平衡因子为 0 （左、右子树的深度相等），将根结点的因子更改为 1 ， BBST 的深度增 1 ；</p></li><li><p>BBST 的根结点的平衡因子为 1（左子的深度大于子的深度）： BBST 的左子树根结点的平衡因子为 1，则需进行单向右旋平衡处理；并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为 0 ，树的深度不变；</p><p> ​    若 BBST 的左子树根结点的平衡因子为 -1 ，则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后，修改根结点和其左、右子树根结点的平衡因子，树的深度不变；</p></li></ol></li><li><p>若  $\displaystyle e$  的关键字大于 BBST 的根结点的关键字，而且在 BBST的子树中不存在和  $\displaystyle e$  有相同关键字的结点，则将  $\displaystyle e$  插入在 BBST 的右子树上，并且当插入之后的右子树深度增加(+1)时，分别就不同情况处理之。其处理操作和(三)中所述相对称。</p></li></ol><p>二叉排序树的类型定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LH +1 <span class="comment">// 左高</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EH 0  <span class="comment">// 等高</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RH -1 <span class="comment">// 右高</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ============================ 数据结构 ============================ */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125; ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> bf;                          <span class="comment">// 平衡因子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =========================== 旋转操作 ============================== */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">R_Rotate</span><span class="params">(BSTree &amp;p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree lc = p-&gt;lchild; <span class="comment">// lc指向p的左子树根结点</span></span><br><span class="line">    p-&gt;lchild = lc-&gt;rchild;</span><br><span class="line">    lc-&gt;rchild = p;</span><br><span class="line">    p = lc; <span class="comment">// p指向新的根结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">L_Rotate</span><span class="params">(BSTree &amp;p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree rc = p-&gt;rchild; <span class="comment">// rc指向p的右子树根结点</span></span><br><span class="line">    p-&gt;rchild = rc-&gt;lchild;</span><br><span class="line">    rc-&gt;lchild = p;</span><br><span class="line">    p = rc; <span class="comment">// p指向新的根结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftBalance</span><span class="params">(BSTree &amp;T)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree lc = T-&gt;lchild; <span class="comment">// lc指向T的左子树根结点</span></span><br><span class="line">    <span class="keyword">switch</span> (lc-&gt;bf)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> LH: <span class="comment">// 新结点插入在T的左孩子的左子树上，要做单右旋处理</span></span><br><span class="line">        T-&gt;bf = lc-&gt;bf = EH;</span><br><span class="line">        R_Rotate(T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RH:                    <span class="comment">// 新结点插入在T的左孩子的右子树上，要做双旋处理</span></span><br><span class="line">        BSTree rd = lc-&gt;rchild; <span class="comment">// rd指向T的左孩子的右子树根</span></span><br><span class="line">        <span class="keyword">switch</span> (rd-&gt;bf)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">            T-&gt;bf = RH;</span><br><span class="line">            lc-&gt;bf = EH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EH:</span><br><span class="line">            T-&gt;bf = lc-&gt;bf = EH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">            T-&gt;bf = EH;</span><br><span class="line">            lc-&gt;bf = LH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rd-&gt;bf = EH;</span><br><span class="line">        L_Rotate(T-&gt;lchild); <span class="comment">// 对T的左子树做左旋平衡处理</span></span><br><span class="line">        R_Rotate(T);         <span class="comment">// 对T做右旋平衡处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RightBalance</span><span class="params">(BSTree &amp;T)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree rc = T-&gt;rchild; <span class="comment">// rc指向T的右子树根结点</span></span><br><span class="line">    <span class="keyword">switch</span> (rc-&gt;bf)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> RH: <span class="comment">// 新结点插入在T的右孩子的右子树上，要做单左旋处理</span></span><br><span class="line">        T-&gt;bf = rc-&gt;bf = EH;</span><br><span class="line">        L_Rotate(T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LH:                    <span class="comment">// 新结点插入在T的右孩子的左子树上，要做双旋处理</span></span><br><span class="line">        BSTree ld = rc-&gt;lchild; <span class="comment">// ld指向T的右孩子的左子树根</span></span><br><span class="line">        <span class="keyword">switch</span> (ld-&gt;bf)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">            T-&gt;bf = LH;</span><br><span class="line">            rc-&gt;bf = EH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EH:</span><br><span class="line">            T-&gt;bf = rc-&gt;bf = EH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">            T-&gt;bf = EH;</span><br><span class="line">            rc-&gt;bf = RH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ld-&gt;bf = EH;</span><br><span class="line">        R_Rotate(T-&gt;rchild); <span class="comment">// 对T的右子树做右旋平衡处理</span></span><br><span class="line">        L_Rotate(T);         <span class="comment">// 对T做左旋平衡处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，构造对应的插入算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InsertAVL</span><span class="params">(BSTree &amp;T, ElemType e, <span class="type">bool</span> &amp;taller)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="comment">// 插入新结点，树长高</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;data = e;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;bf = EH;</span><br><span class="line">        taller = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (EQ(e.key, T-&gt;data.key)) <span class="comment">// 树中已存在和e有相同关键字的结点则不再插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            taller = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LT(e.key, T-&gt;data.key)) <span class="comment">// 应继续在T的左子树中进行搜索</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!InsertAVL(T-&gt;lchild, e, taller)) <span class="comment">// 未插入</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (taller) <span class="comment">// 已插入到T的左子树中且左子树“长高”</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (T-&gt;bf)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> LH: <span class="comment">// 原本左子树比右子树高，需要做左平衡处理</span></span><br><span class="line">                    LeftBalance(T);</span><br><span class="line">                    taller = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EH: <span class="comment">// 原本左右子树等高，现因左子树增高而使树增高</span></span><br><span class="line">                    T-&gt;bf = LH;</span><br><span class="line">                    taller = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RH: <span class="comment">// 原本右子树比左子树高，现左右子树等高</span></span><br><span class="line">                    T-&gt;bf = EH;</span><br><span class="line">                    taller = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 应继续在T的右子树中进行搜索</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!InsertAVL(T-&gt;rchild, e, taller)) <span class="comment">// 未插入</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (taller) <span class="comment">// 已插入到T的右子树中且右子树“长高”</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (T-&gt;bf)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> LH: <span class="comment">// 原本左子树比右子树高，现左右子树等高</span></span><br><span class="line">                    T-&gt;bf = EH;</span><br><span class="line">                    taller = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EH: <span class="comment">// 原本左右子树等高，现因右子树增高而使树增高</span></span><br><span class="line">                    T-&gt;bf = RH;</span><br><span class="line">                    taller = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RH: <span class="comment">// 原本右子树比左子树高，需要做右平衡处理</span></span><br><span class="line">                    RightBalance(T);</span><br><span class="line">                    taller = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>平衡树的查找分析：时间复杂度为 $\displaystyle O(\log_{}{n} )$ 。</p></blockquote><h2 id="2-3-B-树和B-树"><a href="#2-3-B-树和B-树" class="headerlink" title="2.3 B-树和B+树"></a>2.3 B-树和B+树</h2><p><strong>B-树</strong>是一种平衡的多路查找树。一棵 $\displaystyle m$ 阶的B-树，或为空树，或为满足下列特性的 $\displaystyle m$ 叉树：</p><ol><li><p>树中每个结点至多有 $\displaystyle m$ 棵子树；</p></li><li><p>如果根结点不是叶子结点，则至少有两棵子树；</p></li><li><p>除根结点之外的所有非终端结点，至少有 $\displaystyle \frac{m}{2} $ 棵子树；</p></li><li><p>所有的非终端结点中包含下列信息：</p><script type="math/tex; mode=display"> \displaystyle (n,A_{0},K_{1},A_{1},K_{2},A_{2},\cdots ,K_{n},A_{n})</script><p> ​    其中， $\displaystyle K_{i}$ 为关键字，且 $\displaystyle K_{i}&lt;K_{i+1}$ ； $\displaystyle A_{i}$ 指向子树根结点的指针，且指针 $\displaystyle A_{i-1}$ 所指子树中，所有结点的关键字均小于 $\displaystyle K_{i}$ ， $\displaystyle A_{n}$ 所指子树中所有结点的关键字均大于 $\displaystyle K_{n}$ ， $\displaystyle n$ 为关键字的个数（或者 $\displaystyle n+1$ 为子树个数）。</p></li><li><p>所有的叶子结点都出现在同一层次上，并且不带信息。</p></li></ol><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/一棵4阶的B-树.png" alt="一棵4阶的B-树" style="zoom: 100%"></p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/B树的结点详解.png" alt="B树的结点详解" style="zoom: 100%"></p><p>在B-树上进行查找的过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程。</p><p>假设结点类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> m 3 <span class="comment">// B-树的阶，暂设为3</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">KeyType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 关键字项</span></span><br><span class="line">&#125; KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Record</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125; Record;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> keynum;                <span class="comment">// 结点中关键字个数，即结点的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">parent</span>;</span>     <span class="comment">// 指向双亲结点</span></span><br><span class="line">    KeyType key[m + <span class="number">1</span>];        <span class="comment">// 关键字向量，0号单元未用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">ptr</span>[<span class="title">m</span> + 1];</span> <span class="comment">// 子树指针向量</span></span><br><span class="line">    Record *recptr[m + <span class="number">1</span>];     <span class="comment">// 记录指针向量</span></span><br><span class="line">&#125; BTNode, *BTree;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Result</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BTNode *pt; <span class="comment">// 指向找到的结点</span></span><br><span class="line">    <span class="type">int</span> i;      <span class="comment">// 1..m，在结点中的关键字序号</span></span><br><span class="line">    <span class="type">int</span> tag;    <span class="comment">// 1:查找成功，0:查找失败</span></span><br><span class="line">&#125; Result;</span><br></pre></td></tr></table></figure><p>简单的查找操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search</span><span class="params">(BTNode *p, KeyType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= p-&gt;keynum &amp;&amp; LT(p-&gt;key[i].key, K.key); i++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">Result <span class="title function_">SearchBTree</span><span class="params">(BTree T, KeyType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode *p = T, *q = <span class="literal">NULL</span>; <span class="comment">// 初始化，p指向待查结点，q指向p的双亲</span></span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>, i = <span class="number">0</span>;     <span class="comment">// 初始化，found指示是否查找成功，i为查找关键字的序号</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; !found)</span><br><span class="line">    &#123;</span><br><span class="line">        i = Search(p, K); <span class="comment">// 在p-&gt;key[1..keynum]中查找K.key</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; EQ(p-&gt;key[i].key, K.key))</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="number">1</span>; <span class="comment">// 查找成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;ptr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Result(p, i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Result(q, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>B-树的查找分析：在含有 $N$ 个关键字的 B-树上进行查找时，从根结点到关键字所在结点的路径上设计的结点数不超过：</p><script type="math/tex; mode=display">\displaystyle \log_{\displaystyle \frac{m}{2} }{(\frac{N+1}{2} )} +1</script></blockquote><p>B-树的插入和删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InsertBTree</span><span class="params">(BTree &amp;T, KeyType K, BTree q, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, finished = <span class="number">0</span>; <span class="comment">// finished指示插入是否完成，s为插入的关键字序号</span></span><br><span class="line">    KeyType x = K;           <span class="comment">// x为待插入的关键字</span></span><br><span class="line">    BTree ap = <span class="literal">NULL</span>, p = q;  <span class="comment">// ap为新的右子树指针，p为新的右子树指针</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !finished)   <span class="comment">// 自底向上查找待插入位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        Insert(p, i, x, ap); <span class="comment">// 将x和ap分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;keynum &lt; m)   <span class="comment">// 结点未满，插入完成</span></span><br><span class="line">        &#123;</span><br><span class="line">            finished = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 结点已满，沿双亲链进行结点分裂</span></span><br><span class="line">        &#123;</span><br><span class="line">            s = (m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            x = p-&gt;key[s];</span><br><span class="line">            Split(p, s, ap); <span class="comment">// 将p-&gt;key[s+1..m],p-&gt;ptr[s..m]和p-&gt;recptr[s..m]移入新结点*ap</span></span><br><span class="line">            p = p-&gt;parent;</span><br><span class="line">            <span class="keyword">if</span> (p)</span><br><span class="line">            &#123;</span><br><span class="line">                i = Search(p, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!finished) <span class="comment">// T是空树(参数q为NULL)或根结点已分裂为结点(参数q不为NULL)</span></span><br><span class="line">    &#123;</span><br><span class="line">        NewRoot(T, p, x, ap); <span class="comment">// 生成含信息(T,x,ap)的新的根结点*T，原T和ap为子树指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(BTNode *p, <span class="type">int</span> i, KeyType K, BTree ap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = p-&gt;keynum; j &gt; i; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;key[j + <span class="number">1</span>] = p-&gt;key[j];</span><br><span class="line">        p-&gt;ptr[j + <span class="number">1</span>] = p-&gt;ptr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;key[i + <span class="number">1</span>] = K;</span><br><span class="line">    p-&gt;ptr[i + <span class="number">1</span>] = ap;</span><br><span class="line">    <span class="keyword">if</span> (ap)</span><br><span class="line">    &#123;</span><br><span class="line">        ap-&gt;parent = p;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;keynum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Split</span><span class="params">(BTNode *p, <span class="type">int</span> s, BTree &amp;ap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ap = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode)); <span class="comment">// 生成新的右结点*ap</span></span><br><span class="line">    ap-&gt;ptr[<span class="number">0</span>] = p-&gt;ptr[s];                <span class="comment">// 复制*p中后一半的关键字和指针到*ap</span></span><br><span class="line">    <span class="keyword">for</span> (i = s + <span class="number">1</span>; i &lt;= p-&gt;keynum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ap-&gt;key[i - s] = p-&gt;key[i];</span><br><span class="line">        ap-&gt;ptr[i - s] = p-&gt;ptr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ap-&gt;keynum = p-&gt;keynum - s;</span><br><span class="line">    ap-&gt;parent = p-&gt;parent;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= p-&gt;keynum - s; i++) <span class="comment">// 修改双亲指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ap-&gt;ptr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ap-&gt;ptr[i]-&gt;parent = ap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;keynum = s - <span class="number">1</span>; <span class="comment">// 修改*p中前一半的关键字和指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">NewRoot</span><span class="params">(BTree &amp;T, BTree p, KeyType K, BTree ap)</span></span><br><span class="line">&#123;</span><br><span class="line">    BTree q = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode)); <span class="comment">// 生成新的根结点*q</span></span><br><span class="line">    q-&gt;keynum = <span class="number">1</span>;</span><br><span class="line">    q-&gt;ptr[<span class="number">0</span>] = T;</span><br><span class="line">    q-&gt;ptr[<span class="number">1</span>] = ap;</span><br><span class="line">    q-&gt;key[<span class="number">1</span>] = K;</span><br><span class="line">    q-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;parent = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ap)</span><br><span class="line">    &#123;</span><br><span class="line">        ap-&gt;parent = q;</span><br><span class="line">    &#125;</span><br><span class="line">    T = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Search</span><span class="params">(BTNode *p, KeyType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= p-&gt;keynum &amp;&amp; LT(p-&gt;key[i].key, K.key); i++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果在 B-树上删除一个关键字，则首先删除该关键所在的结点。如果该结点为最下层的非终端结点，且其中的关键字数目不少于 $\displaystyle \frac{m}{2} $ ，则删除完成；否则要进行 <strong>合并结点</strong> 的操作。</p><p>删除最下层非终端结点中关键字的情形。有下列三种可能性：</p><ol><li>被删关键字所在结点中的关键字数目不小于 $\displaystyle \frac{m}{2} $ ， 则只需从该结点中删去该关键字 $K$ 和相应指针 $A$ ，树的其他部分不变；</li><li>被删关键字所在结点中的关键字数目等于 $\displaystyle \frac{m}{2}-1 $ ，而与该结点相邻的右兄弟（或左兄弟）结点中的关键字数目大于 $\displaystyle \frac{m}{2}-1 $ ，则需将其兄弟结点中的最小（或最大）的关键字上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移关键字的关键字下移至被删关键字所在结点中；</li><li>被删关键字所在结点和其相邻的兄弟结点中的关键字数目均等于 $\displaystyle \frac{m}{2}-1 $ 。假设该结点有右兄弟，且其右兄弟结点地址由双亲结点中的指针 $A$ 所指，则在删去关键字之后，它所在结点中剩余的关键字和指针加上双亲结点中的关键字 $K$ 一起，合并到 $A$ 所指兄弟结点中（若没有右兄弟，则合并至左兄弟结点中）。</li></ol><p><strong>B+树</strong>：B+树是应文件系统所需而出的一种 B-树的型树。一个 $m$ 阶的B+树和 $m$ 阶的B-树的差异在于：</p><ol><li>有 $n$ 棵子树的结点中含有 $n$ 个关键字；</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。</li></ol><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/B+树.png" alt="B+树" style="zoom: 100%"></p><h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h2 id="3-1-什么是哈希表"><a href="#3-1-什么是哈希表" class="headerlink" title="3.1 什么是哈希表"></a>3.1 什么是哈希表</h2><p>在前面讨论的各种结构（线性表、树等）中，记录在结构中的相对位置是随机的，和记录的关键字之间不存在确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。</p><p>这一类查找方法建立在“比较”的基础上。在顺序查找时，比较的结果为“<code>=</code>”与“<code>!=</code>”两种可能；在折半查找二叉排序树查找和 B-树查找时，比较的结果为“&lt;”、“=”和“&gt;”3种可能。</p><p>查找的效率依赖于查找过程中所进行的比较次数。</p><p><strong>理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系 $\displaystyle f$ ，使每个关键字和结构中一个唯一的存储位置相对应</strong>。因而在查找时，只要根据这个对应关系 $\displaystyle f$ ，找到给定值 $K$ 的像 $\displaystyle f(K)$ 。</p><p>若结构中存在关键字和 $K$ 相等的记录，则必定在 $\displaystyle f(K)$ 的存储位置上，由此，不需要进行比较便可直接取得所查记录。在此，我们称这个对应关系为<strong>哈希(Hash)函数</strong>，按这个思想建立的表为<strong>哈希表</strong>。</p><ol><li>哈希函数是一个映像，因此设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许范围之内即可；</li><li>对不同的关键字可能得到同一哈希地：即 $\displaystyle \mathrm{key1} \ne \mathrm{key2}$ ，而 $\displaystyle f(\mathrm{key1}) = f(\mathrm{key2})$ ，这种现象称<strong>冲突(collision)</strong>。具有相同函数值的关键字对该哈希函数来说称做<strong>同义词synonym)</strong>。</li></ol><blockquote><p>然而，在一般情况下，冲突只能尽可能地少，而不能完全避免。因为，<strong>哈希函数是从关键字集合到地址集合的映像</strong></p></blockquote><h2 id="3-2-哈希函数的构造方法"><a href="#3-2-哈希函数的构造方法" class="headerlink" title="3.2 哈希函数的构造方法"></a>3.2 哈希函数的构造方法</h2><p>常用的构造哈希函数的方法有：</p><ol><li><p>直接定址法</p><p> ​    <strong>取关键字</strong>或者<strong>关键字的某个线性函数值</strong>作为哈希地址。即：</p><script type="math/tex; mode=display"> \displaystyle H(K) = K \quad  or H(K) = a\cdot K+b</script><p> ​    例如：（1）以年龄作为关键字，哈希函数其关键字本身。（2）关键字是年份，哈希函数取<strong>关键字 + 常数</strong>。</p><p> <img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/直接定址法哈希函数.png" alt="直接定址法哈希函数" style="zoom: 100%"></p></li><li><p>数字分析法</p><p> ​    假设关键字是以 $r$ 为基的数（如:以 10 为基的十进制数），并且<strong>哈希表中可能出现的关键字都是事先知道的</strong>，则可取关键字的若干数位组成哈希地址。</p></li><li><p>平方取中法</p><p> ​    <strong>取关键字平方后的中间几位为哈希地址</strong>。这是一种较常用的构造哈希函数的方法，通常在选定哈希函数时不一定能知道关键字的全部情况，取其中哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。</p></li><li><p>折叠法</p><p> ​    将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加和（舍去进位）作为哈希地址，这方法称为<strong>折叠法(olding)</strong>。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到哈希地址。</p></li><li><p>除留余数法</p><p> ​    <strong>取关键字被某个不大于哈希表表长 $m$ 的数 $p$ 除后，所得的余数为哈希地址</strong>。即：</p><script type="math/tex; mode=display"> \displaystyle H(K) = K \quad \mathrm{mod}\quad p</script><p> 这是一种最简单，也最常用的构造哈希函数的方法。它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。</p><blockquote><p>值得注意的是，在使用除留余数法时，对 $p$ 的选择很重要。若 $p$ 选的不好，容易产生同义词。</p></blockquote></li><li><p>随机数法</p><p> ​    选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 $\displaystyle H(K) = \mathrm{random}(K) $ ，其中 <code>random</code> 为<strong>随机函数</strong>。通常，当关键字长度不等时，采用此法构造哈希函数较恰当。</p></li></ol><p>实际工作中需视不同的情况采用不同的哈希函数。通常,考虑的因素有：</p><ol><li>计算哈希函数所需时间（包括硬件指令的因素）；</li><li>关键字的长度；</li><li>哈希表的大小；</li><li>关键字的分布情况；</li><li>记录的查找频率。</li></ol><h2 id="3-3-处理冲突的方法"><a href="#3-3-处理冲突的方法" class="headerlink" title="3.3 处理冲突的方法"></a>3.3 处理冲突的方法</h2><p>通常用的处理冲突的方法有下列几种：</p><ol><li><p>开放定址法</p><script type="math/tex; mode=display"> \displaystyle H_{i} (K) = \left [ H(K) +d_{i} \right ]  \quad \mathrm{mod} \quad  m</script><p> 其中： H(K) 为<strong>哈希函数</strong>； $m$ 为哈希表表长； $\displaystyle d_{i}$ 为增量序列，可有 3 种取法：</p><ol><li>$\displaystyle d_{i} =1,2,3,\cdots ,m-1$ ，称为<strong>线性探测再散列</strong>；</li><li>$\displaystyle d_{i} =\pm 1^{2} ,\pm 2^{2} ,\pm 3^{2} ,\cdots ,\pm (m-1)^{2} $ ，称为<strong>二次探测再散列</strong>；</li><li><script type="math/tex">\displaystyle d_{i} = \text{伪随机数序列}</script> ，称为<strong>随机探测再散列</strong>。</li></ol></li><li><p>再哈希法</p><script type="math/tex; mode=display"> \displaystyle H_{i}(K) = RH_{i} (K)</script><p> ​    $\displaystyle RH_{i} (K)$ 均是不同的哈希函数，即在同义词产生地址冲突时，计算另一个哈希函数地址，直到冲突不再发生。这种方法不易产生<strong>“聚集”</strong>，但是增加了计算的时间。</p></li><li><p>链地址法</p><p> ​    将所有关键字为同义词的记录存储在同一线性链表中。假设某哈希函数产生的哈希地址在区间 $\displaystyle \left [ 0,m-1 \right ] $ 上，则设立一个指针型向量：</p><script type="math/tex; mode=display"> \displaystyle \mathrm{Chain}\quad \mathrm{ChainHash}\left ( m \right )</script><p> ​    其每个分量的初始状态都是空指针。凡哈希地址为 $i$ 的记录都插入到头指针为 $\mathrm{ChainHash}\left ( m \right )   $ 的链表中。在链表中的插入位置可以在表头或者表尾；也可以在中间，以保持同义词在同一线性表中，按关键字有序。</p></li><li><p>建立一个公共溢出区</p><p> ​    假设哈希函数的值域为 $\displaystyle \left [ 0,m-1 \right ] $ ，则向量 $\displaystyle \mathrm{HashTable} \left [ 0..m-1 \right ] $ 为基本表，每个分量存放一个记录，另设立向量 $\displaystyle \mathrm{OverTable} \left [ 0..v \right ] $ 为溢出表。所有关键字和基本表中的关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</p></li></ol><h2 id="3-4-哈希表的查找及其分析"><a href="#3-4-哈希表的查找及其分析" class="headerlink" title="3.4 哈希表的查找及其分析"></a>3.4 哈希表的查找及其分析</h2><p>哈希表的查找算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">Status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ERROR,</span><br><span class="line">    OK</span><br><span class="line">&#125; Status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUPLICATE -1</span></span><br><span class="line"><span class="type">int</span> hashsize[] = &#123;<span class="number">997</span>&#125;; <span class="comment">// 哈希表容量递增表，一个合适的素数序列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125; ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *elem; <span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数据元素个数</span></span><br><span class="line">    <span class="type">int</span> sizeindex;  <span class="comment">// 动态分配数组容量，以hashsize[sizeindex]为当前容量</span></span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, ElemType K, <span class="type">int</span> &amp;p, <span class="type">int</span> &amp;c)</span></span><br><span class="line">&#123;</span><br><span class="line">    p = Hash(K);                                   <span class="comment">// 求得哈希地址</span></span><br><span class="line">    <span class="keyword">while</span> (H.elem[p] != <span class="literal">NULL</span> &amp;&amp; !EQ(K, H.elem[p])) <span class="comment">// 该位置中已有元素且不相等</span></span><br><span class="line">    &#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; hashsize[H.sizeindex] / <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = (p + <span class="number">1</span>) % hashsize[H.sizeindex]; <span class="comment">// 求得下一个哈希地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = (p + <span class="number">1</span>) % hashsize[++H.sizeindex]; <span class="comment">// 求得下一个哈希地址</span></span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (EQ(K, H.elem[p])) <span class="comment">// 查找成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(ElemType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 由于不同的哈希函数构造方法不同，这里不做具体的实现 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表的插入算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InsertHash</span><span class="params">(HashTable &amp;H, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>, p;</span><br><span class="line">    <span class="keyword">if</span> (SearchHash(H, e, p, c) == SUCCESS) <span class="comment">// 表中已有与e有相同关键字的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> DUPLICATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; hashsize[H.sizeindex] / <span class="number">2</span>) <span class="comment">// 插入e</span></span><br><span class="line">    &#123;</span><br><span class="line">        H.elem[p] = e;</span><br><span class="line">        H.count++;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 重建哈希表</span></span><br><span class="line">    &#123;</span><br><span class="line">        ReCreateHashTable(H);</span><br><span class="line">        <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从哈希表的查找过程可得：</p><ol><li>虽然哈希表在关键字与记录的存储位置之间建立了直接映像，但<strong>由于“冲突”的产生，使得哈希表的查找过程仍然是一个给定值和关键字进行比较的过程</strong>。因此，仍需以平均查找长度作为衡量哈希表的查找效率的量度。</li><li>查找过程中需和给定值进行比较的关键字的个数取决于下列三个因素：哈希函数、处理冲突的方法和哈希表的装填因子。</li></ol><p>哈希函数的“好坏”首先影响出现冲突的频繁程度。但是，对于“均匀的”哈希函数可以假定：不同的哈希函数对同一组随机的关键字，产生冲突的可能性相同，因为一般情况下设定的哈希函数是均匀的，则可不考虑它对平均查找长度的影响。对同样一组关键字，设定相同的哈希函数，则不同的处理冲突的方法得到的哈希表不同，它们的平均查找长度也不同。</p><p>对同样的一组关键字，设定相同的哈希函数，则不同的处理冲突的方法得到的哈希表不同，它们的平均查找长度不同。<strong>在一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子</strong>。</p><p><strong>哈希表的装填因子</strong>定义为：</p><h1 id="四、查找算法的分析总结"><a href="#四、查找算法的分析总结" class="headerlink" title="四、查找算法的分析总结"></a>四、查找算法的分析总结</h1>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 图(Graph)【数据结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07.%E5%9B%BE(Graph).html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07.%E5%9B%BE(Graph).html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>快速导航：</p><ul><li><a href="./01.绪论">第一章 绪论【数据结构】</a></li><li><a href="./02.线性表">第二章 线性表【数据结构】</a></li><li><a href="./03.栈和队列">第三章 栈和队列【数据结构】</a></li><li><a href="./04.串">第四章 串【数据结构】</a></li><li><a href="./05.数组和广义表">第五章 数组和广义表【数据结构】</a></li><li><a href="./06.数和二叉树">第六章 数和二叉树【数据结构】</a></li><li><a href="./07.图Graph">第七章 图(Graph)【数据结构】</a></li><li><a href="./09.查找">第九章 查找【数据结构】</a></li></ul></blockquote><p><strong>图(Graph)</strong>是一种较线性表和树更为复杂的数据结构。</p><ul><li>在<strong>线性表</strong>中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；</li><li>在<strong>树形结构</strong>中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关；</li><li>而在<strong>图形结构</strong>中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</li></ul><h1 id="一、图的定义和术语"><a href="#一、图的定义和术语" class="headerlink" title="一、图的定义和术语"></a>一、图的定义和术语</h1><p>在图中的数据元素通常称做<strong>顶点(Vertex)</strong>， $V$ 是顶点的有穷非空集合； $\displaystyle VR$ 是两个顶点之间的关系的集合。</p><p>基本术语：</p><ul><li><strong>顶点(Vertex)</strong>：图中的数据元素；</li><li><strong>弧（Arc）</strong>：两个顶点之间链接的 $\displaystyle \left \langle v,w \right \rangle $ ；并且 $\displaystyle v$ 称为<strong>弧尾（Tail）</strong>， $\displaystyle w$ 称为<strong>弧头（Head）</strong>；</li><li><strong>有向图</strong>：有弧头和弧尾的图，即弧带有方向；</li><li><strong>无向图</strong>：没有弧头和弧尾的图，此时用<strong>边（Edge）</strong>来替代<strong>弧</strong>，即弧不带方向；</li><li><strong>完全图</strong>：有 $\displaystyle \frac{1}{2} n(n-1)$ 条边的无向图，即：任意两个顶点都有边的无向图；</li><li><strong>有向完全图</strong>：有 $\displaystyle n(n-1)$ 条边的有向图，即：任意两个顶点都有两条正反方向的弧的有向图；</li><li><strong>稀疏图</strong>：有很少条边或者弧的图；$\displaystyle e&lt; n\log_{}{n} $ ；</li><li><strong>稠密图</strong>：不是稀疏图的剩余图；（<strong>显然，完全图和有向完全图都是稠密图</strong>）</li><li><strong>权(Weight)</strong>：图的边或者弧带有一个相关数，这个数称为<strong>权</strong>；</li><li><strong>网</strong>：带权的图，称为<strong>网</strong>；</li><li><strong>邻接点</strong>：两个顶点之间有边或者弧，那么这两个顶点之间互为<strong>邻接点</strong>，并且称“边”<strong>依附</strong>与顶点，或者说“边”和顶点<strong>相关联</strong>；</li><li><strong>度(degree)</strong>：和顶点相关联的边的数目；以该顶点为头的弧的数目称为<strong>入度</strong>；以该顶点为尾的弧的数目称为<strong>出度</strong>；</li><li><strong>路径</strong>：从一个顶点到另一个顶点，所走的顶点序列；</li><li><strong>路径长度</strong>：路径上所有的边的数目</li><li><strong>回路或者环</strong>：第一个顶点和最后一个顶点相同的路径；</li><li><strong>简单路径</strong>：序列中顶点不重复出现的路径；</li><li><strong>连通</strong>：无向图中，如果从一个顶点到另一个顶点有路径，那么称该两个顶点是<strong>连通的</strong>；</li><li><strong>连通图</strong>：无向图中，任意两个顶点都是连通的图；</li><li><strong>连通分量</strong>：无向图中，极大连通子图；</li><li><strong>强连通图</strong>：有向图中，任意两个顶点之间都能相互连通的图；</li><li><strong>强连通分量</strong>：有向图中，加大强连通子图；</li><li><strong>生成树</strong>：一个连通图的<strong>生成树</strong>是一个<strong>极小连通子图</strong>（用尽可能少的边，构成连通图），它含有图中的全部顶点，但只有足以构成一棵树的 $\displaystyle n-1$ 条边，即：去掉任意一条边，都会成为非连通图；</li></ul><h1 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h1><h2 id="2-1-数组表示法"><a href="#2-1-数组表示法" class="headerlink" title="2.1 数组表示法"></a>2.1 数组表示法</h2><p><strong>用两个数组分别存储数据元素的信息和数据元素之间的关系的信息</strong>。其数据结构模型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY __INT_MAX__ <span class="comment">// 无穷大</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20    <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DG, DN, UDG, UDN</span><br><span class="line">&#125; GraphKind; <span class="comment">// &#123;有向图，有向网，无向图，无向网&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adj; <span class="comment">// 顶点关系类型。对无权图，用1或0表示相邻否；对带权图，则为权值类型</span></span><br><span class="line">    <span class="comment">// InfoType *info; // 该弧相关信息的指针</span></span><br><span class="line">&#125; ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> vexs[MAX_VERTEX_NUM]; <span class="comment">// 顶点向量</span></span><br><span class="line">    AdjMatrix arcs;            <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;        <span class="comment">// 图的当前顶点数和弧数</span></span><br><span class="line">    GraphKind kind;            <span class="comment">// 图的种类标志</span></span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure><p>上面的代码中， <code>AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM]</code> 表示的是<strong>邻接矩阵</strong>。以二维数组表示有 $n$ 个顶点的图时，需存放 $n$ 个顶点信息和 $\displaystyle 2^{n} $ 个弧信息的存储量。若考虑无向图的邻接矩阵的对称性，则可采用压缩存储的方式，只存入矩阵的下三角（或上三角）元素。</p><blockquote><p>显然，邻接矩阵的主对角线上的元素<strong>恒为 0</strong> 。</p></blockquote><p>借助于邻接矩阵容易判定任意两个顶点之间是否有边（或弧）相连，并容易求得各个顶点的度。</p><p>对于无向图，顶点 $\displaystyle v_{i} $ 的度是邻接矩阵中第 $\displaystyle i$ 行（或第列）的元素之和，即：</p><script type="math/tex; mode=display">\displaystyle \mathrm{TD}(v_{i} ) = \sum_{j=0}^{n-1} A[i][j]\quad (n=\text{INT-MAX} )</script><p>对于有向图来说，第 $\displaystyle i$ 行元素之和为顶点 $\displaystyle v_{i} $ 的出度 $\displaystyle \mathrm{OD} $ ，第 $\displaystyle i$ 列元素之和为顶点 $\displaystyle v_{i} $ 的出度 $\displaystyle \mathrm{ID} $ 。</p><p><strong>网的邻接矩阵</strong>可定义为：</p><script type="math/tex; mode=display">\displaystyle A[i][j]=\left\{\begin{matrix} w_{ij}  & if\left \langle v_{i},v_{j} \right \rangle \\ \infty  & else\end{matrix}\right.</script><p><strong>构造一个具有 $\displaystyle n$ 个顶点和 $\displaystyle e$ 条边的无向网 $\displaystyle G$ 的时间复杂度是 $\displaystyle O(n^{2} +e\times n)$</strong>，其中，对邻接矩阵的初始化耗费了 $\displaystyle O(n^{2})$ 的时间。</p><p>其数据结构模型算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GreatGraph</span><span class="params">(MGraph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G.kind); <span class="comment">// 输入图的种类</span></span><br><span class="line">    <span class="keyword">switch</span> (G.kind)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DG:</span><br><span class="line">        <span class="keyword">return</span> CreateDG(G);</span><br><span class="line">    <span class="keyword">case</span> DN:</span><br><span class="line">        <span class="keyword">return</span> CreateDN(G);</span><br><span class="line">    <span class="keyword">case</span> UDG:</span><br><span class="line">        <span class="keyword">return</span> CreateUDG(G);</span><br><span class="line">    <span class="keyword">case</span> UDN:</span><br><span class="line">        <span class="keyword">return</span> CreateUDN(G);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">CreatDG</span><span class="params">(MGraph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, G.vexnum, G.arcnum); <span class="comment">// 输入顶点数和弧数</span></span><br><span class="line">    <span class="comment">// 顶点向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]); <span class="comment">// 输入顶点向量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G.arcs[i][j].adj = <span class="number">0</span>; <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.arcnum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, i, j); <span class="comment">// 输入一条弧依附的顶点</span></span><br><span class="line">        G.arcs[i][j].adj = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">CreatDN</span><span class="params">(MGraph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, G.vexnum, G.arcnum); <span class="comment">// 输入顶点数和弧数</span></span><br><span class="line">    <span class="comment">// 顶点向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]); <span class="comment">// 输入顶点向量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G.arcs[i][j].adj = INFINITY; <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.arcnum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i, j, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, i, j, w); <span class="comment">// 输入一条弧依附的顶点和权值</span></span><br><span class="line">        G.arcs[i][j].adj = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">CreatUDG</span><span class="params">(MGraph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, G.vexnum, G.arcnum); <span class="comment">// 输入顶点数和弧数</span></span><br><span class="line">    <span class="comment">// 顶点向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]); <span class="comment">// 输入顶点向量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G.arcs[i][j].adj = <span class="number">0</span>; <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.arcnum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, i, j); <span class="comment">// 输入一条弧依附的顶点</span></span><br><span class="line">        G.arcs[i][j].adj = <span class="number">1</span>;</span><br><span class="line">        G.arcs[j][i].adj = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">CreatUDN</span><span class="params">(MGraph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, G.vexnum, G.arcnum); <span class="comment">// 输入顶点数和弧数</span></span><br><span class="line">    <span class="comment">// 顶点向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]); <span class="comment">// 输入顶点向量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G.arcs[i][j].adj = INFINITY; <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.arcnum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i, j, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, i, j, w); <span class="comment">// 输入一条弧依附的顶点和权值</span></span><br><span class="line">        G.arcs[i][j].adj = w;</span><br><span class="line">        G.arcs[j][i].adj = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-邻接表（和逆邻接表）"><a href="#2-2-邻接表（和逆邻接表）" class="headerlink" title="2.2 邻接表（和逆邻接表）"></a>2.2 邻接表（和逆邻接表）</h2><p><strong>邻接表</strong>是图的一种链式存储结构。在邻接表中，对图中的每个顶点建立一个单链表，以顶点为头结点，依次链接该顶点的弧的表结点。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/邻接表的头结点和表结点.svg" alt="邻接表的头结点和表结点" style="zoom: 100%"></p><p><strong>邻接表的数据结构模型</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------- 图的邻接表存储 ---------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> /* 顶点的单链表种，弧结点的结构体 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;           <span class="comment">// 该弧指向的顶点位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向的下一条弧的指针</span></span><br><span class="line">    InfoType *info;       <span class="comment">// 该弧相关信息的指针</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> /* 表示顶点的结构体 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;          <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *firstArc; <span class="comment">// 指向第一条依附该结点的弧的指针</span></span><br><span class="line">&#125; AdjList, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span> /* 表示图的结构体 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertices;   <span class="comment">// 图的顶点列表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">// 图的顶点数和弧数</span></span><br><span class="line">    <span class="type">int</span> kind;           <span class="comment">// 图的种类标志</span></span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure><p>对于无向图来说，如果有 $\displaystyle n$ 个顶点、 $\displaystyle e$ 条边，则它的邻接表需要 $\displaystyle n$ 个顶点结点（头结点）和 $\displaystyle 2e$ 个弧结点（表结点）。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/邻接表和逆邻接表.png" alt="邻接表和逆邻接表" style="zoom: 100%"></p><ul><li>在无向图的邻接表中，求顶点 $\displaystyle v_{i} $ 的<strong>度</strong>，只需要计算第 $\displaystyle i$ 个链表中的结点数。</li><li>在有向图中，求顶点 $\displaystyle v_{i} $ 的<strong>出度</strong>，和无向图求顶的的度一样，只需要计算第 $\displaystyle i$ 个链表中的结点数；但是求顶点 $\displaystyle v_{i} $ 的<strong>入度</strong>时，必须遍历整个邻接表。</li></ul><p>为了便于确定<strong>顶点的入度</strong>或者<strong>以某顶点为头的弧</strong>，建立以和有向图的<strong>逆邻接表</strong>，即：对每个顶点 $\displaystyle v_{i} $ 建立一个链接以 $\displaystyle v_{i} $ 为头的弧结点的表。</p><blockquote><p>在建立邻接表或者逆邻接表时，如果输入的顶点信息，就是顶点的编号，则建立邻接表的时间复杂度为 $\displaystyle O(n+e)$ ；否则，需要通过遍历查询，才能得到顶点在图中的位置，则时间复杂度为 $\displaystyle O(n\times e)$ 。</p></blockquote><h2 id="2-3-十字链表"><a href="#2-3-十字链表" class="headerlink" title="2.3 十字链表"></a>2.3 十字链表</h2><p><strong>十字链表（Orthogonal List）</strong>是有向图的另一种链式存储结构。_可以看成是将有向图的邻接表和逆邻接表组合起来得到的一种链表_。</p><p>在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/图的存储之十字链表.svg" alt="图的存储之十字链表.svg" style="zoom: 100%"></p><p><strong>十字链表的数据结构模型</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------- 十字链表 ---------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">InfoType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125; InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125; VertexType;</span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> /* 顶点的单链表种，弧结点的结构体 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tailvex, headvex; <span class="comment">// 该弧的尾和头顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> *<span class="title">hlink</span>, *<span class="title">tlink</span>;</span></span><br><span class="line">    InfoType *info; <span class="comment">// 该弧相关信息的指针</span></span><br><span class="line">&#125; ArcBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcBox *firstin, *firstout; <span class="comment">// 分别指向该顶点的第一条入弧和出弧</span></span><br><span class="line">&#125; VexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexNode xLinst[MAX_VERTEX_NUM]; <span class="comment">// 顶点列表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;             <span class="comment">// 有向图的定点数和弧数</span></span><br><span class="line">&#125; OLGraph;</span><br></pre></td></tr></table></figure><p>有向图的十字链表的图示如下：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/有向图的十字链表.png" alt="有向图的十字链表" style="zoom: 100%"></p><h2 id="2-4-邻接多重表"><a href="#2-4-邻接多重表" class="headerlink" title="2.4 邻接多重表"></a>2.4 邻接多重表</h2><p><strong>邻接多重表</strong>是无向图的另一种链式存储结构。</p><p>_虽然邻接表是无向图的一种很有效的存储额机构，在邻接表中容易求得顶点和边的各种信息。但是，在邻接表中每一条边，都存在两个结点，这给某些图的操作带来不便_。</p><p>邻接多重表的结构和十字链表类似。在邻接多重链表中，每一条边用一个结点表示，有 6 部分组成：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/邻接多重表.svg" alt="邻接多重表.svg" style="zoom: 100%"></p><p><strong>邻接多重表的数据结构模型</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------- 邻接多重表 -------------- */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">InfoType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125; InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125; VertexType;</span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    unisited = <span class="number">0</span>,</span><br><span class="line">    visited = <span class="number">1</span></span><br><span class="line">&#125; VisitIf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcEBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VisitIf mark;</span><br><span class="line">    <span class="type">int</span> ivex, jvex;                <span class="comment">// 该边依附的两个顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcEBox</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span> <span class="comment">// 分别指向依附这两个顶点的下一条边</span></span><br><span class="line">    InfoType *info;                <span class="comment">// 该边信息</span></span><br><span class="line">&#125; ArcEBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcEBox *firstedge; <span class="comment">// 指向第一条依附该顶点的边</span></span><br><span class="line">&#125; VexBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexBox adjmulist[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">// 图的当前顶点数和边数</span></span><br><span class="line">&#125; AMLGraph;</span><br></pre></td></tr></table></figure><p>得到的结构的图示如下：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/无向图的邻接多重表.png" alt="无向图的邻接多重表" style="zoom: 100%"></p><h1 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h1><p>从图中某一顶点出发，访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做<strong>图的遍历(Traversing Graph)</strong>。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。</p><h2 id="3-1-深度优先"><a href="#3-1-深度优先" class="headerlink" title="3.1 深度优先"></a>3.1 深度优先</h2><p><strong>深度优先搜索(DFS)</strong>遍历类似于树的先根遍历，是树的先根遍历的推广。</p><p><strong>DFS的搜索过程</strong>：假设初始状态下，图的全部顶点都未曾访问过，然后随机挑选一个顶点，开始进行遍历访问；然后访问此顶点的某一个邻接顶点；然后在访问该邻接顶点的某一个邻接顶点，依次进行；<strong>直至，最后访问的顶点已经没有邻接顶点或者没有未访问的邻接顶点</strong>；然后，退回该路径中的上一个结点，<strong>访问上一个结点的下一个未访问邻接点</strong>，依次进行；直至，整个连通图访问完毕。如果有非连通图，接着选取非连通图的另一个子图的某一个顶点，继续按照上述过程进行。</p><blockquote><p>最直观的例子就是“走迷宫”。假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p></blockquote><p>显然，这是一个递归的过程。为了在遍历过程中，便于区分顶点是否已被访问，需要附设访问标志数组 <code>visited[0..n-1]</code> ，其初始值为 <code>&quot;false&quot;</code> ，一旦某个顶点被访问，择其相应的分量置为 <code>&quot;true&quot;</code> 。</p><p>深度优先搜索遍历的算法如下：（主要是针对非连通图）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">Status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ERROR = <span class="number">0</span>,</span><br><span class="line">    OK = <span class="number">1</span></span><br><span class="line">&#125; Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">Boolean</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="literal">false</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="literal">true</span> = <span class="number">1</span></span><br><span class="line">&#125; Boolean;</span><br><span class="line"></span><br><span class="line">Boolean visited[MAX];       <span class="comment">// 访问标志数组</span></span><br><span class="line">Status (*VisitFunc)(<span class="type">int</span> v); <span class="comment">// 函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 邻接矩阵--访问顶点操作</span></span><br><span class="line">Status <span class="title function_">VisitFunc</span><span class="params">(<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 函数指针，对图的顶点访问操作 */</span></span><br><span class="line">    <span class="comment">// 具体实现由用户定义，图的遍历操作调用该函数来访问顶点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 邻接矩阵--获取结点 v 的第一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstNeighbor</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 获取结点 v 的第一个邻接点 */</span></span><br><span class="line">    <span class="comment">// 由于图的存储结构不同，该算法不同，依次不做具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 邻接矩阵--获取结点 v 的第 w 个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextNeighbor</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 获取结点 v 的第 w 个邻接点的下一个邻接点 */</span></span><br><span class="line">    <span class="comment">// 由于图的存储结构不同，该算法不同，依次不做具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 邻接矩阵--深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTranverse</span><span class="params">(Graph G, Status (*Visit)(<span class="type">int</span> v))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 对图 G 进行深度优先遍历 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>; <span class="comment">// 访问标志数组初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    VisitFunc = Visit; <span class="comment">// 使用全局变量VisitFunc，使DFS不必设函数指针参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 递归算法--深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>; <span class="comment">// 访问标志数组置1</span></span><br><span class="line">    VisitFunc(v);      <span class="comment">// 访问第v个顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, v, w))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[w] = <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用二维数组表示邻接矩阵，作为图的存储结构时，查找每个顶点的邻接点所需要的时间为 $\displaystyle O(n^{2} )$ ，其中 $\displaystyle n$ 为途中顶点数。</p><p>以邻接表作为图的存储结构时，找邻接点所需要的时间为 $\displaystyle O(e)$ ，其中， $\displaystyle e$ 为无向图中边的数量或者有向图中弧的数量，并且时间复杂度为 $\displaystyle O(n+e)$ 。</p><h2 id="3-2-广度优先"><a href="#3-2-广度优先" class="headerlink" title="3.2 广度优先"></a>3.2 广度优先</h2><p><strong>广度优先搜索(BFS)</strong>遍历类似于树的按层次遍历。</p><p><strong>DFS的搜索过程</strong>：假设初始状态下，图的全部顶点都未曾访问过，然后随机挑选一个顶点，开始进行遍历访问；然后依次访问该顶点的<strong>未访问邻接点</strong>；然后，再对刚刚访问的邻接点，因此进行 $\displaystyle \mathrm{BFS} $ 访问；直至整个图全部访问完毕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFSTranverse</span><span class="params">(Graph G, Status (*Visit)(<span class="type">int</span> v))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 对图 G 进行广度优先遍历 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[v] = Boolean.<span class="literal">false</span>; <span class="comment">// 访问标志数组初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(Q); <span class="comment">// 初始化辅助队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[v] == Boolean.<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            visited[v] = Boolean.<span class="literal">true</span>;</span><br><span class="line">            Visit(v);</span><br><span class="line">            EnQueue(Q, v); <span class="comment">// v 入队列</span></span><br><span class="line">            <span class="keyword">while</span> (!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(Q, v); <span class="comment">// 队头元素出队并置为 v</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, v, w))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[w] == Boolean.<span class="literal">false</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[w] = Boolean.<span class="literal">true</span>;</span><br><span class="line">                        Visit(w);</span><br><span class="line">                        EnQueue(Q, w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、图的连通性"><a href="#四、图的连通性" class="headerlink" title="四、图的连通性"></a>四、图的连通性</h1><h2 id="4-1-无向图的连通分量和生成树"><a href="#4-1-无向图的连通分量和生成树" class="headerlink" title="4.1 无向图的连通分量和生成树"></a>4.1 无向图的连通分量和生成树</h2><ul><li>对于连通图的遍历，只需要从图中任一顶点出发；</li><li>对于非连通图的遍历，需要从图中的多个顶点出发；<strong>一次遍历访问得到的顶点集合，恰好是图的连通分量</strong>。</li></ul><p>对于一个连通图来书，对它进行一次<strong>深度优先</strong>或者<strong>广度优先</strong>的遍历后，其访问的路径会形成一个<strong>生成树</strong>。并且称由深度优先搜索得到的为深度优先生成树；由广度优先搜索得到的为广度优先生成树。</p><p>对于非连通图，每个连通分量会形成一个<strong>生成树</strong>，并且这些<strong>生成树</strong>会构成一个<strong>森林</strong>。</p><h2 id="4-2-有向图的强连通分量"><a href="#4-2-有向图的强连通分量" class="headerlink" title="4.2 有向图的强连通分量"></a>4.2 有向图的强连通分量</h2><p>【略】</p><h2 id="4-3-最小生成树"><a href="#4-3-最小生成树" class="headerlink" title="4.3 最小生成树"></a>4.3 最小生成树</h2><p>问题：假设要在 $n$ 个城市之间建立通信网络，则连通 $n$ 个城市只需要 $n-1$ 条线路。这时，如何在最省经费的前提下建立这个通信网？</p><p>有 $n$ 个结点，这些结点之间任意连接构成<strong>连通网</strong>。而对于 $n$ 个结点的连通网，可以建立许多不同的生成树，每一棵生成树都可以是一个<strong>连通网</strong>。在这些连通网中，选出权值之和最小的。这个问题就是构造连通网的最小代价生成树（<code>Minimum Cost Spanning Tree</code>），简称<strong>最小生成树</strong>。<strong>一棵生成树的代价就是树上各边的代价之和</strong>。</p><p><strong>普利姆算法（Prim）</strong>：假设 $\displaystyle N=(V,\left \{ E \right \} )$ 是连通网， $\displaystyle \mathrm{TE} $ 是 $\displaystyle \mathrm{N} $ 上最小生成树中边的集合。设定顶点集合 $\displaystyle \mathrm{U} $ 。</p><ol><li>在连通网中，首先找到<strong>权</strong>最小的边，并且将该边的两个顶点加入到 $\displaystyle \mathrm{U} $ 中去，并且将该边添加到 $\displaystyle \mathrm{TE} $ 中去；</li><li>然后，在<strong>依附于 $\displaystyle \mathrm{U} $ 中的顶点的边中，找到最短且不在 $\displaystyle \mathrm{TE} $ 中的一条边</strong>，之后将新的顶点加入到 $\displaystyle \mathrm{U} $ 中去，将新的边加入到 $\displaystyle \mathrm{TE} $ 中去；（简单来讲，找到的边，一端是 $\displaystyle \mathrm{U} $ 集合中的顶点，一端不是 $\displaystyle \mathrm{U} $ 集合中的顶点；不能是两端都是 $\displaystyle \mathrm{U} $ 集合中的顶点；也不能是两端都不是 $\displaystyle \mathrm{U} $ 集合中的顶点）</li><li>重复步骤（2），直至将全部的顶点都加入到 $\displaystyle \mathrm{U} $ 中；</li><li>此时的 $\displaystyle T=(U,TE)$ 就是一个<strong>最小生成树</strong>。</li></ol><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/Prim最小生成树.png" alt="Prim最小生成树" style="zoom: 100%"></p><blockquote><p><code>Prim</code> 算法的<strong>时间复杂度为 $\displaystyle O(n^{2} )$</strong>，与网中的边数无关，因此，<strong>适用于求稠密的网的最小生成树</strong>。</p></blockquote><p><strong>克鲁斯卡尔算法（Kruskal）</strong>：假设 $\displaystyle N=(V,\left \{ E \right \} )$ 是连通网，则令最小生成树的初始状态为：只有 $n$ 个顶点，没有边的非连通图 $\displaystyle T=(V,\left \{ \quad  \right \} )$ ，图中每个顶点自成一个连通分量。</p><ol><li>选择代价最小的一条边；<ol><li>如果该边依附的顶点，落在 $\displaystyle T$ 中不同的连通分量上，则将次边加入到 $\displaystyle T$ 中；</li><li>反之，则舍弃，并且寻找下一条代价最小的边；</li><li>（这样的选边方式，简单来讲，在同一个连通分量上的顶点之间的边，就舍弃）</li></ol></li><li>以此类推，直至 $\displaystyle T$ 上所有的顶点都在同一连通分量上。</li></ol><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/Kruskal最小生成树过程示例图.png" alt="Kruskal最小生成树过程示例图" style="zoom: 100%"></p><h3 id="7-4-4-关节点和重连通分量"><a href="#7-4-4-关节点和重连通分量" class="headerlink" title="7.4.4 关节点和重连通分量"></a>7.4.4 关节点和重连通分量</h3><p>【略】</p><h1 id="五、有向无环图及其应用"><a href="#五、有向无环图及其应用" class="headerlink" title="五、有向无环图及其应用"></a>五、有向无环图及其应用</h1><h2 id="5-1-拓扑排序"><a href="#5-1-拓扑排序" class="headerlink" title="5.1 拓扑排序"></a>5.1 拓扑排序</h2><p>什么是<strong>拓扑排序</strong>？简单地说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><p>回顾离散数学中关于偏序和全序的定义：</p><ul><li>若集合 $\displaystyle X$ 上的关系 $\displaystyle R$ 是<strong>自反的</strong>、<strong>反对称的</strong>和<strong>传递的</strong>，则称 $\displaystyle R$ 是集合 $\displaystyle X$ 上的<strong>偏序关系</strong>。</li><li>设 $\displaystyle R$ 是集合 $\displaystyle X$ 上的偏序，如果对每个 $\displaystyle x,y\in X$ 必有 $\displaystyle xRy$ 或 $\displaystyle yRx$ ，则称 $\displaystyle R$ 是集合 � 上的<strong>全序关系</strong>。</li><li>直观地看，偏序指集合中仅有部分成员之间可比较，而全序指集合中全体成员之间均可比较。</li></ul><p>例如，下图所示的两个有向图，图中弧 $\displaystyle \left \langle x,y \right \rangle $ 表示 $\displaystyle x\le y$ ，则 <code>(a)</code>表示偏序， <code>(b)</code> 表示全序。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/表示偏序和全序的有向图.png" alt="表示偏序和全序的有向图" style="zoom: 100%"></p><p>若在<code>(a)</code>的有向图上人为地加一个表示 $\displaystyle v_{2} \le v_{3} $ 的弧，则 <code>(a)</code>表示的亦为全序，且这个全序称为<strong>拓扑有序(Topological Order)</strong>，而<strong>由偏序定义得到拓扑有序的操作便是拓扑排序</strong>。</p><p><strong>AOV-网</strong>：用顶点表示活动，用弧表示活动之间优先关系的有向图，称为<strong>顶点表示活动网（Activity On Vertex Network）</strong>，简称<strong>AOV-网</strong>。</p><blockquote><p>在<strong>AOV-网</strong>中不应该出现有向环，因为存在环意味着某项活动应该以自己为先决条件。</p></blockquote><p>进行拓扑排序的方法：</p><ol><li>在有向图中选一个没有前驱的顶点，并且输出该顶点；</li><li>从图中删除该顶点和所有以他为尾的弧；</li><li>重复上述两步，直至全部顶点均已输出。<strong>如果当前不存在无前驱的顶点，但是还有顶点给剩余时，说明图中有环</strong>。</li></ol><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/AOV-网及其拓扑有序序列产生的过程.png" alt="AOV-网及其拓扑有序序列产生的过程" style="zoom: 100%"></p><p>针对上述两步操作，采用<a href="https://blog.yuilexi.cn/2023/04/29/大学学习/数据结构/数据结构_2/#邻接表">邻接表</a>作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组(indegree)。入度为零的顶点，即为没有前驱的顶点，删除顶点及以它为尾的弧的操作，则可换以弧头顶点的入度减 1 来实现。</p><p>为了避免重复检测入度为零的顶点，可另设一栈暂存所有入度为零的顶点，由此，可得拓扑排序的算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">TopologicSort</span><span class="params">(ALGraph G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, k, count;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>; <span class="comment">// 用于栈指针下标</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">stack</span>;  <span class="comment">// 建栈存储入度为0的顶点</span></span><br><span class="line">    <span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(G.vexnum * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.vertices[i].in == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = i; <span class="comment">// 将入度为0的顶点入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>; <span class="comment">// 对输出顶点计数</span></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="built_in">stack</span>[top--]; <span class="comment">// 出栈</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);  <span class="comment">// 输出</span></span><br><span class="line">        count++;          <span class="comment">// 对输出顶点计数</span></span><br><span class="line">        <span class="keyword">for</span> (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            k = p-&gt;adjvex; <span class="comment">// 对i号顶点的每个邻接点的入度减1</span></span><br><span class="line">            <span class="keyword">if</span> (!(--G.vertices[k].in))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>[++top] = k; <span class="comment">// 若入度减为0，则入栈，以便于下次循环输出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR; <span class="comment">// 该有向图有回路</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析算法：对有 $n$ 个顶点和 $e$ 条弧的有向图而言，建立求各顶点的入度的时间复杂度为 $\displaystyle O(e)$；建立零入度顶点栈的时间复杂度为 $\displaystyle O(n)$；在拓扑排序过中，若有向图无环，则每个顶点进一次栈，出一次栈，度减 1的操作在 <code>While</code> 语中总共执行 $e$ 次，所以，总的时间复杂度为 $\displaystyle O(n+e)$。</p><h2 id="5-2-关键路径"><a href="#5-2-关键路径" class="headerlink" title="5.2 关键路径"></a>5.2 关键路径</h2><p>与<code>AOV-网</code> 相对应是<code>AOE-网</code>(Activity On Edge)，即<strong>边表示活动的网</strong>。<strong>AOE-网</strong>是一个带权的有向无环图，其中，顶点表示事件(Event)，弧表示活动,权表示活动持续的时间。通常，<strong>AOE-网可用来估算工程的完成时间</strong>。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/7_图(Graph).md/一个简单的AOE-网.png" alt="一个简单的AOE-网" style="zoom: 100%"></p><p>上述的 <code>AOE-网</code> ，有 9 个事件、 11 个活动，并且从 �1 事件开始，期间经历相关的活动，并且最终到 �9 结束。</p><p>由于整个工程只有一个开始点和一个完成点，故在正常的情况（无环）下，网中只有一个入度为零的点（称做源点），和一个出度为零的点（叫做汇点）。</p><p>和AOV-网不同，对AOE-网有待研究的问题是：</p><ol><li>完成整项工程至少需要多少时间？</li><li>哪些活动是影响工程进度的关键？</li></ol><p>由于在 <code>AOE-网</code> 中，有些活动可以<strong>并行地进行</strong>，所以完成工程的最短时间是从开始点到完成点的最长路径的长度（这里所说的路径长度，是指路径上各活动持续时间之和，不是路径上孤的数目）。<strong>路径长度最长的路径叫做 <code>关键路径</code> (Critical Path)</strong>。</p><p>假设开始点是 $\displaystyle V_{1} $ ，从 $\displaystyle V_{1} $ 到 $\displaystyle V_{i} $ 的最长路径长度叫做事件 $\displaystyle V_{i} $ 的最早发生时间；这个时间决定了所有以 $\displaystyle V_{i} $ 为弧尾的弧，所表示的活动的最早开始时间。</p><p><strong>我们用 $\displaystyle e(i)$ 表示活动 $\displaystyle a_{i}$ 的最早开始时间。还可以定义一个活动的最迟开始时间 $\displaystyle l(i)$ ，这是在不推迟整个工程完成的前提下，活动 $\displaystyle a_{i}$ 最迟必须开始进行的时间</strong>。两者之差 $\displaystyle l(i)-e(i)$ 意味着完成活动 $\displaystyle a_{i}$ 的时间（<del>余量</del>）裕量。我们把 $\displaystyle l(i)=e(i)$ 的活动叫做<strong>关键活动</strong>。</p><p>显然，关键路径上的所有活动都是关键活动。因此，提前完成非关键活动并不能加快工程的进度。因此，分析关键路径的目的是辨别哪些是关键活动，以便争取提高关活动的工作效率，缩短整个工期。</p><p>由上面的分析可知，辨别关键活动就是要找到 $\displaystyle l(i)=e(i)$ 的活动。为了求得 <strong>AOE-网</strong>中活动的 $\displaystyle e(i)$ 和 $\displaystyle l(i)$ ，首先应该求得时间 $\displaystyle ve(j)$ 和最早发生时间和最迟发生时间 $\displaystyle vl(j)$ 。如果活动由弧 $$ ，则有如下关系：</p><script type="math/tex; mode=display">\begin{align}\displaystyle e(i) & = ve(j)\\l(i)&=vl(k)-\mathrm{d}ut \end{align}</script><p>由此，得到如下所述，求关键路径的算法：</p><ol><li>输入 $e$ 条弧 $\displaystyle \left \langle j,k \right \rangle $ ，建立 <strong>AOE-网</strong>的存储结构；</li><li>从源点出发，</li><li>从汇点出发，</li></ol><h1 id="六、最短路径"><a href="#六、最短路径" class="headerlink" title="六、最短路径"></a>六、最短路径</h1><h2 id="6-1-从某个源点到其余各顶点的最短路径"><a href="#6-1-从某个源点到其余各顶点的最短路径" class="headerlink" title="6.1 从某个源点到其余各顶点的最短路径"></a>6.1 从某个源点到其余各顶点的最短路径</h2><h2 id="6-2-每一对顶点之间的最短路径"><a href="#6-2-每一对顶点之间的最短路径" class="headerlink" title="6.2 每一对顶点之间的最短路径"></a>6.2 每一对顶点之间的最短路径</h2>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 数和二叉树【数据结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06.%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06.%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>快速导航：</p><ul><li><a href="./01.绪论">第一章 绪论【数据结构】</a></li><li><a href="./02.线性表">第二章 线性表【数据结构】</a></li><li><a href="./03.栈和队列">第三章 栈和队列【数据结构】</a></li><li><a href="./04.串">第四章 串【数据结构】</a></li><li><a href="./05.数组和广义表">第五章 数组和广义表【数据结构】</a></li><li><a href="./06.数和二叉树">第六章 数和二叉树【数据结构】</a></li><li><a href="./07.图Graph">第七章 图(Graph)【数据结构】</a></li><li><a href="./09.查找">第九章 查找【数据结构】</a></li></ul></blockquote><p>树形结构是一类重要的非线性数据结构。其中，以树和二叉树最为常见。</p><h1 id="一、树的定义和基本术语"><a href="#一、树的定义和基本术语" class="headerlink" title="一、树的定义和基本术语"></a>一、树的定义和基本术语</h1><p>基本术语如下：</p><ul><li><strong>结点</strong>：树的结点包含一个数据元素，以及若干指向其子树的分支；</li><li><strong>根</strong>：一个树最顶端的结点；</li><li><strong>结点的度</strong>：结点拥有的子树的个数；</li><li><strong>叶子</strong>或者终端结点：<strong>结点的度</strong>为 0 的结点；</li><li><strong>分支结点</strong>或者非终端结点：<strong>结点的度</strong>不为 0 的结点；</li><li><strong>树的度</strong>：树内所有<strong>结点的度</strong>的最大值；</li><li><strong>孩子</strong>：该结点的<strong>子树的根</strong>；</li><li><strong>双亲</strong>：对于某一结点的孩子来讲，该结点称为双亲；</li><li>兄弟：同一双亲的结点互为兄弟；</li><li>结点的祖先：从根到该结点所经分支上的所有结点；</li><li>子孙：某节点为根的子树中的任一结点，都称为该结点的子孙；</li><li>结点的层次：从根开始定义其，根为第一层，根的孩子为第二层。</li><li><strong>树的深度</strong>：树中结点的最大层次称为<strong>树的深度</strong>；</li><li>无序树和有序树：如果将树中结点的各子树看成从左至右是有次序的，则称该树为<strong>有序树</strong>，否则称为<strong>无序树</strong>。</li><li><strong>森林</strong>： $m$ 棵互不相交的树的集合。</li></ul><h1 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h1><h2 id="2-1-二叉树的定义"><a href="#2-1-二叉树的定义" class="headerlink" title="2.1 二叉树的定义"></a>2.1 二叉树的定义</h2><p><strong>二叉树</strong>是另一种树型结构，它的特点是每个结点最多有两个孩子（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>二叉树有 5 种基本形态：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/二叉树的基本形态.svg" alt="二叉树的基本形态.svg" style="zoom: 40%"></p><h2 id="2-2-二叉树的性质"><a href="#2-2-二叉树的性质" class="headerlink" title="2.2 二叉树的性质"></a>2.2 二叉树的性质</h2><p><strong>性质 1</strong>：在二叉树的第 $i$ 层上，至多有 $\displaystyle 2^{i-1} $ 个结点。</p><p><strong>性质 2</strong>：深度为 $k$ 的二叉树至多有 $\displaystyle 2^{k}-1 $ 个结点。</p><blockquote><p>一颗深度为 $k$ 且有 $\displaystyle 2^{k}-1 $ 个结点的二叉树，称为<strong>满二叉树</strong>。</p></blockquote><p><strong>性质 3</strong>：对于任何一个二叉树 $\displaystyle T$ ，如果其叶子树为 $\displaystyle n_{0} $ ，度为 2 的结点个数为 $\displaystyle n_{2} $ ，则 $\displaystyle n_{0} =n_{2} +1$ 。</p><blockquote><p>深度为 $k$ ，有 $n$ 个结点的二叉树，当且仅当每一个结点都与深度为 $k$ 的满二叉树种编号从 1 至 $n$ 结点一一对应时，称之为<strong>“完全二叉树”</strong>。</p></blockquote><p><strong>性质 4</strong>：具有 $n$ 个结点的完全二叉树的深度为 $\displaystyle \left \lfloor \log_{2}{n}  \right \rfloor +1$ 。</p><p><strong>性质 5</strong>：如果对一棵有 $\displaystyle n$ 个结点的完全二叉树的结点，按层次序编号，有</p><ol><li>如果 $\displaystyle i=1$ ，则结点 $i$ 是二叉树的根，无双亲；如果 $\displaystyle i&gt;1$ ，则双亲是结点 $\displaystyle \left \lfloor \frac{i}{2} \right \rfloor $ 。</li><li>如果 $\displaystyle i&gt;\frac{n}{2} $ ，则结点 $i$ 无左孩子（结点 $i$ 为叶子结点）；否则，其左孩子是结点 $2i$ 。</li><li>如果 $\displaystyle 2i+1&gt;n$ ，则结点 $i$ 无右孩子；否则其右孩子是结点 $\displaystyle 2i+1$ 。</li></ol><h2 id="2-3-二叉树的存储结构"><a href="#2-3-二叉树的存储结构" class="headerlink" title="2.3 二叉树的存储结构"></a>2.3 二叉树的存储结构</h2><h3 id="2-3-1-顺序存储结构"><a href="#2-3-1-顺序存储结构" class="headerlink" title="2.3.1 顺序存储结构"></a>2.3.1 顺序存储结构</h3><p>按照顺序存储结构的定义，约定，用一组联系的存储单元，依次<strong>自上而下、自左而右</strong>存储完全二叉树上的结点元素，即将<strong>完全二叉树</strong>上编号为 $i$ 的结点元素存储在下表为 $i-1$ 的一维数组中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">// 二叉树的最大结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE]; <span class="comment">// 0号单元存储根结点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-链式存储结构"><a href="#2-3-2-链式存储结构" class="headerlink" title="2.3.2 链式存储结构"></a>2.3.2 链式存储结构</h3><p>二叉树的链式存储结构的结点的图示如下：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/二叉树的链式存储.svg" alt="二叉树的链式存储.svg" style="zoom: 30%"></p><p>其数据结构模型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的三叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TripleNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">parent</span>;</span> <span class="comment">// 指向双亲结点</span></span><br><span class="line">&#125; TripleNode, *TripleTree;</span><br></pre></td></tr></table></figure><h1 id="三、遍历二叉树和线索二叉树"><a href="#三、遍历二叉树和线索二叉树" class="headerlink" title="三、遍历二叉树和线索二叉树"></a>三、遍历二叉树和线索二叉树</h1><h2 id="3-1-遍历二叉树"><a href="#3-1-遍历二叉树" class="headerlink" title="3.1 遍历二叉树"></a>3.1 遍历二叉树</h2><p><strong>遍历二叉树</strong>：按照某种搜索路径，依次访问书中的每个结点，使得每个结点均被访问一次，而且仅仅被访问一次。</p><ol><li><p>先序遍历（先根遍历）</p><p> 如果二叉树为空，则空操作</p><ol><li>访问根节点；</li><li>先序遍历左子树；</li><li>先序遍历右子树；</li></ol></li><li><p>中序遍历（中根遍历）</p><p> 如果二叉树为空，则空操作</p><ol><li>中序遍历左子树；</li><li>访问根节点；</li><li>中序遍历右子树；</li></ol></li><li><p>后序遍历（后根遍历）</p><p> 如果二叉树为空，则空操作</p><ol><li>后续遍历左子树；</li><li>后续遍历右子树；</li><li>访问根节点；</li></ol></li><li><p>层次遍历</p><ol><li>从上到下，从左到右，依次遍历</li></ol></li></ol><blockquote><p>访问对应节点的时候，采用递归函数，比较简单。</p></blockquote><p>遍历二叉树的算法如下：</p><ol><li><p>先序遍历；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历二叉树</span></span><br><span class="line">Status <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T, Staus (*Visit)(TElemType e))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Visit(T-&gt;data) == OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (PreOrderTraverse(T-&gt;lchild, Visit) == OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (PreOrderTraverse(T-&gt;rchild, Visit) == OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历二叉树</span></span><br><span class="line">Status <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T, Staus (*Visit)(TElemType e))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (InOrderTraverse(T-&gt;lchild, Visit) == OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Visit(T-&gt;data) == OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (InOrderTraverse(T-&gt;rchild, Visit) == OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历二叉树</span></span><br><span class="line">Status <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T, Staus (*Visit)(TElemType e))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PostOrderTraverse(T-&gt;lchild, Visit) == OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (PostOrderTraverse(T-&gt;rchild, Visit) == OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Visit(T-&gt;data) == OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>显然，遍历啊二叉树的算法种的基本操作是访问结点，则不论按照哪一种次序进行遍历，对含 $n$ 个结点的二叉树，其<strong>时间复杂度均为： $\displaystyle O(n)$</strong> 。</p><p>所需辅助空间为遍历过程中栈的的最大容量，即树的深度，最坏的情况下为 � ，则空间复杂度也为： $\displaystyle O(n)$ 。</p></blockquote><h3 id="3-2-线索二叉树"><a href="#3-2-线索二叉树" class="headerlink" title="3.2 线索二叉树"></a>3.2 线索二叉树</h3><p>遍历二叉树是以一定的规则，将二叉树中结点排列成一个线性序列，得到二叉树中结点的先序序列或者中序序列或者后序序列。</p><p><strong>这实质上是对一个非线性结构进行线性化操作，是每个结点在这些线性序列中有且仅有一个直接前驱和直接后继</strong>。</p><p>但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任意序列中的前驱和后继的信息，这种信息只能在二叉树遍历的过程中动态获取到。</p><p>如何保存这种在遍历过程中得到的信息呢？<strong>一个最简单的办法是在每个结点上增加两个指针域 <code>fwd</code> 和 <code>bkwd</code>，分别指示结点在依任一次序遍历时得到的前驱和后继信息</strong>。</p><p>显然，这样做，使得结构的存储密度大大降低。另一方面，在有 $\displaystyle n$ 个结点的二又链表中必定存在 $\displaystyle n+1$ 个空链域。由此设想，能否利用这些空链域来存放结点的前驱和后继的信息？</p><hr><p>🍁🍁🍁🍁🍁<strong>试作如下规定</strong>：结点若有左子树，则其 <code>lchild</code> 域指示其左孩子；若没有，则令 <code>lchild</code> 域指示其前驱。结点若有右子树，则其 <code>lchild</code> 域指示其右孩子；若没有，则令 <code>lchild</code> 域指示其后继。</p><p>为了避免混淆，尚需改变结点结构，增加两个标志域，图示如下：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/线索二叉树的结构模型.svg" alt="线索二叉树的结构模型.svg" style="zoom: 100%"></p><p>其中：</p><script type="math/tex; mode=display">\begin{align}\mathrm{LTag} &=\left\{\begin{matrix} 0 & \text{LChild域指示结点的左孩子} \\ 1 & \text{LChild域指示结点的前驱}\end{matrix}\right.\\\mathrm{RTag}&=\left\{\begin{matrix} 0 & \text{RChild域指示结点的右孩子} \\ 1 & \text{RChild域指示结点的后继}\end{matrix}\right.\\\end{align}</script><p>以这种结点结构，构成的二叉树链表二叉树的存储结构，叫做<strong>线索链表</strong>，其中指向结点前驱和后继的指针，叫做<strong>线索</strong>。加上线索的二叉树称之为<strong>线索二叉树</strong>。对二叉树以某种次序遍历，使其成为线索二叉树的过程叫做<strong>线索化</strong>。</p><p><strong>线索二叉树的数据结构模型</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">PointerTag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Link = <span class="number">0</span>,  <span class="comment">// Link = 0表示指向左右孩子指针</span></span><br><span class="line">    Thread = <span class="number">1</span> <span class="comment">// Thread = 1表示指向前驱或后继的线索</span></span><br><span class="line">&#125; PointerTag;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;                     <span class="comment">// 结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">// 左右孩子指针或者线索指针</span></span><br><span class="line">    PointerTag LTag;                   <span class="comment">// 左标志</span></span><br><span class="line">    PointerTag RTag;                   <span class="comment">// 右标志</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><ol><li>先序遍历；<ol><li>如果结点没有左子树，那么该结点的前驱就是<strong>双亲</strong>；</li><li>如果结点没有右子树，那么该结点的后继就是双亲的右子树；<ol><li>如果该结点双亲没有右子树，双亲的双亲的右子树</li></ol></li></ol></li><li>中序遍历；<ol><li>结点的后继是遍历右子树时访问的第一个结点，即右子树中最左下的结点</li></ol></li><li>后序线索树中找结点后继较复杂。</li></ol><h1 id="四、树和森林"><a href="#四、树和森林" class="headerlink" title="四、树和森林"></a>四、树和森林</h1><h2 id="4-1-树的存储"><a href="#4-1-树的存储" class="headerlink" title="4.1 树的存储"></a>4.1 树的存储</h2><h3 id="4-1-1-双亲表示法"><a href="#4-1-1-双亲表示法" class="headerlink" title="4.1.1 双亲表示法"></a>4.1.1 双亲表示法</h3><p>假设以一组连续的空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在链表中的位置，其形式说明如下：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/树的双亲表示法.svg" alt="树的双亲表示法" style="zoom: 50%"></p><p>树的双亲表示法的数据结构模型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="comment">// 结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">// 双亲位置</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="comment">// 树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> r, n; <span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure><p><strong>这种存储结构利用了每个结点（除根以外）只有唯一的双亲的性质。根据孩子结点，寻找双亲结点时，比较简单且高效。但是，这种表示法中，求结点的孩子时，需要遍历整个结构</strong>。</p><h3 id="4-1-2-孩子表示法"><a href="#4-1-2-孩子表示法" class="headerlink" title="4.1.2 孩子表示法"></a>4.1.2 孩子表示法</h3><p>由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域。</p><p>但是，按照这种方式构造的结点，其孩子指针域不确定。如果规定每个结点的孩子指针个数相同，则会有很多空链表；如果规定每个结点的孩子指针与其的度相等时，则会带来操作不便。</p><p>另一种方法是，把每个结点的孩子，依次排列成一个线性表，并且以单链表作为存储结构，则 $n$ 个结点有 $n$ 个孩子链表（叶子的孩子链表为空链表）。而 $n$ 个头指针又组成一个线性表，通常采用顺序存储结构。这种存储结构的模型如下：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/树的（带双亲的）孩子表示法.svg" alt="树的（带双亲的）孩子表示法" style="zoom: 36%"></p><p><strong>树的孩子表示法的数据结构模型</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="comment">// 结点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TElemType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125; TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> child; <span class="comment">// 孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> r, n; <span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-孩子兄弟表示法"><a href="#4-1-3-孩子兄弟表示法" class="headerlink" title="4.1.3 孩子兄弟表示法"></a>4.1.3 孩子兄弟表示法</h3><p>又称为二叉树表示法，或者二叉链表表示法。即以二叉链表作为树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点。</p><p><strong>树的孩子兄弟表示法的数据结构模型</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> child; <span class="comment">// 孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>, *<span class="title">nextSibling</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br></pre></td></tr></table></figure><h2 id="4-2-树与二叉树的转换"><a href="#4-2-树与二叉树的转换" class="headerlink" title="4.2 树与二叉树的转换"></a>4.2 树与二叉树的转换</h2><p>由于树和二叉树都可以使用二叉链表作为存储结构（树：孩子兄弟法），<strong>则以二叉链表作为媒介，可以导出树与二叉树之间的一个对应关系</strong>。也就是说，给定一棵树，可以找到唯一的一棵二叉树与之对应。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/树与二叉树的对应关系.png" alt="树与二叉树的对应关系" style="zoom: 100%"></p><blockquote><p>从树的二叉链表的定义可知，任何一棵和树对应的二叉树，其右子树必定为空。</p></blockquote><p>如果把森林中第二课树的根结点看成是第一棵树的根结点的兄弟，则同样可以导出森林和二叉树的对应关系。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/森林与二叉树之间的对应关系.png" alt="森林与二叉树之间的对应关系" style="zoom: 100%"></p><hr><ol><li><p>森林转换成二叉树：如果 $\displaystyle F = \left \{ T_{1} ,T_{2},\cdots ,T_{m} \right \} $ 是森林，则可按照下面规则转换成一个二叉树 $\displaystyle B = (\mathrm{root},\mathrm{LB},\mathrm{RB}   )$ ：</p><ol><li><p>如果 $\displaystyle F$ 是空，即 $m=0$ ，那么 $B$ 是<strong>空树</strong>；</p></li><li><p>如果 $\displaystyle F$ 是不为空，即 $m&gt;0$ ，那么 $B$ 的根 $\mathrm{root}$ 即为<strong>森林中第一棵树 $\displaystyle T_{1} $ 的 $\mathrm{root}$</strong> ； $B$ 的左子树 $\mathrm{LB}$ 是从 $T_{1}$ 中的根结点的子树森林 $\displaystyle T_{1} = \left \{ T_{(1,1)} ,T_{(1,2)},\cdots ,T_{(1,m)}\right \} $ 转换而成的二叉树。</p><blockquote><p> 森林转换成二叉树，简单的方法就是，增加一个虚拟的根结点，作为<strong>森林中所有树的根结点的双亲</strong>，然后将形成的<strong>虚拟树</strong>转化成二叉树。</p></blockquote></li></ol></li><li><p>二叉树转换成森林</p><ol><li>如果 $B$ 为空，那么 $\displaystyle F$ 是空；</li><li>如果 $B$ 不为空，那么 $\displaystyle F$ 中的第一棵树的根 $\mathrm{root}$ 就是二叉树 $B$ 的根； $T_{1}$ 中的根结点的子树森林 $F_{1}$ 就是由 $B$ 的左子树 $\mathrm{LB}$ 转换而成的森林； $\displaystyle F$ 中除 $T_{1}$ 之外的其余树，组成的森林是由 $B$ 的右子树 $\mathrm{RB}$ 转换而成的森林。</li></ol></li></ol><blockquote><p>从上述递归定义，容易写出相互转换的递归算法。同时，森林和树的操作亦可转换成二叉树的操作来实现。</p></blockquote><h2 id="4-3-树和森林的遍历"><a href="#4-3-树和森林的遍历" class="headerlink" title="4.3 树和森林的遍历"></a>4.3 树和森林的遍历</h2><p>由树结构的定义，可引出两种次序遍历树的方法：</p><ul><li>先根（次序）遍历，即：先访问树的根结点，然后依次先根遍历根结点的每棵子树；</li><li>后根（次序）遍历，即：先依次后根遍历根结点的每棵子树，然后访问根节点。</li></ul><p>按照森林和树相互递归的定义，我们可以推出森林的两种遍历方法：</p><ol><li>先序遍历森林：若森林非空，则可按下述规则遍历之<ol><li>访问森林中第一棵树的根结点；</li><li>先序遍历第一棵树中根结点的子树森林；</li><li>先序遍历，除去第一棵树之后剩余的树构成的森林。</li></ol></li><li>中序遍历森林：若森林非空，则可按下述规则遍历之：<ol><li>中序遍历森林中第一棵树的根结点的子树森林；</li><li>访问第一棵树的根结点；</li><li>中序遍历除去第一棵树之后剩余的树构成的森林。</li></ol></li></ol><p>由上节森林与二叉树之间转换的规则可知，当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，则上述森林的先序和中序遍历，即为其对应的二叉树的先序和中序遍历。</p><p><strong>由此可见，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历，可借用二叉树的先序遍历和中序遍历的算法实现之</strong>。</p><h1 id="五、树与等价问题"><a href="#五、树与等价问题" class="headerlink" title="五、树与等价问题"></a>五、树与等价问题</h1><p>【略】</p><h1 id="六、哈夫曼树及其应用"><a href="#六、哈夫曼树及其应用" class="headerlink" title="六、哈夫曼树及其应用"></a>六、哈夫曼树及其应用</h1><h2 id="6-1-最优二叉树"><a href="#6-1-最优二叉树" class="headerlink" title="6.1 最优二叉树"></a>6.1 最优二叉树</h2><p>首先给路径和路径长度的概念：从树中一个结点到另一个结点之间的分支构成两个结点之间的<strong>路径</strong>，路径上的分支数目叫做<strong>路径长度</strong>。</p><p><strong>树的路径长度</strong>：是从<strong>树的根</strong>到每一个结点的路径长度之和。</p><p><strong>结点的带权路径长度</strong>为从该结点到树根之间的路径长度与结点上权的乘积。</p><p><strong>树的带权路径长度</strong>为树中所有<strong>叶子结点</strong>的带权路径长度之和，通常记作 $\displaystyle \mathrm{WPL} = \displaystyle \sum_{k=1}^{n} w_{k} l_{k} $ 。</p><p>假设有 $n$ 个权值 $\displaystyle \left \{ \omega _{1} ,\omega _{2},\cdots ,\omega _{n} \right \} $ ，试构造一棵有 $n$ 个叶子结点的二叉树，每个叶子结点带权为 $\displaystyle \omega _{i}$ ，则其中带权路径长度 $\displaystyle \mathrm{WPL}$ 最小的二叉树，称作<strong>最优二叉树</strong>或者<strong>哈夫曼树</strong>。</p><p>哈夫曼树的构造方法：（<strong>哈夫曼算法</strong>）☯️☯️☯️☯️☯️☯️☯️</p><ol><li>根据给定的 $n$ 个权值 $\displaystyle \left \{ \omega _{1} ,\omega _{2},\cdots ,\omega _{n} \right \} $ ，构成 $n$ 棵二叉树集合 $\displaystyle F = \left \{ T_{1} , T_{2},\cdots , T_{n} \right \} $ ，其中，每棵二叉树 $\displaystyle T_{i}$ 中，只有一个带权为 $\displaystyle w_{i}$ 的根节点，<strong>其左右子树为空</strong>；</li><li>在 $\displaystyle F $ 中选取两棵根结点的权值最小的二叉树树，作为左右子树，构造一棵新的二叉树，并且新的二叉树的根结点的权值是其左、右子树上的根结点的权值之和；</li><li>在 $\displaystyle F $ 中删除这两棵树，同时将新得到的二叉树加入 $\displaystyle F $ 中；</li><li>重复（2）和（3）步骤，直至 $\displaystyle F $ 只含有一棵树为止；</li><li>最后得到的树，便是<strong>哈夫曼树</strong>。</li></ol><p>哈夫曼树的构造算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125; ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> parent, lchild, rchild;</span><br><span class="line">&#125; Node, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Weight[<span class="number">16</span>] = &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">29</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Creat</span><span class="params">(HuffmanTree &amp;HT, <span class="type">float</span> *weight, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nodeCount = <span class="number">2</span> * length - <span class="number">1</span>; <span class="comment">// 结点数</span></span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>((nodeCount + <span class="number">1</span>) * <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    HuffmanTree p = HT;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化前length个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = &#123;*(weight + i), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化后length-1个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = length + <span class="number">1</span>; i &lt; nodeCount + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建赫夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (i = length + <span class="number">1</span>; i &lt; nodeCount + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在HT[1~i-1]选择parent为0且weight最小的两个结点，其序号分别为s1和s2</span></span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        Select(HT, i - <span class="number">1</span>, &amp;s1, &amp;s2);</span><br><span class="line">        <span class="comment">// 用s1和s2的weight作为i的weight，parent指向s1和s2</span></span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1;</span><br><span class="line">        HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 找到第一个parent为0的结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s1 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到第二个parent为0的结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">        &#123;</span><br><span class="line">            s2 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从剩余的结点中找到权值最小的两个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1 &amp;&amp; i != s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[s1].weight)</span><br><span class="line">            &#123;</span><br><span class="line">                s2 = s1;</span><br><span class="line">                s1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (HT[i].weight &lt; HT[s2].weight)</span><br><span class="line">            &#123;</span><br><span class="line">                s2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-哈夫曼编码"><a href="#6-2-哈夫曼编码" class="headerlink" title="6.2 哈夫曼编码"></a>6.2 哈夫曼编码</h2><p>目前，进行快速远距离通信的主要手段是<strong>电报</strong>，即将需要传颂的文文字转换成由二进制的字符组成的字符串。当然，在传送电文时，希望总长度尽可能的短。<strong>如果对每个字符设计长度不等的编码，并且让电文中出现次数较多的字符，尽可能的短的编码，则传送点问的总长度便可减少</strong>。</p><p>因此，如果要设计长短不等的编码，则必须是任意一个字符的编码都不是另一个字符的编码的前缀，这种编码称作<strong>前缀编码</strong>。</p><p>假设每种字符在电文中出现的次数为 $\displaystyle w_{i}$ ，其编码长度为 $\displaystyle l_{i}$ ，电文中只有 $n$ 种字符，则电文总长度为 $\displaystyle \sum_{i=1}^{n} w_{i} l_{i} $ 。对应二叉树上，如果置 $\displaystyle w_{i}$ 为叶子结点的权， $\displaystyle l_{i}$ 恰好为从根到叶子的路径长度，那么 $\displaystyle \sum_{i=1}^{n} w_{i} l_{i} $ 恰好是二叉树上带权路径长度。</p><p><strong>由此可见，设计电文总长度最短的二进制前缀编码，即为以 $n$ 种字符出现的频率作为权值，设计一棵哈夫曼树的问题，由此得到的二进制前缀编码，便称为哈夫曼编码</strong>。</p><p>其哈夫曼编码的具体算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// w存放n个字符的权值(均&gt;0)，构造赫夫曼树HT，并求出n个字符的赫夫曼编码HC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode &amp;HC, <span class="type">int</span> *w, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果小于一个字符，那么就不需要构造赫夫曼树</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> nodeCount = <span class="number">2</span> * n - <span class="number">1</span>;                                  <span class="comment">// 赫夫曼树的结点数</span></span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>((nodeCount + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HTNode)); <span class="comment">// 0号单元未用</span></span><br><span class="line">    HuffmanTree p = HT;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化前n个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = &#123;*(w + i), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化后n-1个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt; nodeCount + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建赫夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt; nodeCount + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在HT[1~i-1]选择parent为0且weight最小的两个结点，其序号分别为s1和s2</span></span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        Select(HT, i - <span class="number">1</span>, &amp;s1, &amp;s2);</span><br><span class="line">        <span class="comment">// 用s1和s2的weight作为i的weight，parent指向s1和s2</span></span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1;</span><br><span class="line">        HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从叶子到根逆向求每个字符的赫夫曼编码</span></span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line">    <span class="type">char</span> *cd = (<span class="type">char</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 临时存放每个字符的编码</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;                            <span class="comment">// 编码结束符</span></span><br><span class="line">    <span class="comment">// 逐个字符求赫夫曼编码</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>; <span class="comment">// 编码结束符位置</span></span><br><span class="line">        <span class="type">int</span> c = i;         <span class="comment">// 从叶子到根逆向求编码</span></span><br><span class="line">        <span class="type">int</span> f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --start;</span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            c = f;</span><br><span class="line">            f = HT[f].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        HC[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>((n - start) * <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 为第i个字符编码分配空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);                          <span class="comment">// 把求得的编码从临时空间cd复制到HC</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 找到第一个parent为0的结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s1 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到第二个parent为0的结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">        &#123;</span><br><span class="line">            s2 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从剩余的结点中找到权值最小的两个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1 &amp;&amp; i != s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[s1].weight)</span><br><span class="line">            &#123;</span><br><span class="line">                s2 = s1;</span><br><span class="line">                s1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (HT[i].weight &lt; HT[s2].weight)</span><br><span class="line">            &#123;</span><br><span class="line">                s2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、回溯法与树的遍历"><a href="#七、回溯法与树的遍历" class="headerlink" title="七、回溯法与树的遍历"></a>七、回溯法与树的遍历</h1><p>【略】</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 数组和广义表【数据结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>快速导航：</p><ul><li><a href="./01.绪论">第一章 绪论【数据结构】</a></li><li><a href="./02.线性表">第二章 线性表【数据结构】</a></li><li><a href="./03.栈和队列">第三章 栈和队列【数据结构】</a></li><li><a href="./04.串">第四章 串【数据结构】</a></li><li><a href="./05.数组和广义表">第五章 数组和广义表【数据结构】</a></li><li><a href="./06.数和二叉树">第六章 数和二叉树【数据结构】</a></li><li><a href="./07.图Graph">第七章 图(Graph)【数据结构】</a></li><li><a href="./09.查找">第九章 查找【数据结构】</a></li></ul></blockquote><p>数组和广义表可以看成是线性表在下述含义上的扩展：线性表中的元素本身也可能是一个数据结构。</p><h1 id="一、数组的定义"><a href="#一、数组的定义" class="headerlink" title="一、数组的定义"></a>一、数组的定义</h1><p>数组的抽象数据模型为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADT Array</span><br><span class="line">&#123;</span><br><span class="line">    数据对象:i, j, D;</span><br><span class="line">    数据关系:R;</span><br><span class="line">    基本操作:</span><br><span class="line">    Statue InitArray(&amp;A, n, bound[n]); // 初始化操作，建立一个n维数组A，构造成功返回OK，否则返回ERROR</span><br><span class="line">    DestroyArray(&amp;A);                  // 销毁数组A</span><br><span class="line">    Value(A, &amp;e, index[]);             // 将数组A中下标为 index[] 的元素值返回给e</span><br><span class="line">    Assign(&amp;A, e, index[]);            // 将e的值赋给数组A中下标为 index[] 的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组一旦被定义，它的<strong>维数</strong>和<strong>维界</strong>就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。</p></blockquote><h1 id="二、数组的顺序表示和实现"><a href="#二、数组的顺序表示和实现" class="headerlink" title="二、数组的顺序表示和实现"></a>二、数组的顺序表示和实现</h1><p>由于<strong>数组一般不做插入或者删除操作</strong>，也就是说，一旦建立了数组，则结构中的元素个数和元素之间的关系就不再发生变动。对二维数组可有两种存储方式：<strong>以列序优先</strong>和<strong>以行序有限</strong>。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/二维数组的存储模式.svg" alt="二维数组的存储模式.svg" style="zoom: 36%"></p><blockquote><p>通常情况下，二维数组的存储<strong>以行序优先</strong>，并且在大多的计算机编程语言中（包含 <code>C</code> 语言），都是<strong>以行序优先</strong>来存储二维数组。</p></blockquote><p>假设每个数据元素占 $L$ 个存储单元，并且以行序优先，则二维数组 $A$ 中，任一元素 $\displaystyle a_{ij} $ 的存储位置可由下式确定：</p><script type="math/tex; mode=display">\displaystyle \mathrm{Loc}(i,j) = \mathrm{Loc}(0,0) +(i\times n+j)</script><p>式中， $\displaystyle \mathrm{Loc}(i,j)$ 是 $\displaystyle a_{ij} $ 的存储位置； $\displaystyle \mathrm{Loc}(0,0)$ 是 $a_{00}$ 的存储位置，即<strong>二维数组 $A$ 的起始存储位置，也称为基址地址或者基址</strong>。</p><blockquote><p>由于计算各个域元素存储位置的时间相等，所以存取数组中任一元素的时间也相等。称具有这一特点的存储结构为<strong>随机存储结构</strong>。</p></blockquote><h1 id="三、矩阵的压缩"><a href="#三、矩阵的压缩" class="headerlink" title="三、矩阵的压缩"></a>三、矩阵的压缩</h1><h2 id="3-1-特殊矩阵"><a href="#3-1-特殊矩阵" class="headerlink" title="3.1 特殊矩阵"></a>3.1 特殊矩阵</h2><h3 id="3-1-1-零元矩阵和全-k-阵"><a href="#3-1-1-零元矩阵和全-k-阵" class="headerlink" title="3.1.1 零元矩阵和全 $k$ 阵"></a>3.1.1 零元矩阵和全 $k$ 阵</h3><p>只需要存储三个数字：矩阵的行、列数以及矩阵元素的值。</p><h3 id="3-1-2-对称矩阵"><a href="#3-1-2-对称矩阵" class="headerlink" title="3.1.2 对称矩阵"></a>3.1.2 对称矩阵</h3><p>如果 $n$ 阶矩阵 $A$ 中的元素，满足 $\displaystyle a_{i,j} =a_{j,i} $ ，则称矩阵 $A$ 为<strong>对称矩阵</strong>。</p><p>对于对称矩阵，可以为<strong>每一对对称元</strong>分配一个存储空间，即将 $\displaystyle n^{2} $ 和元素压缩存储到 $\displaystyle \frac{n(n+1)}{2} $ 个元的空间中。因此，原矩阵的下标（注意：<strong>这里的下标从 0 开始</strong>）与压缩后的一维数组的下标的对应关系为：</p><script type="math/tex; mode=display">\displaystyle k=\left\{\begin{matrix}\frac{i(i-1)}{2}+j-1 & \text{当}i\ge j \\\frac{j(j-1)}{2}+i-1 & \text{当}i<  j\end{matrix}\right.</script><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/对称矩阵的压缩.svg" alt="对称矩阵的压缩.svg" style="zoom: 100%"></p><p>因此，对应的转换算法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对称矩阵的压缩</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">Compression</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n * (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i * (i + <span class="number">1</span>) / <span class="number">2</span> + j] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对称矩阵的解压缩</span></span><br><span class="line"><span class="type">int</span> **<span class="title function_">Decompression</span><span class="params">(<span class="type">int</span> *matrix, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **result = (<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i][j] = matrix[i * (i + <span class="number">1</span>) / <span class="number">2</span> + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-上三角矩阵和下三角矩阵"><a href="#3-1-3-上三角矩阵和下三角矩阵" class="headerlink" title="3.1.3 上三角矩阵和下三角矩阵"></a>3.1.3 上三角矩阵和下三角矩阵</h3><p>由于对称矩阵是将矩阵转化为上三角或者下三角矩阵来进行计算的，因此，压缩和解压缩的过程与对称矩阵类似。</p><h3 id="3-1-4-对角矩阵"><a href="#3-1-4-对角矩阵" class="headerlink" title="3.1.4 对角矩阵"></a>3.1.4 对角矩阵</h3><p>有 $n$ 阶矩阵，主对角线元素不全为 0 ，其余元素全为 0 的矩阵，称为<strong>对角矩阵</strong>。对角矩阵的压缩较为简单，只需要将对角线上所有元素转化为一维数组即可。</p><h2 id="3-2-稀疏矩阵"><a href="#3-2-稀疏矩阵" class="headerlink" title="3.2 稀疏矩阵"></a>3.2 稀疏矩阵</h2><p>假设在 $\displaystyle m\times n$ 矩阵中，有 $\displaystyle t$ 个元素不为 0 。令 $\displaystyle \delta =\frac{t}{m\times n} $ ，称 $\displaystyle \delta $ 为<strong>稀疏因子</strong>。通常认为 $\displaystyle \delta\le 0.05$ 时称为<strong>稀疏矩阵</strong>。</p><p>现有稀疏矩阵 $M$ ：</p><script type="math/tex; mode=display">\displaystyle {\large M=\begin{bmatrix} 0 &{\color{Red} 12} & {\color{Red} 9}  & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 0 & 0\\{\color{Red}  -3}  & 0 & 0 & 0 & 0 & {\color{Red} 14}  & 0\\ 0 & 0 & {\color{Red} 24}  & 0 & 0 & 0 & 0\\ 0 & {\color{Red} 18}  & 0 & 0 & 0 & 0 & 0\\ {\color{Red} 15}  & 0 & 0 & {\color{Red} -7}  & 0 & 0 & 0\end{bmatrix} }</script><p>以及转置矩阵：</p><script type="math/tex; mode=display"> \displaystyle {\large T=\begin{bmatrix} 0 & 0 & {\color{Red} -3}  & 0 & 0 & {\color{Red} 15}\\ {\color{Red} 12}  & 0 & 0 & 0 & {\color{Red} 18}  & 0 \\{\color{Red}  9}  & 0 & 0 & {\color{Red} 24} & 0 & 0\\ 0 & 0 &  0 & 0 & 0 & {\color{Red}  -7}\\ 0 & 0 & 0 & 0 & 0 & 0 \\ 0& 0 & {\color{Red} 14} & 0 & 0 & 0 \\ 0& 0 & 0 & 0 & 0 & 0 \end{bmatrix} }</script><h3 id="3-2-1-三元组表"><a href="#3-2-1-三元组表" class="headerlink" title="3.2.1 三元组表"></a>3.2.1 三元组表</h3><p>假设以顺序存储结构来表示三元组表，得到稀疏矩阵压缩的一种方式——<strong>三元组顺序表</strong>。</p><p><strong>三元组顺序表的数据结构</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 12500 <span class="comment">// 假设非零元个数的最大值为12500</span></span></span><br><span class="line"><span class="comment">// 表示三元组的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Triple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    Element e;</span><br><span class="line">&#125; Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TSMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>]; <span class="comment">// 非零元三元组表，data[0]未用</span></span><br><span class="line">    <span class="type">int</span> mu;                   <span class="comment">// 矩阵的行数和列数</span></span><br><span class="line">    <span class="type">int</span> nu;                   <span class="comment">// 矩阵的行数和列数</span></span><br><span class="line">    <span class="type">int</span> tu;                   <span class="comment">// 矩阵的非零元个数</span></span><br><span class="line">&#125; TSMatrix;</span><br></pre></td></tr></table></figure><p>那么，构造对应的压缩算法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TSMatrix *<span class="title function_">Compression</span><span class="params">(Element **matrix, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    TSMatrix *result = (TSMatrix *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSMatrix));</span><br><span class="line">    result-&gt;mu = m;</span><br><span class="line">    result-&gt;nu = n;</span><br><span class="line">    result-&gt;tu = count;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j].value != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result-&gt;data[k].i = i;</span><br><span class="line">                result-&gt;data[k].j = j;</span><br><span class="line">                result-&gt;data[k].data = matrix[i][j];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果为：<code>a.data</code> ：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">0</th><th style="text-align:center">2</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">j</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">value</td><td style="text-align:center">12</td><td style="text-align:center">9</td><td style="text-align:center">-3</td><td style="text-align:center">14</td><td style="text-align:center">24</td><td style="text-align:center">18</td><td style="text-align:center">15</td><td style="text-align:center">-7</td></tr></tbody></table></div><hr><p>矩阵的转置运算：方法一</p><p>@算法 5-1 ：用三元组表进行矩阵的转置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法 5-1 ：用三元组表进行矩阵的转置：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Transform</span><span class="params">(TSMatrix matrix, TSMatrix &amp;result)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 交换行列值</span></span><br><span class="line">    result.mu = matrix.nu;</span><br><span class="line">    result.nu = matrix.mu;</span><br><span class="line">    result.tu = matrix.tu;</span><br><span class="line">    <span class="type">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 交换每一个三元组的行列值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; matrix.nu; col++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= matrix.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix.data[p].j == col)</span><br><span class="line">            &#123;</span><br><span class="line">                result.data[q].i = matrix.data[p].j;</span><br><span class="line">                result.data[q].j = matrix.data[p].i;</span><br><span class="line">                result.data[q].data = matrix.data[p].data;</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般的矩阵转置算法，其<strong>时间复杂度为： $\displaystyle O(m\times n)$</strong> 。但是如果非零元个数与 $\displaystyle m\times n$ 同数量级时，<strong>三元组顺序表的转置算法</strong>的时间复杂度就变成了 $\displaystyle O(m\times n^{2} )$ 。</p><p>因此，<strong>用三元组表进行矩阵的转置</strong>，仅仅适合 $\displaystyle t \ll m\times n$ 的情况，即不是稀疏矩阵的情况。</p></blockquote><p>矩阵的转置运算：方法二</p><p><strong>快速转置</strong>：如果能预先确定矩阵 $\displaystyle M$ 中，每一列（即 $T$ 中每一行）的第一个非零元在 <code>b.data</code> 中应有的位置，那么在对 <code>a.data</code> 中的三元组依次做转置时，便可以直接放到 <code>b.data</code> 中恰当的位置。</p><p>为此，需要附设 <code>num</code> 和 <code>cpot</code> 两个向量。</p><ul><li><code>num[co]</code> 表示矩阵 $M$ 中第 $col$ 列中，非零元的个数；</li><li><code>cpot[col]</code> 指示 $M$ 中，第 $col$ 列第一个非零元素在 <code>a.data</code> 中的恰当位置。</li></ul><p>显然有：</p><script type="math/tex; mode=display">\displaystyle \mathrm{cpot}\left [ \mathrm{col}  \right ]  =\left\{\begin{matrix} 1& \mathrm{col}=1 \\ \mathrm{cpot}\left [ \mathrm{col} -1 \right ] +\mathrm{num} \left [ \mathrm{col} -1 \right ]  &1< \mathrm{col}\le \mathrm{a.nu}\end{matrix}\right.</script><p>因此，得到的向量表为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">col</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">num[col]</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">cpot[col]</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">5</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:center">9</td></tr></tbody></table></div><p>@算法 5-2 ：使用带向量的三元组表进行转置的方法，称为<strong>快速转置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法 5-2 ：使用带向量的三元组表进行转置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 采用三元组顺序表存储表示，求矩阵M的转置矩阵T</span></span><br><span class="line">    T.mu = M.nu;</span><br><span class="line">    T.nu = M.mu;</span><br><span class="line">    T.tu = M.tu;</span><br><span class="line">    <span class="keyword">if</span> (T.tu &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> col, t;</span><br><span class="line">        <span class="comment">// 初始化num数组</span></span><br><span class="line">        <span class="type">int</span> *num = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M.nu);</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; M.nu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计每一列的非零元个数</span></span><br><span class="line">        <span class="keyword">for</span> (t = <span class="number">1</span>; t &lt;= M.tu; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[M.data[t].j]++; <span class="comment">// 将每一个非零元的列下标对应的num数组的值加1，如果有重复的则会累加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化cpot数组</span></span><br><span class="line">        <span class="type">int</span> *cpot = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M.nu);</span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt; M.nu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将矩阵M的三元组表存入矩阵T的三元组表中</span></span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">1</span>; p &lt;= M.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M.data[p].j;</span><br><span class="line">            t = cpot[col];</span><br><span class="line">            T.data[t].i = M.data[p].j;</span><br><span class="line">            T.data[t].j = M.data[p].i;</span><br><span class="line">            T.data[t].data = M.data[p].data;</span><br><span class="line">            cpot[col]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-行逻辑连接的顺序表"><a href="#3-2-2-行逻辑连接的顺序表" class="headerlink" title="3.2.2 行逻辑连接的顺序表"></a>3.2.2 行逻辑连接的顺序表</h3><p>为了便于存取任意一行的非零元，则需要知道每一行的第一个非零元在三元组顺序表中的位置。类似上面的 <code>cpot</code> 向量一样，在表示压缩矩阵的结构体内，添加一个指示“行”信息的辅助数组。称这种“带行链接信息”的三元组表为行逻辑链接的顺序表，其类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TSMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>]; <span class="comment">// 非零元三元组表，data[0]未用</span></span><br><span class="line">    <span class="type">int</span> rpos[MAXSIZE + <span class="number">1</span>];    <span class="comment">// rpos[i]表示矩阵第i行第一个非零元在data中的位置</span></span><br><span class="line">    <span class="type">int</span> mu;                   <span class="comment">// 矩阵的行数和列数</span></span><br><span class="line">    <span class="type">int</span> nu;                   <span class="comment">// 矩阵的行数和列数</span></span><br><span class="line">    <span class="type">int</span> tu;                   <span class="comment">// 矩阵的非零元个数</span></span><br><span class="line">&#125; RLSSMatrix;</span><br></pre></td></tr></table></figure><p>两个矩阵相乘的经典算法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m1; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n1; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            t += a[i][k] * b[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        c[i][j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>此算法的时间复杂度为： $\displaystyle O(m_{1} \times n_{2} \times s)$</strong> 。</p></blockquote><h3 id="3-2-3-十字链表法"><a href="#3-2-3-十字链表法" class="headerlink" title="3.2.3 十字链表法"></a>3.2.3 十字链表法</h3><p>十字链表的稀疏矩阵的压缩，其数据模型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i, j;                    <span class="comment">// 该非零元的行下标和列下标</span></span><br><span class="line">    <span class="type">int</span> e;                       <span class="comment">// 该非零元的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">right</span>, *<span class="title">down</span>;</span> <span class="comment">// 该非零元所在行表和列表的后继链域</span></span><br><span class="line">&#125; OLNode, *OLink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    OLink *rhead, *chead; <span class="comment">// 行指针和列指针</span></span><br><span class="line">    <span class="type">int</span> mu, nu, tu;       <span class="comment">// 矩阵的行数、列数和非零元个数</span></span><br><span class="line">&#125; CrossList;</span><br></pre></td></tr></table></figure><p>其图示模型为：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/稀疏矩阵的十字链表.png" alt="稀疏矩阵的十字链表" style="zoom: 150%"></p><h3 id="3-2-4-行-列链表法【扩展】"><a href="#3-2-4-行-列链表法【扩展】" class="headerlink" title="3.2.4 行/列链表法【扩展】"></a>3.2.4 行/列链表法【扩展】</h3><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/行链表法.svg" alt="行链表法" style="zoom: 70%"></p><h1 id="四、广义表"><a href="#四、广义表" class="headerlink" title="四、广义表"></a>四、广义表</h1><p>广义表是线性表的推广。也有人称其为列表（Lists）。</p><p>广义表一般记作：</p><script type="math/tex; mode=display">\displaystyle \mathrm{LS} = (a_{1},a_{2},\cdots ,a_{n} )</script><p>其中， $\displaystyle \mathrm{LS}$ 是广义表的名称， $n$ 是它的长度。在线性表的定义中， $\displaystyle a_{i}$ 只限于单个元素。<strong>而在广义表中， $\displaystyle a_{i}$ 可以是单个元素，也可以是广义表，分别称为广义表的原子和子表</strong>。当广义表非空时，称第一个元素 $\displaystyle a_{i}$ 为 $\displaystyle \mathrm{LS}$ 的表头，其余元素组成的表是 $\displaystyle \mathrm{LS}$ 的表尾。</p><p><strong>链表的 3 个重要结论</strong>：</p><ol><li>列表的元素可以是子表，而子表的元素还可以是子表。由此，<strong>列表是一个多层次的结构</strong>，可以用图形象地表示。</li><li>列表可以为其他列表所共享。</li><li>列表可以是一个递归的表，即列表也可以是其本身的一个子表。（<strong>深度无穷限，长度有限值</strong>）</li></ol><h1 id="五、广义表的存储结构"><a href="#五、广义表的存储结构" class="headerlink" title="五、广义表的存储结构"></a>五、广义表的存储结构</h1><p>由于广义表中的数据元素可以具有不同的结构，因此难以用顺序存储结构表示，通常使用链式存储结构，每个数据元素可用一个结点表示。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/广义表的存储结构.svg" alt="广义表的存储结构.svg" style="zoom: 100%"></p><p>一个<strong>表结点</strong>可由 3 个域组成：</p><ul><li>标志域：</li><li>指向表头的指针域</li><li>指向表尾的指针域</li></ul><p>而<strong>原子结点</strong>只需要两个域：</p><ul><li>标志域</li><li>值域</li></ul><p><strong>广义表的数据结构模型</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElemTag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ATOM,</span><br><span class="line">    LIST</span><br><span class="line">&#125; ElemTag;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AtomType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125; AtomType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag; <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        AtomType atom; <span class="comment">// atom是原子结点的值域，AtomType由用户定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">child</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *GList;</span><br></pre></td></tr></table></figure><h1 id="六、-m-元多项式的表示"><a href="#六、-m-元多项式的表示" class="headerlink" title="六、 $m$ 元多项式的表示"></a>六、 $m$ 元多项式的表示</h1><p>一个 $m$ 元多项式的每一项，最多有 $m$ 个变元。如果用线性表来表示，则每个数据元素需要 $m+1$ 个数据项，存储一个系数值和 $m$ 个指数值。</p><p>这将产生两个问题：</p><ol><li>无论多项式中各项的变元数是多少，如果都按照 $m$ 个变元分配存储空间，则将会造成浪费；</li><li>如果都按照实际的变元数来分配存储空间，则会造成结点的大小不均，给操作带来不便</li><li>对 $m$ 值不同的多项式，线性表中的结点大小也是不同的，这样会引起存储管理的不便。</li></ol><p>任何一个 $m$ 元多项式都可以：<strong>先分解出一个主变元，随后在分解出第二个变元</strong>，等等。由此，一个 $m$ 元的多项式首先是它的主变元的多项式，而其系数又是第二变元的多项式，由此可用广义表来表示 $m$ 元多项式。</p><p>例如：</p><script type="math/tex; mode=display">\displaystyle P(x,y,z) = x^{10} y^{3} z^{2} +2x^{6} y^{3} z^{2} +3x^{5} y^{2} z^{2} +x^{4} y^{4} z^{} +6x^{3} y^{4} z^{} +2y^{3} z^{2} +15</script><p>将 $z$ 作为主变元，则得到：</p><script type="math/tex; mode=display">\displaystyle P(x,y,z) = (x^{10} y^{3}+2x^{6} y^{3}+3x^{5} y^{2}+2y^{3} )z^{2}+(x^{4} y^{4}+6x^{3} y^{4})z  +15</script><p>二对应的 $A,B,C$ 又得到一个 $m-1$ 元多项式，为：</p><script type="math/tex; mode=display">\begin{align}A(x,y) & =  (x^{10} +2x^{6} )y^{3} +3x^{5} y^{2} \\B(x,y) & =  (x^{4}+6x^{3})y^{4} +2y\\V(x,y) & = 15\\\end{align}</script><p>数据结构模型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElemTag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ATOM,</span><br><span class="line">    LIST</span><br><span class="line">&#125; ElemTag;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MPNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag; <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span>;     <span class="comment">// 指数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">float</span> coef;           <span class="comment">// 系数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">MPNode</span> *<span class="title">child</span>;</span> <span class="comment">// 指向子表</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MPNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向后继结点</span></span><br><span class="line">&#125; MPNode, *MPLink;       <span class="comment">// 多项式的广义表</span></span><br></pre></td></tr></table></figure><h1 id="七、广义表的递归算法"><a href="#七、广义表的递归算法" class="headerlink" title="七、广义表的递归算法"></a>七、广义表的递归算法</h1><h2 id="7-1-求广义表的深度"><a href="#7-1-求广义表的深度" class="headerlink" title="7.1 求广义表的深度"></a>7.1 求广义表的深度</h2><p><strong>广义表的深度定义为广义表中括弧的重数</strong>，是广义表的一种量度。</p><blockquote><p>简单来讲，有多少重的子广义表</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GListDepth</span><span class="params">(GList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果广义表为空，返回1</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GList p = L;</span><br><span class="line">    <span class="comment">// 如果是原子结点，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;tag == ATOM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是表结点，递归求子表的深度</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        depth = GListDepth(p-&gt;child);</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max + <span class="number">1</span>; <span class="comment">// 返回广义表的深度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-复制广义表"><a href="#7-2-复制广义表" class="headerlink" title="7.2 复制广义表"></a>7.2 复制广义表</h2><p><strong>复制一个广义表，只要分别复制其表头和表尾，然后合成即可</strong>。其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CopyGList</span><span class="params">(GList &amp;T, GList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (GList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        T-&gt;tag = L-&gt;tag;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;tag == ATOM)</span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;atom = L-&gt;atom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CopyGList(T-&gt;child, L-&gt;child);</span><br><span class="line">            CopyGList(T-&gt;next, L-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 串【数据结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04%E4%B8%B2.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>快速导航：</p><ul><li><a href="./01.绪论">第一章 绪论【数据结构】</a></li><li><a href="./02.线性表">第二章 线性表【数据结构】</a></li><li><a href="./03.栈和队列">第三章 栈和队列【数据结构】</a></li><li><a href="./04.串">第四章 串【数据结构】</a></li><li><a href="./05.数组和广义表">第五章 数组和广义表【数据结构】</a></li><li><a href="./06.数和二叉树">第六章 数和二叉树【数据结构】</a></li><li><a href="./07.图Graph">第七章 图(Graph)【数据结构】</a></li><li><a href="./09.查找">第九章 查找【数据结构】</a></li></ul></blockquote><h1 id="一、字符串的定义"><a href="#一、字符串的定义" class="headerlink" title="一、字符串的定义"></a>一、字符串的定义</h1><p><strong>串</strong>（或者字符串）是由零个或者多个字符组成的有限序列，一般记为：</p><script type="math/tex; mode=display">\displaystyle s = 'a_{1} a_{2}a_{3}\cdots a_{n}'(n\ge 0)</script><p>其中， <code>s</code> 是串的名，用<strong>单引号</strong>括起来的字符序列是串的值。 串中字符的数目 $n$ 称为串的长度。零个字符的串称为<strong>空串</strong>，记作 $\displaystyle \phi $ 。</p><p>串中任意个连续的字符组成的子序列称为该串的<strong>字串</strong>。包含字串的串相应的称为<strong>主串</strong>。通常称字符在序列中的序号为该字符在串中的<strong>位置</strong>（索引位置从 0 开始）。</p><p>由<strong>一个</strong>或者<strong>多个</strong>空格组成的串称为<strong>空格串</strong>。</p><blockquote><p>当且仅当两个串的长度相等，并且各个对应位置的字符都相等，称<strong>两个串相等</strong>。</p></blockquote><p>串的抽象数据模型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT String&#123;</span><br><span class="line">    数据对象: D;</span><br><span class="line">    数据关系: R;</span><br><span class="line">    基本操作:</span><br><span class="line">    StrAssign(&amp;T, chars); // 生成一个值等于 chars 的串 T</span><br><span class="line">    StrCopy(&amp;T, S); // 由串 S 复制得串 T</span><br><span class="line">    StrEmpty(S); // 如果 S 是空串，则返回 True；否则，返回 False</span><br><span class="line">    StrCompare(S, T); // 如果 S &gt; T ，则返回值 &gt; 0；如果 S = T ，则返回值 = 0；如果 S &lt; T ，则返回值 &lt; 0；</span><br><span class="line">    StrLength(S); // 返回 S 的元素个数，称为串的长度</span><br><span class="line">    ClearString(&amp;S); // 将 S 清空</span><br><span class="line">    Concat(&amp;T, S1, S2); // 用 T 返回由 S1 和 S2 连接而成的新串</span><br><span class="line">    SubString(&amp;Sub, S, pos, len); // 用 Sub 返回串 S 的第 pos 个字符起，长度为 len 的字串</span><br><span class="line">    Index(S, T, pos); // 如果 S 字串存在和串 T 值相同的字串，则返回它在主串 S 中第 pos 个字符之后第一次出现的位置；否则函数值为 0</span><br><span class="line">    Replace(&amp;S, T, V); // 用 V 替换主串 S 中出现的所有与 T 相等的不重叠的字串</span><br><span class="line">    StrInsert(&amp;S, pos, T); // 在串 S 的第 pos 个字符之前插入串 T</span><br><span class="line">    StrDelete(&amp;S, pos, len); // 从串 S 中删除第 pos 个字符起长度为len的子串</span><br><span class="line">    Destory(&amp;S); // 串 S 被摧毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、串的表示和实现"><a href="#二、串的表示和实现" class="headerlink" title="二、串的表示和实现"></a>二、串的表示和实现</h1><h2 id="2-1-定长顺序表存储表示"><a href="#2-1-定长顺序表存储表示" class="headerlink" title="2.1 定长顺序表存储表示"></a>2.1 定长顺序表存储表示</h2><p>类似与线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。</p><p>在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255                         <span class="comment">// 用户可在255以内定义最大串长</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> SString[MAXSTRLEN + <span class="number">1</span>]; <span class="comment">// 0号单元存放串的长度</span></span><br></pre></td></tr></table></figure><blockquote><p>串的实际长度可在这预定义长度范围内随意，超过预定义长度的串值则被舍去，称之为<strong>“截断”</strong>。</p></blockquote><ol><li><p>串连接 <code>Concat(&amp;T, S1, S2)</code> ；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Concat</span><span class="params">(SString &amp;T, SString S1, SString S2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S1[<span class="number">0</span>] + S2[<span class="number">0</span>] &lt;= MAXSTRLEN) <span class="comment">// 未截断</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[<span class="number">1.</span>.S1 [<span class="number">0</span>]] = S1[<span class="number">1.</span>.S1 [<span class="number">0</span>]];</span><br><span class="line">        T[S1[<span class="number">0</span>] + <span class="number">1.</span>.S1 [<span class="number">0</span>] + S2[<span class="number">0</span>]] = S2[<span class="number">1.</span>.S2 [<span class="number">0</span>]];</span><br><span class="line">        T[<span class="number">0</span>] = S1[<span class="number">0</span>] + S2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S1[<span class="number">0</span>] &lt; MAXSTRLEN) <span class="comment">// 截断 S2</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[<span class="number">1.</span>.S1 [<span class="number">0</span>]] = S1[<span class="number">1.</span>.MAXSTRLEN - S2[<span class="number">0</span>]];</span><br><span class="line">        T[S1[<span class="number">0</span>] + <span class="number">1.</span>.MAXSTRLEN] = S2[<span class="number">1.</span>.MAXSTRLEN];</span><br><span class="line">        T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 截断 S1, S2</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[<span class="number">0.</span>.MAXSTRLEN] = S1[<span class="number">0.</span>.MAXSTRLEN];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求字串 <code>SubString(&amp;Sub, S, pos, len)</code>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">1</span> || pos &gt; S[<span class="number">0</span>] || len &lt; <span class="number">0</span> || len &gt; S[<span class="number">0</span>] - pos + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Sub[<span class="number">1.</span>.len] = S[pos..pos + len - <span class="number">1</span>];</span><br><span class="line">    Sub[<span class="number">0</span>] = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-堆分配存储表示"><a href="#2-2-堆分配存储表示" class="headerlink" title="2.2 堆分配存储表示"></a>2.2 堆分配存储表示</h2><p>字符串的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; HString;</span><br></pre></td></tr></table></figure><h2 id="2-3-串的块链存储表示"><a href="#2-3-串的块链存储表示" class="headerlink" title="2.3 串的块链存储表示"></a>2.3 串的块链存储表示</h2><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/4_串.md/串的块链存储结构.svg" alt="串的块链存储结构.svg" style="zoom: 30%"></p><p>为了便于进行串的操作，当以链表储存串值时，除头指针外，还可以附设一个尾指针，指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串的存储结构为<strong>块链结构</strong>。</p><p><strong>串的块链存储结构的数据结构</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块链结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> chunkChars[CHUNKSIZE]; <span class="comment">// 字符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span>         <span class="comment">// 指向下一个块的指针</span></span><br><span class="line">&#125; Chunk;</span><br><span class="line"><span class="comment">// 串的块链结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Chunk *head; <span class="comment">// 串的头指针</span></span><br><span class="line">    Chunk *tail; <span class="comment">// 串的尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;  <span class="comment">// 串的当前长度</span></span><br><span class="line">&#125; LString;</span><br></pre></td></tr></table></figure><p><strong>存储密度</strong>的概念：</p><script type="math/tex; mode=display">\displaystyle {\large \mathbb{\text{存储密度} =\frac{串值所占存储位}{实际分配的存储位} } }</script><h1 id="三、串的模式匹配算法"><a href="#三、串的模式匹配算法" class="headerlink" title="三、串的模式匹配算法"></a>三、串的模式匹配算法</h1><h2 id="3-1-求子串位置的定位函数"><a href="#3-1-求子串位置的定位函数" class="headerlink" title="3.1 求子串位置的定位函数"></a>3.1 求子串位置的定位函数</h2><p><strong>字串的定位操作通常称作串的模式匹配，是各种串处理系统中最重要的操作之一</strong>。定位函数的算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255                         <span class="comment">// 用户可在255以内定义最大串长</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> SString[MAXSTRLEN + <span class="number">1</span>]; <span class="comment">// 0号单元存放串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span>;</span><br><span class="line"></span><br><span class="line">SString str = &#123;<span class="number">10</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    SString t = &#123;<span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;;</span><br><span class="line">    a = Index(str, t, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 结果是: 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = pos; <span class="comment">// 主串索引从pos开始</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;       <span class="comment">// 模式串从 1 开始匹配</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt;= S[<span class="number">0</span>] &amp;&amp; i &lt;= T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果字符对应相等，则前往下一个字符位置</span></span><br><span class="line">        <span class="keyword">if</span> (S[index] == T[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ++index;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不相等，主串回到上一次（第一次）匹配字符的下一位置，重新匹配</span></span><br><span class="line">        <span class="comment">// 模式串从 1 开始，重新匹配</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = index - i + <span class="number">2</span>; <span class="comment">// index = index - (i - 1) + 1;</span></span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; T[<span class="number">0</span>]) <span class="comment">// 匹配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> index - T[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 匹配失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的基本思想是：从主串 S 的第 pos 个字符起和模式的第一个字符比较之，若相等，则继续逐个比较后续字符；否则，从主串的下一个字符起，再重新和模式的字符比较之。依次类推，直至模式 T 中的每个字符依次和主串 S 中的一个连续的字符序列相等，则称<strong>匹配成功</strong>，函数值为和模式 T 中第一个字符相等的字符，在主串 S 中的序号；否则称<strong>匹配不成功</strong>，函数值为零。</p><blockquote><ul><li><strong>算法的时间复杂度为： $\displaystyle O(n+m)$</strong>；</li><li><strong>算法在坏的情况下，时间复杂度为：$\displaystyle O(n \times m)$</strong>。</li></ul></blockquote><h2 id="3-2-模式匹配的改进算法（KMP-算法）"><a href="#3-2-模式匹配的改进算法（KMP-算法）" class="headerlink" title="3.2 模式匹配的改进算法（KMP 算法）"></a>3.2 模式匹配的改进算法（KMP 算法）</h2><p>这种改进算法是 <code>D.E.Knuth</code> 与 <code>VRPratt</code> 和 <code>JHMorris</code> 同时发现的,因此人们称它为<strong>克努特一莫里斯一普拉特操作（简称为 KMP 算法）</strong>。此算法可以在 <code>O(n+m)</code> 的时间数量级上完成串的模式匹配操作。</p><p>其改进在于：每当一趟匹配过程中出现字符比较不等时，不需回溯 <code>i</code> 指针，而是利用已经得到的“部分匹配”的结果，将模式向右“滑动”尽可能远的一段距离后，继续进行比较。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/4_串.md/KMP算法过程举例.png" alt="KMP算法过程举例" style="zoom: 150%"></p><p>现在讨论一般情况。假设主串为 $\displaystyle ‘S_{0} S_{1} S_{2} \cdots S_{n-1} ‘$ ，模式串为 $\displaystyle ‘P_{0} P_{1} P_{2} \cdots P_{m-1} ‘$ 。实现改进算法需要解决下列问题：<strong>当匹配过程产生“失配”时，模式串“向右滑行”的距离需要多远？</strong></p><blockquote><p>换句话说，当主串中位置 $i$ 字符与模式中位置 $j$ 字符“失配”时，主串中位置 $i$ 字符应与模式串中那个字符在比较？</p></blockquote><p>假设，当与模式串中的位置 $j$ 个字符串进行比较时，发生了 “失配”，因此，能够得到下列关系：（即前 $j$ 个字符对应相等，匹配正确）</p><script type="math/tex; mode=display">\displaystyle 'S_{i-j} S_{i-j+1} \cdots S_{i-1} '= 'P_{0} P_{1} P_{2} \cdots P_{j-1} '</script><p>并且，接下来应该将模式串向右滑动一段距离，即主串位置 $i$ 的字符与模式串中 $\displaystyle ‘P_{0} P_{1} P_{2} \cdots P_{j-1} ‘$ 子串的某个字符进行比较。因此，假设“应当”与模式串中位置 $k$ 字符进行比较（显然，$\displaystyle k&lt;j-1$，而“<strong>满足比较</strong>”的前提是：模式串中前 $k$ 个字符串与主串中位置 $i$ 字符之前的 $k$ 个字符串匹配成功，即：</p><script type="math/tex; mode=display">\displaystyle 'P_{0} P_{1} P_{2} \cdots P_{j-1} '='S_{i-k} S_{i-k+1} \cdots S_{i-1} '</script><blockquote><p>简单来讲，就是模式串中前 $j$ 个字符 $\displaystyle ‘P_{0} P_{1} P_{2} \cdots P_{j-1} ‘$ 子串中，前 $k$ 个字符的子串与后 $k$ 个字符的子串能够<strong>匹配成功</strong>。</p><p>并且模式串向右滑动 $j-k$ 个字符，就满足“比较”的条件。</p></blockquote><p>因此，构造一个数组，存储的是模式串每一个位置如果发生“失配”后，重新与主串比较的位置，即 $k$ 。令 $\displaystyle \mathrm{text}\left [ j \right ]  =k$ ，得：</p><script type="math/tex; mode=display">\displaystyle \mathrm{next}\left [ j \right ] = \left\{\begin{matrix}-1 & & j=0\\ 0 & & j=1\\ k & & 1< j< m-1\end{matrix}\right.</script><p>例如：书本 <code>P80</code> 的模式串 <code>abcac</code> 的 <code>next</code> 数组为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">$j$</th><th style="text-align:center">位置 $j$ 之前的子串</th><th style="text-align:right">子串开头开始</th><th style="text-align:left">子串结尾开始</th><th>$\displaystyle \mathrm{next}\left [ j \right ]$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">空</td><td style="text-align:right">空</td><td style="text-align:left">空</td><td>-1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">a</td><td style="text-align:right"></td><td style="text-align:left"></td><td>0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">ab</td><td style="text-align:right">a</td><td style="text-align:left">b</td><td>0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">abc</td><td style="text-align:right">a, ab</td><td style="text-align:left">bc, c</td><td>0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">abca</td><td style="text-align:right"><strong>a</strong>, ab, abc,</td><td style="text-align:left">bca, ca, <strong>a</strong></td><td>1</td></tr></tbody></table></div><p>再举个 <code>ABAABCAC</code> 的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:center">$j$</th><th style="text-align:center">位置 $j$ 之前的子串</th><th style="text-align:right">子串开头开始</th><th style="text-align:left">子串结尾开始</th><th style="text-align:center">$\displaystyle \mathrm{next}\left [ j \right ]$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">空</td><td style="text-align:right">空</td><td style="text-align:left">空</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">A</td><td style="text-align:right"></td><td style="text-align:left"></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">AB</td><td style="text-align:right">A</td><td style="text-align:left">B</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ABA</td><td style="text-align:right"><strong>A</strong>, AB</td><td style="text-align:left">BA, <strong>A</strong></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">ABAA</td><td style="text-align:right"><strong>A</strong>, AB, ABA</td><td style="text-align:left">BAA, AA, <strong>A</strong></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ABAAB</td><td style="text-align:right">A, <strong>AB</strong>, ABA, ABAA</td><td style="text-align:left">BAAB, AAB, <strong>AB</strong>, B</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ABAABC</td><td style="text-align:right">A, AB, ABA, ABAA, ABAAB</td><td style="text-align:left">BAABC, AABC, ABC, BC, C</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ABAABCA</td><td style="text-align:right"><strong>A</strong>, AB, ABA, ABAA, ABAAB, ABAABC</td><td style="text-align:left">BAABCA, AABCA, ABCA, BCA, CA, <strong>A</strong></td><td style="text-align:center">1</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 栈和队列【数据结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-栈和队列【数据结构】"><a href="#第三章-栈和队列【数据结构】" class="headerlink" title="第三章 栈和队列【数据结构】"></a>第三章 栈和队列【数据结构】</h1><blockquote><p>快速导航：</p><ul><li><a href="./01.绪论">第一章 绪论【数据结构】</a></li><li><a href="./02.线性表">第二章 线性表【数据结构】</a></li><li><a href="./03.栈和队列">第三章 栈和队列【数据结构】</a></li><li><a href="./04.串">第四章 串【数据结构】</a></li><li><a href="./05.数组和广义表">第五章 数组和广义表【数据结构】</a></li><li><a href="./06.数和二叉树">第六章 数和二叉树【数据结构】</a></li><li><a href="./07.图Graph">第七章 图(Graph)【数据结构】</a></li><li><a href="./09.查找">第九章 查找【数据结构】</a></li></ul></blockquote><h1 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h1><h2 id="1-1-栈的定义"><a href="#1-1-栈的定义" class="headerlink" title="1.1 栈的定义"></a>1.1 栈的定义</h2><p><strong>栈</strong>（Stack）是一种特殊的线性表，<strong>它只能在表的一端进行插入和删除操作</strong>，这一端被称为<strong>栈顶（Top）</strong>，另一端被称为<strong>栈底（Bottom）</strong>。栈的特点是“<strong>先进后出</strong>”（Last In First Out，LIFO），即<strong>最后插入的元素最先被删除，而最先插入的元素最后被删除</strong>。</p><blockquote><p>象一下生活中的<strong>羽毛球筒</strong>，就是先放进去的在底部，最后才能拿出来；后放进去的在顶部，最先拿出来。</p></blockquote><p>栈的抽象数据类型中包含一下方法：</p><ol><li><code>InitStack( &amp;S )</code> ：构造一个空栈；</li><li><code>DestoryStack( &amp;S )</code> ：将栈 S 销毁；</li><li><code>ClearStack( &amp;S )</code> ：将栈 S 清空；</li><li><code>StackEmpty( S )</code> ：如栈 S 为空，则返回 TURE；反之，则返回 FALSER；</li><li><code>StackLength( S )</code> ：返回栈 S 的元素个数，即栈的长度；</li><li><code>GetTop( S, &amp;e )</code> ：返回栈顶的元素到 e</li><li><code>Push( &amp;S, e)</code> ：插入元素 e 为新的栈顶</li><li><code>Pop( &amp;S, &amp;e)</code> ：删除 S 的栈顶元素，并用 e 返回其值</li><li><code>StackTraverse( S, visit())</code> ：从栈底到栈顶依次对 S 的每个数据元素调用函数 <code>visit()</code> 。一旦<code>visit()</code> 失败，则操作失败。</li></ol><h2 id="1-2-栈的表示和实现"><a href="#1-2-栈的表示和实现" class="headerlink" title="1.2 栈的表示和实现"></a>1.2 栈的表示和实现</h2><p>栈也有两种存储表示方法。</p><ul><li><p>顺序栈，即栈的顺序存储结构，是利用一组地址连续的存储单元，依次存放自栈底到栈顶的数据元素，同时附设指针 <code>top</code> 指示栈顶的元素在顺序表中的元素位置。</p><p> 由于栈在使用过程中，所需要的最大空间的大小难以估计，因此，一般来说，在初始化设空栈时，不应限定栈的最大容量。一个合理的做法是：</p><ol><li>先给栈分配一个基本容量；</li><li><p>在应用过程中，当栈的空间不够使用时再逐段扩大。</p><p><strong>顺序栈的数据模型</strong>如下：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE = 100; <span class="comment">// 存储空间初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT = 10; <span class="comment">// 存储空间分配增量，每一次扩充栈，都是以 10 个元素为单位</span></span></span><br><span class="line"><span class="comment">// 数据域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType* base; <span class="comment">// 栈底指针</span></span><br><span class="line">    SElemType* top; <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> stacksize; <span class="comment">// 栈的元素个数</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><p> 上面的<strong>顺序栈</strong>有以下关系：</p><ol><li>当 <code>base == NULL</code> 时，栈不存在；</li><li>当 <code>base != NULL &amp;&amp; base == top</code> 时，栈为空，此时<code>stacksize == 1</code> ；</li><li>指针 <code>top</code> 永远指向<strong>栈顶的下一个元素位置</strong>，其指向的位置随栈的变化而变化；</li><li>指针 <code>base</code> 永远指向栈底的位置，并且不会改变；</li></ol></li><li><p>链栈，采用链式结构实现栈的表示和实现。</p></li></ul><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/栈顶指针和栈中元素之间的关系.svg" alt="栈顶指针和栈中元素之间的关系.svg" style="zoom: 100%"></p><h1 id="二、栈的应用"><a href="#二、栈的应用" class="headerlink" title="二、栈的应用"></a>二、栈的应用</h1><h2 id="2-1-数制转换"><a href="#2-1-数制转换" class="headerlink" title="2.1 数制转换"></a>2.1 数制转换</h2><p>二进制、八进制、十六进制，这种进制都是 2 的倍数，因此在转换之间很简单。日常生活中，使用较多的是十进制，但是计算机常用的是二进制、十六进制，因此，<strong>十进制数与其他进制数的转换是计算机实现计算的基本问题</strong>。</p><p>其解决方法有很多，下面是一个简单的方法： $\displaystyle (1348)_{10} = (2504)_{8} $</p><script type="math/tex; mode=display">\begin{align}1348{\div} 8 &=168\cdots \cdots 4\\ 168{\div} 8 &=21\cdots \cdots 0\\ 21{\div} 8 &=2\cdots \cdots 5\\ 2{\div} 8 &=0\cdots \cdots 2\\ \end{align}</script><p>就是不断用正数结果除以 8（对应的进制数），然后根据运算的先后顺序，从后往前输出对应的<strong>余数</strong>。</p><p>@算法 3-1 ：栈的应用：进制转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法 3-1 ：栈的应用——进制转换：十进制数 n 转换为 d 进制数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">conversion</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SqStack s;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">SElemType e;</span><br><span class="line">InitStack(&amp;s); <span class="comment">// 初始化空栈 s</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N); <span class="comment">// 输入一个十进制数 N</span></span><br><span class="line"><span class="keyword">while</span> (N)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;s, N % <span class="number">8</span>); <span class="comment">// N 除以 8 的余数进栈</span></span><br><span class="line">N = N / <span class="number">8</span>; <span class="comment">// N 除以 8 的商作为新的 N</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!StackEmpty(s))</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;e); <span class="comment">// 弹出栈顶元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, e); <span class="comment">// 打印栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-括号匹配"><a href="#2-2-括号匹配" class="headerlink" title="2.2 括号匹配"></a>2.2 括号匹配</h2><p>对于一个含有 <code>()</code> 、 <code>[]</code> 、 <code>&#123;&#125;</code> 的行运算表达式，由于添加了括号，会改变运算的顺序。</p><p><strong>括号匹配</strong>：运算表达式中，括号都是成对出现的，并且允许嵌套。那么，针对嵌套的括号，当匹配到做括号时，就把它入栈，匹配到对应的右括号时，就出栈。</p><blockquote><p>在算法中，每读入一个括号，如果是左括号就入栈；如果是右括号，则将栈顶元素出栈，并且比较二者的括号类型，括号类型不一致就是不合法的情况。</p></blockquote><h2 id="2-3-行编辑程序"><a href="#2-3-行编辑程序" class="headerlink" title="2.3 行编辑程序"></a>2.3 行编辑程序</h2><p>当存在程序跳转语句的时候，就需要把当前指令地址进行入栈处理；当跳转语句结束后，就把栈中的指令地址弹出，使其能够<strong>继续执行原来的逻辑顺序</strong>。</p><p>假设用户输入的是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whli##ilr#e(s# *s)</span><br></pre></td></tr></table></figure><p>其中， <code>#</code> 代表删除键，那么最终结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while( *s)</span><br></pre></td></tr></table></figure><h2 id="2-4-迷宫求解"><a href="#2-4-迷宫求解" class="headerlink" title="2.4 迷宫求解"></a>2.4 迷宫求解</h2><p>求迷宫中一条从入口到出口的路径算法，可简单描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    若: 当前位置可通,</span><br><span class="line">    则&#123;</span><br><span class="line">        将当前位置插入栈顶,</span><br><span class="line">        若: 当前位置是出口位置, 则: 结束;</span><br><span class="line">        否则: 切换当前位置的东邻方块为新的当前位置</span><br><span class="line">    &#125;</span><br><span class="line">    否则&#123;</span><br><span class="line">        若: 栈不空，且栈顶位置尚有其他方向未经探索,</span><br><span class="line">        则: 设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一相邻快;</span><br><span class="line">        若: 栈不空，但是栈顶位置的四周均不可通,</span><br><span class="line">        则&#123;</span><br><span class="line">                删除栈顶位置;</span><br><span class="line">                若: 栈不空，则重新测试新的栈顶位置,</span><br><span class="line">                直至找到一个可通的相邻快或者出栈至栈空</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;while(栈不为空)</span><br></pre></td></tr></table></figure><h2 id="2-5-表达式求值"><a href="#2-5-表达式求值" class="headerlink" title="2.5 表达式求值"></a>2.5 表达式求值</h2><p>要对一个算术表达式求值，首先要了解算术四则运算的规则。即：</p><ol><li>先乘除，后加减；</li><li>从左到右；</li><li>先括号内，在括号外；</li></ol><blockquote><p>任何一个表达式都是由<strong>操作数</strong>、<strong>运算符</strong>和<strong>界限符</strong>组成的，称之为<strong>单词</strong>。</p></blockquote><p>为了实现优先算法，可以使用两个工作栈。一个称作 <code>OPTR</code> ，用以寄存运算符；另外一个称作 <code>OPND</code> ，用于寄存操作数或原运算结果。算法的基本思想是：</p><ol><li>首先，置操作数栈为空，表达式起始符 <code>#</code> ；</li><li>依次读入表达式中的每个字符，<ol><li>如果是操作数，则进 <code>OPND</code> 栈；</li><li>如果是运算符，则和 <code>OPTR</code> 栈的栈顶运算符比较优先权后，做出相应的操作；</li></ol></li><li>直至整个表达式求值完毕。</li></ol><p>@算法 3-4 ：表达式求值（由书本的代码改进而来）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OperandType <span class="title function_">EvaluateExpression</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(OPTR);    Push(OPTR,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    InitStack(OPND);</span><br><span class="line">    C = getchar(); <span class="comment">// 依次读取表达式的各各字符</span></span><br><span class="line">    <span class="comment">// 如果 C == &#x27;#&#x27; &amp;&amp; GetTop(OPTR) == &#x27;#&#x27; 满足，就说明表达式的左右都已到达界限，该表达式解析完毕</span></span><br><span class="line">    <span class="keyword">while</span>( !(C == <span class="string">&#x27;#&#x27;</span> &amp;&amp; GetTop(OPTR) == <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(C == 数字)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(OPND, C);</span><br><span class="line">            C = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(比较: GetTop(OPTR) 和 C )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span> : <span class="comment">//  新的运算符优先级高，因此栈中的运算先不处理；但是无法知道后续运算的优先级，因此暂时将当前的运算符入栈</span></span><br><span class="line">                    Push(OPTR, C);</span><br><span class="line">                    C = getchar(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span> : <span class="comment">// 要么匹配括号，要么表达式结束</span></span><br><span class="line">                    Pop(OPTR, C);</span><br><span class="line">                    C = getchar(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span> : <span class="comment">// 新的运算符优先级低，就需要处理栈中高优先级的运算</span></span><br><span class="line">                    Pop(OPTR, theta);</span><br><span class="line">                    Pop(OPND, a);    Pop(OPND, b);</span><br><span class="line">                    result = Operate(a, theta, b)</span><br><span class="line">                    Push(OPND, result); <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GetTop(OPND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、栈与递归的实现"><a href="#三、栈与递归的实现" class="headerlink" title="三、栈与递归的实现"></a>三、栈与递归的实现</h1><p>栈还有一个重要应用是在程序设计语言上实现递归。一个直接调用自己或通过一系列的调用语句间接调用自己的函数，称作<strong>递归函数</strong>。</p><blockquote><p>递归函数在实际中，应当避免使用，因为递归会占用大量的栈内存，使用不当会导致<strong>爆栈</strong>。</p></blockquote><p>递归是程序设计中一个强有力的工具。其一、有很多数学函数是递归定义的，如阶乘函数：</p><script type="math/tex; mode=display">\displaystyle \mathrm{Fact}(n) \left\{\begin{matrix} 1 & n=0\\ n \cdot \mathrm{Fact}(n) & n> 0\end{matrix}\right.</script><p>其二，有的数据结构，如二叉树、广义表等，由于结构本身固有的递归特性；其三，还有一类问题本身没有明显的递归结构，但是用递归求解比迭代求解更简单，如八皇后问题、<code>Hanoi</code> 塔问题等。</p><hr><p>例题 3-2（ $n$ 阶 <code>Hanoi</code> 塔问题）：假设有 3 个分别命名为 X、Y 和 Z 的塔座，在塔座 X 上插有 n 个直径大小各不相同、依小到大编号为 $\displaystyle 1,2,\cdots ,n$ 的圆盘。现要求将 X 轴上的 n 个圆盘移至塔座 Z 上，并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：</p><ul><li>每次只能移动一个圆盘；</li><li>圆盘可以插在 X、Y 和 Z 中的任一塔座上；</li><li>任何时刻都不能将一个较大的圆盘压在较小的圆盘之上；</li></ul><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/汉诺塔实物模型.webp" alt="汉诺塔实物模型" style="zoom: 100%"></p><p>@算法 3-5 ：汉诺塔问题的递归步骤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉诺塔问题。将n个盘子从A柱子移动到C柱子，其中B柱子作为辅助柱子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> Source, <span class="type">char</span> Transfer, <span class="type">char</span> Target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        move(<span class="number">1</span>, Source, Target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Hanoi(n - <span class="number">1</span>, Source, Target, Transfer);</span><br><span class="line">        move(n, Source, Target);</span><br><span class="line">        Hanoi(n - <span class="number">1</span>, Transfer, Source, Target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> Source, <span class="type">char</span> Target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, Source, Target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h1><h2 id="4-1-队列的定义"><a href="#4-1-队列的定义" class="headerlink" title="4.1 队列的定义"></a>4.1 队列的定义</h2><p>和<strong>栈</strong>相反，<strong>队列</strong>是一种<strong>先进后出</strong>的线性表（<code>FIFO</code>），它只允许在表的一端进行插入，而在另一端删除元素。允许插入的一段叫做<strong>队尾</strong>，允许删除的一点则称为<strong>队头</strong>。</p><blockquote><p>队列在程序设计中也经常出现。一个最经典的例子就是操作系统的<strong>作业排队</strong>。</p></blockquote><p>队列的抽象数据类型中包含一下方法：</p><ol><li><code>InitQueue( &amp;Q )</code> ：构造一个队列；</li><li><code>DestoryQueue( &amp;S )</code> ：将队列 S 销毁；</li><li><code>ClearQueue( &amp;S )</code> ：将队列 S 清空；</li><li><code>QueueEmpty( S )</code> ：如队列 S 为空，则返回 TURE；反之，则返回 FALSER；</li><li><code>QueuekLength( S )</code> ：返回队列 S 的元素个数，即队列的长度；</li><li><code>GetHead( S, &amp;e )</code> ：返回队头的元素给 e</li><li><code>EnQueue( &amp;S, e)</code> ：插入元素 e 为新的队尾元素</li><li><code>DeQueue( &amp;S, &amp;e)</code> ：删除 S 的队头元素，并用 e 返回其值</li><li><code>QueueTraverse( S, visit())</code> ：从栈底到栈顶依次对 S 的每个数据元素调用函数 <code>visit()</code> 。一旦<code>visit()</code> 失败，则操作失败。</li></ol><p><strong>双端队列</strong>是限定插入和删除操作在表的两端进行的线性表。尽管双端队列看起来似乎比栈和队列更灵活，但是实际上在应用程序中远不及栈和队列，故仅作了解即可。</p><h2 id="4-2-链队列"><a href="#4-2-链队列" class="headerlink" title="4.2 链队列"></a>4.2 链队列</h2><p>用链表表示的队列简称<strong>链队列</strong>。<strong>一个链队列，显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定</strong>。</p><p>如下图所示：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/单链队列.svg" alt="单链队列.svg" style="zoom: 40%"></p><p>并且，当 <code>Q.front == Q.rear</code> 时，队列为空，如下如所示：</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/单链空队列.svg" alt="单链空队列.svg" style="zoom: 100%"></p><hr><p><strong>单链队列的数据结构</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造队列元素结点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType dataElem; <span class="comment">// 队列中的数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向队列中下一元素的指针</span></span><br><span class="line">&#125; QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造队列的队头和队尾的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QNode *frontPtr; <span class="comment">// 队头指针</span></span><br><span class="line">    QNode *rearPtr;  <span class="comment">// 队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ======================== 基本操作 =============================== */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QNode *newNode = (QNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!newNode)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    newNode-&gt;dataElem = e;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rearPtr-&gt;next = newNode;</span><br><span class="line">    Q.rearPtr = newNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.frontPtr == Q.rearPtr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    QNode *p = Q.frontPtr-&gt;next;</span><br><span class="line">    e = p-&gt;dataElem;</span><br><span class="line">    Q.frontPtr-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rearPtr == p)</span><br><span class="line">        Q.rearPtr = Q.frontPtr;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-循环队列"><a href="#4-3-循环队列" class="headerlink" title="4.3 循环队列"></a>4.3 循环队列</h2><p>在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放队列从头到尾的元素之外，尚需附设两个指针 <code>front</code> 和 <code>rear</code> 分别知识队列头元素及队列尾元素的位置。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/3_栈和队列.md/队列的顺序存储结构.svg" alt="队列的顺序存储结构.svg" style="zoom: 100%"></p><p>假设当前为队列分配的最大空间为 6 ，则当队列处于<strong>上图最后一个状态</strong>时，不能再继续插入新的队尾元素，否则会出现数组越界而导致程序代码被破坏。</p><blockquote><p>从上述分析可见，在 C 语言中，不能用动态分配的一维数组，来实现循环队列。如果用户的应用程序中设有循环队列，<strong>则必须为它设定一个最大队列长度</strong>，如果用户无法估计的最大程度，则宜采用链队列。</p></blockquote><p><strong>循环队列</strong>：一种巧妙的方法是，<strong>将顺序队列臆造</strong>成一个环状的空间。</p><p><strong>循环队列的数据结构</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100 <span class="comment">// 最大队列长度</span></span></span><br><span class="line"><span class="comment">// 循环队列的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base; <span class="comment">// 初始化的动态分配存储空间</span></span><br><span class="line">    <span class="type">int</span> front;       <span class="comment">// 队列头指针，若队列不空，指向队列头元素</span></span><br><span class="line">    <span class="type">int</span> rear;        <span class="comment">// 队列尾指针，若队列不空，指向队列尾元素的下一个位置</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------ 循环队列的基本操作的算法描述 -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空队列Q</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q.base = (QElemType *)<span class="built_in">malloc</span>(MAXQSIZE * <span class="keyword">sizeof</span>(QElemType));</span><br><span class="line">    <span class="keyword">if</span> (!Q.base)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取队列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front) <span class="comment">// 队列满</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue Q, QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">// 队列空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    *e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 线性表【数据结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E7%BA%BF%E6%80%A7%E8%A1%A8.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E7%BA%BF%E6%80%A7%E8%A1%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-线性表【数据结构】"><a href="#第二章-线性表【数据结构】" class="headerlink" title="第二章 线性表【数据结构】"></a>第二章 线性表【数据结构】</h1><blockquote><p>快速导航：</p><ul><li><a href="./01.绪论">第一章 绪论【数据结构】</a></li><li><a href="./02.线性表">第二章 线性表【数据结构】</a></li><li><a href="./03.栈和队列">第三章 栈和队列【数据结构】</a></li><li><a href="./04.串">第四章 串【数据结构】</a></li><li><a href="./05.数组和广义表">第五章 数组和广义表【数据结构】</a></li><li><a href="./06.数和二叉树">第六章 数和二叉树【数据结构】</a></li><li><a href="./07.图Graph">第七章 图(Graph)【数据结构】</a></li><li><a href="./09.查找">第九章 查找【数据结构】</a></li></ul></blockquote><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>线性结构的特点是：在数据元素的非空有限集中，</p><ol><li>存在唯一一个被称作“第一个”的数据元素；</li><li>存在唯一一个被称为“最后一个”的数据元素；</li><li>除第一个数据元素外，其余每个数据元素只有一个“前驱”元素；</li><li>除最后一个元素外，每个元素只有一个“后继”元素。</li></ol><h1 id="一、线性表的类型定义"><a href="#一、线性表的类型定义" class="headerlink" title="一、线性表的类型定义"></a>一、线性表的类型定义</h1><p><strong>线性表</strong>是最常用的且最简单的一种数据结构。一个线性表是 $n$ 个数据元素的有限序列。例如：</p><script type="math/tex; mode=display">\displaystyle \left ( A,B,C,D,\cdots  \right )</script><p>在复杂的线性表中，一个数据元素可以有若干个<strong>数据项</strong>组成。在这种情况下，常把数据元素称为<strong>记录</strong>，含有大量记录的线性表又称为<strong>文件</strong>。</p><p>线性表中元素的个数 $\displaystyle n(n\ge 0)$ 定义为线性表的<strong>长度</strong>， $\displaystyle n=0$ 时称为空表。在非空表中的每个数据元素都有一个确定的位置，如 $\displaystyle a_{1} $ 是第一个元素， $\displaystyle a_{n} $ 是最后一个数据元素， $\displaystyle a_{i} $ 是第 $\displaystyle i $ 个元素，称 $\displaystyle i $ 为数据元素 $\displaystyle a_{i} $ 在线性表中的<strong>位序</strong>。</p><p>抽象数据类型的线性表的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ADT List</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    Data data; <span class="comment">// 数据元素的集合</span></span><br><span class="line">    Relation relation; <span class="comment">// 集合中两两数据元素之间的关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    List <span class="title function_">InitList</span><span class="params">( &amp;L )</span>; <span class="comment">// 构造一个空的线性表L，其地址为&amp;L</span></span><br><span class="line">    DestoryList( &amp;L ); <span class="comment">// 线性表L存在的前提下，销毁线性表L(释放内存)</span></span><br><span class="line">    ClearList( &amp;L ); <span class="comment">// 线性表L存在的前提下，清空线性表L(不释放内存)</span></span><br><span class="line">    ListEmpty( L ); <span class="comment">// 线性表L存在的前提下，若L为空表，则返回TURE；反之，返回FALSE</span></span><br><span class="line">    ListLength( L ); <span class="comment">// 线性表L存在的前提下，返回L中数据元素的个数</span></span><br><span class="line">    GetElem( L , i , &amp;e ); <span class="comment">// 线性表L存在，并且i不超过最大索引值。返回第 i 个元素，并且用地址&amp;e接收</span></span><br><span class="line">    LocationElem( L, e, compare()); <span class="comment">// 返回L中第1个与e满足关系compare()的数据元素的位置。不存在则返回0</span></span><br><span class="line">    PriorElem( L, cur_e, &amp;pre_e); <span class="comment">// 返回cur_e的前驱给&amp;pre_e；否则操作失败，&amp;pre_e无定义</span></span><br><span class="line">    NextElem( L, cur_e, &amp;next_e); <span class="comment">// 返回cur_e的后继给&amp;next_e；否则操作失败，&amp;next_e无定义</span></span><br><span class="line">    ListInsert( &amp;L, i , e); <span class="comment">// 在L中的第i个元素位置，插入元素e</span></span><br><span class="line">    ListDelete( &amp;L, i, &amp;e); <span class="comment">// 删除L中的第i个数据元素</span></span><br><span class="line">    ListTraverse( L, visit()); <span class="comment">// 依次对L的每个数据元素调用函数visit()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、线性表的顺序表示和实现"><a href="#二、线性表的顺序表示和实现" class="headerlink" title="二、线性表的顺序表示和实现"></a>二、线性表的顺序表示和实现</h1><h2 id="2-1-顺序表的结构"><a href="#2-1-顺序表的结构" class="headerlink" title="2.1 顺序表的结构"></a>2.1 顺序表的结构</h2><p><strong>线性表的“顺序表示”指的是：用一组地址连续的存储单元，依次存储线性表的数据元素</strong>。</p><p>假设线性表的每个元素需占用 $l$ 个存储单元，应以所占的第一个单元的存储地址作为数据元素的存储位置。则线性表中第 $i+1$ 个数据元素的存储位置为：</p><script type="math/tex; mode=display">\displaystyle Loc(a_{i+1}) = Loc(a_{i}) + l</script><p>一般来说，线性表的第 $i$ 个数据元素 $\displaystyle a_{i} $ 的存储位置为：</p><script type="math/tex; mode=display">\displaystyle Loc( a_{i} ) = Loc(a_{1} ) + l\times (i-1)</script><p>@<strong>线性表的顺序存储结构的数据结构</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------- 线性表的动态分配顺序存储结构 ----------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100 <span class="comment">// 线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10 <span class="comment">// 线性表存储空间的分配增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType *elem; <span class="comment">// 存储空间基址</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">// 当前长度</span></span><br><span class="line"><span class="type">int</span> listsize; <span class="comment">// 当前分配的存储容量(以sizeof(ElemType)为单位)</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>由上述定义可知，线性表的顺序存储结构的特点是：</p><ol><li>数组的长度是固定的，需要事先定义；</li><li>如果插入元素而导致空间不足，可进行再分配。</li></ol><hr><p>@线性表的动态分配顺序存储结构的初始化，其算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2.3 线性表的动态分配顺序存储结构的初始化</span></span><br><span class="line">Status <span class="title function_">InitList_Sq</span><span class="params">(SqList&amp; L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造一个空的线性表L</span></span><br><span class="line">L.elem = (ElemType *)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="keyword">if</span> (!L.elem) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">// 存储分配失败</span></span><br><span class="line">L.length = <span class="number">0</span>; <span class="comment">// 空表长度为0</span></span><br><span class="line">L.listsize = LIST_INIT_SIZE; <span class="comment">// 初始存储容量</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">// InitList_Sq</span></span><br></pre></td></tr></table></figure><h2 id="2-2-插入操作"><a href="#2-2-插入操作" class="headerlink" title="2.2 插入操作"></a>2.2 插入操作</h2><p><strong>线性表的插入操作</strong>：在线性表的第 $i-1$ 个数据元素和第 $i$ 个数据元素之间，插入一个新的数据元素，并且线性表的长度由 $n$ 变为 $n+1$ ，同时，原本第 $i$ 个元素至第 $n$ 个元素以此向后移一个位置。</p><p><strong>一般情况下，在第 $\displaystyle i(0\le i \le n)$ 个元素之前，插入一个元素时，需将第 $i$ 至第第 $n$ 元素（共第 $n-(i-1) = n-i+1$ 个元素）向后移动一个位置</strong>。</p><p>@线性表的顺序存储结构的插入操作，其算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2.4 线性表的顺序存储结构的插入操作</span></span><br><span class="line">Status <span class="title function_">ListInsert_Sq</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在顺序线性表L中第i个位置之前插入新的元素e</span></span><br><span class="line"><span class="comment">// i的合法值为 1 &lt;= i &lt;= ListLength_Sq(L)+1</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR; <span class="comment">// i值不合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L.length &gt;= L.listsize) <span class="comment">// 当前存储空间已满,增加分配</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType *newbase = (ElemType *)<span class="built_in">realloc</span>(L.elem, (L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="keyword">if</span> (!newbase) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">// 存储分配失败</span></span><br><span class="line">L.elem = newbase; <span class="comment">// 新基址</span></span><br><span class="line">L.listsize += LISTINCREMENT; <span class="comment">// 增加存储容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType *q = &amp;(L.elem[i - <span class="number">1</span>]); <span class="comment">// q为插入位置</span></span><br><span class="line"><span class="keyword">for</span> (ElemType *p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; --p) <span class="comment">// 插入位置及之后的元素右移</span></span><br><span class="line">*(p + <span class="number">1</span>) = *p;</span><br><span class="line">*q = e; <span class="comment">// 插入e</span></span><br><span class="line">++L.length; <span class="comment">// 表长增1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">// ListInsert_Sq</span></span><br></pre></td></tr></table></figure><h2 id="2-3-删除操作"><a href="#2-3-删除操作" class="headerlink" title="2.3 删除操作"></a>2.3 删除操作</h2><p>线性表的删除操作，与插入操作相反。<strong>一般情况下，删除第 $\displaystyle i(0\le i \le n)$ 个元素，需将第 $i+1$ 至第 $n$ 元素（共 $n-i$ 个元素）依次向前移动一个位置</strong>。</p><p>@算法 2-5 ：顺序表的删除操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2.5 线性表的顺序存储结构的删除操作</span></span><br><span class="line">Status <span class="title function_">ListDelete_Sq</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在顺序线性表L中删除第i个元素,并用e返回其值</span></span><br><span class="line"><span class="comment">// i的合法值为 1 &lt;= i &lt;= ListLength_Sq(L)</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length) <span class="keyword">return</span> ERROR; <span class="comment">// i值不合法</span></span><br><span class="line"></span><br><span class="line">    ElemType *p = &amp;(L.elem[i - <span class="number">1</span>]); <span class="comment">// p为被删除元素的位置</span></span><br><span class="line">e = *p; <span class="comment">// 被删除元素的值赋给e</span></span><br><span class="line">ElemType *q = L.elem + L.length - <span class="number">1</span>; <span class="comment">// 表尾元素的位置</span></span><br><span class="line"><span class="keyword">for</span> (p +=<span class="number">1</span> ; p &lt;= q; ++p) <span class="comment">// 被删除元素之后的元素左移</span></span><br><span class="line">*(p - <span class="number">1</span>) = *p;</span><br><span class="line">--L.length; <span class="comment">// 表长减1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">// ListDelete_Sq</span></span><br></pre></td></tr></table></figure><h2 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h2><p>假定在线性表中的，任何位置上的插入或者删除元素都是等概率的，那么在顺序存储结构的线性表中，插入或者删除一个数据元素，平均需要移动表中一半的元素。<strong>时间复杂度为 $O(n)$ </strong>。</p><h1 id="三、线性表的链式表示和实现"><a href="#三、线性表的链式表示和实现" class="headerlink" title="三、线性表的链式表示和实现"></a>三、线性表的链式表示和实现</h1><h2 id="3-1-线性链表"><a href="#3-1-线性链表" class="headerlink" title="3.1 线性链表"></a>3.1 线性链表</h2><p>线性表的链式存储结构特点是：用一组“任意”的存储单元存储线性表的数据元素。除了存储本身外，还需要存储一个指示其直接后继的信息。这两部分信息组成的数据元素的存储映像，称为<strong>结点</strong>。它包含有两个域：</p><ul><li>存储数据元素的域称为<strong>数据域</strong></li><li>存储直接后继存储位置的域称为<strong>指针域</strong></li></ul><p>指针域中存储的信息称为<strong>指针或链</strong>。 $n$ 个结点链结成一个<strong>链表</strong>，即为线性表：</p><script type="math/tex; mode=display">\displaystyle (a_{1}, a_{2},\cdots ,a_{n})</script><p>的<strong>链式存储结构</strong>。又有于此链表的每个节点中只包含一个指针域，故又称<strong>线性链表</strong>或<strong>单链表</strong>。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/2_线性表.md/单链表.svg" alt="单链表.svg" style="zoom: 100%"></p><p>整个链表的存取必须从<strong>头指针</strong>开始进行，头指针指示链表中第一个结点的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为“空”，即<code>NULL</code>。</p><p>有时，我们在单链表的第一个结点之前附设一个结点，称之为<strong>头结点</strong>。<strong>头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等类的附加信息，头结点的指针域存储指向第一个元素结点的指针</strong>。</p><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/2_线性表.md/带头结点的单链表.svg" alt="带头结点的单链表.svg" style="zoom: 100%"></p><p><strong>单链表的数据结构</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;      <span class="comment">// 数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125; LNode, * LinkList;</span><br></pre></td></tr></table></figure><blockquote><p>在单链表中，取得第 $i$ 个元素，必须从头指针出发寻找，因此，<strong>单链表是非随机存取的存储结构</strong>。</p></blockquote><p>@算法 2-8 ：获取单链表中，第 $i$ 个元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2.8 获取单链表的第 i 个元素</span></span><br><span class="line">Status <span class="title function_">GetElem_L</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType&amp; e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// L为带头结点的单链表的头指针</span></span><br><span class="line"><span class="comment">// 当第i个元素存在时,其值赋给e并返回OK,否则返回ERROR</span></span><br><span class="line">LNode *p = L-&gt;next; <span class="comment">// 初始化,p指向第一个结点,j为计数器</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>; <span class="comment">// j为计数器</span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">// 顺指针向后查找,直到p指向第i个元素或p为空</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i) <span class="keyword">return</span> ERROR; <span class="comment">// 第i个元素不存在</span></span><br><span class="line">e = p-&gt;data; <span class="comment">// 取第i个元素</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">// GetElem_L</span></span><br></pre></td></tr></table></figure><blockquote><p>上述算法的基本操作是：比较 $i$ 与 $j$ 的值并后移指针，因此，<strong>时间复杂度为 $O(n)$ </strong>。</p></blockquote><p>@算法 2-9 ：单链表的插入操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2.9 单链表的插入操作</span></span><br><span class="line">Status <span class="title function_">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在带头结点的单链线性表L中第i个位置之前插入元素e</span></span><br><span class="line"><span class="comment">// i的合法值为 1 &lt;= i &lt;= ListLength(L)+1</span></span><br><span class="line">LNode *p = L; <span class="comment">// 初始化,p指向头结点,j为计数器</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) <span class="comment">// 寻找第i-1个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>) <span class="keyword">return</span> ERROR; <span class="comment">// i小于1或者大于表长加1</span></span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 生成新结点</span></span><br><span class="line">s-&gt;data = e; <span class="comment">// 插入L中</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">// ListInsert_L</span></span><br></pre></td></tr></table></figure><p>@算法 2-10 ：单链表的删除操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2.10 单链表的删除操作</span></span><br><span class="line">Status <span class="title function_">ListDelete_L</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在带头结点的单链线性表L中,删除第i个元素,并由e返回其值</span></span><br><span class="line"><span class="comment">// i的合法值为 1 &lt;= i &lt;= ListLength(L)</span></span><br><span class="line">LNode *p = L; <span class="comment">// 初始化,p指向头结点,j为计数器</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="number">1</span>) <span class="comment">// 寻找第i个结点,并令p指向其前趋</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || j &gt; i - <span class="number">1</span>) <span class="keyword">return</span> ERROR; <span class="comment">// 删除位置不合理</span></span><br><span class="line">LNode *q = p-&gt;next; <span class="comment">// 删除并释放结点</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">e = q-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">// ListDelete_L</span></span><br></pre></td></tr></table></figure><blockquote><p>在插入或者删除结点时，必须先找到对应的结点位置。<strong>时间复杂度为 $O(n)$ </strong>。</p></blockquote><h2 id="3-2-循环链表"><a href="#3-2-循环链表" class="headerlink" title="3.2 循环链表"></a>3.2 循环链表</h2><p><strong>循环链表</strong>是一种链表数据结构，与普通链表的不同之处在于<strong>它的最后一个节点指向链表的第一个节点</strong>。</p><ul><li>优点：可以轻松地实现循环遍历操作；</li><li>缺点：比普通链表的操作要稍微复杂一些；</li><li>另外，循环链表也需要注意避免出现死循环的情况。</li></ul><p><img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/2_线性表.md/循环链表.svg" alt="循环链表.svg" style="zoom: 100%"></p><p>循环链表的操作和线性链表基本一致，差别仅在于<strong>算法中的循环条件不是 <code>p == NULL</code> 或者是 <code>P-&gt;next == NULL</code> ，而是是否等于头结点指针</strong>。</p><h2 id="3-3-双向链表"><a href="#3-3-双向链表" class="headerlink" title="3.3 双向链表"></a>3.3 双向链表</h2><p>前面讨论的结点中只有一个<strong>直接后记</strong>的指针域，因此，从某个节点出发，只能顺指针往后巡查其它节点。为克服单链表这种单向性的缺点，可利用<strong>双向链表</strong>。</p><p><strong>双向链表</strong>：在指针域使用两个指针，分别指向该元素结点的<strong>直接前驱</strong>和<strong>直接后继</strong>，而数据域不发生任何改变，这样的链表称为<strong>双向链表</strong>。</p><p><strong>双向链表的数据结构</strong>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------- 双向链表 ----------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span> <span class="comment">// 直接前驱指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span> <span class="comment">// 直接后继指针</span></span><br><span class="line">&#125; DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure><blockquote><p>双向链表也可以有循环链表。</p></blockquote><p>三种链表的优缺点：</p><ul><li>单项链表和循环链表：只能进行<strong>单向的遍历访问</strong>，如果链表的长度很大，可能会遍历整个链表</li><li>双向链表：能够双向的进行遍历，不仅能知道<strong>直接后继</strong>，也能知道<strong>直接前驱</strong>。</li><li>双向链表：会<strong>额外增加一部分内存</strong>，以便于存放<strong>指向直接前驱的指针</strong>。</li></ul><blockquote><p>由于链表在空间的合理利用上，以及插入、删除时不需要移动等的优点，因此，在很多场合下，<strong>链表是线性表的首选存储结构</strong>。</p><p>然而，也存在着某些基本操作不如顺序存储结构的缺点。</p></blockquote><h1 id="四、一元多项式的表示及相加"><a href="#四、一元多项式的表示及相加" class="headerlink" title="四、一元多项式的表示及相加"></a>四、一元多项式的表示及相加</h1><p><strong>符号多项式的操作，已经成为表处理的典型应用</strong>。在数学上，一个一元多项式 $\displaystyle P_{n} (x)$ 可按升幂写成：</p><script type="math/tex; mode=display">\displaystyle P_{n} (x) = p_{0} x^{0} +p_{1} x^{1} +p_{2} x^{2} +\cdots +p_{n} x^{n}</script><p>它是由 $n+1$ 个系数唯一确定。因此在计算机里，它可以用一个线性表 $P$ 来表示：</p><script type="math/tex; mode=display">\displaystyle P_{n} = (p_{0}, p_{1},p_{2},\cdots ,p_{n})</script><p>假设 $\displaystyle Q_{m} (x)$ 是一元 $m$ 次多项式，同样可用线性表 $Q$ 表示：</p><script type="math/tex; mode=display">\displaystyle Q_{n} = (q_{0}, q_{1},q_{2},\cdots ,q_{n})</script><p>了不失一般性，设 $\displaystyle m&lt; n$ ，则两个多项式相加的结果为可用线性表 $R$ 表示：</p><script type="math/tex; mode=display">\displaystyle \displaystyle R_{n} = (p_{0}+q_{0}, p_{01}+q_{01},p_{2}+q_{2},\cdots ,p_{m}+q_{m},p_{m+1},p_{m+2},\cdots ,p_{n})</script><p>显然，我们可以对 $P,Q,R$ 采用顺序存储结构，使得多项式相加的算法定义的十分简单。然而，在通常的应用中，<strong>多项式的次数可能很高且变化很大</strong>，使得顺序存储结构的最大长度很难确定。例如下面形式：</p><script type="math/tex; mode=display">\displaystyle S(x) = 1+3x^{10000} +2x^{20000}</script><p>如果用上述的线性表来表示，就要用一长度为 20001 的线性表，表中仅有三个非零元素，这种对存储空间的浪费时应当避免的。</p><p>因此，<strong>使用链表只存储非零的幂项元素，链表结点的数据域包含两个元素，当前的系数以及幂指数</strong>。</p><p><strong>运算规则如下</strong>：假设指针 <code>qa</code> 和指针 <code>qb</code> 分别指向多项式 $A$ 和多项式 $B$ 中当前比较的某个结点，比较结点中的指数项，有三种情况：</p><ol><li>指针 <code>qa</code> 所指结点的指数值 &lt; 指针 <code>qb</code> 所指结点的指数值，则应摘取 <code>qa</code> 指针所指结点插入到“<strong>和多项式</strong>”链表中去；</li><li>指针 <code>qa</code> 所指结点的指数值 &gt; 指针 <code>qb</code> 所指结点的指数值，则应摘取 <code>qb</code> 指针所指结点插入到“<strong>和多项式</strong>”链表中去；</li><li>指针 <code>qa</code> 所指结点的指数值 = 指针 <code>qb</code> 所指结点的指数值，则将两个结点中的系数相加：<ul><li>若和数不为零，则修改 <code>qa</code> 所指结点的系数值，同时释放 <code>qb</code> 所指结点；</li><li>反之，释放 <code>qa</code> 和 <code>qb</code> 所指结点；</li></ul></li></ol><p><strong>注意事项</strong>：</p><ol><li>多项式的第一项元素的系数大于零，不需要添加 <code>+</code> ；</li><li>多项式系数为 0 的项，不需要存储；</li><li>多项式系数为 1 的项，不需要打印数字 <code>1</code> 。</li></ol><p>@算法 2-22 ：建立多项式的数据结构模型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------- 多项式相加 ----------</span></span><br><span class="line"><span class="comment">// 这是书本上的多项式相加的方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> coef; <span class="comment">// 系数</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">exp</span>;  <span class="comment">// 指数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系数-指数</span></span><br><span class="line"><span class="type">int</span> LA[][<span class="number">2</span>] = &#123; &#123;<span class="number">7</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">8</span>&#125;, &#123;<span class="number">5</span>, <span class="number">17</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> LB[][<span class="number">2</span>] = &#123; &#123;<span class="number">8</span>, <span class="number">1</span>&#125;, &#123;<span class="number">22</span>, <span class="number">7</span>&#125;, &#123;<span class="number">-9</span>, <span class="number">8</span>&#125;, &#123;<span class="number">3</span>, <span class="number">16</span>&#125;, &#123;<span class="number">5</span>, <span class="number">17</span>&#125;, &#123;<span class="number">6</span>, <span class="number">18</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//然后构造一个将多项式元素的数组转化为链表的方法。代码如下：</span></span><br><span class="line">Node* <span class="title function_">changeToList</span><span class="params">(<span class="type">int</span> data[][<span class="number">2</span>], <span class="type">int</span> row, <span class="type">int</span> <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Node* head = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 创建头结点</span></span><br><span class="line">head-&gt;coef = <span class="number">0</span>;</span><br><span class="line">head-&gt;<span class="built_in">exp</span> = <span class="number">-1</span>;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Node* current = head; <span class="comment">// 当前结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line">Node* tmp = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">tmp-&gt;coef = data[i][<span class="number">0</span>];</span><br><span class="line">tmp-&gt;<span class="built_in">exp</span> = data[i][<span class="number">1</span>];</span><br><span class="line">tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">current-&gt;next = tmp;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着构造一个将链表打印成多项式的方法。代码如下：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNodeList</span><span class="params">(Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line">Node* current = head-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;多项式为: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;P(x)= &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span> (current-&gt;<span class="built_in">exp</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, current-&gt;coef);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d*X&quot;</span>, current-&gt;coef);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d*X^%d&quot;</span>, current-&gt;coef, current-&gt;<span class="built_in">exp</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;+%d*X^%d&quot;</span>, current-&gt;coef, current-&gt;<span class="built_in">exp</span>);</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着构造一个将两个多项式相加的方法。代码如下：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main_add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Node* result, * P, * Q, * currentResult, * currentP, * currentQ;</span><br><span class="line"></span><br><span class="line">result = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">result-&gt;coef = <span class="number">0</span>;</span><br><span class="line">result-&gt;<span class="built_in">exp</span> = <span class="number">-1</span>;</span><br><span class="line">result-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">P = changeToList(LA, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">Q = changeToList(LB, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">currentP = P-&gt;next;</span><br><span class="line">currentQ = Q-&gt;next;</span><br><span class="line">currentResult = result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (currentP != <span class="literal">NULL</span> &amp;&amp; currentQ != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (currentP-&gt;<span class="built_in">exp</span> &lt; currentQ-&gt;<span class="built_in">exp</span>)</span><br><span class="line">&#123;</span><br><span class="line">currentResult-&gt;next = currentP;</span><br><span class="line">currentP = currentP-&gt;next;</span><br><span class="line"></span><br><span class="line">currentResult = currentResult-&gt;next;</span><br><span class="line">currentResult-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currentP-&gt;<span class="built_in">exp</span> &gt; currentQ-&gt;<span class="built_in">exp</span>)</span><br><span class="line">&#123;</span><br><span class="line">currentResult-&gt;next = currentQ;</span><br><span class="line">currentQ = currentQ-&gt;next;</span><br><span class="line"></span><br><span class="line">currentResult = currentResult-&gt;next;</span><br><span class="line">currentResult-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">currentP-&gt;coef += currentQ-&gt;coef;</span><br><span class="line"><span class="keyword">if</span> (currentP-&gt;coef != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">currentResult-&gt;next = currentP;</span><br><span class="line">currentP = currentP-&gt;next;</span><br><span class="line"></span><br><span class="line">currentResult = currentResult-&gt;next;</span><br><span class="line">currentResult-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Node* tmp = currentQ = currentQ;</span><br><span class="line">currentQ = currentQ-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* tmp = currentP;</span><br><span class="line">currentP = currentP-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line"></span><br><span class="line">tmp = currentQ;</span><br><span class="line">currentQ = currentQ-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (currentP != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">currentResult-&gt;next = currentP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (currentQ != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">currentResult-&gt;next = currentQ;</span><br><span class="line">&#125;</span><br><span class="line">printNodeList(result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 绪论【数据结构】</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BB%AA%E8%AE%BA.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BB%AA%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论【数据结构】"><a href="#第一章-绪论【数据结构】" class="headerlink" title="第一章 绪论【数据结构】"></a>第一章 绪论【数据结构】</h1><blockquote><p>快速导航：</p><ul><li><a href="./01.绪论">第一章 绪论【数据结构】</a></li><li><a href="./02.线性表">第二章 线性表【数据结构】</a></li><li><a href="./03.栈和队列">第三章 栈和队列【数据结构】</a></li><li><a href="./04.串">第四章 串【数据结构】</a></li><li><a href="./05.数组和广义表">第五章 数组和广义表【数据结构】</a></li><li><a href="./06.数和二叉树">第六章 数和二叉树【数据结构】</a></li><li><a href="./07.图Graph">第七章 图(Graph)【数据结构】</a></li><li><a href="./09.查找">第九章 查找【数据结构】</a></li></ul></blockquote><h1 id="一、什么是数据结构"><a href="#一、什么是数据结构" class="headerlink" title="一、什么是数据结构"></a>一、什么是数据结构</h1><p>一般来说，用计算机解决一个具体问题，大致需要经过下列几个步骤：</p><ol><li>重具体问题中抽象出一个适当的数学模型</li><li>设计一个解数学模型的算法</li><li>编写程序，进行调试、调整直至得到最终答案</li></ol><p>但是有很多非数值问题无法用数学方程加以描述。例如：树、图等结构。描述这类非数值计算问题的数学模型不再是数学方程，而是诸如表、树和图之类的数据结构。</p><blockquote><p>因此，<strong>数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作的学科</strong>。</p></blockquote><h1 id="二、基本术语"><a href="#二、基本术语" class="headerlink" title="二、基本术语"></a>二、基本术语</h1><p>数据结构的基本术语：</p><ul><li><strong>数据</strong>：在计算机科学中，指的是所有能输入到计算机中，并且计算机程序处理的符号的总称。</li><li><strong>数据元素</strong>：数据的基本单位。</li><li><strong>数据项</strong>：一个数据元素可由若干数据项组成。<strong>数据项是数据的不可分割的最小单位</strong>。</li><li><strong>数据对象</strong>：性质相同的数据元素的集合。</li><li><strong>数据结构</strong>：相互之间存在一种或多种特定关系的数据元素的集合。</li><li><strong>结构</strong>：数据元素之间的关系。</li></ul><p>数据元素之间有 4 种基本关系：</p><ol><li><strong>集合</strong>：数据元素之间除了”同属于一个集合“之外，别无其它关系；</li><li><strong>线性结构</strong>：数据元素之间存在一个对一个的关系；</li><li><strong>树形结构</strong>：数据元素之间存在一个对多个的关系；</li><li><strong>图状结构或者网状结构</strong>：数据元素之间存在多个对多个的关系。</li></ol><h1 id="四、算法和算法分析"><a href="#四、算法和算法分析" class="headerlink" title="四、算法和算法分析"></a>四、算法和算法分析</h1><h2 id="4-1-算法"><a href="#4-1-算法" class="headerlink" title="4.1 算法"></a>4.1 算法</h2><p><strong>算法</strong>是对特定问题求解步骤的一种描述，它是指令的有限序列，每一条指令代表一个或多个操作。具有下列 5 个重要特性：有穷性；确定性；可行性；输入；输出。</p><h2 id="4-2-算法的设计要求"><a href="#4-2-算法的设计要求" class="headerlink" title="4.2 算法的设计要求"></a>4.2 算法的设计要求</h2><p>应考虑达到以下目标：</p><ol><li>正确性；</li><li>可读性；</li><li>健壮性；</li><li>高效率与低存储。</li></ol><h2 id="4-3-算法的效率质量"><a href="#4-3-算法的效率质量" class="headerlink" title="4.3 算法的效率质量"></a>4.3 算法的效率质量</h2><p>算法执行时间需要依据该算法编制的程序在计算机上运行时所消耗的时间来度量。度量一个程序的执行时间，通常有两种方法：</p><ol><li>事后统计法</li><li>事前分析估算法。一个高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：<ol><li>依据的算法选用何种策略</li><li>问题的规模</li><li>书写程序的语言</li><li>编译程序所产生的机器代码的质量</li><li>机器执行指令的速度</li></ol></li></ol><p>一般情况下，算法中基本操作重复执行的次数是问题规模 $n$ 的某个函数 $f(n)$ ，算法的事件量度记作：</p><script type="math/tex; mode=display">T(n) = O[f(n)]</script><p>它表示随问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。</p><h2 id="4-4-算法的存储空间要求"><a href="#4-4-算法的存储空间要求" class="headerlink" title="4.4 算法的存储空间要求"></a>4.4 算法的存储空间要求</h2><p>类似于算法的时间复杂度，以<strong>空间复杂度</strong>作为算法所需存储空间的量度，记作：</p><script type="math/tex; mode=display">S(n) = O[f(n)]</script>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客使用MathJax公式并解决Markdown渲染冲突问题</title>
      <link href="/Hexo/Trouble/%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98.html"/>
      <url>/Hexo/Trouble/%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="利用MathJax来渲染LaTeX数学公式"><a href="#利用MathJax来渲染LaTeX数学公式" class="headerlink" title="利用MathJax来渲染LaTeX数学公式"></a>利用MathJax来渲染LaTeX数学公式</h1><p><code>hexo</code>主题<code>Next</code>中已经集成了对<code>mathjax</code>的支持。在<strong>主题配置文件</strong>中，找到下面配置片段：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启MathJax渲染</span></span><br><span class="line">  <span class="comment"># 是否再每一页进行MathJax渲染。</span></span><br><span class="line">  <span class="comment"># false:将会对在YAML front matters中添加 mathjax:true 的MD文件进行渲染</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然后可以安装一个Mathjax的渲染引擎。在当前项目路径下，打开终端，并输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo<span class="literal">-renderer-marked</span> <span class="literal">--save</span> //如果之前按安装其他的渲染插件，先删除</span><br><span class="line">npm install hexo<span class="literal">-renderer-kramed</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>这样就能渲染出数学公式。例如下面效果：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//行内公式（或者叫内联公式）</span><br><span class="line"><span class="built_in">$</span>a <span class="keyword">\parallel</span> c,b <span class="keyword">\parallel</span> c <span class="keyword">\Rightarrow</span> a <span class="keyword">\parallel</span> b <span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">//多行公式（或者加公式块）</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;l&#125;  </span><br><span class="line">  <span class="keyword">\nabla</span> <span class="keyword">\cdot</span> <span class="keyword">\mathbf</span>&#123;E&#125; =<span class="keyword">\cfrac</span>&#123;<span class="keyword">\rho</span>&#125;&#123;<span class="keyword">\varepsilon</span> <span class="built_in">_</span>0&#125;  <span class="keyword">\\</span>  </span><br><span class="line">  <span class="keyword">\nabla</span> <span class="keyword">\cdot</span> <span class="keyword">\mathbf</span>&#123;B&#125; = 0 <span class="keyword">\\</span>  </span><br><span class="line">  <span class="keyword">\nabla</span> <span class="keyword">\times</span>  <span class="keyword">\mathbf</span>&#123;E&#125; = -<span class="keyword">\cfrac</span>&#123;<span class="keyword">\partial</span> <span class="keyword">\mathbf</span>&#123;B&#125;&#125;&#123;<span class="keyword">\partial</span> t &#125;  <span class="keyword">\\</span>  </span><br><span class="line">  <span class="keyword">\nabla</span> <span class="keyword">\times</span>  <span class="keyword">\mathbf</span>&#123;B&#125; = <span class="keyword">\mu</span> <span class="built_in">_</span>0<span class="keyword">\mathbf</span>&#123;J&#125; + <span class="keyword">\mu</span> <span class="built_in">_</span>0<span class="keyword">\varepsilon</span><span class="built_in">_</span>0 <span class="keyword">\cfrac</span>&#123;<span class="keyword">\partial</span> <span class="keyword">\mathbf</span>&#123;E&#125;&#125;&#123;<span class="keyword">\partial</span> t &#125;   </span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125; </span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><ul><li><p>内联公式：$a \parallel c,b \parallel c \Rightarrow a \parallel b $</p></li><li><p>公式块</p><script type="math/tex; mode=display">  \begin{array}{l}    \nabla \cdot \mathbf{E} =\cfrac{\rho}{\varepsilon _0}  \\    \nabla \cdot \mathbf{B} = 0 \\    \nabla \times  \mathbf{E} = -\cfrac{\partial \mathbf{B}}{\partial t }  \\    \nabla \times  \mathbf{B} = \mu _0\mathbf{J} + \mu _0\varepsilon_0 \cfrac{\partial \mathbf{E}}{\partial t }   \end{array}</script></li></ul><h1 id="内联公式的不正常显示"><a href="#内联公式的不正常显示" class="headerlink" title="内联公式的不正常显示"></a>内联公式的不正常显示</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>例如下面的<code>Latex</code>语法：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>E<span class="built_in">_</span>&#123;1&#125;  = E<span class="built_in">_</span>&#123;2&#125; <span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>正确的显示应该是： $E_{1}  = E_{2} $ ，而<code>hexo</code>确把它渲染为：$E<em>{1}  = E</em>{2}$ 。</p><p>我们不难发现，本应该显示公式，但是却出现源码，并且部分变为斜体。原因是<code>hexo</code>先用<code>marked.js</code>渲染，然后再交给<code>MathJax</code>渲染。在<code>marked.js</code>渲染的时候下划线<code>_</code>是被替换掉，并且换成了<code>&lt;em&gt;</code>标签，即斜体字，另外LaTeX中的<code>\\</code>也会被转义成一个<code>\</code>，这样会导致<code>MathJax</code>渲染时不认为它是一个换行符了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过修改<code>Hexo</code>渲染的源码来解决。</p><ol><li><p>首先进入<code>[Blog-name]\node_modules\kramed\lib\rules\inline.js</code>文件内，找到下面代码并且替换掉。这样就能解决<strong>换行</strong>冲突的问题。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到下面代码，并且注释掉</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//将下面代码添加到刚刚注释的地方</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p><code>[Blog-name]\node_modules\kramed\lib\rules\inline.js</code>文件内，找到下面代码并且替换掉。这样就能解决<strong>斜体</strong>冲突的问题。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到下面代码，并且注释掉</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line"><span class="comment">//将下面代码添加到刚刚注释的地方</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>保存文件，并且重启项目，刷新网页。</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl; hexo s</span><br><span class="line">hexo cl</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这种方法意在解决<code>Hexo</code>的数学公式渲染问题，因此不需要对<code>Markdown</code>文件进行修改，就能正确显示数学公式</p></blockquote><h1 id="内联公式的样式调整"><a href="#内联公式的样式调整" class="headerlink" title="内联公式的样式调整"></a>内联公式的样式调整</h1><p>在使用<code>Mathjax</code>公式时，内联公式的位置并不是垂直居中显示，并且还会偶尔出现横向滚动条。因此，为了改善数学公式的观看体验，下面将对上述问题进行解决。</p><p>首先来到<code>[hexo-project]\source\css\custom.css</code>文件（这是自定义的文件，如果没有就先创建）内，添加下面内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数学内联公式水平居中显示 */</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-class">.mathjax-overflow</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数学内联公式取消横向滚动条 */</span></span><br><span class="line"><span class="selector-class">.mathjax-overflow</span> &#123;</span><br><span class="line">    <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再到主题配置文件<code>_config.butterfly.yml</code>内，找到下面位置，并添加对上述<code>CSS</code>文件的引用：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/personal.css&quot;</span> <span class="string">media=&quot;defer&quot;</span> <span class="string">onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br></pre></td></tr></table></figure><p>然后重启项目并且刷新网页：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo cl;hexo s</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h1 id="文章配置说明"><a href="#文章配置说明" class="headerlink" title="文章配置说明"></a>文章配置说明</h1><h2 id="参考目录："><a href="#参考目录：" class="headerlink" title="参考目录："></a>参考目录：</h2><ul><li>文章引用<ol><li><a href="https://segmentfault.com/a/1190000007261752">Hexo下mathjax的转义问题</a></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
            <tag> MathJax </tag>
            
            <tag> 公式渲染 </tag>
            
            <tag> 渲染冲突 </tag>
            
            <tag> latex </tag>
            
            <tag> 数学公式 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二章 无穷级数【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/12.%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/12.%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十二章-无穷级数"><a href="#第十二章-无穷级数" class="headerlink" title="第十二章 无穷级数"></a>第十二章 无穷级数</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><strong><a href="./12.无穷级数">第十二章 无穷级数</a></strong></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="12-1-常数项级数的概念和性质"><a href="#12-1-常数项级数的概念和性质" class="headerlink" title="12.1 常数项级数的概念和性质"></a>12.1 常数项级数的概念和性质</h1><h2 id="12-1-1-常数项级数的概念"><a href="#12-1-1-常数项级数的概念" class="headerlink" title="12.1.1 常数项级数的概念"></a>12.1.1 常数项级数的概念</h2><p><strong>定义</strong>：常数 $u_{1},u_{2},\cdots ,u_{n},\dots $ ，那么称</p><script type="math/tex; mode=display">S=\displaystyle \sum_{i=1}^{\infty } u_{i} = u_{1}+u_{i2}+\dots +u_{n}+\dots</script><p>为<strong>无穷级数</strong>，简称<strong>级数</strong>。</p><blockquote><p>级数是无穷个项的和，而数列是前 $n$ 项的。</p></blockquote><p><strong>前 $n$ 项和</strong>：称 $S_{n}=\sum_{i=1}^{n} u_{i} = u_{1}+u_{i2}+\dots +u_{n}$ 为级数的前 $n$ 项部分和。</p><p><strong>定义（级数的收敛）</strong>：如果 $\displaystyle \lim_{n \to \infty} S_{n}=S\quad (S\text{为常数} )$ 存在且成立，那么称级数是收敛的；反之，级数是发散的。</p><p><strong>余项</strong>：称 $\displaystyle R_{n}= S-S_{n}=u_{n+1}+u_{n+2}+\cdots $ 为级数的余项。</p><p><strong>等比（几何）级数</strong>： $\displaystyle a + aq +aq^{2} +\cdots +aq^{n} +\cdots $ ，且 $a\ne 0$ 。</p><ol><li>当 $|q|=1$ 时<ol><li>当 $q = 1$ 时，级数为 $a+a+\dots $ ，级数发散的；</li><li>当 $q=-1$ 时，级数为 $a-a+a-1+\dots $ ，可能是 $0$ ，也可能是 $a$ ，因此级数发散的；</li></ol></li><li>当 $|q|\ne 1$ 时， $\displaystyle S_{n}=\frac{a(1-q^{n})}{1-q} $ <ol><li>当 $|q|&lt;1$ 时， $\displaystyle\lim_{n \to \infty}  S_{n}=\frac{a(1-q^{n})}{1-q}= \frac{a}{1-q}$ ，级数收敛；</li><li>当 $|q|&gt;1$ 时， $\displaystyle\lim_{n \to \infty}  S_{n}=\frac{a(1-q^{n})}{1-q}=\infty$ ，级数发散的。</li></ol></li></ol><h2 id="12-1-2-收敛级数的基本性质"><a href="#12-1-2-收敛级数的基本性质" class="headerlink" title="12.1.2 收敛级数的基本性质"></a>12.1.2 收敛级数的基本性质</h2><p><strong>性质 1</strong>：如果 $\displaystyle \sum_{i=1}^{\infty } u_{i}$ 收敛于 $S$ ，那么 $\displaystyle \sum_{i=1}^{\infty } ku_{i} $ 收敛于 $kS$ 。</p><p><strong>性质 2</strong>：如果级数 $\displaystyle \sum_{i=1}^{\infty } u_{i} $ 和 $\displaystyle \sum_{i=1}^{\infty } v_{i} $ 分别收敛于 $S$ 和 $W$ ，那么 $\displaystyle \sum_{i=1}^{\infty } \left ( u_{i} \pm v_{i}  \right ) $ 收敛于 $S\pm W$ 。</p><ol><li>如果两个级数收敛，那么相加减后的级数也收敛；</li><li>如果两个级数相加减后的级数收敛，那么原来的两个级数不一定收敛。</li></ol><p><strong>性质 3</strong>：去掉、加上或改变有限项，级数的敛散性不改变。</p><p><strong>性质 4</strong>：级数 $\sum u_{n}$ 收敛，任意相邻几项加括号，得到的新的级数是收敛的。</p><ol><li>这个性质反过来不成立，即加括号后收敛，原级数不一定收敛。</li><li>如果加括号后，级数是发散的，那么原级数是发散的。</li></ol><p><strong>调和级数</strong>：发散的。</p><script type="math/tex; mode=display">1+\frac{1}{2}+\frac{1}{3}+\cdots +\frac{1}{n}+\cdots</script><p><strong>$p$级数 </strong>：形如：</p><script type="math/tex; mode=display">\displaystyle \sum_{n=1}^{\infty } \frac{1}{n^{p} }</script><ol><li>当 $p&gt;1$ 时，级数是收敛的。</li></ol><h2 id="12-1-3-柯西审敛原理"><a href="#12-1-3-柯西审敛原理" class="headerlink" title="12.1.3 柯西审敛原理"></a>12.1.3 柯西审敛原理</h2><p>略</p><h1 id="12-2-常数项技术的审敛法"><a href="#12-2-常数项技术的审敛法" class="headerlink" title="12.2 常数项技术的审敛法"></a>12.2 常数项技术的审敛法</h1><h2 id="12-2-1-正项级数及其审敛法"><a href="#12-2-1-正项级数及其审敛法" class="headerlink" title="12.2.1 正项级数及其审敛法"></a>12.2.1 正项级数及其审敛法</h2><p><strong>定义</strong>：满足 $u_{n}\ge0$ 的级数，称为正项级数。</p><ol><li>如果 $m&lt;n$ ，那么 $S_{m}\le S_{n}$ ；</li><li>$\left \{ S_{n} \right \} \ge 0$ ；</li></ol><p><strong>定理 1</strong>：$\sum u_{n} $ 收敛 $\Longleftrightarrow $  $\left \{ S_{n}  \right \} $ 有界。</p><p><strong>定理 2</strong>： $\sum u_{n},\sum v_{n}$ 都是正项级数，且 $u_{n}\le v_{n}$ ；</p><ul><li>如果 $\sum v_{n}$ 是收敛的，那么 $\sum u_{n}$ 也是收敛的；</li><li>如果 $\sum u_{n}$ 是发散的，那么 $\sum v_{n}$ 也是发散的。</li></ul><p><strong>定理 3（比较审敛法）</strong>：级数 $\sum u_{n}，\sum v_{n}$ 都是正项级数：</p><ol><li>已知 $\displaystyle \lim_{n\to \infty} \frac{u_{n} }{v_{n}} =l(0\le l&lt;+\infty )$ ，如果 $\sum v_{n}$ 收敛，那么 $\sum u_{n}$ 也是收敛的；</li><li>已知 $\displaystyle \lim_{n\to \infty} \frac{u_{n} }{v_{n}} &gt;(\mathrm{or:}+\infty  )$ ，如果级数 $\sum u_{n}$ 是发散的，那么级数 $\sum v_{n}$ 也是发散的。</li></ol><p><strong>定理 4（比较审敛法）</strong>：级数 $\sum u_{n}$ 是正项级数，且 $\displaystyle \lim_{n\to \infty} \frac{u_{n+1}}{u_{n}} =\rho $ ：</p><ol><li>如果 $\rho &gt;1$ 时，级数是发散的；</li><li>如果 $\rho=1$ 时，级数的敛散性不能通过该方法确定；</li><li>如果 $\rho &lt;1$ 时，级数是收敛。</li></ol><p><strong>定理 5（根值审敛法）（柯西判别法）</strong>：级数 $\sum u_{n}$ 是正项级数，且 $\displaystyle \lim_{n\to \infty} \sqrt[n]{u_{n}} =\rho $ ：</p><ol><li>如果 $\rho &gt;1$ 时，级数是发散的；</li><li>如果 $\rho=1$ 时，级数的敛散性不能通过该方法确定；</li><li>如果 $\rho &lt;1$ 时，级数是收敛。</li></ol><h2 id="12-2-2-交错级数及其审敛法"><a href="#12-2-2-交错级数及其审敛法" class="headerlink" title="12.2.2 交错级数及其审敛法"></a>12.2.2 交错级数及其审敛法</h2><p><strong>形如</strong>： $u_{1} -u_{2} +u_{3} -u_{4}+\dots $ 的级数，称为交错级数。</p><p><strong>定理 1（莱布尼茨定理）</strong>：如果交错级数 $\displaystyle \sum_{n=1}^{\infty } (-1)^{n-1} u_{n} $ 满足：</p><ol><li>$u_{n} \ge u_{n+1}$ ；</li><li>$\displaystyle \lim_{n \to \infty} u_{n} =0$ </li></ol><p>则级数是收敛的，并且 $\displaystyle S\le u_{1} $ 。</p><h2 id="12-2-3-绝对收敛与条件收敛"><a href="#12-2-3-绝对收敛与条件收敛" class="headerlink" title="12.2.3 绝对收敛与条件收敛"></a>12.2.3 绝对收敛与条件收敛</h2><p>有一般项级数： $\displaystyle \sum_{n=1}^{\infty } u_{n} $ ，那么它的绝对值级数为： $\displaystyle \sum_{n=1}^{\infty } \left | u_{n} \right |  $ 。</p><p><strong>定理</strong>：如果 $\displaystyle \sum_{n=1}^{\infty } \left | u_{n} \right |$ 是收敛的，那么 $\displaystyle \sum_{n=1}^{\infty } u_{n} $ 也是收敛的。</p><p><strong>绝对收敛</strong>：如果 $\displaystyle \sum_{n=1}^{\infty } \left | u_{n} \right |$ 和 $\displaystyle \sum_{n=1}^{\infty } u_{n} $ 都是收敛的，那么称  $\displaystyle \sum_{n=1}^{\infty } u_{n} $ 是绝对收敛的；</p><p><strong>条件收敛</strong>：如果 $\displaystyle \sum_{n=1}^{\infty } u_{n} $ 收敛， $\displaystyle \sum_{n=1}^{\infty } \left | u_{n} \right |$ 发散，那么称  $\displaystyle \sum_{n=1}^{\infty } u_{n} $ 是条件收敛的。</p><p><strong>定理</strong>“任意项级数 $\displaystyle \sum_{n=1}^{\infty } u_{n} $ ，并且有 $\displaystyle \lim_{n \to \infty}\left | \frac{u_{n+1} }{u_{n}}  \right | =l$ ，</p><ol><li>如果 $l&lt;1$ ，那么 $\displaystyle \sum_{n=1}^{\infty } u_{n} $ 绝对收敛；</li><li>如果 $\displaystyle l&gt;1(+\infty )$ ，那么 $\displaystyle \sum_{n=1}^{\infty } u_{n} $ 是发散的；</li><li>如果 $l=1$ ，无法判断。</li></ol><h2 id="12-2-4-绝对收敛级数的性质"><a href="#12-2-4-绝对收敛级数的性质" class="headerlink" title="12.2.4 绝对收敛级数的性质"></a>12.2.4 绝对收敛级数的性质</h2><h1 id="12-3-幂级数"><a href="#12-3-幂级数" class="headerlink" title="12.3 幂级数"></a>12.3 幂级数</h1><h2 id="12-3-1-函数项级数的概念"><a href="#12-3-1-函数项级数的概念" class="headerlink" title="12.3.1 函数项级数的概念"></a>12.3.1 函数项级数的概念</h2><p><strong>数列</strong>：形如：$u_{1},u_{2},\cdots ,u_{n},\cdots $ 称为<strong>数列</strong>。</p><p><strong>级数</strong>：数列的每一项之和 $\displaystyle \sum_{n=1}^{\infty } u_{n}=u_{1}+u_{2}+\cdots +u_{n}+\cdots $ ，称为<strong>级数</strong>。</p><p><strong>函数列</strong>：形如：$u_{1}(x),u_{2}(x),\cdots ,u_{n}(x),\cdots $ ，称为<strong>函数列</strong>。</p><p><strong>函数项无穷级数</strong>：函数数列的每一项之和 $\displaystyle \sum_{n=1}^{\infty } u_{n}(x)=u_{1}(x)+u_{2}(x)+\cdots +u_{n}(x)+\cdots $ ，称为<strong>函数项无穷级数</strong>。</p><p><strong>定义（幂级数）</strong>：函数项无穷级数的每一项满足： $\displaystyle u_{n}(x)=a_{n-1} x_{n-1} $ ，称为<strong>幂级数</strong>，并且称</p><script type="math/tex; mode=display">\displaystyle S = u_{1}(x)+u_{2}(x)+\cdots +u_{n}(x)+\cdots</script><p>为<strong>和函数</strong>。余项：</p><script type="math/tex; mode=display">\displaystyle \Upsilon _{n}(x) =S(x) -S_{n}(x)</script><h2 id="12-3-2-幂级数及其收敛性"><a href="#12-3-2-幂级数及其收敛性" class="headerlink" title="12.3.2 幂级数及其收敛性"></a>12.3.2 幂级数及其收敛性</h2><p><strong>定理（阿贝尔定理）</strong>：幂级数 $\displaystyle \sum_{n=0}^{\infty } a_{n} x^{n} $ </p><ol><li>如果 $x=x_{0}$ 是收敛的，那么 $\displaystyle \left | x \right | &lt;\left | x_{0}  \right | $ 幂级数绝对值收敛；</li><li>如果 $x=x_{0}$ 是发散的，那么 $\displaystyle \left | x \right | &gt;\left | x_{0}  \right | $ 时，幂级数是发散的。</li></ol><p><strong>分界点</strong>：满足 $\displaystyle \left | x \right | &lt;\left | x_{0}  \right | $ 是，幂级数收敛， $\displaystyle \left | x \right | &gt;\left | x_{0}  \right | $ 时，幂级数发散，称 $x_{0}$ 是收敛点，并且收敛半径为 $R=x_{0}$ ，收敛区间为： $\displaystyle \left ( -R,R \right ) $ 。</p><p><strong>定理</strong>：极限 $\displaystyle \lim_{n \to \infty} \left | \frac{a_{n+1} }{a_{n} }  \right | =\rho $ ，</p><ol><li>如果 $\rho \ne 0$ ，那么 $\displaystyle R=\frac{1}{\rho } $ ；</li><li>如果 $\rho =0$ ，那么 $\displaystyle R=+\infty $ ；</li><li>如果 $\displaystyle \rho =+\infty $ ，那么 $\displaystyle R=0$ 。</li></ol><h2 id="12-3-3-幂级数的运算"><a href="#12-3-3-幂级数的运算" class="headerlink" title="12.3.3 幂级数的运算"></a>12.3.3 幂级数的运算</h2><p><strong>性质 1</strong>：幂级数的和函数 $S(x)$ 在收敛域 $I$ 上是连续的。</p><p><strong>性质 2</strong>：幂级数的和函数 $S(x)$ 在收敛域 $I$ 上是可积的。</p><h1 id="12-4-函数展开成幂级数"><a href="#12-4-函数展开成幂级数" class="headerlink" title="12.4 函数展开成幂级数"></a>12.4 函数展开成幂级数</h1><h1 id="12-5-函数的幂级数展开式的应用"><a href="#12-5-函数的幂级数展开式的应用" class="headerlink" title="12.5 函数的幂级数展开式的应用"></a>12.5 函数的幂级数展开式的应用</h1><h2 id="12-5-1-近似计算"><a href="#12-5-1-近似计算" class="headerlink" title="12.5.1 近似计算"></a>12.5.1 近似计算</h2><h2 id="12-5-2-微分方程的幂级数解法"><a href="#12-5-2-微分方程的幂级数解法" class="headerlink" title="12.5.2 微分方程的幂级数解法"></a>12.5.2 微分方程的幂级数解法</h2><h2 id="12-5-3-欧拉公式"><a href="#12-5-3-欧拉公式" class="headerlink" title="12.5.3 欧拉公式"></a>12.5.3 欧拉公式</h2><h1 id="12-6-函数项级数的一致收敛性"><a href="#12-6-函数项级数的一致收敛性" class="headerlink" title="12.6 函数项级数的一致收敛性"></a>12.6 函数项级数的一致收敛性</h1><h2 id="12-6-1-函数项级数的一致收敛性"><a href="#12-6-1-函数项级数的一致收敛性" class="headerlink" title="12.6.1 函数项级数的一致收敛性"></a>12.6.1 函数项级数的一致收敛性</h2><h2 id="12-6-2-一致收敛性的基本性质"><a href="#12-6-2-一致收敛性的基本性质" class="headerlink" title="12.6.2 一致收敛性的基本性质"></a>12.6.2 一致收敛性的基本性质</h2><h1 id="12-7-傅里叶级数"><a href="#12-7-傅里叶级数" class="headerlink" title="12.7 傅里叶级数"></a>12.7 傅里叶级数</h1><h2 id="12-7-1-三角级数"><a href="#12-7-1-三角级数" class="headerlink" title="12.7.1 三角级数"></a>12.7.1 三角级数</h2><h2 id="12-7-2-函数展开成傅里叶级数"><a href="#12-7-2-函数展开成傅里叶级数" class="headerlink" title="12.7.2 函数展开成傅里叶级数"></a>12.7.2 函数展开成傅里叶级数</h2><h2 id="12-7-3-正弦级数和余弦级数"><a href="#12-7-3-正弦级数和余弦级数" class="headerlink" title="12.7.3 正弦级数和余弦级数"></a>12.7.3 正弦级数和余弦级数</h2><h1 id="12-8-一般周期函数的傅里叶级数"><a href="#12-8-一般周期函数的傅里叶级数" class="headerlink" title="12.8 一般周期函数的傅里叶级数"></a>12.8 一般周期函数的傅里叶级数</h1><p>【略】</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录 高等数学常用公式</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/13.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/13.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><strong><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></strong></li></ul></blockquote><h1 id="一、三角恒等式"><a href="#一、三角恒等式" class="headerlink" title="一、三角恒等式"></a>一、三角恒等式</h1><h2 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>$\displaystyle \csc x= \frac{1}{\sin x} $</td></tr><tr><td style="text-align:center">2</td><td>$\displaystyle \sec x= \frac{1}{\cos x} $</td></tr><tr><td style="text-align:center">3</td><td>$\displaystyle \tan x=\frac{\sin x}{\cos x} $</td></tr><tr><td style="text-align:center">4</td><td>$\displaystyle \sin ^{2} x+\cos ^{2} x=1$</td></tr><tr><td style="text-align:center">5</td><td>$\displaystyle \tan ^{2} x+1=\sec ^{2} x$</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><h2 id="倍角公式"><a href="#倍角公式" class="headerlink" title="倍角公式"></a>倍角公式</h2><h3 id="二倍角公式"><a href="#二倍角公式" class="headerlink" title="二倍角公式"></a>二倍角公式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">$\displaystyle \sin 2x=2\sin x\cdot \cos x$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">$\displaystyle \cos 2x=\cos ^{2} x-\sin ^{2} x=1-2\sin ^{2} x=2\cos ^{2} x-1$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">$\displaystyle \tan 2x=\frac{2\tan x}{1-\tan ^{2} x} $</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">$\displaystyle \cot 2x=\frac{\cot ^{2}x-1 }{2\cot x} $</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">$\displaystyle \sec 2x=\frac{\sec ^{2}x+\csc^{2}x  }{\csc^{2}x -\sec ^{2}x} =\frac{\sec ^{2}x\cdot \csc^{2}x}{\csc^{2}x -\sec ^{2}x} $</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">$\displaystyle \csc 2x=\frac{\sec ^{2}x+\csc^{2}x  }{2\sec x\cdot \csc x} =\frac{\sec x\cdot \csc x}{2} $</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><h2 id="积化和差"><a href="#积化和差" class="headerlink" title="积化和差"></a>积化和差</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td><script type="math/tex">\displaystyle \sin \alpha \cdot \cos \beta = \frac{\sin (\alpha +\beta )+\sin (\alpha -\beta )}{2}</script></td></tr><tr><td style="text-align:center">2</td><td><script type="math/tex">\displaystyle \cos \alpha  \cdot \sin \beta = \frac{\sin (\alpha +\beta )-\sin (\alpha -\beta )}{2}</script></td></tr><tr><td style="text-align:center">3</td><td>$\displaystyle \cos \alpha  \cdot \cos \beta = \frac{\cos (\alpha +\beta )+\cos  (\alpha -\beta )}{2}$</td></tr><tr><td style="text-align:center">4</td><td>$\displaystyle \sin \alpha  \cdot\sin \beta = -\frac{\cos (\alpha +\beta )-\cos  (\alpha -\beta )}{2}$</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><ul><li>正余余正，正加正减；</li><li>余余正正，余加负余减。</li></ul><h2 id="和差化积"><a href="#和差化积" class="headerlink" title="和差化积"></a>和差化积</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>$\displaystyle \sin \alpha + \sin \beta =2\sin \frac{\alpha +\beta }{2} \cdot \cos  \frac{\alpha -\beta }{2}$</td></tr><tr><td style="text-align:center">2</td><td>$\displaystyle \sin \alpha - \sin \beta =2\cos \frac{\alpha +\beta }{2} \cdot \sin \frac{\alpha -\beta }{2}$</td></tr><tr><td style="text-align:center">3</td><td>$\displaystyle \cos \alpha + \cos \beta =2\cos \frac{\alpha +\beta }{2} \cdot\cos \frac{\alpha -\beta }{2}$</td></tr><tr><td style="text-align:center">4</td><td>$\displaystyle \cos \alpha - \cos \beta =-2\sin \frac{\alpha +\beta }{2} \cdot\sin \frac{\alpha -\beta }{2}$</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><ol><li>正加正，正在前；</li><li>正减正，余在前；</li><li>余加余，余并肩；</li><li>余减余，负正弦。</li></ol><h1 id="导数与微分"><a href="#导数与微分" class="headerlink" title="导数与微分"></a>导数与微分</h1><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">函数</th><th style="text-align:center">导数</th><th style="text-align:center">微分</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$C(\text{常数} )$</td><td style="text-align:center">$0$</td><td style="text-align:center">$\mathrm{d}(C)=0\mathrm{d}x  $</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$x^{u}$</td><td style="text-align:center">$ux^{u-1}$</td><td style="text-align:center">$\mathrm{d}(x^{u})=ux^{u-1}\mathrm{d}x  $</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$a^{x}$</td><td style="text-align:center">$a^{x}\mathrm{ln}a$</td><td style="text-align:center">$\mathrm{d}(a^{x})=a^{x}\mathrm{ln}a\mathrm{d}x   $</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$e^{x}$</td><td style="text-align:center">$e^{x}$</td><td style="text-align:center">$\mathrm{d}(e^{x})=e^{x}\mathrm{d}x $</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$\displaystyle \log_{a}{x}$</td><td style="text-align:center">$\displaystyle \frac{1}{x\ln{a}} $</td><td style="text-align:center">$\displaystyle \mathrm{d}(\log_{a}{x})  = \frac{1}{x\ln{a}}\mathrm{d}x$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$\displaystyle \ln{x}$</td><td style="text-align:center">$\displaystyle \frac{1}{x}$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\ln{x})  = \frac{1}{x}\mathrm{d}x$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$\sin x$</td><td style="text-align:center">$\cos x$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\sin x)  = \cos x\mathrm{d}x$</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">$\displaystyle \cos x$</td><td style="text-align:center">$\displaystyle -\sin x$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\cos x)  = -\sin x\mathrm{d}x$</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">$\displaystyle \tan x$</td><td style="text-align:center">$\displaystyle \sec ^{2}x$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\tan x)  = \sec ^{2}x\mathrm{d}x$</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">$\displaystyle \cot x$</td><td style="text-align:center">$\displaystyle -\csc ^{2}x $</td><td style="text-align:center">$\displaystyle \mathrm{d}(\cot x)  = -\csc ^{2}x\mathrm{d}x$</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">$\displaystyle \sec x$</td><td style="text-align:center">$\displaystyle \sec x\cdot \tan x$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\sec x)  = \sec x\cdot \tan x \mathrm{d}x$</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">$\displaystyle \csc x$</td><td style="text-align:center">$\displaystyle -\csc x\cdot \cot x$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\csc x)  = -\csc x\cdot \cot x \mathrm{d}x$</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">$\displaystyle \arcsin x$</td><td style="text-align:center">$\displaystyle \frac{1}{\sqrt{1-x^{2} } }$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\arcsin x)  = \frac{1}{\sqrt{1-x^{2} } }\mathrm{d}x$</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">$\displaystyle \arccos x$</td><td style="text-align:center">$\displaystyle -\frac{1}{\sqrt{1-x^{2} } }$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\arccos x)  = -\frac{1}{\sqrt{1-x^{2} } }\mathrm{d}x$</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">$\displaystyle \arctan x$</td><td style="text-align:center">$\displaystyle \frac{1}{1+x^{2} }$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\arctan x)  = \frac{1}{1+x^{2} }\mathrm{d}x$</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">$\displaystyle \operatorname{arccot} $</td><td style="text-align:center">$\displaystyle -\frac{1}{1+x^{2} }$</td><td style="text-align:center">$\displaystyle \mathrm{d}(\operatorname{arccot} x)  = -\frac{1}{1+x^{2} }\mathrm{d}x$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h1 id="常用等价无穷小"><a href="#常用等价无穷小" class="headerlink" title="常用等价无穷小"></a>常用等价无穷小</h1><p>当 $x\to 0$ 时</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">函数一</th><th style="text-align:center">函数二</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$\displaystyle a^{x} -1$</td><td style="text-align:center">$\displaystyle x\ln{a} $</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$\displaystyle (1+x)^{a} -1$</td><td style="text-align:center">$\displaystyle ax (a\ne 0)$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$\displaystyle x -\ln{(1+x)} $</td><td style="text-align:center">$\displaystyle \frac{1}{2} x^{2} $</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$\displaystyle \ln_{}{(x+1)} $</td><td style="text-align:center">$\displaystyle x$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$\displaystyle \sin x,\tan x,\arcsin x,\arctan x$</td><td style="text-align:center">$\displaystyle x$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$\displaystyle 1-\cos ^{2}x $</td><td style="text-align:center">$\displaystyle \frac{1}{2} x^{2} $</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$\displaystyle 1-\cos ^{a} x$</td><td style="text-align:center">$\displaystyle \frac{a}{2} x^{2} $</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h1 id="二、微分中值定理与泰勒公式"><a href="#二、微分中值定理与泰勒公式" class="headerlink" title="二、微分中值定理与泰勒公式"></a>二、微分中值定理与泰勒公式</h1><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><p>假设函数 $f(x)$ 在 $x_{0}$ 处有 $n$ 阶导数</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>公式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td></td></tr><tr><td style="text-align:center">2</td><td></td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><h1 id="三、不定积分表"><a href="#三、不定积分表" class="headerlink" title="三、不定积分表"></a>三、不定积分表</h1><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">函数</th><th style="text-align:center">不定积分</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$k$</td><td style="text-align:center">$\int k\mathrm{d}x =kx+C$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$\displaystyle x^{a}$</td><td style="text-align:center">$\displaystyle \int x^{a} \mathrm{d}x =\frac{1}{a+1}x^{a+1}  x+C(a\ne -1)$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$\displaystyle \frac{1}{x} $</td><td style="text-align:center">$\displaystyle \int \frac{1}{x} \mathrm{d}x = \ln_{}{\left \lfloor x \right \rfloor } +C$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$\displaystyle a^{x} (a&gt;0,a\ne 1)$</td><td style="text-align:center">$\displaystyle a^{x} (a&gt;0,a\ne 1)\displaystyle \int  a^{x}\mathrm{d}x = \frac{a^{x} }{\ln_{}{a} } +C$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$\displaystyle e^{x} $</td><td style="text-align:center">$\displaystyle \int e^{x}\mathrm{d}x = e^{x} +C$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$\displaystyle \lg_{a}{x}$</td><td style="text-align:center">$\displaystyle \int  \lg_{a}{x}\mathrm{d}x = \frac{1}{\ln{a}}(x\ln_{}{x}-x )  +C$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$\ln_{}{x} $</td><td style="text-align:center">$\displaystyle \int  \ln_{}{x} \mathrm{d}x = x\ln_{}{x}-x+C$</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">$\displaystyle \sin x $</td><td style="text-align:center">$\displaystyle \int  \sin x\mathrm{d}x =-\cos x+C$</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">$\displaystyle \cos x $</td><td style="text-align:center">$\displaystyle \int  \cos x \mathrm{d}x =\sin x+C$</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">$\displaystyle \sec ^{2}x$</td><td style="text-align:center">$\displaystyle \int  \sec ^{2}x \mathrm{d}x =\int \frac{1}{\cos ^{2}x } \mathrm{d}x =\tan x+C$</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">$\displaystyle \csc ^{2}x$</td><td style="text-align:center">$\displaystyle \int  \csc ^{2}x \mathrm{d}x =\int \frac{1}{\sin ^{2}x } \mathrm{d}x =\cot x+C$</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">$\sec x\cdot \tan x $</td><td style="text-align:center">$\displaystyle \int\sec x\cdot \tan x \mathrm{d}x =\sec x+C$</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">$\displaystyle \csc x\cdot \tan x$</td><td style="text-align:center">$\displaystyle \int\csc x\cdot \tan x\mathrm{d}x =-\csc x+C$</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">$\displaystyle \frac{1}{\sqrt{1-x^{2}}}$</td><td style="text-align:center">$\displaystyle \int\frac{1}{\sqrt{1-x^{2}}}\mathrm{d}x =\arcsin x+C$</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">$\displaystyle \frac{1}{1+x^{2}}$</td><td style="text-align:center">$\displaystyle \int\frac{1}{1+x^{2}}\mathrm{d}x =\arctan x+C$</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">$\displaystyle \frac{1}{x^{2}+a^{2} } $</td><td style="text-align:center">$\displaystyle \int\frac{1}{x^{2}+a^{2} } \mathrm{d}x =\frac{\arctan \frac{x}{a} }{a} +C$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h1 id="四、牛顿-莱布尼兹公式"><a href="#四、牛顿-莱布尼兹公式" class="headerlink" title="四、牛顿-莱布尼兹公式"></a>四、牛顿-莱布尼兹公式</h1><script type="math/tex; mode=display">\displaystyle \int_{a}^{b} f(x)\mathrm{d}x  = F(b)-F(a)</script><h1 id="五、微分方程"><a href="#五、微分方程" class="headerlink" title="五、微分方程"></a>五、微分方程</h1><h2 id="一阶线性微分方程的解"><a href="#一阶线性微分方程的解" class="headerlink" title="一阶线性微分方程的解"></a>一阶线性微分方程的解</h2><p>已知微分方程 ${y}’ +P(x)y = Q(x)$ ；</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th>通解</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">齐次</td><td>$\displaystyle y=Ce^{\displaystyle -\int P(x)\mathrm{d}x} $</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">非齐次</td><td>$\displaystyle y=e^{\displaystyle -\int P(x)\mathrm{d}x} (\int Q(x)e^{\displaystyle \int P(x)\mathrm{d}x} \mathrm{d}x +C)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="二阶常系数齐次线性微分方程的解"><a href="#二阶常系数齐次线性微分方程的解" class="headerlink" title="二阶常系数齐次线性微分方程的解"></a>二阶常系数齐次线性微分方程的解</h2><p>已知微分方程 ${y}’’ +p{y}’ +qy=0$ ，特征方程的为 $r^{2} +pr+q=0$ 。</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th>通解</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">两个实根</td><td>$\displaystyle y = C_{1}e^{r_{1} x}+C_{2}e^{r_{2} x} $</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">一个2重实根</td><td>$\displaystyle y = (C_{1}+C_{2})e^{rx} $</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">复数根</td><td>$y = e^{\alpha } (C_{1}\cos \beta x+C_{2}\sin \beta x)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h1 id="六、向量与空间方程"><a href="#六、向量与空间方程" class="headerlink" title="六、向量与空间方程"></a>六、向量与空间方程</h1><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><h2 id="空间方程"><a href="#空间方程" class="headerlink" title="空间方程"></a>空间方程</h2><h3 id="空间平面"><a href="#空间平面" class="headerlink" title="空间平面"></a>空间平面</h3><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th style="text-align:center">方程</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">点法式</td><td style="text-align:center">$A(x-x_{0} )+B(y-y_{0} )+C(z-z_{0} )=0$</td><td>点 $(x_{0},y_{0},z_{0})$，过该点的法向量 $n=(A,B,C)$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">一般方程</td><td style="text-align:center">$Ax+By+C+D=0$</td><td>一条法向量 $n=(A,B，C)$ ， $D$ 是平面的“相位”</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th style="text-align:center">方程</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">一般方程</td><td style="text-align:center">$\left\{\begin{matrix} A_{1} x+B_{1} y+C_{1} +D_{1} =0\\ A_{2} x+B_{2} y+C_{2} +D_{2} =0\end{matrix}\right.$</td><td>两平面相交</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">对称式</td><td style="text-align:center">$\displaystyle \frac{x-x_{0} }{m} +\frac{y-y_{0} }{n} +\frac{z-z_{0} }{p}=t$</td><td>方向向量 $s=(m,n,p)$ ，直线过点 $M_{0} (x_{0},y_{0} ,z_{0}  )$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">参数方程</td><td style="text-align:center">$\left\{\begin{matrix}x = mt+x_{0}  \\ y =nt+y_{0}\\z = pt+z_{0}\end{matrix}\right.$</td><td>由对称式可得</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h3><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th style="text-align:center">方程</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">球面</td><td style="text-align:center">$x^{2} +y^{2} +z^{2} =R^{2}$</td><td>球心在原点，半径为 $R$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">球面</td><td style="text-align:center">$(x-x_{0} )^{2}+ (y-y_{0} )^{2} +(z-z_{0} )=R^{2} $</td><td>球心在点 $M_{0} (x_{0},y_{0} ,z_{0}  )$ ，半径为 $R$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">球面一般方程</td><td style="text-align:center">$Ax^{2} +Ay^{2}+Az^{2}  +Dx+Ey+Fz+G=0$</td><td>注意：满足条件</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h1 id="七、向量"><a href="#七、向量" class="headerlink" title="七、向量"></a>七、向量</h1><h2 id="向量函数的求导"><a href="#向量函数的求导" class="headerlink" title="向量函数的求导"></a>向量函数的求导</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">原函数</th><th style="text-align:center">导函数</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$C$</td><td style="text-align:center">$\mathbf{0} $</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$C\overrightarrow{U(t)} $</td><td style="text-align:center">$C\overrightarrow{ {U}’ (t)} $</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$\overrightarrow{U(t)} \pm \overrightarrow{V(t)} $</td><td style="text-align:center">$\overrightarrow{ {U}’ (t)} \pm \overrightarrow{ {V}’ (t)} $</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$\varphi (t)\overrightarrow{V(t)} $</td><td style="text-align:center">${\varphi }’ (t)\overrightarrow{V (t)} +\varphi (t)\overrightarrow{ {V}’ (t)}$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$\overrightarrow{U(t)} \cdot \overrightarrow{V(t)} $</td><td style="text-align:center">$\overrightarrow{ {U}’ (t)} \cdot \overrightarrow{V(t)} +\overrightarrow{U(t)} \cdot \overrightarrow{ {V}’ (t)} $</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$\overrightarrow{U(t)} \times \overrightarrow{V (t)} $</td><td style="text-align:center">$\overrightarrow{ {U}’ (t)} \times \overrightarrow{V(t)} +\overrightarrow{U (t)} \times \overrightarrow{ {V }’ (t)} $</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$\overrightarrow{U\left [ \varphi (t) \right ] }$</td><td style="text-align:center">${\varphi }’ (t)\overrightarrow{ {U}’ \left [ \varphi (t) \right ] }$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h1 id="八、坐标系"><a href="#八、坐标系" class="headerlink" title="八、坐标系"></a>八、坐标系</h1><h2 id="平面坐标系"><a href="#平面坐标系" class="headerlink" title="平面坐标系"></a>平面坐标系</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th><th style="text-align:center">直角坐标系与极坐标的关系</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">线元</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">线元</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">面元</td><td style="text-align:center">$\mathrm{d}x\mathrm{d}y=\rho \mathrm{d}\rho  \mathrm{d}\theta $</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="空间坐标系"><a href="#空间坐标系" class="headerlink" title="空间坐标系"></a>空间坐标系</h2><p>【略】</p><h1 id="九、曲线积分与曲面积分"><a href="#九、曲线积分与曲面积分" class="headerlink" title="九、曲线积分与曲面积分"></a>九、曲线积分与曲面积分</h1><h2 id="9-1-曲线积分"><a href="#9-1-曲线积分" class="headerlink" title="9.1 曲线积分"></a>9.1 曲线积分</h2><ol><li><p>第一类曲线积分（对弧长的曲线积分）</p><script type="math/tex; mode=display"> \displaystyle \int_{L}^{} f(x,y)\mathrm{d} l</script></li><li><p>第一类曲线积分计算法</p><script type="math/tex; mode=display"> \displaystyle \int_{L}^{} f(x,y)\mathrm{d} l = \int_{\alpha }^{\beta } f \left [ \varphi (t),\psi (t)  \right ] \cdot \sqrt{ {\varphi}'^{2} (t) + {\psi}'^{2} (t) } \mathrm{d}t</script></li><li><p>第二类曲线积分（对坐标的曲线积分）</p><script type="math/tex; mode=display"> \begin{align}\displaystyle \int_{L} P(x,y) \mathrm{d}x \\\displaystyle \int_{L} Q(x,y) \mathrm{d}y \\\end{align}</script></li><li><p>第二类曲线积分计算法</p><script type="math/tex; mode=display"> \displaystyle \int_{L} P(x,y) \mathrm{d}x + Q(x,y) \mathrm{d}y = \int_{\alpha }^{\beta } P\left [ \varphi (t),\psi (t)  \right ] \cdot {\varphi}'(t)+Q\left [ \varphi (t),\psi (t)  \right ] \cdot {\psi}'(t) \mathrm{d}t</script></li><li><p>两类曲线积分之间的联系</p><script type="math/tex; mode=display"> \displaystyle \int_{L} P\mathrm{d}x + Q\mathrm{d}y = \displaystyle \int_{L} (P\cos \alpha  + Q\cos \beta )\mathrm{d}l</script></li><li><p>格林公式</p><p> 在平面闭区域 $D$ 上的二重积分可以通过沿闭区域 $D$ 的边界曲线 $L$ 上的曲线积分来表达。</p><script type="math/tex; mode=display"> \displaystyle \underset{D}{\iint} \left ( \frac{\partial Q}{\partial x} -\frac{\partial P}{\partial y} \right ) \mathrm{d}x \mathrm{d}y  = \oint_{L} P\mathrm{d}x+Q\mathrm{d}y</script></li></ol><h2 id="9-2-曲面积分"><a href="#9-2-曲面积分" class="headerlink" title="9.2 曲面积分"></a>9.2 曲面积分</h2><ol><li><p>第一类曲面积分（对面积的曲面积分）</p><script type="math/tex; mode=display"> \displaystyle \underset{\Sigma }{\iint } f(x,y,z) \mathrm{d}S</script></li><li><p>第一类曲面积分的计算法</p><script type="math/tex; mode=display"> \displaystyle \underset{D_{xy} }{\iint } f(x,y,z) \cdot \sqrt{1+Z_{x}^{2} (x+y) + Z_{y}^{2} (x+y)} \mathrm{d}x\mathrm{d}y</script></li><li><p>第二类曲面积分（对坐标的曲面积分）</p><script type="math/tex; mode=display"> \begin{align}\underset{D}{\iint } P\mathrm{d}y\mathrm{d}z\\\underset{D}{\iint } Q\mathrm{d}x\mathrm{d}z\\\underset{D}{\iint } R\mathrm{d}x\mathrm{d}y\\\end{align}</script></li><li><p>第二类曲面积分的计算法</p></li><li><p>两类曲面积分之间的联系</p></li><li><p>高斯公式</p><p> 空间闭区域上的三重积分与其边界曲面上的曲面积分之间的关系。</p><script type="math/tex; mode=display"> \displaystyle \underset{D}{ \iiint } \left ( \frac{\partial P}{\partial x}  + \frac{\partial P}{\partial x} + \frac{\partial P}{\partial x} \right ) \mathrm{d}d= \underset{\Sigma }{\int\kern{-8pt}\int \kern{-25mu} \bigcirc \bf } P\mathrm{d}y \mathrm{d}z+Q\mathrm{d}z \mathrm{d}z +R\mathrm{d}x \mathrm{d}y</script></li></ol><h2 id="9-3-斯托克斯公式"><a href="#9-3-斯托克斯公式" class="headerlink" title="9.3 斯托克斯公式"></a>9.3 斯托克斯公式</h2><p>斯托克斯公式是格林公式的推广，表示曲面上的曲面积分与曲面的边界曲线的曲线积分之间的联系。</p><script type="math/tex; mode=display">\begin{align}\displaystyle &\underset{\Sigma }{\iint } \left ( \frac{\partial R}{\partial y}- \frac{\partial Q}{\partial z}\right ) \mathrm{d}y \mathrm{d}z +\left ( \frac{\partial P}{\partial z}- \frac{\partial R}{\partial z}\right )\mathrm{d}x\mathrm{d}z+\left ( \frac{\partial Q}{\partial x}- \frac{\partial P}{\partial y}\right ) \mathrm{d}x \mathrm{d}y \\&= \oint _{L} P\mathrm{d}x+Q\mathrm{d}y+R\mathrm{d}z\end{align}</script><p>其公式的运算方法如下：</p><script type="math/tex; mode=display">\begin{vmatrix} \mathrm{d}y \mathrm{d}z  &  \mathrm{d}z \mathrm{d}z  &  \mathrm{d}z \mathrm{d}y \\ \frac{\partial }{\partial x}  & \frac{\partial }{\partial y}  & \frac{\partial }{\partial z} \\  P& Q &R\end{vmatrix}</script>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一章 曲线积分和曲面积分【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/11.%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E5%92%8C%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/11.%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E5%92%8C%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十一章-曲面积分和曲线积分"><a href="#第十一章-曲面积分和曲线积分" class="headerlink" title="第十一章 曲面积分和曲线积分"></a>第十一章 曲面积分和曲线积分</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><strong><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></strong></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="11-1-对弧长的曲线积分"><a href="#11-1-对弧长的曲线积分" class="headerlink" title="11.1 对弧长的曲线积分"></a>11.1 对弧长的曲线积分</h1><h2 id="11-1-1-对弧长的曲线积分的概念与性质"><a href="#11-1-1-对弧长的曲线积分的概念与性质" class="headerlink" title="11.1.1 对弧长的曲线积分的概念与性质"></a>11.1.1 对弧长的曲线积分的概念与性质</h2><p><strong>定义（曲线积分）</strong>： 曲线积分表达式：</p><script type="math/tex; mode=display">\displaystyle \int\limits_{L}f(x,y)\mathrm{d}L</script><p><strong>性质</strong>：</p><ol><li>$\displaystyle \int\limits_{L}\left [ \alpha f(x,y)+\beta g(x,y) \right ] \mathrm{d}L= \alpha\int\limits_{L}f(x,y)\mathrm{d}L+\beta \int\limits_{L}g(x,y)\mathrm{d}L$ 。</li><li>$\displaystyle \int\limits_{L}f(x,y) \mathrm{d}L = \int\limits_{L_{1} }f(x,y) \mathrm{d}L +\int\limits_{L_{2} }f(x,y) \mathrm{d}L $ 。</li><li>$\displaystyle \left | \int\limits_{L}f(x,y)\mathrm{d}L \right | \le \int\limits_{L}\left | f(x,y) \right | \mathrm{d}L$ 。</li><li>$\displaystyle \text{if:}  f(x,y)\le  g(x,y) ,\quad \int\limits_{L}f(x,y) \mathrm{d}L\le \int\limits_{L}g(x,y) \mathrm{d}L$ 。</li></ol><h2 id="11-1-2-对弧长的曲线积分的计算方法"><a href="#11-1-2-对弧长的曲线积分的计算方法" class="headerlink" title="11.1.2 对弧长的曲线积分的计算方法"></a>11.1.2 对弧长的曲线积分的计算方法</h2><p><strong>定理</strong>：假设曲线 $L$ 的参数方程为 $\left\{\begin{matrix} x=\varphi (t)\\ y=\psi (t)\end{matrix}\right.\quad (\alpha \le t\le \beta ) $ ，并且 $\displaystyle \left [ {\varphi }’ (t) \right ]^{2}+ \left [ {\psi}’ (t) \right ]^{2}\ne 0$ ，那么</p><script type="math/tex; mode=display">\displaystyle \int\limits_{L}f(x,y)\mathrm{d}L= \int\limits_{\alpha }^{\beta } f\left [ \varphi (t),\psi (t)\right ] \sqrt{\displaystyle\left [ {\varphi }'(t)\right ]^{2}+\left [ {\psi}' (t)\right ]^{2}}\mathrm{d}t</script><p>特殊情况：</p><ol><li>如果 $y=g(x)$ ，那么参数方程为：$\displaystyle \left\{\begin{matrix} x = t\\y=g(t)\end{matrix}\right.\quad t\in \left [ m,n \right ] $ 。</li></ol><h1 id="11-2-对坐标的曲线积分"><a href="#11-2-对坐标的曲线积分" class="headerlink" title="11.2 对坐标的曲线积分"></a>11.2 对坐标的曲线积分</h1><h2 id="11-2-1-对坐标的曲线积分的概念与性质"><a href="#11-2-1-对坐标的曲线积分的概念与性质" class="headerlink" title="11.2.1 对坐标的曲线积分的概念与性质"></a>11.2.1 对坐标的曲线积分的概念与性质</h2><p><strong>引例</strong>：物体做功的计算公式为： $W = \overrightarrow{F} \cdot \overrightarrow{x} $ ，假设物体的运动轨迹是一条曲线 $F(x,y)=0$ 进行运动，那么将曲线分成 $n$ 段，每一段近似为直线运动，去每一段上的一点作为计算点，得到：</p><script type="math/tex; mode=display">\begin{align}W & = \displaystyle \lim_{\lambda \to 0} \sum_{i=1}^{n} F(\xi _{i},\eta _{i})\cdot (\Delta x\overrightarrow{i} +\Delta y\overrightarrow{j})\\&  = \lim_{\lambda \to 0} \sum_{i  = 1}^{n}\left [ P(\xi _{i},\eta _{i})\Delta x_{i} +Q(\xi _{i},\eta _{i})\Delta y_{i} \right ] \end{align}</script><p>其中， $F(x,y)= P(x,y)\overrightarrow{i}  + Q(x,y)\overrightarrow{j} $ 。</p><p><strong>定义</strong>：设 $L$ 为<strong>有向线段</strong>，函数 $F(x,y)$ 的对坐标轴的曲线积分为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \int\limits_{L}P(x,y)\mathrm{d}x &=\lim_{\lambda \to 0} \sum_{i  = 1}^{n}P(\xi _{i},\eta _{i})\Delta x_{i} \\\displaystyle \int\limits_{L}Q(x,y)\mathrm{d}y &=\lim_{\lambda \to 0} \sum_{i  = 1}^{n}Q(\xi _{i},\eta _{i})\Delta x_{i} \\\end{align}</script><blockquote><p>三维的曲线同样适用。</p></blockquote><p><strong>性质 1</strong>： $\displaystyle \int\limits_{L}\left [ \alpha F_{1} (x,y)+ \beta F_{2}(x,y) \right ] \cdot \mathrm{d}r =\alpha  \int\limits_{L} F_{1} (x,y) \cdot \mathrm{d}r+\beta \int\limits_{L} F_{2} (x,y) \cdot \mathrm{d}r$ 。</p><p><strong>性质 2</strong>： $\int\limits_{L}F(x,y)\cdot \mathrm{d}r = \int\limits_{L_{1}}F(x,y)\cdot \mathrm{d}r +\int\limits_{L_{2}}F(x,y)\cdot \mathrm{d}r $ 。</p><p><strong>性质 3</strong>： $L^{-}$ 是曲线 $L$ 的反向曲线，那么 $\int\limits_{L^{-} }F(x,y)\cdot \mathrm{d}r = -\int\limits_{L}F(x,y)\cdot \mathrm{d}r $ 。</p><h2 id="11-2-2-对坐标的曲线积分的计算方法"><a href="#11-2-2-对坐标的曲线积分的计算方法" class="headerlink" title="11.2.2 对坐标的曲线积分的计算方法"></a>11.2.2 对坐标的曲线积分的计算方法</h2><p><strong>定理</strong>：函数 $F(x,y)$ 能表示为参数方程： $\left\{\begin{matrix}x=\varphi (t)\\y=\psi (t)\end{matrix}\right.$ ，起点 $A$ 到终点 $B$ ，参数满足 $t:\alpha\to  \beta $ ，那么得到下面的关系：</p><script type="math/tex; mode=display">\begin{align}\int\limits_{L}P(x,y)\mathrm{d}x+Q(x,y)\mathrm{d}y & = \int_{\alpha }^{\beta } \left [  P \left ( \varphi(t),\psi (t) \right ) {\varphi}'(t)+ Q\left ( \varphi(t),\psi (t) \right ) {\psi}'(t) \right ]  \mathrm{d}t \end{align}</script><h2 id="11-2-3-两类曲线积分之间的联系"><a href="#11-2-3-两类曲线积分之间的联系" class="headerlink" title="11.2.3 两类曲线积分之间的联系"></a>11.2.3 两类曲线积分之间的联系</h2><p><strong>回忆</strong>：</p><ul><li>第一类曲线积分： $\displaystyle \int\limits_{L}f(x,y)\mathrm{d}L= \int\limits_{\alpha }^{\beta } f\left [ \varphi (t),\psi (t)\right ] \sqrt{\displaystyle\left [ {\varphi }’(t)\right ]^{2}+\left [ {\psi}’ (t)\right ]^{2}}\mathrm{d}t$ 。</li><li>第二类曲线积分： $\begin{align}\int\limits_{L}P(x,y)\mathrm{d}x+Q(x,y)\mathrm{d}y &amp; = \int_{\alpha }^{\beta } \left [  P \left ( \varphi(t),\psi (t) \right ) {\varphi}’(t)+ Q\left ( \varphi(t),\psi (t) \right ) {\psi}’(t) \right ]  \mathrm{d}t \end{align}$ 。</li></ul><p>上面两种曲线积分，其本质上应该是等价的，那么可以得到：</p><script type="math/tex; mode=display">\begin{align}\text{第二类} &=\int_{\alpha }^{\beta } \left [  P \left ( \varphi(t),\psi (t) \right ) {\varphi}'(t)+Q\left ( \varphi(t),\psi (t) \right ) {\psi}'(t) \right ]\mathrm{d}t \\&=\int_{\alpha }^{\beta}P(\varphi(t),\psi (t))\frac{ {\varphi}'(t)}{\sqrt{ {\varphi}'^{2} (t)+{\psi}'^{2} (t)} } +Q(\varphi(t),\psi (t))\frac{ {\psi}'(t)}{\sqrt{ {\varphi}'^{2} (t)+{\psi}'^{2} (t)}} \sqrt{ {\varphi}'^{2} (t)+{\psi}'^{2} (t)}\mathrm{d}t\\&=\int\limits_{L}\left [ P(x,y)\cos \alpha +Q(x,y)\cos \beta  \right ] \mathrm{d}s \end{align}</script><h1 id="11-3-格林公式及其应用"><a href="#11-3-格林公式及其应用" class="headerlink" title="11.3 格林公式及其应用"></a>11.3 格林公式及其应用</h1><h2 id="11-3-1-格林公式"><a href="#11-3-1-格林公式" class="headerlink" title="11.3.1 格林公式"></a>11.3.1 格林公式</h2><p>在平面闭区域 $D$ 上的二重积分，只关注平面的边界曲线，就是<strong>格林公式</strong>的意义。</p><p><strong>单连通区域</strong>： $D$ 平面区域，其中内部任意的闭曲线围成的部分都是属于 $D$ 。</p><p><strong>复连通区域</strong>：区域中间有洞的。</p><p><strong>正方向</strong>：外边缘逆时针，内边缘顺时针。</p><p><strong>定理（格林公式）</strong>：闭区域 $D$ 有分段光滑的曲线 $L$ 围成的，函数 $P(a,y),Q(x,y)$ 在 $D$ 上有一阶连续偏导，那么有：</p><script type="math/tex; mode=display">\iint\limits_{D}(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y})\mathrm{d}x\mathrm{d}y = \oint_{L}P\mathrm{d}x+Q\mathrm{d}y</script><h2 id="11-3-2-平面上曲线积分与路径无关的条件"><a href="#11-3-2-平面上曲线积分与路径无关的条件" class="headerlink" title="11.3.2 平面上曲线积分与路径无关的条件"></a>11.3.2 平面上曲线积分与路径无关的条件</h2><h2 id="11-3-3-二元函数的全微分求积"><a href="#11-3-3-二元函数的全微分求积" class="headerlink" title="11.3.3 二元函数的全微分求积"></a>11.3.3 二元函数的全微分求积</h2><h1 id="11-4-对面积的曲面积分"><a href="#11-4-对面积的曲面积分" class="headerlink" title="11.4 对面积的曲面积分"></a>11.4 对面积的曲面积分</h1><h2 id="11-4-1-对面积的曲面积分的概念与性质"><a href="#11-4-1-对面积的曲面积分的概念与性质" class="headerlink" title="11.4.1 对面积的曲面积分的概念与性质"></a>11.4.1 对面积的曲面积分的概念与性质</h2><p><strong>引例</strong>：设曲面形构建具有连续面密度 $\rho (x,y,z)$ ，求质量 $M$ 。</p><p><strong>定义</strong>：设 $\Sigma $ 为光滑曲面， $f(x,y,z)$ 是定义在 $\Sigma $ 上的一个有界函数，若对 $\Sigma $ 做任意分割和局部区域取任意点，下面</p><script type="math/tex; mode=display">\lim_{\lambda \to 0} \sum_{k=1}^{n}f(\xi_{k}  ,\eta_{k}  ,\zeta_{k})\Delta S_{k} =\iint\limits_{\Sigma }f(x,y,z)\mathrm{d}S</script><p>都存在，则称此极限为函数 $f(x,y,z)$ 在曲面 $\Sigma $ 上<strong>对面积的曲面积分</strong>或者<strong>第一类曲面积分</strong>，其中 $f(x,y,z)$ 叫做被积函数， $\Sigma $ 叫做积分曲面。</p><p><strong>曲面积分的性质</strong>：</p><ol><li>与曲线积分的性质相似。</li></ol><h2 id="11-4-2-对面积的曲面积分的计算法"><a href="#11-4-2-对面积的曲面积分的计算法" class="headerlink" title="11.4.2 对面积的曲面积分的计算法"></a>11.4.2 对面积的曲面积分的计算法</h2><p><strong>定理</strong>：设有光滑曲面 $\Sigma :z=z(x,y),\quad (x,y)\in D_{xy} $ ，函数 $f(x,y,z)$ 在 $\Sigma $ 上连续，则曲面积分 $\displaystyle \iint\limits_{\Sigma }f(x,y,z)\mathrm{d}S$ 存在，且有：</p><script type="math/tex; mode=display">\iint\limits_{\Sigma }f(x,y,z)\mathrm{d}S = \iint\limits_{D}f(x,y,z(x,y))\sqrt{1+z_{x}^{2}(x,y)+z_{y}^{2}(x,y)} \mathrm{d}x\mathrm{d}y</script><p>上述公式是：曲面向 $xOy$ 平面进行投影，当然也可以向 $xOz,yOz$ 平面投影。</p><h1 id="11-5-对坐标的曲面积分"><a href="#11-5-对坐标的曲面积分" class="headerlink" title="11.5 对坐标的曲面积分"></a>11.5 对坐标的曲面积分</h1><h2 id="11-5-1-对坐标的曲面积分的概念与性质"><a href="#11-5-1-对坐标的曲面积分的概念与性质" class="headerlink" title="11.5.1 对坐标的曲面积分的概念与性质"></a>11.5.1 对坐标的曲面积分的概念与性质</h2><p><strong>有向曲面</strong>：</p><ol><li>方向余弦 $\cos \alpha &gt;0$ ，作为曲面的前侧； $\cos \alpha&lt;0$ ，作为曲面的后侧。</li><li>方向余弦 $\cos\beta&gt;0$ ，作为曲面的右侧； $\cos\beta &lt;0$ ，作为曲面的左侧。</li><li>方向余弦 $\cos\gamma &gt;0$ ，作为曲面的上侧； $\cos\gamma  &lt;0$ ，作为曲面的下册。</li><li>封闭曲面：内测、外侧。</li></ol><p>设 $\Sigma $ 为空间中的有向曲面，其面元 $\Delta S$ 在 $xOy$ 面上的投影记为 $\left ( \Delta S \right ) _{xy} $ 的面积为 $\left ( \Delta \sigma  \right ) _{xy} $ ，则规定：</p><script type="math/tex; mode=display">\left ( \Delta S\right)_{xy} =\left\{\begin{matrix} \left ( \Delta \sigma \right)_{xy} & \cos \gamma >0\\  -\left ( \Delta \sigma \right)_{xy}  & \cos \gamma <0\\ 0&\cos \gamma =0\end{matrix}\right.</script><p><strong>定义</strong>：设 $\Sigma $ 为光滑的有向曲面，在 $\Sigma $ 上定义了一个向量场 $\overrightarrow{A} =(P,Q,R)$ ，其中， $P,Q,R$ 是关于 $x,y,z$ 的三元函数，那么</p><script type="math/tex; mode=display">\iint\limits_{\Sigma }P\mathrm{d}y\mathrm{d}z+Q\mathrm{d}x\mathrm{d}z+R\mathrm{d}x\mathrm{d}y</script><p>称为<strong>对坐标的曲面积分</strong>或者<strong>第二类曲面积分</strong>。</p><p>  $\displaystyle \iint\limits_{\Sigma }P\mathrm{d}y\mathrm{d}z$  称为 $P$ 在有向曲面 $\Sigma $ 上 <strong>对 $x,y$ 的曲面积分</strong>；</p><p> $\displaystyle \iint\limits_{\Sigma }Q\mathrm{d}x\mathrm{d}z$ 称为 $Q$ 在有向曲面 $\Sigma $ 上 <strong>对 $x,z$ 的曲面积分</strong>；</p><p> $\displaystyle \iint\limits_{\Sigma }R\mathrm{d}x\mathrm{d}y$ 称为 $R$ 在有向曲面 $\Sigma $ 上 <strong>对 $y,z$ 的曲面积分</strong>。</p><p>流过有向曲面 $\Sigma $ 的流体的流量为</p><script type="math/tex; mode=display">\Phi =\iint\limits_{\Sigma }P\mathrm{d}y\mathrm{d}z+Q\mathrm{d}x\mathrm{d}z+R\mathrm{d}x\mathrm{d}y</script><p>如果记 $\Sigma $ 正常的单位法向量为 $\overrightarrow{n} =(\cos \alpha ,\cos \beta ,\cos \gamma )$ ，并且令 $\overrightarrow{\mathrm{d}S} =\overrightarrow{n}\mathrm{d}S=(\mathrm{d}y\mathrm{d}z,\mathrm{d}x\mathrm{d}z,\mathrm{d}x\mathrm{d}y)$ ，则对坐标的曲面积分也常写为如下向量形式：</p><script type="math/tex; mode=display">\iint\limits_{\Sigma }P\mathrm{d}y\mathrm{d}z+Q\mathrm{d}x\mathrm{d}z+R\mathrm{d}x\mathrm{d}y=\iint\limits_{\Sigma }\overrightarrow{A} \cdot \overrightarrow{\mathrm{d}S}</script><h2 id="11-5-2-对坐标的曲面积分的计算法"><a href="#11-5-2-对坐标的曲面积分的计算法" class="headerlink" title="11.5.2 对坐标的曲面积分的计算法"></a>11.5.2 对坐标的曲面积分的计算法</h2><p><strong>定理</strong>：设光滑曲面 $\Sigma :z=z(x,y),\quad (x,y)\in D_{xy} $ ，取上侧 $R(x,y,z)$ 是 $\Sigma $ 上的连续函数，则</p><script type="math/tex; mode=display">\iint\limits_{\Sigma }R(x,y,z)\mathrm{d}x\mathrm{d}y=\iint\limits_{D_{xy} }R(x,y,z(x,y))\mathrm{d}x\mathrm{d}y</script><h2 id="11-5-3-两类曲面积分之间的联系"><a href="#11-5-3-两类曲面积分之间的联系" class="headerlink" title="11.5.3 两类曲面积分之间的联系"></a>11.5.3 两类曲面积分之间的联系</h2><script type="math/tex; mode=display">\iint\limits_{\Sigma }P\mathrm{d}y\mathrm{d}z+Q\mathrm{d}z\mathrm{d}x+R\mathrm{d}x\mathrm{d}y=\iint\limits_{\Sigma }(P\cos \alpha +Q\cos \beta +R\cos \gamma )\mathrm{d}S</script><p> 也有向量形式：</p><script type="math/tex; mode=display">\iint\limits_{\Sigma }\overrightarrow{A} \cdot \overrightarrow{\mathrm{d}S} =\iint\limits_{\Sigma }\overrightarrow{A} \cdot \overrightarrow{n} \mathrm{d}S</script><h1 id="11-6-高斯公式"><a href="#11-6-高斯公式" class="headerlink" title="11.6 高斯公式"></a>11.6 高斯公式</h1><h2 id="11-6-1-高斯公式"><a href="#11-6-1-高斯公式" class="headerlink" title="11.6.1 高斯公式"></a>11.6.1 高斯公式</h2><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E9%AB%98%E6%96%AF%E5%AE%9A%E7%90%86.png" alt="高斯定理" style="zoom:50%" /></p><h1 id="11-7-斯托克斯公式"><a href="#11-7-斯托克斯公式" class="headerlink" title="11.7 斯托克斯公式"></a>11.7 斯托克斯公式</h1><h2 id="11-7-1-斯托克斯公式"><a href="#11-7-1-斯托克斯公式" class="headerlink" title="11.7.1 斯托克斯公式"></a>11.7.1 斯托克斯公式</h2><p>【略】</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 重积分【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/10.%E9%87%8D%E7%A7%AF%E5%88%86.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/10.%E9%87%8D%E7%A7%AF%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-重积分"><a href="#第十章-重积分" class="headerlink" title="第十章 重积分"></a>第十章 重积分</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><strong><a href="./10.重积分">第十章 重积分</a></strong></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="10-1-二重积分的概念与性质"><a href="#10-1-二重积分的概念与性质" class="headerlink" title="10.1 二重积分的概念与性质"></a>10.1 二重积分的概念与性质</h1><h2 id="10-1-1-二重积分的概念"><a href="#10-1-1-二重积分的概念" class="headerlink" title="10.1.1 二重积分的概念"></a>10.1.1 二重积分的概念</h2><p>引例：求解曲顶柱体的体积。</p><p><strong>定义</strong>：有界函数 $f(x,y)$ ，将区域 $D$ 任意的分成 $n$ 个区域 $\Delta \delta _{n} $ ，在每一个 $\Delta \delta _{n} $ 中，任意取一点 $(\zeta _{n} ,\eta_{n}  )$ ，那么</p><script type="math/tex; mode=display">\displaystyle \lim_{\lambda \to 0} \sum _{i=1}^{n} f(\zeta _{i} ,\eta_{i}  )\Delta \delta _{i} = \iint_{D}f(x,y)\mathrm{d} \sigma</script><p><strong>$X$ 型区域</strong>：</p><h2 id="10-1-2-二重积分的性质"><a href="#10-1-2-二重积分的性质" class="headerlink" title="10.1.2 二重积分的性质"></a>10.1.2 二重积分的性质</h2><p><strong>性质 1</strong>： $\displaystyle \iint_{D}(\alpha f(x,y)+\beta g(x,y))d\sigma =\alpha \iint_{D} f(x,y)\mathrm{d} \sigma +\beta\iint_{D} g(x,y)\mathrm{d} \sigma $ 。</p><p><strong>性质 2（极其重要）</strong>： $\displaystyle \iint_{D}f(x,y)\mathrm{d}\sigma = \iint_{D_{1} }f(x,y)\mathrm{d}\sigma + \iint_{D_{2} }f(x,y)\mathrm{d}\sigma $ 。</p><p><strong>性质 3</strong>：$\displaystyle if: f(x,y)\equiv 1, \quad \iint_{D}f(x,y)\mathrm{d}\sigma=\sigma$ 。</p><p><strong>性质 4</strong>： $\displaystyle if: f(x,y)\le g(x,y), \quad \iint_{D}f(x,y)\mathrm{d}\sigma\le \iint_{D}g(x,y)\mathrm{d}\sigma$ 。</p><ol><li>推论： $\displaystyle \left | \iint_{D}f(x,y)\mathrm{d}\sigma \right | \le  \iint_{D}\left | f(x,y) \right |   \mathrm{d}\sigma$ 。</li></ol><p><strong>性质 5</strong>：$f(x,y)$ 的最大值、最小值是 $M,m$ ，那么 $\displaystyle m\sigma  \le \iint_{D}f(x,y)\mathrm{d}\sigma \le M\sigma $ 。</p><p><strong>性质 6（中值定理）</strong>： $\displaystyle m\le \frac{\iint_{D}f(x,y)\mathrm{d}\sigma }{\sigma } \le M$ ，即能找到一点 $\displaystyle \sigma f(\xi ,\eta ) = \iint_{D}f(x,y)\mathrm{d}\sigma $ 。</p><ol><li>理解：原来的函数是一个曲顶的柱体，一定能找到一个平顶的柱体，使二者的体积相等。</li></ol><h1 id="10-2-二重计算的计算法"><a href="#10-2-二重计算的计算法" class="headerlink" title="10.2 二重计算的计算法"></a>10.2 二重计算的计算法</h1><h2 id="10-2-1-利用直角坐标计算二重积分"><a href="#10-2-1-利用直角坐标计算二重积分" class="headerlink" title="10.2.1 利用直角坐标计算二重积分"></a>10.2.1 利用直角坐标计算二重积分</h2><p><strong>方法</strong>：设函数 $f(x,y)$ ，</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97-%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="二重积分的计算-直角坐标系" style="zoom:100%" /></p><p>那么积分式为：</p><script type="math/tex; mode=display">\displaystyle V=\int_{a}^{b} \left [ \int_{\varphi (x)}^{\psi (x)} f(x,y)\mathrm{d}y\right ]\mathrm{d}x</script><p>这是先 $y$ 在 $x$ 的二重积分，其也可以写作：</p><script type="math/tex; mode=display">\displaystyle V=\int_{a}^{b}\mathrm{d}x\int_{\varphi (x)}^{\psi (x)} f(x,y)\mathrm{d}y</script><blockquote><p>先 $x$ 再 $y$ 的形式：</p><script type="math/tex; mode=display">\displaystyle V=\int_{a}^{b} \left [ \int_{\varphi (y)}^{\psi (y)} f(x,y)\mathrm{d}x\right ]\mathrm{d}y</script><p>其也可以写作：</p><script type="math/tex; mode=display">\displaystyle V=\int_{a}^{b}\mathrm{d}y\int_{\varphi (y)}^{\psi (y)} f(x,y)\mathrm{d}x</script></blockquote><p><strong>$X,Y$ 型区域</strong>：</p><ol><li>在x轴上任取一点x，过该点作一条垂直于x轴的直线去穿区域，与D的边界曲线之交点不多于两个，即一进一出，此区域为X型区域。</li><li>类似的，在y轴上任取一点y，过该点作一条垂直于y轴的直线去穿区域，与D的边界曲线之交点不多于两个，即一进一出，此区域为Y型区域。</li></ol><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/X%E5%9E%8B%E5%8C%BA%E5%9F%9F%E4%B8%8EY%E5%9E%8B%E5%8C%BA%E5%9F%9F.png" alt="X型区域与Y型区域" style="zoom:50%" /></p><blockquote><ul><li>$X$ 型区域：使用先 $y$ 后 $x$ 的二重积分；</li><li>$Y$ 型区域：使用先 $x$ 后 $y$ 的二重积分。</li></ul></blockquote><h2 id="10-2-2-利用极坐标计算二重积分"><a href="#10-2-2-利用极坐标计算二重积分" class="headerlink" title="10.2.2 利用极坐标计算二重积分"></a>10.2.2 利用极坐标计算二重积分</h2><p><strong>极坐标系</strong>：确定平面上任意一点的位置，首先确定一个<strong>极点</strong>和一条<strong>极轴</strong>，那么，一组参数：点到极点的长度 $\rho$ 以及形成的夹角 $\theta$ ，就能描述平面内的任意一点。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="极坐标系" style="zoom:50%" /></p><p><strong>极坐标与直角坐标之间的转化</strong>：直角坐标系中的点 $(x,y)$，极坐标系中的点是 $\displaystyle (\rho ,\theta )$ ，它们之间的关系是</p><script type="math/tex; mode=display">\left\{\begin{matrix}x = \rho \cos \theta  \\y = \rho\sin \theta \end{matrix}\right.</script><p><strong>微分关系</strong>： $\displaystyle \mathrm{d}x \mathrm{d}y =\rho \mathrm{d}\rho  \mathrm{d}\theta  $ ，即</p><script type="math/tex; mode=display">\displaystyle \iint_{D}f(x,y)\mathrm{d}x \mathrm{d}y= \iint_{D}f(\rho \cos \theta ,\rho \sin \theta )\rho \mathrm{d}\rho \mathrm{d}\theta</script><h2 id="10-2-3-二重积分的换元法"><a href="#10-2-3-二重积分的换元法" class="headerlink" title="10.2.3 二重积分的换元法"></a>10.2.3 二重积分的换元法</h2><p><strong>直角坐标系</strong> $\to$ <strong>极坐标系</strong></p><p><strong>定理</strong>：$f(x,y)$ 在区域 $D$ 连续，并且 $\displaystyle x=x(u,v),y = y(u,v)$ 具有一阶连续偏导数，同时 $\displaystyle J=\frac{\partial (x,y)}{\partial (u,v)}\ne 0 $ ，那么对于区域 $D^{‘}$ 上的自变量 $u,v$ ，能得到：</p><script type="math/tex; mode=display">\displaystyle \iint_{D}f(x,y)\mathrm{d}x\mathrm{d}y= \iint_{D^{'} }f\left [ x(u,v),y(u,v) \right ]\cdot \left | J(u,v) \right |  \mathrm{d}u\mathrm{d}v</script><h1 id="10-3-三重积分"><a href="#10-3-三重积分" class="headerlink" title="10.3 三重积分"></a>10.3 三重积分</h1><h2 id="10-3-1-三重积分的概念"><a href="#10-3-1-三重积分的概念" class="headerlink" title="10.3.1 三重积分的概念"></a>10.3.1 三重积分的概念</h2><p>引例：假设存在一个物体，它的密度分布是不均匀的，密度函数为 $f(x,y,z)$ ，为了求解物体的质量，那么将物体任意分成 $n$ 个方块，方块的外接圆直径为 $\lambda $ ，当切割的小块足够小的时候，密度分布近似相等，那么将所有的小块质量相加，就能得到整体的质量：</p><script type="math/tex; mode=display">\lim_{\lambda  \to 0} \sum_{i=1}^{n} f(\eta _{i},\xi _{i},\varrho _{i})\Delta v_{i} = M</script><p><strong>定义（三重积分）</strong>：设三元函数为 $f(x,y,z)$ ，函数的三元积分为：</p><script type="math/tex; mode=display">\displaystyle \iiint\limits_{V}f(x,y,z)\mathrm{d}v</script><h2 id="10-3-2-三重积分的计算"><a href="#10-3-2-三重积分的计算" class="headerlink" title="10.3.2 三重积分的计算"></a>10.3.2 三重积分的计算</h2><p><strong>直角坐标系</strong>：三重积分的计算方法为：</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{b} \mathrm{d}x\int_{\varphi (x)}^{\psi(x)} \mathrm{d}y\int_{\phi (x,y)}^{\omega (x,y)} f(x,y,z)\mathrm{d}z</script><p><strong>柱面坐标系</strong>： 坐标系中的点为 $(\rho ,\theta ,z)$ ，满足的关系为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle x &= \rho \cos \theta \\\displaystyle y &= \rho \sin \theta \\\displaystyle z &= z \\\end{align}</script><p>并且有以下微分关系：</p><script type="math/tex; mode=display">\displaystyle \mathrm{d}x\mathrm{d}y\mathrm{d}z= \rho \mathrm{d}\rho \mathrm{d}\theta \mathrm{d}z</script><p><strong>球面坐标</strong>：坐标系中的点为 $\displaystyle (r,\theta ,\phi )$ ，满足的关系为</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="球坐标系" style="zoom:100%" /></p><script type="math/tex; mode=display">\begin{align}x&=r\sin \phi \cos \theta \\y&=r\sin \phi \sin \theta \\z&=r\cos \theta \end{align}</script><p>微分满足的关系为：</p><script type="math/tex; mode=display">\displaystyle  \mathrm{d}v\mathrm{d}x\mathrm{d}y\mathrm{d}z= r^{2} \sin \phi \mathrm{d}r\mathrm{d}\phi \mathrm{d}\theta</script><h1 id="10-4-重积分的应用"><a href="#10-4-重积分的应用" class="headerlink" title="10.4 重积分的应用"></a>10.4 重积分的应用</h1><h2 id="10-4-1曲面的面积"><a href="#10-4-1曲面的面积" class="headerlink" title="10.4.1曲面的面积"></a>10.4.1曲面的面积</h2><p>曲面 $z=f(x,y)$ ，去曲面上一个微元 $\mathrm{d}S$ ，并且向 $xOy$ 平面做投影，得到微元 $\mathrm{d}\sigma $ 。假设两个面微元的夹角为： $\theta $ ，那么得到 $\displaystyle \mathrm{d}S=\frac{\mathrm{d}\sigma }{\cos \theta } $ 。那么，</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d}\sigma }{\mathrm{d}S} =\cos\theta= \frac{\left | n_{1}\cdot n_{2} \right | }{ \left | n_{1} \right |\left |  n_{2} \right | }= \frac{1}{\sqrt{1+f_{x}^{2}  + f_{y}^{2}  } }</script><p>所以，得到：</p><script type="math/tex; mode=display">\displaystyle \mathrm{d}S = \frac{1}{\cos \theta } \mathrm{d}\sigma = \sqrt{1+f_{x}^{2}  + f_{y}^{2} } \mathrm{d}\sigma</script><h2 id="10-4-2-质心"><a href="#10-4-2-质心" class="headerlink" title="10.4.2 质心"></a>10.4.2 质心</h2><p><strong>曲面的之质心</strong>：假设曲面的面密度是 $u(x,y)$ ，那么质心的公式为：</p><script type="math/tex; mode=display">\begin{align}\overline{x} &=\frac{\iint\limits_{D}xu(x,y)\mathrm{d}\sigma }{\iint\limits_{D}u(x,y)\mathrm{d}\sigma } \\\overline{y} &=\frac{\iint\limits_{D}yu(x,y)\mathrm{d}\sigma }{\iint\limits_{D}u(x,y)\mathrm{d}\sigma } \\\end{align}</script><p><strong>三维物体的质心</strong>：</p><h2 id="10-4-3-转动惯量"><a href="#10-4-3-转动惯量" class="headerlink" title="10.4.3 转动惯量"></a>10.4.3 转动惯量</h2><p>【略】</p><h2 id="10-4-4-引力"><a href="#10-4-4-引力" class="headerlink" title="10.4.4 引力"></a>10.4.4 引力</h2><p>【略】</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九章 多元函数微分法及其应用【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/09.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E6%B3%95%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/09.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E6%B3%95%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-多元函数微分法及其应用"><a href="#第九章-多元函数微分法及其应用" class="headerlink" title="第九章 多元函数微分法及其应用"></a>第九章 多元函数微分法及其应用</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><strong><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></strong></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="9-1-多元函数的基本概念"><a href="#9-1-多元函数的基本概念" class="headerlink" title="9.1 多元函数的基本概念"></a>9.1 多元函数的基本概念</h1><h2 id="9-1-1-平面点集和n维空间"><a href="#9-1-1-平面点集和n维空间" class="headerlink" title="9.1.1 平面点集和n维空间"></a>9.1.1 平面点集和n维空间</h2><p><strong>定义（平面点集）</strong>：集合 $R^{2} =\left \{ (x,y)|x,y\in R \right \} $  称为<strong>平面点集</strong>。</p><p><strong>邻域</strong>：以点 $P$ 为中心，取一个半径小于 $\delta $ 的点集，称为点 $P$ 的邻域，记作 $U(P,\delta )=\left \{ P|\left | PP_{0} \right |&lt;\delta   \right \} $ 。</p><p><strong>去心邻域</strong>：在邻域的基础上，去除中心点，记作 $\overset{\circ }{U}  (P,\delta )=\left \{ P|\left | PP_{0} \right |&lt;\delta   \right \} $ 。</p><p><strong>内点</strong>：对于任意一点 $M$ ， $\exists \delta \in R $ ，使得 $U(P,\delta )\subseteq A$ ，称该点为点集 $A$ 的内点。</p><p><strong>外点</strong>：对于任意一点 $M$ ， $\exists \delta \in R $ ，使得 $U(P,\delta )\cap A=\phi $ ，称该点为点集 $A$ 的内点。</p><p><strong>边界点</strong>：点 $M$ 的任意一个邻域，都有一部分在区域内部，一部分在区域外部，称为边界点，边界点组成的集合称为<strong>边界</strong>。</p><p><strong>聚点</strong>： $\forall \delta \in R $ ，都有 $ \overset{\circ}{U} (P,\delta )$ 里面由 $E$ 的点 。（ $E$ 是点集）</p><blockquote><p>据点包含内点以及边界。</p></blockquote><p><strong>开集</strong>：点集 $A$ 上的点全是内点。（集合不含边界）</p><p><strong>闭集</strong>：点集 $A$ 含有边界。</p><p><strong>联通集</strong>：任给集合中的两点，存在由内点组成的折线，将该两点连接起来，这样的点集称为<strong>联通集</strong>。</p><p><strong>开区域</strong>：联通的开集。</p><p><strong>比区域</strong>：联通的必区域。</p><p><strong>有界集</strong>：例如：圆环等有最大范围，不能无限延深的点集。</p><p><strong>无界集</strong>：点集的范围无穷大，称为<strong>无界集</strong></p><p><strong>$n$ 维空间</strong>： $R^{n} =\left \{ (x_{1},x_{2},\cdots ,x_{n})|x_{i}\in R \right \} $ 。</p><h2 id="9-1-2多元函数的概念"><a href="#9-1-2多元函数的概念" class="headerlink" title="9.1.2多元函数的概念"></a>9.1.2多元函数的概念</h2><p><strong>定义</strong>：有两个及以上自变量的函数，称为<strong>多元函数</strong></p><h2 id="9-1-3多元函数的极限"><a href="#9-1-3多元函数的极限" class="headerlink" title="9.1.3多元函数的极限"></a>9.1.3多元函数的极限</h2><p>对比：一元函数的极限：$\displaystyle \lim_{x \to x_{0}}f(x)=a $ 。</p><p><strong>二元函数的极限</strong>：点 $(x,y)$ 向 $(x_{0},y_{0})$ 逼近，即 $(x,y)\to (x_{0} ,y_{0} )$ ，那么称极限</p><script type="math/tex; mode=display">\displaystyle \lim_{\begin{matrix}(x,y)\to (x_{0},y_{0})\end{matrix}} f(x,y)=a</script><p> 为<strong>二元函数的极限</strong>。</p><p><strong>二重极限存在</strong>：任意方向逼近，都成立，极限才会存在。如果以多种方式逼近，他们的极限值不相等，那么该点的极限值不存在。因此，证明极限不存在，只需要找到某两个方向逼近的极限值不相等，即可。</p><blockquote><p>注意：</p><p>一元函数的极限，它的逼近方向为正向和负向；而二元函数极限，它的逼近方向是任意方向</p></blockquote><hr><p><strong>求极限——例题</strong>：求解极限 $\displaystyle \lim_{(z,y)\to(0,2)} \frac{\sin xy}{x} $ 。</p><p>解：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \lim_{(z,y)\to(0,2)} \frac{\sin xy}{x} &= \lim_{(z,y)\to(0,2)} y\frac{\sin xy}{xy}\\&=2\end{align}</script><h2 id="9-1-4-多元函数的连续性"><a href="#9-1-4-多元函数的连续性" class="headerlink" title="9.1.4 多元函数的连续性"></a>9.1.4 多元函数的连续性</h2><p><strong>回忆</strong>：一元函数可导必定连续。</p><p><strong>二元函数的连续性</strong>：对 $x$ 的偏导存在，那么在曲面上，有关 $x$ 的曲线是连续的；对 $y$ 的偏导存在，那么在曲面上，有关 $y$ 的曲线是连续的</p><h1 id="9-2-偏导数"><a href="#9-2-偏导数" class="headerlink" title="9.2 偏导数"></a>9.2 偏导数</h1><h2 id="9-2-1-偏导数的定义及其及算法"><a href="#9-2-1-偏导数的定义及其及算法" class="headerlink" title="9.2.1 偏导数的定义及其及算法"></a>9.2.1 偏导数的定义及其及算法</h2><p><strong>回忆</strong>：一元函数的导数为：当 $x\to x_{0}$ ，极限 $\displaystyle \lim_{x \to x_{0}}\frac{f(x)-f(x_{0})}{x-x_{0}}  $ 。</p><p>对于多元函数来说，自变量有多个，不能同时对所有自变量的整体进行求导，因此，引进偏导数。</p><p><strong>偏导数</strong>：已知一个二元函数 $z=f(x,y)$ ，当 $x\to x_{0}$ 时，导数 $\displaystyle \lim_{x \to x_{0},y_{0}}\frac{f(x,y_{0})-f(x_{0},y_{0})}{x-x_{0}}  $ 存在，那么其为函数䣌对 $x$ 的偏导数，记作 $\displaystyle \frac{\partial z}{\partial x} $ ，那么函数对 $y$ 的偏导数为 $\displaystyle \frac{\partial z}{\partial y}  =\lim_{x,y\to y_{0}}\frac{f(x_{0},y)-f(x_{0},y_{0})}{y-y_{0}}  $ 。</p><p><strong>二元函数偏导的计算法</strong>：</p><ol><li>对 $x$ 求偏导时，把 $y$ 看作常数，对 $x$ 求导数；</li><li>对 $y$ 求偏导时，把 $x$ 看作常数，对 $y$ 求导数。</li></ol><h2 id="9-2-2-高阶偏导数"><a href="#9-2-2-高阶偏导数" class="headerlink" title="9.2.2 高阶偏导数"></a>9.2.2 高阶偏导数</h2><h1 id="9-3-全微分"><a href="#9-3-全微分" class="headerlink" title="9.3 全微分"></a>9.3 全微分</h1><h2 id="9-3-1-全微分的定义"><a href="#9-3-1-全微分的定义" class="headerlink" title="9.3.1 全微分的定义"></a>9.3.1 全微分的定义</h2><p><strong>偏增量</strong>： $\Delta Z_{x} =f(x_{0}+\Delta x,y_{0})-f(x_{0},y_{0})$ 和 $\displaystyle \Delta Z_{y} =f(x_{0},y_{0}+\Delta y)-f(x_{0},y_{0})$ 。</p><p><strong>全增量</strong>： $\displaystyle \Delta Z =f(x_{0}+\Delta x,y_{0}+\Delta y)-f(x_{0},y_{0})$ 。</p><p><strong>定义（全微分）</strong>：假设 $\displaystyle z=f(x,y)$ 在点 $(x,y)$ 某邻域内有定义，在 $(x,y)$ 产生增量 $\displaystyle \Delta x ,\Delta y$ ，得到</p><script type="math/tex; mode=display">\displaystyle \Delta Z =f(x_{0}+\Delta x,y_{0}+\Delta y)-f(x_{0},y_{0})</script><p>如果上述能写成</p><script type="math/tex; mode=display">\displaystyle \Delta z = A\Delta x+B\Delta y +  o (\rho )</script><p>其中， $A,B$ 是 $x,y$ 的函数，与 $\displaystyle \Delta x ,\Delta y$ 无关，并且 $\displaystyle \rho =\sqrt{(x)^{2}+(\Delta y)^{2}} $ 。当 $\displaystyle\Delta z\to 0$ ，记作 $\displaystyle\mathrm{d}z $ ，那么上式就化为</p><script type="math/tex; mode=display">\displaystyle \displaystyle\mathrm{d}z  = A\Delta x+B\Delta y</script><p>上述式子就是<strong>全微分公式</strong>。</p><p><strong>定理（可微的必要条件）</strong>：如果 $\displaystyle z=f(x,y)$ 在点 $(x,y)$ 处可微，则偏导数 $\displaystyle {f}’ _{x} (x,y),{f}’ _{y} (x,y)$ 存在，且</p><script type="math/tex; mode=display">\displaystyle \displaystyle \displaystyle\mathrm{d}z  = {f}' _{x} (x,y)\Delta x+{f}' _{y} (x,y)\Delta y</script><blockquote><p>偏导数存在是可微的必要不充分条件。</p></blockquote><p><strong>可微的充分条件</strong>：如果 $\displaystyle z=f(x,y)$ 在点 $(x,y)$ 某个邻域内，有连续的偏导数 $\displaystyle {f}’ _{x} (x,y),{f}’ _{y} (x,y)$ 则在 $(x,y)$ 处可微。</p><blockquote><p>为了便于记忆，全微分公式可表示为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \displaystyle \displaystyle\mathrm{d}z & =  \mathrm{d}_{x} z + \mathrm{d}_{y} z \\& = {f}' _{x} (x,y)\mathrm{d}x+{f}' _{y} (x,y)\mathrm{d}y\end{align}</script></blockquote><h2 id="9-3-2-全微分在近似计算中的应用"><a href="#9-3-2-全微分在近似计算中的应用" class="headerlink" title="9.3.2 全微分在近似计算中的应用"></a>9.3.2 全微分在近似计算中的应用</h2><h1 id="9-4-多元复合函数的求导法则"><a href="#9-4-多元复合函数的求导法则" class="headerlink" title="9.4 多元复合函数的求导法则"></a>9.4 多元复合函数的求导法则</h1><p><strong>情况一</strong>： 多元复合函数 $\displaystyle z=f(u,v),u=\varphi (t),v=\psi (t)$ ，那么</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d} z}{\mathrm{d} t} =\frac{\partial z}{\partial u} \cdot \frac{\mathrm{d} u}{\mathrm{d} t}+\frac{\partial z}{\partial v} \cdot \frac{\mathrm{d} v}{\mathrm{d} t}</script><p><strong>情况二</strong>：多元复合函数 $\displaystyle z=f(u,v),u=\varphi (x,y),v=\psi (x,y)$ ，那么</p><script type="math/tex; mode=display">\begin{align}\displaystyle \frac{\partial z}{\partial x}  & = \frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial x} +\frac{\partial z}{\partial v} \cdot \frac{\partial v}{\partial x} \\\displaystyle \frac{\partial z}{\partial y} & = \frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial y} +\frac{\partial z}{\partial v} \cdot \frac{\partial v}{\partial y} \end{align}</script><p> <strong>情况三</strong>：多元复合函数 $\displaystyle z=f(u,v,w),u=\varphi (x,y),v=\psi (x,y),w=\omega (x,y)$ ，那么</p><script type="math/tex; mode=display">\begin{align}\displaystyle \frac{\partial z}{\partial x}  & = \frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial x} +\frac{\partial z}{\partial v} \cdot \frac{\partial v}{\partial x}+\frac{\partial z}{\partial w} \cdot \frac{\partial w}{\partial x} \\\displaystyle \frac{\partial z}{\partial y} & = \frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial y} +\frac{\partial z}{\partial v} \cdot \frac{\partial v}{\partial y} +\frac{\partial z}{\partial w} \cdot \frac{\partial w}{\partial y} \end{align}</script><h1 id="9-5-隐函数的求导公式"><a href="#9-5-隐函数的求导公式" class="headerlink" title="9.5 隐函数的求导公式"></a>9.5 隐函数的求导公式</h1><h2 id="9-5-1-一个方程的情形"><a href="#9-5-1-一个方程的情形" class="headerlink" title="9.5.1 一个方程的情形"></a>9.5.1 一个方程的情形</h2><p><strong>定理（隐函数存在定理）</strong>：函数 $F(x,y)$ 在某邻域内有连续的偏导数，且 $\displaystyle F(x_{0},y_{0})=0,{F}’_{y_{0} }  (x_{0},y_{0}) \ne 0$ ，那么</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d} y}{\mathrm{d} x}=-\frac{ {F}'_{x} }{ {F}'_{y} }</script><blockquote><p>上述定理要注意负号</p></blockquote><h2 id="9-5-2-方程组的情形"><a href="#9-5-2-方程组的情形" class="headerlink" title="9.5.2 方程组的情形"></a>9.5.2 方程组的情形</h2><p>已知方程组</p><script type="math/tex; mode=display">\left\{\begin{matrix}F(x,y,u,v)=0 \\G(x,y,u,v)=0 \\\end{matrix}\right.</script><p> 那么偏导数 $\displaystyle \frac{\partial u}{\partial x} ,\frac{\partial u}{\partial y} ,\frac{\partial v}{\partial x} ,\frac{\partial v}{\partial y} $ 。</p><p><strong>定理</strong>：<strong>雅可比行列式</strong>：</p><script type="math/tex; mode=display">\displaystyle J = \frac{\partial (F,G)}{\partial (u,v)} = \begin{vmatrix} \frac{\partial F}{\partial u}  & \frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial u}  &\frac{\partial G}{\partial v} \end{vmatrix}</script><p>并且</p><script type="math/tex; mode=display">\displaystyle \frac{\partial u}{\partial x}  = - \frac{1}{J}  \frac{\partial (F,G)}{\partial (x,v)}</script><script type="math/tex; mode=display"></script><h1 id="9-6-多元函数微分学的几何应用"><a href="#9-6-多元函数微分学的几何应用" class="headerlink" title="9.6 多元函数微分学的几何应用"></a>9.6 多元函数微分学的几何应用</h1><h2 id="9-6-1-一元向量值函数及其导数"><a href="#9-6-1-一元向量值函数及其导数" class="headerlink" title="9.6.1 一元向量值函数及其导数"></a>9.6.1 一元向量值函数及其导数</h2><p>存在 $\displaystyle \left\{\begin{matrix}x=\varphi (t) \\ y=\psi (t)\\z=\omega (t)\end{matrix}\right.$ ，那么向量 $\displaystyle \overrightarrow{r}  = x\overrightarrow{i} +y\overrightarrow{j}  +z\overrightarrow{k} $ 就是</p><script type="math/tex; mode=display">\displaystyle \overrightarrow{r}  = \varphi (t)\overrightarrow{i} +\psi (t)\overrightarrow{j}  +\omega (t)\overrightarrow{k}</script><p> 假设 $t\in \left [ \alpha ,\beta  \right ] $ ，映射关系为 $\displaystyle f: \left [ \alpha ,\beta  \right ] \to R^{3} $ 。因此</p><script type="math/tex; mode=display">\displaystyle \overrightarrow{f(t)} = f_{1}(t)\overrightarrow{i} +f_{2}(t)\overrightarrow{j}+f_{3}(t)\overrightarrow{k}</script><p><strong>极限</strong>： $t\to t_{0},\displaystyle f(t_{0})\to \overrightarrow{r_{0}} $ ，即 $\displaystyle \lim_{t \to t_{0}} \overrightarrow{f(t)} =\overrightarrow{r_{0}} $  。</p><p><strong>导向量</strong>： $\displaystyle \lim_{\Delta t \to 0} \frac{\Delta \overrightarrow{r} }{\Delta t}=  \lim_{\Delta t \to 0}\frac{\overrightarrow{f(t_{0}+\Delta t)} -\overrightarrow{f(t_{0})} }{\Delta t} $ 。并且可以表示为：</p><script type="math/tex; mode=display">\displaystyle \overrightarrow{ {f}' (t)} = { f_{1} }' (t)\overrightarrow{i} +{ f_{2} }' (t)\overrightarrow{j} +{f_{3} }' (t)\overrightarrow{k}</script><p><strong>有关向量函数的求导规则，参考：<a href="https://blog.yuilexi.cn/2023/04/26/大学学习/高等数学/高等数学常用公式/#向量函数的求导">高等数学常用公式 | 🪐星空鸟🪐 (yuilexi.cn)</a></strong>。</p><h2 id="9-6-2-空间曲线的切线与法平面"><a href="#9-6-2-空间曲线的切线与法平面" class="headerlink" title="9.6.2 空间曲线的切线与法平面"></a>9.6.2 空间曲线的切线与法平面</h2><p><strong>定义</strong>：假设曲线的参数方程：</p><script type="math/tex; mode=display">\left\{\begin{matrix}x=\varphi (t) \\y=\psi (t) \\z = \omega (t)\end{matrix}\right.</script><p>其中， $t\in \left [ \alpha ,\beta  \right ] $ 。曲线上一点 $t_{0}$ ，那么，称向量</p><script type="math/tex; mode=display">\overrightarrow{T} = ({\varphi }'(t_{0}),{\psi  }'(t_{0}),{\omega }'(t_{0}) )</script><p>为点 $t=t_{0}$ 时的<strong>切向量</strong>，对应的<strong>切线方程</strong>：</p><script type="math/tex; mode=display">\displaystyle \frac{ x-x_{0} }{ {\varphi }'(t_{0})} =\frac{ y-y_{0} }{ {\psi }'(t_{0}) } =\frac{ z-z_{0} }{ {\omega }'(t_{0}) }</script><p>其对应的<strong>法平面的方程</strong>为：</p><script type="math/tex; mode=display">{\varphi }' (t_{0} )( x-x_{0} )+{\psi  }' (t_{0} )(y-y_{0})+{\omega }' (t_{0} )(z-z_{0})=0</script><h2 id="9-6-3-曲面的切平面与法线"><a href="#9-6-3-曲面的切平面与法线" class="headerlink" title="9.6.3 曲面的切平面与法线"></a>9.6.3 曲面的切平面与法线</h2><p><strong>隐函数方程</strong>：例如： $\displaystyle F(x,y,z)=0$  。那么，在点 $(x_{0} ,y_{0} ,z_{0} )$ 处的<strong>切平面</strong>为：</p><script type="math/tex; mode=display">\displaystyle {F}'_{x} (x_{0},y_{0},z_{0})(x-x_{0})+{F}'_{y} (x_{0},y_{0},z_{0})(y-y_{0})+{F}'_{z} (x_{0},y_{0},z_{0})(z-z_{0})=0</script><p>并且其对应的法线方程为：</p><script type="math/tex; mode=display">\displaystyle \frac{x-x_{0}}{ {F}'_{x} (x_{0},y_{0},z_{0}) } =\frac{y-y_{0}}{ {F}'_{y} (x_{0},y_{0},z_{0}) } =\frac{z-z_{0}}{ {F}'_{z} (x_{0},y_{0},z_{0}) }</script><p><strong>形式二</strong>：形如 $\displaystyle z=f(x,y)$ ，那么将上述式子转化为：$\displaystyle F = f(x,y)-z$ ，然后根据<strong>隐函数方程</strong>方法来做就行了。</p><h1 id="9-7-方向导数与梯度"><a href="#9-7-方向导数与梯度" class="headerlink" title="9.7 方向导数与梯度"></a>9.7 方向导数与梯度</h1><h2 id="9-7-1-方向导数"><a href="#9-7-1-方向导数" class="headerlink" title="9.7.1 方向导数"></a>9.7.1 方向导数</h2><p><strong>方向导数</strong>：已知二元函数 $\displaystyle z=f(x,y)$ ，它的偏导数 $\displaystyle \frac{\partial z}{\partial x} $ 的几何含义：投影沿 $x$ 方向，函数斜率的大小；偏导 $\displaystyle \frac{\partial z}{\partial y} $ 的几何含义是：投影沿 $y$ 方向，函数斜率的大小。但是，对于二元函数的图像，应该是一个曲面，对于曲面来说，某点的切线有很多条，假设切线的投影方向为：</p><script type="math/tex; mode=display">\displaystyle l = x\cos \theta  +y\sin \theta</script><p>那么，对 $l$ 的偏导为 $\displaystyle \frac{\partial z}{\partial l} $ 。</p><p><strong>定理</strong>：已知 $f(x,y)$ 在点 $(x_{0},y_{0})$ 处可微，那么方向导数存在，且</p><script type="math/tex; mode=display">\displaystyle \frac{\partial f}{\partial l}  = {f}'_{x} (x,y)\cos \alpha + {f}'_{y} (x,y)\cos\beta</script><p>其中：<strong>$\displaystyle (\cos \alpha ,\cos\beta )$ 是向量 $l$ 的方向余弦</strong>。</p><h2 id="9-7-2-梯度"><a href="#9-7-2-梯度" class="headerlink" title="9.7.2 梯度"></a>9.7.2 梯度</h2><p><strong>梯度</strong>：已知二元函数 $f(x,y)$ ，向量的方向余弦为 $\displaystyle \overrightarrow{l^{\circ}}  = (\cos \alpha ,\cos \beta )$ ，那么，在点 $M$ 的方向导数就是</p><script type="math/tex; mode=display">\begin{align}\displaystyle \frac{\partial f}{\partial l} |_{M} & = \frac{\partial f}{\partial x}  \cos \alpha +\frac{\partial f}{\partial y}  \cos\beta\\&= (\frac{\partial f}{\partial x}\overrightarrow{e_{x} }+ \frac{\partial f}{\partial y}\overrightarrow{e_{y} })\cdot (\cos \alpha \overrightarrow{e_{x}}+ \cos\beta\overrightarrow{e_{y} })\\&= \overrightarrow{G} \cdot \overrightarrow{l^{\circ} } \end{align}</script><p>那么，这时引入<strong>梯度</strong>的概念，记作 $\overrightarrow{G}$ ，此时<strong>方向余弦就是梯度点乘方向余弦</strong>。</p><blockquote><p><strong>梯度是一个向量</strong>。</p><p>梯度的几何意义：多元函数在某点变化最快的方向，就是梯度的方向，而最大的变化率，就是梯度的模。</p></blockquote><h1 id="9-8-多元函数的极值及其求法"><a href="#9-8-多元函数的极值及其求法" class="headerlink" title="9.8 多元函数的极值及其求法"></a>9.8 多元函数的极值及其求法</h1><h2 id="9-8-1-多元函数的极值及最大值与最小值"><a href="#9-8-1-多元函数的极值及最大值与最小值" class="headerlink" title="9.8.1 多元函数的极值及最大值与最小值"></a>9.8.1 多元函数的极值及最大值与最小值</h2><p><strong>定理（必要条件）</strong>：二元函数 $z=f(x,y)$ 偏导存在，并且在 $(x_{0},y_{0})$ 处取得极值，那么</p><script type="math/tex; mode=display">\displaystyle {f} _{x} (x_{0},y_{0})=0, {f}_{y} (x_{0},y_{0})=0</script><p><strong>驻点</strong>： ${f}_{x}=0, {f}_{y}=0$ 同时存在，这样的点称为<strong>驻点</strong>。</p><blockquote><p>极值点一定是驻点，但是驻点不一定是极值点。</p></blockquote><p><strong>定理（充分条件）</strong>：二元函数 $z=f(x,y)$ 偏导，并且 $\displaystyle {f} _{x} (x_{0},y_{0})=0, {f}_{y} (x_{0},y_{0})=0$ ，得到</p><script type="math/tex; mode=display">\begin{align}\displaystyle A & = f_{xx}(x_{0},y_{0}) \\\displaystyle B & = f_{xy}(x_{0},y_{0}) \\\displaystyle C & = f_{yy}(x_{0},y_{0}) \\\end{align}</script><p>如果：</p><ol><li>$AC-B^{2}&gt;0$ ，是极值点<ol><li>$A&gt;0$ ，极大值；</li><li>$A&lt;0$ ，极小值。</li></ol></li><li>$AC-B^{2}&lt;0$ ，没有极值点</li><li>$AC-B^{2}=0$，极值点不确定</li></ol><p><strong>最值</strong>：最值出现的位置：驻点、偏导不存在的位置、端点</p><h2 id="9-8-2-条件极值-拉格朗日乘数法"><a href="#9-8-2-条件极值-拉格朗日乘数法" class="headerlink" title="9.8.2 条件极值 拉格朗日乘数法"></a>9.8.2 条件极值 拉格朗日乘数法</h2><p><strong>定义（条件极值）</strong>：函数 $f(x,y)$ ，在某种条件 $\varphi (x,y)$ 下的极值。</p><p><strong>拉格朗日乘数法</strong>：构造辅助函数：</p><script type="math/tex; mode=display">L(x,y)=f(x,y) + \lambda \varphi (x,y)</script><p>只需要满足：</p><script type="math/tex; mode=display">L_{x} (x,y)=0,L_{y} (x,y)=0</script><p>求的的点就是<strong>条件极值点</strong>。</p><h1 id="9-9-二元函数的泰勒公式"><a href="#9-9-二元函数的泰勒公式" class="headerlink" title="9.9 二元函数的泰勒公式"></a>9.9 二元函数的泰勒公式</h1><p>【略】</p><h1 id="9-10-最小二乘法"><a href="#9-10-最小二乘法" class="headerlink" title="9.10 最小二乘法"></a>9.10 最小二乘法</h1><p>【略】</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章 向量代数与空间解析几何【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/08.%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/08.%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章 向量代数与空间解析几何"></a>第八章 向量代数与空间解析几何</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><strong><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></strong></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="8-1-向量及其线性运算"><a href="#8-1-向量及其线性运算" class="headerlink" title="8.1 向量及其线性运算"></a>8.1 向量及其线性运算</h1><h2 id="8-1-1-向量的定义"><a href="#8-1-1-向量的定义" class="headerlink" title="8.1.1 向量的定义"></a>8.1.1 向量的定义</h2><p><strong>定义（向量）</strong>：既有大小，又有方向的量，称为<strong>向量</strong>，记作 $\mathbf{\alpha } \text{或者}\overrightarrow{\alpha  } $ 。</p><p><strong>定义（向量相等）</strong>：大小相等，方向相同，那么向量相等，即平移能够重合的向量。</p><blockquote><p>现阶段涉及的向量，指的是<strong>自由向量</strong>，即不考虑向量起点。</p></blockquote><p><strong>定义（向量的长度）</strong>：向量的长度，称为<strong>向量的模</strong>，也称为<strong>范数</strong>，记作 $\left | \overrightarrow{AB}  \right | $ 。</p><p>规定，长度为 1 的向量为单位向量，记作 $\displaystyle \frac{1}{\left | \overrightarrow{a}  \right | }  \overrightarrow{a}$ ；长度为 0 的向量为 0 向量，记作 $\overrightarrow{0}$ 。</p><p>两个向量起点重合，那么形成的夹角，称为<strong>向量的夹角</strong>，且 $0\le \theta \le \pi $ 。</p><ol><li>向量的夹角为 $0$ 或者 $\pi$ ，那么称向量平行；</li><li>向量的夹角为 $\displaystyle \frac{\pi }{2} $ ，那么称向量垂直；</li><li>特别地，<strong>零向量</strong>与任意向量平行，与任意向量垂直。</li></ol><h2 id="8-1-2-向量的线性运算"><a href="#8-1-2-向量的线性运算" class="headerlink" title="8.1.2 向量的线性运算"></a>8.1.2 向量的线性运算</h2><p>向量的加减遵循<strong>三角形法则</strong>或者<strong>平行四边形法则</strong>。</p><ol><li><p>$\overrightarrow{c}  = \overrightarrow{a}  + \overrightarrow{b} $ ；</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E5%90%91%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97.svg" alt="向量的运算" style="zoom:50%" /></p></li><li><p>$\overrightarrow{a}  + \overrightarrow{b} =\overrightarrow{b}  + \overrightarrow{a} $ ；</p></li></ol><h2 id="8-1-3-空间直角坐标系"><a href="#8-1-3-空间直角坐标系" class="headerlink" title="8.1.3 空间直角坐标系"></a>8.1.3 空间直角坐标系</h2><p>空间坐标系如图所示：</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E7%A9%BA%E9%97%B4%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB-%E5%8F%B3%E6%89%8B%E7%B3%BB.svg" alt="空间直角坐标系-右手系" style="zoom:50%" /></p><p>其 $x,y,z$ 轴对应的单位向量记作 $\overrightarrow{i}, \overrightarrow{j}, \overrightarrow{k} $  。那么空间中的向量就可以表示为：</p><script type="math/tex; mode=display">\overrightarrow{r} =x\overrightarrow{i} +y\overrightarrow{j}+z\overrightarrow{k}</script><p>其坐标形式为： $\overrightarrow{r} =(x,y,z) $ 。</p><hr><p><strong>例题</strong>：已知向量的关系如下图，且 $\overrightarrow{AM}=\lambda \overrightarrow{MB}  $ ，求解 $\lambda $ 。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E4%BE%8B%E9%A2%98-%E5%9B%BE%E7%A4%BA-%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97.svg" alt="例题-图示-向量的计算" style="zoom:50%" /></p><hr><p><strong>向量的模</strong>： $\displaystyle \left | \overrightarrow{r}  \right | =\sqrt{x^{2}+y^{2}+z^{2}} $ 。</p><p><strong>两点距离</strong>：已知点 $\displaystyle A = (x_{1},y_{1},z_{1}),\quad B= (x_{2},y_{2},z_{2})$ ，那么 $\overrightarrow{AB} = (x_{2}-x_{1},y_{2}-y_{1},z_{2}-z_{1}) $ ，并且 $\displaystyle \left | \overrightarrow{AB}  \right | = \sqrt{(x_{1}-x_{2})^{2}+(y_{1}-y_{2})^{2}+(z_{1}-z_{2})^{2}} $ 。</p><h2 id="8-1-4-方向角与方向余弦"><a href="#8-1-4-方向角与方向余弦" class="headerlink" title="8.1.4 方向角与方向余弦"></a>8.1.4 方向角与方向余弦</h2><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E6%96%B9%E5%90%91%E4%BD%99%E5%BC%A6.svg" alt="方向余弦" style="zoom:50%" /></p><p><strong>定义（方向角）</strong>：已知向量 $\displaystyle \overrightarrow{OM}=\overrightarrow{r}  =(x,y,z)$ ，那么角为 $\alpha, \beta, \gamma $ ，其大小为：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \cos \alpha & = \frac{x}{|\overrightarrow{OM} |} \\\displaystyle \cos \beta  & = \frac{y}{|\overrightarrow{OM} |} \\\displaystyle \cos \gamma  & = \frac{z}{|\overrightarrow{OM} |} \end{align}</script><p>并且，称向量</p><script type="math/tex; mode=display">\begin{align}(\cos \alpha,\cos \beta,\cos \gamma) & = \left ( \frac{x}{|\overrightarrow{OM}|} ,\frac{y}{|\overrightarrow{OM}|} ,\frac{z}{|\overrightarrow{OM}|} \right ) \\& = \frac{1}{\left | \overrightarrow{OM}  \right | } \left (x,y,z \right ) \\&= \overrightarrow{e_{r} } \end{align}</script><p>为向量 $\overrightarrow{OM} $ 的<strong>方向余弦</strong>。</p><blockquote><p>注意：方向余弦是一个单位向量。</p><p>方向角如有如下关系：</p><ol><li>$\displaystyle \cos^{2}\alpha +\cos ^{2}\beta +\cos ^{2}\gamma =1$ 。</li></ol></blockquote><h2 id="8-1-5-投影"><a href="#8-1-5-投影" class="headerlink" title="8.1.5 投影"></a>8.1.5 投影</h2><p><strong>定义</strong>：两个向量 $\overrightarrow{OA},\overrightarrow{OB}$ ，向量 $A$ 向 $B$ 的投影为 $\left | \overrightarrow{OM}  \right | $ 。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E6%8A%95%E5%BD%B1.svg" alt="投影" style="zoom:50%" /></p><p>记作 $\displaystyle P_{rj_{u} } \overrightarrow{OA} $ 。</p><p><strong>性质 1</strong>： $\displaystyle P_{rj_{u} } \overrightarrow{OA} =\left | \overrightarrow{OM}  \right |\cos \theta  $ 。</p><h1 id="8-2-数量积-向量积-混合积"><a href="#8-2-数量积-向量积-混合积" class="headerlink" title="8.2 数量积 向量积 混合积"></a>8.2 数量积 向量积 混合积</h1><h2 id="8-2-1-数量积"><a href="#8-2-1-数量积" class="headerlink" title="8.2.1 数量积"></a>8.2.1 数量积</h2><p><strong>定义（数量积）</strong>： $\displaystyle \overrightarrow{a} \cdot \overrightarrow{b} =\left | \overrightarrow{a} \right | \left | \overrightarrow{b}  \right |\cos \theta  $ ，并且有下面形式：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \overrightarrow{a} \cdot \overrightarrow{b} & = \left | \overrightarrow{a} \right | \left | \overrightarrow{b}  \right |\cos \theta\\&=\left | \overrightarrow{a} \right |P_{rj_{b} }  \\&=  \left | \overrightarrow{b}  \right |P_{rj_{a} }\end{align}</script><p><strong>性质</strong>：</p><ol><li>$\overrightarrow{a} \cdot \overrightarrow{a} =\left | \overrightarrow{a}  \right | ^{2} $ ；</li><li>$\overrightarrow{a} \cdot \overrightarrow{b} =0 \Longleftrightarrow \overrightarrow{a}\bot  \overrightarrow{b} $ ；</li><li>$\overrightarrow{a} \cdot \overrightarrow{b} =\overrightarrow{b} \cdot \overrightarrow{a}$ ；</li><li>$(a+b)\cdot c = a\cdot c+b\cdot c$ ；</li></ol><hr><p><strong>示例</strong>：使用向量证明余弦定理：$\displaystyle c^{2} =a^{2}+b^{2}-2ab\cos \theta $ 。</p><p>证明：</p><script type="math/tex; mode=display">\begin{align}c & = a - b \\\left | c \right | ^{2}& =(a-b)(a-b) = a\cdot a + b\cdot b -b\cdot a-a\cdot b\\& = \left | a \right | ^{2} +\left | b \right | ^{2} -2\left | a \right | \left | b \right |\cos \theta  \end{align}</script><p><strong>数量积的坐标表达式</strong>： 向量 $\displaystyle a=(x_{1},y_{1},z_{1} ),\quad b = (x_{2},y_{2},z_{2} )$ ，那么</p><script type="math/tex; mode=display">\displaystyle a\cdot b = x_{1}x_{2}+y_{1}y_{2} +z_{1}z_{2}</script><h2 id="8-2-2-向量积"><a href="#8-2-2-向量积" class="headerlink" title="8.2.2 向量积"></a>8.2.2 向量积</h2><p><strong>定义（向量积）</strong>：任意的 $a,b$ 两向量，那么向量积为 $\displaystyle c =a\times b$ 。</p><ol><li>向量 $c$ 的模： $\displaystyle \left | c \right |  =\left | a \right | \left | b \right | \sin \theta $ ；</li><li>向量 $c$ 的方向：右手准测，四指指向向量 $a$，并且手指逐渐旋转指向 $b$ ，那么大拇指的方向就是向量 $c$ 的方向。</li></ol><blockquote><p>注意：向量积的结果是一个向量</p></blockquote><p><strong>性质</strong>：</p><ol><li>$\displaystyle a\times a=0$ ；</li><li>$\displaystyle a\times b=0 \Longleftrightarrow a // b$ ；</li></ol><p><strong>运算律</strong>：</p><ol><li>$\displaystyle a\times b = -b\times a$ ；</li><li>$\displaystyle (a+b)\times c = a\times c+b\times c$ </li></ol><p><strong>向量积的计算</strong>：任意的向量 $a=\left ( x_{1},y_{1},z_{1}\right ),\quad b =\left ( x_{2},y_{2},z_{2}\right ) $ ，那么</p><script type="math/tex; mode=display">\begin{align}\displaystyle a\times b & = \begin{vmatrix} i & j & k\\ x_{1}  & y_{1}  & z_{1} \\ x_{2}  & y_{2}  &z_{2} \end{vmatrix}\\&=(y_{1}z_{2}-y_{2}z_{1} )i + (x_{2}z_{1}-x_{1}z_{2})j + (x_{1}y_{2}- x_{2}y_{1}   )k\end{align}</script><h1 id="8-3-平面及其方程"><a href="#8-3-平面及其方程" class="headerlink" title="8.3 平面及其方程"></a>8.3 平面及其方程</h1><h2 id="8-3-1-曲面方程与空间曲线方程"><a href="#8-3-1-曲面方程与空间曲线方程" class="headerlink" title="8.3.1 曲面方程与空间曲线方程"></a>8.3.1 曲面方程与空间曲线方程</h2><p><strong>定义</strong>：满足 $F(x,y,z)=0$ 的所有点的集合，称为<strong>曲面方程</strong>。满足方程组 $\displaystyle \left\{\begin{matrix} F(x,y,z)=0\\ G(x,y,z)=0\end{matrix}\right.$ 的点的集合。称为<strong>曲线</strong>。</p><p><strong>定义（平面的法线）</strong>：与一个平面垂直的线，称为<strong>法线</strong>。</p><h2 id="8-3-2-平面的点法式方程"><a href="#8-3-2-平面的点法式方程" class="headerlink" title="8.3.2 平面的点法式方程"></a>8.3.2 平面的点法式方程</h2><p><strong>已知一条法线，和任意一点，就可以确定一个平面</strong>。</p><p>已知点 $M_{0} (x_{0},y_{0},z_{0})$ ，法线向量 $n=(A,B,C)$ ，设平面任意点一点为 $M(x,y,z)$ 那么，平面中的任意一条向量 $\overrightarrow{M_{0} M} $ 与法相 $n$ 垂直，即 $n\cdot \overrightarrow{M_{0} M} =0$ ，可得平面的点法式方程为：</p><script type="math/tex; mode=display">A(x-x_{0} )+B(y-y_{0} )+C(z-z_{0} )=0</script><h2 id="8-3-3-平面的一般方程"><a href="#8-3-3-平面的一般方程" class="headerlink" title="8.3.3 平面的一般方程"></a>8.3.3 平面的一般方程</h2><p><strong>定义（平面的一般方程）</strong>：形如 $Ax+By+C+D=0$ 的方程，称为<strong>平面的一般方程</strong>。</p><ol><li>如果 $D=0$ ，那么平面<strong>过原点</strong>；</li><li>如果 $A=0$ ，那么平面<strong>平行于 $x$ 轴</strong> ；</li><li>如果 $A=B=0$ ，那么平面<strong>平行于面 $xOy$ </strong> ；</li></ol><h2 id="8-3-4-两平面的夹角"><a href="#8-3-4-两平面的夹角" class="headerlink" title="8.3.4 两平面的夹角"></a>8.3.4 两平面的夹角</h2><p><strong>定义</strong>：两平面夹角等于法向量的夹角或者其补角 $\displaystyle 0\le \theta \le \frac{\pi }{2} $ 。设两平面的法向量 $n_{1} =(A_{1},B_{1},C_{1}),\quad n_{2} =(A_{2},B_{2},C_{2})$ ，那么平面的夹角 $\theta $ 满足：</p><script type="math/tex; mode=display">\theta  = \pi -\left \langle \widehat{n_{1} ,n_{2}}   \right \rangle</script><p>并且有 $\cos \theta =\left | \cos \left \langle\widehat{n_{1},n_{2}}   \right \rangle  \right | $ ，那么夹角的计算公式为：</p><script type="math/tex; mode=display">\displaystyle \cos \theta = \frac{\left | A_{1}A_{2}+B_{1}B_{2}+C_{1}C_{2} \right | }{\sqrt{A_{1}^{2}+B_{1}^{2}+C_{1}^{2}} \sqrt{A_{2}^{2}+B_{2}^{2}+C_{2}^{2}} }</script><ol><li>垂直： $\left | A_{1}A_{2}+B_{1}B_{2}+C_{1}C_{2} \right |=0$ ；</li><li>平行或重合： $\displaystyle \frac{A_{1} }{A_{2}} =\frac{B_{1} }{B_{2}} =\frac{C_{1} }{C_{2}} $ 。</li></ol><h1 id="8-4-空间直线及其方程"><a href="#8-4-空间直线及其方程" class="headerlink" title="8.4 空间直线及其方程"></a>8.4 空间直线及其方程</h1><h2 id="8-4-1-空间直线的一般方程"><a href="#8-4-1-空间直线的一般方程" class="headerlink" title="8.4.1 空间直线的一般方程"></a>8.4.1 空间直线的一般方程</h2><p><strong>定义</strong>：有两平面相交，得到一条直线，所以直线的一般方程为：</p><script type="math/tex; mode=display">\left\{\begin{matrix} A_{1} x+B_{1} y+C_{1} +D_{1} =0\\ A_{2} x+B_{2} y+C_{2} +D_{2} =0\end{matrix}\right.</script><h2 id="8-4-2-空间直线的对称式方程与参数方程"><a href="#8-4-2-空间直线的对称式方程与参数方程" class="headerlink" title="8.4.2 空间直线的对称式方程与参数方程"></a>8.4.2 空间直线的对称式方程与参数方程</h2><p><strong>定义（方向向量）</strong>：与直线平行的向量，称为<strong>直线的方向向量</strong>。</p><p><strong>定义（对称式）</strong>：直线过一点 $M_{0} (x_{0},y_{0} ,z_{0}  )$ 且方向向量为 $s=(m,n,p)$ ，那么直线的对称式方程为：</p><script type="math/tex; mode=display">\displaystyle \frac{x-x_{0} }{m} +\frac{y-y_{0} }{n} +\frac{z-z_{0} }{p}=t</script><p><strong>定义（参数方程）</strong>：有对称式可得，用参数 $t$ 来表示 $x,y,z$ ，得到参数方程：</p><script type="math/tex; mode=display">\left\{\begin{matrix}x = mt+x_{0}  \\ y =nt+y_{0}\\z = pt+z_{0}\end{matrix}\right.</script><h2 id="8-4-3-两直线的夹角"><a href="#8-4-3-两直线的夹角" class="headerlink" title="8.4.3 两直线的夹角"></a>8.4.3 两直线的夹角</h2><p><strong>定义</strong>：两直线的夹角等于方向向量的夹角或其补角 $\displaystyle 0\le \theta \le \frac{\pi }{2} $ 。设两直线的方向向量 $n_{1} =(A_{1},B_{1},C_{1}),\quad n_{2} =(A_{2},B_{2},C_{2})$ ，那么直线的夹角 $\theta $ 满足：</p><script type="math/tex; mode=display">\displaystyle \cos \theta = \frac{\left | A_{1}A_{2}+B_{1}B_{2}+C_{1}C_{2} \right | }{\sqrt{A_{1}^{2}+B_{1}^{2}+C_{1}^{2}} \sqrt{A_{2}^{2}+B_{2}^{2}+C_{2}^{2}} }</script><h2 id="8-4-4-平面与直线的夹角"><a href="#8-4-4-平面与直线的夹角" class="headerlink" title="8.4.4 平面与直线的夹角"></a>8.4.4 平面与直线的夹角</h2><p><strong>定义</strong>：直线与平面的夹角等于直线与投影的夹角，即等于直线与法线夹角的余角。设直线的方向向量为 $s =(m,n,p)$ ，平面的法向量为 $n =(A,B,C)$ ，那么夹角 $\theta $ 满足：</p><script type="math/tex; mode=display">\displaystyle \sin \theta = \frac{\left | mA+nB+pC \right | }{\sqrt{m^{2}+n^{2}+p^{2}} \sqrt{A^{2}+B^{2}+C^{2}} }</script><ol><li>直线与平面垂直： $\displaystyle \frac{A}{m} =\frac{B}{n} =\frac{C}{p} $ ；</li><li>直线与平面平行： $mA+nB+pC=0$ 。</li></ol><h1 id="8-5-曲面及其方程"><a href="#8-5-曲面及其方程" class="headerlink" title="8.5 曲面及其方程"></a>8.5 曲面及其方程</h1><h2 id="8-5-1-曲面研究的基本问题"><a href="#8-5-1-曲面研究的基本问题" class="headerlink" title="8.5.1 曲面研究的基本问题"></a>8.5.1 曲面研究的基本问题</h2><blockquote><ol><li>已知曲面作为点的几何轨迹，建立点的方程；</li><li>已知方程研究曲面的形状</li></ol></blockquote><p><strong>球面</strong>：球心在点 $M_{0} (x_{0},y_{0} ,z_{0}  )$ ，半径为 $R$ ，其曲面方程为：</p><script type="math/tex; mode=display">(x-x_{0} )^{2}+ (y-y_{0} )^{2} +(z-z_{0} )=R^{2}</script><p><strong>球面的一般方程</strong>：形如：</p><script type="math/tex; mode=display">Ax^{2} +Ay^{2}+Az^{2}  +Dx+Ey+Fz+G=0</script><p>其中满足的条件是：</p><ol><li>$A\ne =0$ ；</li><li>$R^{2} =(\frac{D}{2A})^{2} +(\frac{E}{2A})^{2}+(\frac{F}{2A})^{2}-\frac{G}{A} &gt; 0$ ，即 $D^{2} +E^{2} +F^{2} -4G&gt; 0$ 。</li></ol><h2 id="8-5-2-旋转曲面"><a href="#8-5-2-旋转曲面" class="headerlink" title="8.5.2 旋转曲面"></a>8.5.2 旋转曲面</h2><p><strong>母线和轴</strong>：给定的曲线称为<strong>母线</strong>，绕着旋转的称为<strong>轴</strong>。</p><p>假设以 $z$ 轴为旋转轴， $xOz$ 平面的曲线方程为： $f(y,z)=0$ ，那么，曲线绕 $z$ 轴旋转一周，任取 $z=z_{1}$ ，这时候截面是一个圆，其满足的关系为：</p><script type="math/tex; mode=display">r = \sqrt{x^{2}+y^{2}  } =\left | y_{1}  \right |</script><p>因此，以 $z$ 轴为旋转轴的曲面方程为：</p><script type="math/tex; mode=display">f(\pm \sqrt{x^{2}+y^{2}  },z)</script><p>同理可得：其他的轴旋转</p><blockquote><p>旋转曲面要注意两点：</p><ol><li>旋转曲线所在的平面；</li><li>旋转轴。</li></ol></blockquote><h2 id="8-5-3-柱面"><a href="#8-5-3-柱面" class="headerlink" title="8.5.3 柱面"></a>8.5.3 柱面</h2><p><strong>定义（圆柱面）</strong>：形如：</p><script type="math/tex; mode=display">x^{2} +y^{2} =R^{2}</script><p>的空间曲面，称为<strong>圆柱面</strong>。</p><p><strong>定义（抛物柱面）</strong>：将一条抛物线沿 $z$ 轴移动，形成的曲面称为<strong>抛物柱面</strong>。</p><script type="math/tex; mode=display">y^{2} =ax(a>0)</script><blockquote><p>柱面的本质是：在某一平面上的一条曲线，以沿垂直于平面的直线为轴，上下移动，形成为的曲面称为<strong>柱面</strong></p></blockquote><h2 id="8-5-4-二次曲面"><a href="#8-5-4-二次曲面" class="headerlink" title="8.5.4 二次曲面"></a>8.5.4 二次曲面</h2><p><strong>定义（二次曲线）</strong>：如果方程 $F(a,y,z)=0$ 是一个三元二次方程，那么所代表的曲面，称为<strong>二次曲面</strong>。</p><p><strong>椭圆锥面</strong>： $\displaystyle \frac{x^{2} }{a^{2} } +\frac{y^{2} }{b^{2} }=z^{2} $ 。</p><ol><li>z 平面的截面是一个椭圆，</li><li>离原点越远，椭圆越大。</li></ol><blockquote><p>注意：这不是旋转而成的，因为截面不是圆</p></blockquote><p><strong>椭球面</strong>： $\displaystyle \frac{x^{2} }{a^{2} } +\frac{y^{2} }{b^{2} }+\frac{z^{2} }{c^{2} }=1$ 。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E6%A4%AD%E7%90%83%E9%9D%A2.png" alt="椭球面" style="zoom:50%" /></p><p><strong>椭圆抛物面</strong>： $\displaystyle \frac{x^{2} }{a^{2} } +\frac{y^{2} }{b^{2} }=z$ 。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E6%A4%AD%E5%9C%86%E6%8A%9B%E7%89%A9%E9%9D%A2.png" alt="椭圆抛物面" style="zoom:50%" /></p><p><strong>单叶双曲面</strong>： $\displaystyle \frac{x^{2} }{a^{2} } +\frac{y^{2} }{b^{2} }-\frac{z^{2} }{c^{2} }=1$ 。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E5%8D%95%E5%8F%B6%E5%8F%8C%E6%9B%B2%E9%9D%A2.png" alt="单叶双曲面" style="zoom:50%" /></p><p><strong>双叶双曲面</strong>： $\displaystyle \frac{x^{2} }{a^{2} } +\frac{y^{2} }{b^{2} }-\frac{z^{2} }{c^{2} }=-1$ 。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E5%8F%8C%E5%8F%B6%E5%8F%8C%E6%9B%B2%E9%9D%A2.png" alt="双叶双曲面" style="zoom:50%" /></p><p><strong>双曲抛物面</strong>： $\displaystyle \frac{x^{2} }{a^{2} } -\frac{y^{2} }{b^{2} }=z$ 。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E5%8F%8C%E6%9B%B2%E6%8A%9B%E7%89%A9%E9%9D%A2.png" alt="双曲抛物面" style="zoom:50%" /></p><h1 id="8-6-空间曲线及其方程"><a href="#8-6-空间曲线及其方程" class="headerlink" title="8.6 空间曲线及其方程"></a>8.6 空间曲线及其方程</h1><h2 id="8-6-1-空间曲线的一般方程"><a href="#8-6-1-空间曲线的一般方程" class="headerlink" title="8.6.1 空间曲线的一般方程"></a>8.6.1 空间曲线的一般方程</h2><p>两个曲面相交，构成空间曲线。即 $\displaystyle \left\{\begin{matrix} F(x,y,z)=0\\G(x,y,z)=0\end{matrix}\right.$ 。</p><h2 id="8-6-2-空间曲线的参数方程"><a href="#8-6-2-空间曲线的参数方程" class="headerlink" title="8.6.2 空间曲线的参数方程"></a>8.6.2 空间曲线的参数方程</h2><p>$\left\{\begin{matrix} x=A(t)\\ y=B(t)\\z=C(t)\end{matrix}\right.$</p><h2 id="8-6-3-空间曲线在坐标面上的投影"><a href="#8-6-3-空间曲线在坐标面上的投影" class="headerlink" title="8.6.3 空间曲线在坐标面上的投影"></a>8.6.3 空间曲线在坐标面上的投影</h2><p>空间曲线方程：$\displaystyle \left\{\begin{matrix} F(x,y,z)=0\\G(x,y,z)=0\end{matrix}\right.$ ，消去 $z$ 得到： $\displaystyle \left\{\begin{matrix}H(x,y)=0\\z=0\end{matrix}\right.$ 。</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 微分方程【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/07.%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/07.%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="七、微分方程"><a href="#七、微分方程" class="headerlink" title="七、微分方程"></a>七、微分方程</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><strong><a href="./07.微分方程">第七章 微分方程</a></strong></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="7-1-微分方程的基本概念"><a href="#7-1-微分方程的基本概念" class="headerlink" title="7.1 微分方程的基本概念"></a>7.1 微分方程的基本概念</h1><p>一般地，凡是表示<strong>未知函数、未知函数的导数与自变量之间的关系</strong>的方程，叫做<strong><font color='red'>微分方程</font></strong>，有时简称方程。</p><p>微分方程中所出现的未知函数的最高阶导数的阶数，叫做<strong><font color='red'>微分方程的阶</font></strong>。</p><p>把某个函数带入微分方程，能使该方程成为恒等式，这个函数就叫做该<strong><font color='red'>微分方程的解</font></strong>。</p><p>如果为微分方程的解中含有任意常数，且任意常数的个数与微分方程的阶数相同，这样的解叫做微分方程的<strong><font color='red'>通解</font></strong>。</p><p><strong><font color='red'>初值条件</font></strong>。</p><p>确定了通解中任意常数以后，就得到微分方程的<strong><font color='red'>特解</font></strong>。</p><h1 id="7-2-可分离变量的微分方程"><a href="#7-2-可分离变量的微分方程" class="headerlink" title="7.2 可分离变量的微分方程"></a>7.2 可分离变量的微分方程</h1><p>一阶微分方程：</p><script type="math/tex; mode=display">\displaystyle {y}' =f(x,y)</script><p>一阶微分方程有时也写成如下的对称形式：</p><script type="math/tex; mode=display">\displaystyle P(x,y)\mathrm{d}x +Q(x,y)\mathrm{d}y =0</script><p>🧭一般地，如果一个一阶微分方程能写成🧭🧭🧭</p><script type="math/tex; mode=display">\displaystyle g(y)\mathrm{d}y =f(x)\mathrm{d}x</script><p>的形式，就是说，能把微分方程写成一端只含 $y$ 的函数的 $\mathrm{d}y$ ，另一端只含 $x$ 的函数和 $\mathrm{d}x $ 那么原方程就成为<strong>可分离变量的微分方程</strong>。</p><p>假定方程中的 $g(x)$ 与 $f(x)$ 函数是连续的。设 $y=\varphi (x)$ 是方程的解，将它带入方程得</p><script type="math/tex; mode=display">\displaystyle g\left [ \varphi (x) \right ]  {\varphi }' (x)\mathrm{d}x =f(x)\mathrm{d}x</script><h1 id="7-3-齐次方程"><a href="#7-3-齐次方程" class="headerlink" title="7.3 齐次方程"></a>7.3 齐次方程</h1><h2 id="7-3-1-齐次方程"><a href="#7-3-1-齐次方程" class="headerlink" title="7.3.1 齐次方程"></a>7.3.1 齐次方程</h2><p>如果<strong>一阶微分方程</strong>可化为</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d}y}{\mathrm{d}x} =\varphi (\frac{y}{x} )</script><p>的形式，那么就称这方程为<strong><font color='red'>齐次方程</font></strong>，例如</p><script type="math/tex; mode=display">\displaystyle (xy-x^{2} )\mathrm{d}x -(x^{2}-2xy )\mathrm{d}y =0</script><hr><p>齐次方程的解题：</p><ol><li>$\displaystyle u=\frac{y}{x} $ ；</li><li>$\displaystyle y=xu$ ；</li><li>$\displaystyle \frac{\mathrm{d} y}{\mathrm{d} x} =u + x\frac{\mathrm{d} u}{\mathrm{d} x} $ ；</li><li>带入方程。</li></ol><h2 id="7-3-2-可化为齐次的方程"><a href="#7-3-2-可化为齐次的方程" class="headerlink" title="7.3.2 可化为齐次的方程"></a>7.3.2 可化为齐次的方程</h2><p>方程</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d} y}{\mathrm{d} x} =\frac{ax+by+c}{a_{1} x+b_{1} y+c_{1} }</script><p>当 $c = c_{1} =0$ 时，方程是齐次的；否则不是齐次的。在非齐次的情况下，可用下列变换把它化为齐次方程，令 $x =X+h,y=Y+k$ ，其中 $h$ 以及 $k$ 是<strong>待定常系数</strong>。于是</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d} Y}{\mathrm{d} X} =\frac{aX+bY+ah+bk+c}{a_{1} X+b_{1} Y+a_{1} h+b_{1} k+c_{1} }</script><p>如果方程组</p><script type="math/tex; mode=display">\left\{\begin{matrix} ah & + & bk & + & c & = & 0\\ a_{1} h & + & b_{1} k & + & c_{1} & = &0\end{matrix}\right.</script><p>的系数行列式 $\displaystyle \begin{vmatrix} a &amp;b \\ a_{1}  &amp;b_{1} \end{vmatrix}\ne 0$ ，方程有唯一解。那么可以给定 $h$ 和 $k$ 使它们满足上述方程组。这样，微分方程就化为</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d} Y}{\mathrm{d} X} =\frac{aX+bY}{a_{1} X+b_{1} Y}</script><h1 id="7-4-一阶线性微分方程"><a href="#7-4-一阶线性微分方程" class="headerlink" title="7.4 一阶线性微分方程"></a>7.4 一阶线性微分方程</h1><h2 id="7-4-1-线性方程"><a href="#7-4-1-线性方程" class="headerlink" title="7.4.1 线性方程"></a>7.4.1 线性方程</h2><p>方程</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d}y }{\mathrm{d}x } +P(x)y=Q(x)</script><p>叫做<strong><font color='red'>一阶线性微分方程</font></strong>，因为他对于未知函数 $y$ 及其导数是一次方程。如果 $\displaystyle Q\equiv 0$ ，那么<strong>方程变为齐次的</strong>；反之，则为<strong>非齐次</strong>的。</p><p><strong>一阶线性方程的求解</strong>：</p><p>设 $\displaystyle \frac{\mathrm{d}y }{\mathrm{d}x } +P(x)y=Q(x)$ 为非齐次线性方程。为了求出该方程的解，我们先利用齐次形式</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d}y }{\mathrm{d}x } +P(x)y=0</script><p>上述方程叫做<strong>对应于非齐次线性方程的齐次线性方程1.然后，分离变量可得</strong></p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d}y }{y }=-P(x)\mathrm{d}x</script><p>两边积分，然后求解，得</p><script type="math/tex; mode=display">y = \displaystyle C{\large \mathrm{e} ^{-\int P(x)\mathrm{d}x }}  (C = \pm \mathbin{e}^{C_{1} }  )</script><p>这就是对应的齐次线性方程的<strong>通解</strong>。</p><p>现在我们使用所谓的<code>常数易变法</code>来求解<strong>非齐次线性方程</strong>的通解。该方法是将齐次方程的通解中的 $C$ 换成未知函数 $u(x)$ ，即做变换</p><script type="math/tex; mode=display">y = \displaystyle u{\large \mathrm{e} ^{-\int P(x)\mathrm{d}x }}</script><p>带入非齐次线性方程得</p><script type="math/tex; mode=display">u = \displaystyle \int Q(x)\mathrm{e}^{\int P(x)\mathrm{d}x }  \mathrm{d}x +C</script><p>因此，非齐次线性方程的通解为</p><script type="math/tex; mode=display">\begin{align}y & = \mathrm{e}^{-\int P(x)\mathrm{d}x }  ( \int Q(x)\mathrm{e}^{\int P(x)\mathrm{d}x }  \mathrm{d}x +C)\\& = C\mathrm{e}^{-\int P(x)\mathrm{d}x } + \mathrm{e}^{-\int P(x)\mathrm{d}x }\int Q(x)\mathrm{e}^{\int P(x)\mathrm{d}x }  \mathrm{d}x\end{align}</script><p>上式右端第一项对应的是齐次线性方程的通解，第二项是非齐次线性方程的一个特解。由此可知，<strong>一阶非齐次线性方程的通解等于对应的齐次方程的通解与非齐次方程的一个特解之和</strong>。</p><h3 id="7-4-2-伯努利方程"><a href="#7-4-2-伯努利方程" class="headerlink" title="7.4.2 伯努利方程"></a>7.4.2 伯努利方程</h3><p>方程</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d}y }{\mathrm{d}x } +P(x)y=Q(x)y^{n} \quad (n\ne 0,1)</script><p>叫做<strong><font color='red'>伯努利方程</font></strong>。当 $n=0,1$ 时，这时线性微分方程；当 $n\ne 0,1$ 时，方程不是线性的，但是通过变量的代换，便可把它化为线性。方程两边同时除以 $y^{n}$ 得</p><script type="math/tex; mode=display">\displaystyle y^{-n} \frac{\mathrm{d}y }{\mathrm{d}x } +P(x)y^{1-n} =Q(x)</script><p>令 $z = y^{1-n} $ ，所以 $\displaystyle \frac{\mathrm{d} z}{\mathrm{d} x} =(1-n)y^{-n} \frac{\mathrm{d} y}{\mathrm{d} x} $ ，伯努利方程就能线性化为</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d} z}{\mathrm{d} x} +(1-n)P(x)z=(1-n)Q(x)</script><p>求出这个方程得通解后，反代换就能得到伯努利方程的通解。</p><h1 id="7-5-可降阶得高阶微分方程"><a href="#7-5-可降阶得高阶微分方程" class="headerlink" title="7.5 可降阶得高阶微分方程"></a>7.5 可降阶得高阶微分方程</h1><p>二阶及二阶以上的微分方程，称<strong>高阶微分方程</strong>。对于有些高阶微分方程，我们可以通过代换将它化成较低阶的方程来求解。</p><h2 id="7-5-1-y-n-f-x-型的微分方程"><a href="#7-5-1-y-n-f-x-型的微分方程" class="headerlink" title="7.5.1 ${y}^{(n)} =f(x)$ 型的微分方程"></a>7.5.1 ${y}^{(n)} =f(x)$ 型的微分方程</h2><p>微分方程</p><script type="math/tex; mode=display">{y}^{(n)} =f(x)</script><p>的右端仅含有自变量 $x$ 。显然，两边积分，就能得到一个 $n-1$ 阶的微分方程</p><script type="math/tex; mode=display">{y}^{(n-1)} =\int f(x)\mathrm{d}x +C_{1}</script><p>同理可得</p><script type="math/tex; mode=display">{y}^{(n-2)} =\int \left [ \int f(x)\mathrm{d}x  +C_{1} \right ] \mathrm{d}x +C_{2}</script><p>依次法，连续积分 $n$ 次，便得含有 $n$ 个任意数的通解。</p><h2 id="7-5-2-y-’’-f-x-y-’-型的微分方程"><a href="#7-5-2-y-’’-f-x-y-’-型的微分方程" class="headerlink" title="7.5.2 ${y}’’ =f(x,{y}’ )$ 型的微分方程"></a>7.5.2 ${y}’’ =f(x,{y}’ )$ 型的微分方程</h2><p>方程</p><script type="math/tex; mode=display">{y}'' =f(x,{y}' )</script><p>右端不显含未知数 $y$ 。不妨设 ${y}’ =p$ ，那么上述方程就为</p><script type="math/tex; mode=display">{p}' =f(x,p)</script><p>这是一个关于变量 $x,p$ 的一阶微分方程。然后通过以解为方程的解法，先求解出 $p$ 的通解，然后根据 $\displaystyle y = \int p\mathrm{d}x +C_{2} $ 反解出 $y$ 的通解。</p><h2 id="7-5-3-y-’’-f-y-y-’-型的微分方程"><a href="#7-5-3-y-’’-f-y-y-’-型的微分方程" class="headerlink" title="7.5.3 ${y}’’ =f(y,{y}’ )$ 型的微分方程"></a>7.5.3 ${y}’’ =f(y,{y}’ )$ 型的微分方程</h2><p>方程</p><script type="math/tex; mode=display">{y}'' =f(y,{y}' )</script><p>中不明显地含自变量 $x$ 。为了求出它的解，不妨设 ${y}’ =p$ ，我们可以得到：</p><script type="math/tex; mode=display">\begin{align}{y}'' & = \frac{\mathrm{d} p}{\mathrm{d} x} \\&=\frac{\mathrm{d} p}{\mathrm{d} y}\cdot \frac{\mathrm{d} y}{\mathrm{d} x}\\&=p\frac{\mathrm{d} p}{\mathrm{d} y} \end{align}</script><p>那么，上述方程就可以转换为以下形式：</p><script type="math/tex; mode=display">p\frac{\mathrm{d} p}{\mathrm{d} y} =f(y,p)</script><p>这是一个关于变量 $y,p$ 的一阶微分方程。</p><h1 id="7-6-高阶线性微分方程"><a href="#7-6-高阶线性微分方程" class="headerlink" title="7.6 高阶线性微分方程"></a>7.6 高阶线性微分方程</h1><h2 id="7-6-2-线性微分方程的解的结构"><a href="#7-6-2-线性微分方程的解的结构" class="headerlink" title="7.6.2 线性微分方程的解的结构"></a>7.6.2 线性微分方程的解的结构</h2><p>这里讨论齐次线性方程</p><script type="math/tex; mode=display">{y}'' +P(x){y}' +Q(x)y=0</script><p><strong>定理 1</strong>：如果函数 $y_{1} (x)$ 与 $y_{2} (x)$ 是方程的两个解，那么</p><script type="math/tex; mode=display">y = C_{1} y_{1} (x)+C_{2} y_{2} (x)</script><p>也是方程的解，其中 $C_{1},C_{2}$ 是任意常数。</p><p><strong>定理 2</strong>：如果函数 $y_{1} (x)$ 与 $y_{2} (x)$ 是方程的两个线性无关的特解，那么</p><script type="math/tex; mode=display">y = C_{1} y_{1} (x)+C_{2} y_{2} (x)</script><p>就是方程的通解。</p><ul><li><p><strong>推论</strong>：</p><p>  ​    如果 $y_{1} (x),y_{2} (x),\dots ,y_{n} (x)$ 是 $n$ 阶齐次线性方程</p><script type="math/tex; mode=display">  {y}^{(n)} +a_{1} {y}^{(n-1)} +\dots +a_{n-1} {y}'+a_{n-1} y=0</script><p>  ​    的 $n$ 个线性无关的解，那么此方程的通解为</p><script type="math/tex; mode=display">  y = C_{1}y_{1}(x) + C_{2}y_{2}(x)+\dots + C_{n}y_{n}(x)</script><p>  ​    其中，$C_{1},C_{2},\dots ,C_{n}$ 为任意常数。</p></li></ul><p><strong>定理 3</strong>：设 $y^{*} (x) $ 是二阶非齐次线性方程</p><script type="math/tex; mode=display">{y}'' +P(x){y}' +Q(x)y=f(x)</script><p>的一个特解。 $Y(x)$ 是对应的的齐次方程的通解。则二阶非线性微分方程的通解为</p><script type="math/tex; mode=display">y=Y(x)+y^{*} (x)</script><p><strong>定理 4</strong>：设非齐次线性方程的右端 $f(x)$ 是两个函数之和，即</p><script type="math/tex; mode=display">{y}'' +P(x){y}' +Q(x)y=f_{1} (x)+f_{2} (x)</script><p>而 $y_{1} ^{<em>}(x) $ 和 $y_{2} ^{</em>}(x) $ 分别是方程</p><script type="math/tex; mode=display">\begin{align}{y}'' +P(x){y}' +Q(x)y & = f_{1} (x)\\{y}'' +P(x){y}' +Q(x)y & = f_{2} (x)\end{align}</script><p>的特解，则 $y_{1} ^{<em>}(x)+y_{2} ^{</em>}(x)$ 就是原方程的特解。</p><p>这一定理通常称为线性微分方程的解的<strong><font color='red'>叠加定理</font></strong>。</p><h2 id="7-6-3-常数变易法【略】"><a href="#7-6-3-常数变易法【略】" class="headerlink" title="7.6.3 常数变易法【略】"></a>7.6.3 常数变易法【略】</h2><p>​    </p><h1 id="7-7-常系数齐次线性微分方程"><a href="#7-7-常系数齐次线性微分方程" class="headerlink" title="7.7 常系数齐次线性微分方程"></a>7.7 常系数齐次线性微分方程</h1><p>形如： ${y}’’ +p{y}’ +qy=0$ 的微分方程，称为<strong>二阶常系数齐次线性微分方程</strong>。</p><hr><p>求通解的步骤：</p><ol><li>列出特征方程，解出特征值。<ol><li>特征方程： $r^{2} +pr+q=0$ ；</li><li>特征方程的解： $\displaystyle r_{1} =\frac{-p+\sqrt{p^{2}-4q} }{2} ,\quad r_{2} =\frac{-p-\sqrt{p^{2}-4q} }{2}$ 。</li></ol></li><li>根据特征值的解的情况，列出对应的通解一般式<ol><li>当 $\displaystyle \Delta =p^{2}-4q&gt;0$ 时，通解的形式为： $\displaystyle y = C_{1}e^{r_{1} x}+C_{2}e^{r_{2} x} $ 。</li><li>当 $\displaystyle \Delta =p^{2}-4q=0$ 时， $\displaystyle r_{1}=r_{2} $ ，那么通解的形式为： $\displaystyle y = (C_{1}+C_{2})e^{rx} $ 。</li><li>当 $\displaystyle \Delta =p^{2}-4q&lt;0$ 时， $\displaystyle r_{1}=\alpha +\beta i ,\quad r_{2}=\alpha -\beta i $ ，那么通解的形式为： $y = e^{\alpha } (C_{1}\cos \beta x+C_{1}\sin \beta x)$ 。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 定积分的应用【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/06.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/06.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-定积分的应用"><a href="#第六章-定积分的应用" class="headerlink" title="第六章 定积分的应用"></a>第六章 定积分的应用</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><strong><a href="./06.定积分的应用">第六章 定积分的应用</a></strong></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="6-1-定积分的元素法"><a href="#6-1-定积分的元素法" class="headerlink" title="6.1 定积分的元素法"></a>6.1 定积分的元素法</h1><p>【待补充】</p><h1 id="6-2-定积分在几何学上的应用"><a href="#6-2-定积分在几何学上的应用" class="headerlink" title="6.2 定积分在几何学上的应用"></a>6.2 定积分在几何学上的应用</h1><h2 id="6-2-1-平面图形的面积"><a href="#6-2-1-平面图形的面积" class="headerlink" title="6.2.1 平面图形的面积"></a>6.2.1 平面图形的面积</h2><p>【待补充】</p><h2 id="6-2-2-体积"><a href="#6-2-2-体积" class="headerlink" title="6.2.2 体积"></a>6.2.2 体积</h2><p>【待补充】</p><h2 id="6-2-3-平面曲线的弧长"><a href="#6-2-3-平面曲线的弧长" class="headerlink" title="6.2.3 平面曲线的弧长"></a>6.2.3 平面曲线的弧长</h2><p>【待补充】</p><h1 id="6-3-定积分在物理学上的应用"><a href="#6-3-定积分在物理学上的应用" class="headerlink" title="6.3 定积分在物理学上的应用"></a>6.3 定积分在物理学上的应用</h1><p>【待补充】</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 定积分【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/05.%E5%AE%9A%E7%A7%AF%E5%88%86.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/05.%E5%AE%9A%E7%A7%AF%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-定积分"><a href="#第五章-定积分" class="headerlink" title="第五章 定积分"></a>第五章 定积分</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><strong><a href="./05.定积分">第五章 定积分</a></strong></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="5-1-定积分的概念与性质"><a href="#5-1-定积分的概念与性质" class="headerlink" title="5.1 定积分的概念与性质"></a>5.1 定积分的概念与性质</h1><h2 id="5-1-1-定积分问题举例"><a href="#5-1-1-定积分问题举例" class="headerlink" title="5.1.1 定积分问题举例"></a>5.1.1 定积分问题举例</h2><p>曲边梯形的面积。</p><p>变速直线运动的路程</p><h2 id="5-1-2-定积分的定义"><a href="#5-1-2-定积分的定义" class="headerlink" title="5.1.2 定积分的定义"></a>5.1.2 定积分的定义</h2><p><strong>定义（<font color="red">定积分</font>）</strong> ：设函数 $f(x)$ 在 $\displaystyle \left [ a,b \right]$ 上<strong>有界</strong>，在 $\displaystyle \left [ a,b \right]$ <strong>任意</strong>插入若干个分点</p><script type="math/tex; mode=display">\displaystyle a = x_{0} <x_{1} <x_{2} <\dots <x_{n}  = b,</script><p>把区间 $\displaystyle \left [ a,b \right]$ 分成 $n$ 个小区间</p><script type="math/tex; mode=display">\displaystyle \left [ x_{0} ,x_{1}  \right ], \left [  x_{1} ,x_{2}  \right ] \dots \left [  x_{n-1} ,x_{n}  \right ]</script><p>各个小区间的长度依次为</p><script type="math/tex; mode=display">\displaystyle \Delta x_{1}  = x_{1} -x_{0}, \Delta x_{2}  = x_{2} -x_{1},\dots , \Delta x_{n}  = x_{n} -x_{n-1}</script><p>在每个小区间 $\displaystyle \left [ x_{i-1},x_{i}  \right ] $ 上取一点 $\displaystyle \xi _{i} $ ，作函数 $\displaystyle f(\xi _{i} )$ 与小区间长度 $\displaystyle \Delta x_{i} $ 的乘积 $\displaystyle f(\xi _{i} )\Delta x_{i} (i = 1,2,3,\dots ,n)$ ，并作出和</p><script type="math/tex; mode=display">\displaystyle S = \sum_{i=1}^{n} f(\xi _{i} )\Delta x_{i}</script><p>记 $\displaystyle \lambda  = \text{max}\left \{ \Delta x_{1},\Delta x_{2},\dots ,\Delta x_{n}  \right \}  $ ，如果当 $\displaystyle \lambda \to 0$ 时，这个“和”的极限总存在，且与闭区间 $\displaystyle \left [ a,b \right]$ 的分法及点 $\displaystyle \xi _{i} $ 的取法无关，那么称这个极限 $I$ 为函数 $f(x)$ 在区间 $\displaystyle \left [ a,b \right]$ 上的<strong><font color='red'>定积分（简称积分）</font></strong>，记作 $\displaystyle \int_{a}^{b} f(x)\mathrm{d}x $ ，即</p><script type="math/tex; mode=display">\int_{a}^{b} f(x)\mathrm{d}x =I= \sum_{i=1}^{n} f(\xi _{i} )\Delta x_{i}</script><p>其中 $f(x)$ 叫做<strong>被积函数</strong>，$\displaystyle f(x)\mathrm{d}x $ 叫做<strong>被积表达式</strong>， $x$ 叫做<strong>积分变量</strong>，$a$ 叫做<strong>积分下限</strong>， $b$ 叫做<strong>积分上限</strong>， $\displaystyle \left [ a,b \right]$ 叫做<strong>积分区间</strong>。</p><hr><p><strong>定理 1</strong> ：设函数 $f(x)$ 在区间 $\displaystyle \left [ a,b \right]$ 上连续，则 $f(x)$ 在区间 $\displaystyle \left [ a,b \right]$ 上可积</p><p><strong>定理 2</strong> ：设函数 $f(x)$ 在区间 $\displaystyle \left [ a,b \right]$ 上有界，且<strong>只有有限个间断点</strong>，则 $f(x)$ 在 $\displaystyle \left [ a,b \right]$ 上可积</p><blockquote><p><strong>定积分</strong>其实就是不定积分的一个进阶知识。</p><p>注意：定积分的值只与被积函数与积分区间有关，与积分变量无关</p></blockquote><h2 id="5-1-3-定积分的近似计算"><a href="#5-1-3-定积分的近似计算" class="headerlink" title="5.1.3 定积分的近似计算"></a>5.1.3 定积分的近似计算</h2><p>矩形法、梯形法和抛物线法</p><h2 id="5-1-4-定积分的性质"><a href="#5-1-4-定积分的性质" class="headerlink" title="5.1.4 定积分的性质"></a>5.1.4 定积分的性质</h2><p>为了计算和应用方便，我们对定积分进行如下<strong>规定</strong>：</p><ol><li>当 $b = a$ 时，$\displaystyle \int_{a}^{b} f(x)\mathrm{d}x =0$ </li><li>当 $a&gt;b$ 时， $\displaystyle \int_{a}^{b} f(x)\mathrm{d}x =-\int_{b}^{a} f(x)\mathrm{d}x$ </li></ol><p><strong>性质 1</strong> ：设 $\alpha $ 和 $\beta $ 均为常数，则</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{b} \left [ \alpha f(x)+\beta g(x) \right ] \mathrm{d}x =\alpha \int_{a}^{b} f(x)\mathrm{d}x+\beta \int_{a}^{b} g(x)\mathrm{d}x</script><p><strong>性质 2</strong> ：设函数 $f(x)$ ，且 $\displaystyle a$ ，则</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{c} f(x)\mathrm{d}x =\int_{a}^{b} f(x)\mathrm{d}x +\int_{b}^{c} f(x)\mathrm{d}x</script><p><strong>性质 3</strong> ：如果在区间 $\displaystyle \left [ a,b \right]$ 上 $\displaystyle f(x)\equiv 1$ ，那么</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{b} 1\mathrm{d}x  = \int_{a}^{b}\mathrm{d}x =b-a</script><p><strong>性质 4</strong> ：如果在区间 $\displaystyle \left [ a,b \right]$ 上 $\displaystyle f(x)\ge 0$ ，那么</p><script type="math/tex; mode=display">\displaystyle\int_{a}^{b}  f(x)\mathrm{d}x\ge 0</script><ul><li><p><strong>推论 1</strong> ：如果在区间 $\displaystyle \left [ a,b \right]$ 上 $\displaystyle f(x)\le 0$ ，那么</p><script type="math/tex; mode=display">  \displaystyle\int_{a}^{b}  f(x)\mathrm{d}x\le 0</script></li><li><p><strong>推论 2</strong> ：</p><script type="math/tex; mode=display">  \displaystyle \left | \int_{a}^{b}f(x)\mathrm{d}x   \right | \le \int_{a}^{b} \left | f(x) \right | \mathrm{d}x(a<b)</script></li></ul><p><strong>性质 5</strong> ：设 $M$ 及 $m$ 分别是函数 $f(x)$ 在区间 $\displaystyle \left [ a,b \right]$ 上的最大值及最小值，则</p><script type="math/tex; mode=display">\displaystyle m(b-a)\le \int_{a}^{b} f(x)\mathrm{d}x \le M(b-a),(a<b)</script><p><strong>性质 5（<font color='red'>定积分中值定理</font>）</strong> ：如果函数 $f(x)$ 在积分区间 $\displaystyle \left [ a,b \right]$ 上连续，那么在 $\left [ a,b \right ] $ 上至少存在一个点 $\xi $ ，使下式成立：</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{b} f(x)\mathrm{d}x = f(\xi )(b-a)\quad (a\le \xi \le b)</script><p>这个公式叫做 <strong>积分中值公式</strong> 。</p><h1 id="5-2-微积分基本公式"><a href="#5-2-微积分基本公式" class="headerlink" title="5.2 微积分基本公式"></a>5.2 微积分基本公式</h1><h2 id="5-2-1-变速直线运动的位置与速度的关系"><a href="#5-2-1-变速直线运动的位置与速度的关系" class="headerlink" title="5.2.1 变速直线运动的位置与速度的关系"></a>5.2.1 变速直线运动的位置与速度的关系</h2><p>设速度为 $v$ ，位移为 $x$</p><script type="math/tex; mode=display">x = \int_{a}^{b} v\mathrm{d}t</script><h2 id="5-2-2-积分上限的函数及其导数"><a href="#5-2-2-积分上限的函数及其导数" class="headerlink" title="5.2.2 积分上限的函数及其导数"></a>5.2.2 积分上限的函数及其导数</h2><p><strong>定理 1</strong> ：如果函数 $f(x)$ 在区间 $\displaystyle \left [ a,b \right ] $ 上连续，那么积分上限的函数</p><script type="math/tex; mode=display">\displaystyle \Phi (x) = \int_{a}^{x} f(t)\mathrm{d}t</script><p>在 $\displaystyle \left [ a,b \right ] $ 上可导，并且它的导数</p><script type="math/tex; mode=display">{\color{Red} \displaystyle{ \Phi }' (x) = \frac{\mathrm{d} }{\mathrm{d} x} \int_{a}^{x} f(t)\mathrm{d}t =f(x),(a\le x\le b)}</script><p><strong>定理 2</strong> ：如果函数 $f(x)$ 在区间 $\displaystyle \left [ a,b \right ] $ 上连续，那么函数</p><script type="math/tex; mode=display">\displaystyle \Phi (x) = \int_{a}^{x} f(t)\mathrm{d}t</script><p>就是 $f(x)$ 在区间 $\displaystyle \left [ a,b \right ] $ 上的一个原函数。</p><h2 id="5-2-3-牛顿-莱布尼茨公式"><a href="#5-2-3-牛顿-莱布尼茨公式" class="headerlink" title="5.2.3 牛顿-莱布尼茨公式"></a>5.2.3 牛顿-莱布尼茨公式</h2><p><strong>定理 3（<font color='red'>微积分基本定理</font>）</strong> ：如果函数 $\displaystyle F(x)$ 是连续函数 $f(x)$ 在区间 $\displaystyle \left [ a,b \right ] $ 上的一个原函数，那么</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{b} f(x)\mathrm{d}x  = F(b)-F(a)</script><h1 id="5-3-换元法和分部积分法"><a href="#5-3-换元法和分部积分法" class="headerlink" title="5.3 换元法和分部积分法"></a>5.3 换元法和分部积分法</h1><h2 id="5-3-1-定积分的换元法"><a href="#5-3-1-定积分的换元法" class="headerlink" title="5.3.1 定积分的换元法"></a>5.3.1 定积分的换元法</h2><p><strong>定理</strong> ：假设函数 $f(x)$ 在区间 $\displaystyle \left [ a,b \right ] $ 上连续，函数 $\displaystyle x=\varphi (t)$ 满足条件：</p><ol><li>$\displaystyle \varphi (\alpha )=a,\varphi (\beta )=b$ ；</li><li>$\displaystyle \varphi (t)$ 在区间 $\displaystyle \left [ \alpha ,\beta  \right ] $ 上有连续导数，其值域 $\displaystyle R_{\varphi }  = \left [ a,b \right ] $ ，则有</li></ol><script type="math/tex; mode=display">\displaystyle \int_{a}^{b} f(x)\mathrm{d}x =\int_{\alpha }^{\beta } f[\varphi (t)]{\varphi }' (t)\mathrm{d}t</script><p>上述公式叫做定积分的<strong>换元公式</strong> 。</p><h2 id="5-3-2-定积分的分部积分法"><a href="#5-3-2-定积分的分部积分法" class="headerlink" title="5.3.2 定积分的分部积分法"></a>5.3.2 定积分的分部积分法</h2><p>依据不定积分的分部积分法，可得</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{b}  u{v}'\mathrm{d}x  =\left [ uv \right ]_{a}^{b}     -\int_{a}^{b}   {u}' v\mathrm{d}x</script><p>或者下面的形式：</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{b}u\mathrm{d}v  =\left [ uv \right ]_{a}^{b}-\int_{a}^{b} v\mathrm{d}u</script><h1 id="5-4-反常积分"><a href="#5-4-反常积分" class="headerlink" title="5.4 反常积分"></a>5.4 反常积分</h1><h2 id="5-4-1-无穷限的反常积分"><a href="#5-4-1-无穷限的反常积分" class="headerlink" title="5.4.1 无穷限的反常积分"></a>5.4.1 无穷限的反常积分</h2><p>设函数 $f(x)$ 在区间 $\displaystyle \left [ a,+\infty  \right ) $ 上连续，任取 $t&gt;a$ 作定积分 $\displaystyle \int_{a}^{t} f(x)\mathrm{d}x $ ，再求极限：</p><script type="math/tex; mode=display">\displaystyle \lim_{t \to +\infty} \int_{a}^{t} f(x)\mathrm{d}x</script><p>对这个对变上限定积分算是称为：函数 $f(x)$ 在无穷区间 $\displaystyle \left [ a,+\infty  \right ) $ 上的 <strong><font color='red'>反常积分</font></strong> ，记作： $\displaystyle \int_{a}^{+\infty } f(x)\mathrm{d}x $ 。</p><hr><p><strong>定义 1</strong> ：（1）设函数 $f(x)$ 在区间 $\displaystyle \left [ a,+\infty  \right ) $ 上连续，如果反常积分的极限存在，那么称反常积分 $\displaystyle \int_{a}^{+\infty } f(x)\mathrm{d}x $ 收敛，并称此极限为该反常积分的值；如果极限不存在，那么称反常积分 $\displaystyle \int_{a}^{+\infty } f(x)\mathrm{d}x $ 发散。</p><p>（2）设函数 $f(x)$ 在区间 $\left ( -\infty ,a \right ] $ 上连续，如果反常积分的极限存在，那么称反常积分 $\displaystyle \int_{-\infty}^{a } f(x)\mathrm{d}x $ 收敛，并称此极限为该反常积分的值；如果极限不存在，那么称反常积分 $\displaystyle \int_{-\infty}^{a } f(x)\mathrm{d}x $ 发散。</p><p>（3）设函数 $f(x)$ 在区间 $\left ( -\infty ,+  \infty  \right )$ 上连续，如果反常积分的极限存在，那么称反常积分 $\displaystyle \int_{-\infty}^{+  \infty  } f(x)\mathrm{d}x $ 收敛，并称此极限为该反常积分的值；如果极限不存在，那么称反常积分 $\displaystyle \int_{-\infty}^{+  \infty  } f(x)\mathrm{d}x $ 发散。</p><p>上述反常积分统称为 <strong><font color='red'>无穷限的反常积分</font></strong> 。</p><h2 id="5-4-2-无界函数的反常积分"><a href="#5-4-2-无界函数的反常积分" class="headerlink" title="5.4.2 无界函数的反常积分"></a>5.4.2 无界函数的反常积分</h2><p>如果函数 $f(x)$ 在点 $a$ 的任一邻域内都无界，那么点 $a$ 称为函数 $f(x)$ 的 <strong><font color='red'>瑕点</font></strong> （也称为无界间断点）。无界函数的反常积分又称为 <strong><font color='red'>瑕积分</font></strong> 。</p><p>设函数 $f(x)$ 在区间 $\displaystyle (a,b]$ 上连续，任取 $t&gt;a$ 作定积分 $\displaystyle \int_{t}^{b} f(x)\mathrm{d}x $ ，再求极限：</p><script type="math/tex; mode=display">\displaystyle \lim_{t \to a^{+} } \int_{t}^{a} f(x)\mathrm{d}x</script><p>对这个对变上限定积分算是称为：函数 $f(x)$ 在区间 $\displaystyle (a,b]$ 上的 <strong><font color='red'>反常积分</font></strong> ，记作： $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 。</p><hr><p><strong>定义 2</strong> ：（1）设函数 $f(x)$ 在区间 $\displaystyle (a,b]$ 上连续， $x=a$ 为 $f(x)$ 的瑕点，如果极限存在，那么称反常积分 $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 收敛，并称此极限为该反常积分的值；如果极限不存在，那么称反常积分 $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 发散。</p><p>（2）设函数 $f(x)$ 在区间 $\displaystyle [a,b)$ 上连续， $x=b$ 为 $f(x)$ 的瑕点，如果极限存在，那么称反常积分 $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 收敛，并称此极限为该反常积分的值；如果极限不存在，那么称反常积分 $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 发散。</p><p>（3）设函数 $f(x)$ 在区间 $\displaystyle [a,c)$ 及区间 $\displaystyle (c,b]$ 上连续，点 $c$ 为 $f(x)$ 的瑕点。如果反常积分 $\displaystyle \int_{a}^{c } f(x)\mathrm{d}x $ 与反常积分 $\displaystyle \int_{c}^{b } f(x)\mathrm{d}x $ 均收敛，那么称反常积分 $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 收敛，并称反常积分 $\displaystyle \int_{a}^{c } f(x)\mathrm{d}x $ 的值与反常积分 $\displaystyle \int_{c}^{b } f(x)\mathrm{d}x $ 的值之和为反常积分 $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 的值；否则，就称反常积分 $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 发散。</p><blockquote><p><strong>计算无界函数的反常积分，也可借用“牛顿-莱布尼茨公式”</strong>。</p></blockquote><h1 id="5-5-反常积分的审敛法-Gamma-函数"><a href="#5-5-反常积分的审敛法-Gamma-函数" class="headerlink" title="5.5 反常积分的审敛法   \Gamma 函数"></a>5.5 反常积分的审敛法   <script type="math/tex">\Gamma</script> 函数</h1><h2 id="5-5-1-无穷限反常积分的审敛法"><a href="#5-5-1-无穷限反常积分的审敛法" class="headerlink" title="5.5.1 无穷限反常积分的审敛法"></a>5.5.1 无穷限反常积分的审敛法</h2><p><strong>定理 1</strong> ：设函数 $f(x)$ 在区间 $\displaystyle \left [ a,+\infty  \right ) $ 上连续，且 $f(x) \ge 0$ 。若函数</p><script type="math/tex; mode=display">\displaystyle F(x) = \int_{a}^{x} f(t)\mathrm{d}t</script><p>在区间 $\displaystyle \left [ a,+\infty  \right ) $ 上有界，则反常积分 $\displaystyle \int_{a}^{+  \infty } f(x)\mathrm{d}x $ 收敛。</p><p><strong>定理 2（比较审敛原理）</strong> ：设函数 $f(x)$ ，$g(x)$ 在区间 $\displaystyle \left [ a,+\infty  \right ) $ 上连续。如果 $\displaystyle 0\le f(x) \le g(x) ,(a\le x\le +  \infty )$ 并且 $\displaystyle \int_{a}^{+  \infty } g(x)\mathrm{d}x $ 收敛，那么 $\displaystyle \int_{a}^{+  \infty } f(x)\mathrm{d}x $ 也收敛；如果 $\displaystyle 0\le g(x) \le f(x) ,(a\le x\le +  \infty )$ ，并且 $\displaystyle \int_{a}^{+  \infty } g(x)\mathrm{d}x $ 发散，那么 $\displaystyle \int_{a}^{+  \infty } f(x)\mathrm{d}x $ 也发散。</p><p><strong>定理 3（比较审敛法 1）</strong> ：设函数 $f(x)$ 在区间 $\displaystyle \left [ a,+\infty  \right ) ,(a&gt;0)$ 上连续，且 $\displaystyle f(x)\ge 0$ 。如果存在常数 $M&gt;0$ 及 $p&gt;1$ ，使得 $\displaystyle f(x)\le \frac{M}{x^{p} }\quad  (a\le x\le x+  \infty )$ ，那么反常积分 $\displaystyle \int_{a}^{+  \infty } f(x)\mathrm{d}x $ 收敛；如果存在常数 $N&gt;0$ 使得 $\displaystyle f(x)\ge \frac{N}{x}\quad  (a\le x\le x+  \infty )$ ，那么反常积分 $\displaystyle \int_{a}^{+  \infty } f(x)\mathrm{d}x $ 发散。</p><p><strong>定理 4（极限审敛法 2）</strong> ：设函数 $f(x)$ 在区间 $\displaystyle \left [ a,+\infty  \right ) $ 上连续，且 $\displaystyle f(x)\ge 0$ 。如果存在常数 $p&gt;1$ 使得 $\displaystyle \lim_{x \to +\infty } x^{p} f(x) = c&lt;+\infty $ ，那么反常积分 $\displaystyle \int_{a}^{+  \infty } f(x)\mathrm{d}x $ 收敛； $\displaystyle \lim_{x \to +  \infty } x f(x) =d&gt;0(\text{或者}  \lim_{x \to +  \infty } x f(x) =+  \infty )$ ，那么反常积分 $\displaystyle \int_{a}^{+  \infty } f(x)\mathrm{d}x $ 发散。</p><p><strong>定理 5</strong> ：设函数 $f(x)$ 在区间 $\displaystyle \left [ a,+\infty  \right ) $ 上连续。如果反常积分 $\displaystyle \int_{a}^{+  \infty } \left | f(x) \right | \mathrm{d}x$ 收敛，那么反常积分</p><script type="math/tex; mode=display">\displaystyle \int_{a}^{+  \infty }  f(x)  \mathrm{d}x</script><p>也收敛。</p><h2 id="5-5-2-无界函数的反常积分的审敛法"><a href="#5-5-2-无界函数的反常积分的审敛法" class="headerlink" title="5.5.2 无界函数的反常积分的审敛法"></a>5.5.2 无界函数的反常积分的审敛法</h2><p><strong>定理 6（比较审敛法 2）</strong> ：设函数 $f(x)$ 在区间 $\displaystyle (a,b]$ 上连续，且 $\displaystyle f(x)\ge 0$ ， $x=a$ 为 $f(x)$ 的瑕点。如果存在常数 $M&gt;0$ 及 $q&lt;1$ ，使得</p><script type="math/tex; mode=display">\displaystyle f(x)\le \frac{M}{(x-a)^{q} } \quad(a<x\le b)</script><p>那么反常积分 $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 收敛；如果存在常数 $N&gt;0$ ，使得</p><script type="math/tex; mode=display">\displaystyle f(x)\ge \frac{N}{x-a}</script><p>那么反常积分  $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 发散。</p><p><strong>定理 7（极限审敛法 2）</strong> ：设函数 $f(x)$ 在区间 $\displaystyle (a,b]$ 上连续，且 $\displaystyle f(x)\ge 0$ ， $x=a$ 为 $f(x)$ 的瑕点。如果存在常数 $0&lt;q&lt;1$ ，使得</p><script type="math/tex; mode=display">\displaystyle \lim_{x \to a^{+} } (x-a)^{q} f(x)</script><p>存在，那么反常积分  $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 收敛；如果</p><script type="math/tex; mode=display">\displaystyle \lim_{x \to a^{+} } (x-a) f(x) = d>0\quad(\text{或者} \lim_{x \to a^{+} } (x-a) f(x) = +  \infty )</script><p>那么反常积分  $\displaystyle \int_{a}^{b } f(x)\mathrm{d}x $ 发散。</p><h2 id="5-5-3-Gamma-函数"><a href="#5-5-3-Gamma-函数" class="headerlink" title="5.5.3 \Gamma 函数"></a>5.5.3 <script type="math/tex">\Gamma</script> 函数</h2><p>在理论和应用上都用重要意义的 <strong>$\Gamma $ 函数</strong>。函数的定义是：</p><script type="math/tex; mode=display">\displaystyle \Gamma (s) = \int_{0}^{+  \infty } e^{-x} x^{s-1} \mathrm{d} x\quad(s>0)</script><p><strong>重要性质</strong> ：</p><ol><li><p><strong>递推公式</strong>：$ \displaystyle \Gamma (s+1) =  s\Gamma (s)$ ；</p></li><li><p>当 $\displaystyle s\to 0^{+} $ 时，$\displaystyle \Gamma (s)\to +  \infty $ ；</p></li><li><p>$\displaystyle \Gamma (s)\Gamma (1-s) = \frac{\pi }{\sin \pi s} \quad (0$ ，这个公式称为<strong><font color='red'>余元公式</font></strong> 。</p></li><li><p>在 $\displaystyle \Gamma (s) = \int_{0}^{+  \infty } e^{-x} x^{s-1} \mathrm{d} x\quad(s&gt;0)$ 做代换 $\displaystyle x = u^{2} $ ，有</p><script type="math/tex; mode=display"> \displaystyle \Gamma (s) = 2\int_{0}^{+  \infty } e^{-u^{2} } u^{2s-1} \mathrm{d}u</script><p> ​    再令 $2s-1=t$ 得：</p><script type="math/tex; mode=display"> \displaystyle \int_{0}^{+  \infty } e^{-u^{2} } u^{t} \mathrm{d}u = \frac{1}{2} \Gamma (\frac{1+t}{2} )\quad (t>-1)</script><p> ​    上式左端是实际应用中常见得积分，它的值可以通过上式用 $\Gamma$ 函数计算出来。如果令 $\displaystyle s=\frac{1}{2} $ ，得：</p><script type="math/tex; mode=display"> \displaystyle 2\int_{0}^{+  \infty } e^{-u^{2} }\mathrm{d}u =  \Gamma (\frac{1}{2} ) = \sqrt{\pi } \quad (t>-1)</script><p> ​    从而得到在概率论中常用的积分。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 不定积分【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/04.%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/04.%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="四、不定积分"><a href="#四、不定积分" class="headerlink" title="四、不定积分"></a>四、不定积分</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><strong><a href="./04.不定积分">第四章 不定积分</a></strong></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="4-1-不定积分的概念与性质"><a href="#4-1-不定积分的概念与性质" class="headerlink" title="4.1 不定积分的概念与性质"></a>4.1 不定积分的概念与性质</h1><h2 id="4-1-1-原函数概念"><a href="#4-1-1-原函数概念" class="headerlink" title="4.1.1 原函数概念"></a>4.1.1 原函数概念</h2><p><strong>定义 1</strong> ：如果在区间 $I$ 上，可导函数 $F(x)$ 的导数为 $f(x)$ ，即对任一 $\displaystyle x\in I$ ，都有</p><script type="math/tex; mode=display">\displaystyle {F}' (x) =f(x)\text{或者} \mathrm{d}F(x)=f(x)\mathrm{d}x</script><p>那么函数 $F(x)$ 就称为 $f(x)$ 在区间 $I$ 上的一个<strong><font color='red'>原函数</font></strong> 。</p><p> <strong><font color='red'>原函数存在定理</font></strong> ：如果函数 $f(x)$ 在区间 $I$ 上连续，那么在区间 $I$ 上存在可导函数 $F(x)$ ，使得对任一 $\displaystyle x\in I$ 都有</p><script type="math/tex; mode=display">\displaystyle {F}' (x) =f(x)</script><blockquote><p>简单来说：<strong>连续函数一定有原函数</strong>。</p></blockquote><h2 id="4-1-2-不定积分的概念"><a href="#4-1-2-不定积分的概念" class="headerlink" title="4.1.2 不定积分的概念"></a>4.1.2 不定积分的概念</h2><p><strong>定义 2</strong> ：在区间 $I$ 上，函数 $f(x)$ 的带有任意常数项的原函数，称为 $f(x)$ 在区间 $I$ 上的 <strong><font color='red'></strong>不定积分<strong>&lt;/font&gt;</strong> ，记作</p><script type="math/tex; mode=display"> \displaystyle \int f(x)\mathrm{d}x=F(x) +C</script><p>其中记号 $\displaystyle \int $ 称为<u><strong>积分号</strong></u>，$\displaystyle f(x)$ 称为<u><strong>被积函数</strong></u>，$\displaystyle f(x)\mathrm{d}x $ 称为<u><strong>被积表达式</strong></u>， $x$ 称为<u><strong>积分变量</strong></u>。</p><blockquote><p>不定积分其实就是其原函数的全体，并且原函数之间沿 $y$ 轴之间是相互<strong>平行</strong>的。</p></blockquote><h2 id="4-1-3-不定积分的性质"><a href="#4-1-3-不定积分的性质" class="headerlink" title="4.1.3 不定积分的性质"></a>4.1.3 不定积分的性质</h2><p><strong>性质 1</strong> ：设函数 $\displaystyle f(x)$ 和函数 $\displaystyle g(x)$ 的原函数存在，则</p><script type="math/tex; mode=display">\displaystyle \int \left [ f(x)+g(x) \right ]\mathrm{d}x =\int f(x)\mathrm{d}x+\int g(x)\mathrm{d}x</script><p><strong>性质 2</strong> ：设函数  $\displaystyle f(x)$ 的原函数存在， $k$ 为非零常数，则</p><script type="math/tex; mode=display">\displaystyle \int kf(x)\mathrm{d}x  = k\int f(x)\mathrm{d}x</script><h1 id="4-2-换元积分法"><a href="#4-2-换元积分法" class="headerlink" title="4.2 换元积分法"></a>4.2 换元积分法</h1><h2 id="4-2-1-第一类换元法"><a href="#4-2-1-第一类换元法" class="headerlink" title="4.2.1 第一类换元法"></a>4.2.1 第一类换元法</h2><p><strong>定理 1</strong> ：设 $\displaystyle f(u)$ 具有原函数，$\displaystyle u = \varphi (x)$ 可导，则有换元公式</p><script type="math/tex; mode=display">\displaystyle \int f \left [ \varphi (x) \right ] {\varphi }'  (x) \mathrm{d}x  = \left [ \int f(u)\mathrm{d}u  \right ]_{u = \varphi (x)}</script><blockquote><p>核心思想：就是凑出方便积分的积分变量。</p></blockquote><h2 id="4-2-2-第二类换元法"><a href="#4-2-2-第二类换元法" class="headerlink" title="4.2.2 第二类换元法"></a>4.2.2 第二类换元法</h2><p><strong>定理 2</strong> ：设 $\displaystyle x = \psi (t)$ 是单调的可导函数，并且 $\displaystyle {\psi}’  (x)\ne 0$ 。又设 $\displaystyle f\left [ \psi (t) \right ] {\psi }’ (t)$ 具有原函数，则换元公式</p><script type="math/tex; mode=display">\displaystyle \int f(x)\mathrm{d}x  =\left [  \int f\left [ \psi (t) \right ] {\psi }' (t)\mathrm{d}t  \right ]_{t = \psi ^{-1}(x) }</script><p>其中 $\psi ^{-1}(x)$ 是 $\displaystyle x = \psi(t)$ 的反函数。</p><h1 id="4-3-分部积分法"><a href="#4-3-分部积分法" class="headerlink" title="4.3 分部积分法"></a>4.3 分部积分法</h1><p>设函数 <script type="math/tex">\displaystyle u = u(x)</script> 和函数 <script type="math/tex">\displaystyle v = v(x)</script> 具有连续导数，则两个函数乘积的导数公式为</p><script type="math/tex; mode=display">\displaystyle {(uv)}'  = {u}' v+u{v}'</script><p>移项，得</p><script type="math/tex; mode=display">\displaystyle u{v}' ={(uv)}' -{u}' v</script><p>对这个等式两边求不定积分，得</p><script type="math/tex; mode=display">\displaystyle \int u{v}'\mathrm{d}x  =uv  -\int {u}' v\mathrm{d}x</script><p>上述公式称为 <strong><font color='red'>分部积分公式</font></strong> 。</p><h1 id="4-4-有理函数的积分"><a href="#4-4-有理函数的积分" class="headerlink" title="4.4 有理函数的积分"></a>4.4 有理函数的积分</h1><h2 id="4-4-1-有理函数的积分"><a href="#4-4-1-有理函数的积分" class="headerlink" title="4.4.1 有理函数的积分"></a>4.4.1 有理函数的积分</h2><p>两个多项式的商 <script type="math/tex">\displaystyle \frac{P(x)}{Q(x)}</script> 称为 <strong><font color='red'>有理函数</font></strong> ，又称为 <strong>有理分式</strong> 。我们总假定分子多项式与分母多项式之间没有公因式。当分子多项式的次数小于分母多项式的次数时，称为有理函数的<strong>真分式</strong>，反之称为<strong>假分式</strong>。</p><p>对于真分式  <script type="math/tex">\displaystyle \frac{P(x)}{Q(x)}</script> ，如果分母可以分解为两个多项式的乘积：<script type="math/tex">\displaystyle Q(x) = Q_{1} (x)Q_{2} (x)</script> ，且 <script type="math/tex">\displaystyle Q_{1} (x)</script> 与 <script type="math/tex">\displaystyle Q_{2} (x)</script> 没有公因式，那么它可拆分成两个真分式之和</p><script type="math/tex; mode=display">\displaystyle \frac{P(x)}{Q(x)}  = \frac{P_{1} (x)}{Q_{1} (x)} +\frac{P_{2} (x)}{Q_{2} (x)}</script><p>上述步骤称为<strong>把真分式化成<font color='red'>部分分式</font>之和</strong>。</p><h1 id="4-5-积分表的使用"><a href="#4-5-积分表的使用" class="headerlink" title="4.5 积分表的使用"></a>4.5 积分表的使用</h1><p><em>详情请看附录</em><a href="./13.高等数学常用公式">高等数学常用公式</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 微分中值定理与导数的应用【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/03.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B8%8E%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/03.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B8%8E%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-微分中值定理与导数的应用"><a href="#第三章-微分中值定理与导数的应用" class="headerlink" title="第三章 微分中值定理与导数的应用"></a>第三章 微分中值定理与导数的应用</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><strong><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></strong></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><h1 id="3-1-微分中值定理"><a href="#3-1-微分中值定理" class="headerlink" title="3.1 微分中值定理"></a>3.1 微分中值定理</h1><h2 id="3-1-1-罗尔定理"><a href="#3-1-1-罗尔定理" class="headerlink" title="3.1.1 罗尔定理"></a>3.1.1 罗尔定理</h2><p><font color='red'>费马引理</font> ：设函数 $f(x)$ 在点 $x_{0} $ 的某邻域 $U(x_{0} )$ 内有定义，并且在 $x_{0}$ 处可导，如果对任意的 $x\in U(x_{0} )$ ，有</p><script type="math/tex; mode=display">\displaystyle f(x)\le f(x_{0} ),\quad (\text{ 或者 } f(x)\ge f(x_{0} ))</script><p>那么 $\displaystyle {f}’ (x_{0} ) = 0$ 。</p><ul><li><p>证明;</p><p> 不妨设 $x\in U(x_{0} )$ 时，有 $\displaystyle f(x)\le f(x_{0} )$ （如果 $f(x)\ge f(x_{0} )$ ，可以类似的证明）。于是，对于 $x_{0}+ \Delta x\in U(x_{0} )$ ，有</p><script type="math/tex; mode=display">f(x_{0}+\Delta x )\le f(x_{0} )</script><p> 那么，当 $\Delta x&gt; 0$ 时，我们能得到</p><script type="math/tex; mode=display">\displaystyle \frac{f(x_{0}+\Delta x )-f(x_{0} )}{\Delta x} \le 0</script><p> 那么，当 $\Delta x&lt; 0$ 时，我们能得到</p><script type="math/tex; mode=display">\displaystyle \frac{f(x_{0}+\Delta x )-f(x_{0} )}{\Delta x} \ge 0</script><p> 根据函数 $f(x)$ 在 $\displaystyle x_{0}$ 可导条件以及极限的保号性，可以得到</p><script type="math/tex; mode=display">\begin{align}{f}' (x) & = {f}' _{+} (x_{0} )  = \lim_{\Delta x \to 0^{+} } \frac{f(x_{0}+\Delta x )-f(x_{0} )}{\Delta x} \le 0\\{f}' (x) & = {f}' _{-} (x_{0} )  = \lim_{\Delta x \to 0^{-} } \frac{f(x_{0}+\Delta x )-f(x_{0} )}{\Delta x} \ge 0\\\end{align}</script><p>所以，根据夹逼准则可得， ${f}’ (x_{0} )=0$ 。证毕。</p><blockquote><p><strong>驻点</strong>：导数为 0 的点。</p></blockquote></li></ul><hr><p><font color='red'>罗尔定理</font> ：如果函数 $f(x)$ 满足：（1）在闭区间 $\displaystyle \left [ a,b \right ] $ 内连续；（2）在开区间 $\displaystyle (a,b)$ 内可导；（3）在区间端点处的函数值相等，即 $f(a) = f(b)$ 。</p><p>那么在 $(a,b)$ 内至少有一点 $\xi (a&lt;\xi)$ ，使得 ${f}’ (\xi ) = 0$ 。</p><h2 id="3-1-2-拉格朗日中值定理"><a href="#3-1-2-拉格朗日中值定理" class="headerlink" title="3.1.2 拉格朗日中值定理"></a>3.1.2 拉格朗日中值定理</h2><p><font color='red'>拉格朗日中值定理</font> ：如果函数 $f(x)$ 满足：（1）在闭区间 $\left [ a,b \right ] $ 内连续；（2）在开区间 $(a,b)$ 内可导</p><p>那么那么在 $(a,b)$ 内至少有一点 $\xi (a&lt;\xi)$ ，使等式</p><script type="math/tex; mode=display">\displaystyle f(b)-f(a) = {f}'(\xi )(b-a)</script><p>成立。上述公式称为<strong><font color='red'>拉格朗日中值公式</font></strong>。变换形式可得</p><script type="math/tex; mode=display">\displaystyle \frac{f(b)-f(a)}{b-a}  = {f}'(\xi )</script><hr><p>设 $x$ 为区间 $[a,b]$ 内一点， $x+\Delta x$ 为这一区间的另一点。则拉格朗日中值公式就变为</p><script type="math/tex; mode=display">f(x+\Delta x)-f(x)={f}' (x+\theta \Delta x)\cdot \Delta x\quad (0<\theta <1)</script><p>如果记 $f(x)$ 为 $y$ ，那么上式就能转化为</p><script type="math/tex; mode=display">\Delta y={f}' (x+\theta \Delta x)\cdot \Delta x\quad (0<\theta <1)</script><p>函数的微分 $\mathrm{d}y ={f}’ (x+\theta \Delta x)\cdot \Delta x$ 是函数的增量 $\Delta y$ 的近似表达式，一般来说，以 $\mathrm{d}y $ 替代 $\Delta y$ 时产生的误差，只有当 $\Delta x\to 0$ 时，才趋于零；而上式给出自变量取得有限增量 $\Delta x$ 时，函数增量 $\Delta y$ 的准确表达式。因此，这个定理也叫做<strong><font color='red'>有限增量定理</font></strong>，上式称为<strong>有限增量公式</strong>。拉格朗日中值定理在微分学中占有重要位置，有时也称这定理为<strong>微分中值公式</strong>。</p><p><strong>定理</strong> ：如果函数 $f(x)$ 在区间 $I$ 上连续， $I$ 内可导且<u>导数恒为零</u>，那么 $f(x)$ 在区间 $I$ 上是一个常数。</p><h2 id="3-1-3-柯西中值定理"><a href="#3-1-3-柯西中值定理" class="headerlink" title="3.1.3 柯西中值定理"></a>3.1.3 柯西中值定理</h2><p><font color='red'>柯西中值定理</font> ：如果函数 $f(x)$ 和 $F(x)$ ：（1）在闭区间 $\left [ a,b \right ] $ 内连续；（2）在开区间 $\displaystyle (a,b)$ 内可导；（3）对任一 $x\in (a,b),{F}’(x)\ne 0$</p><p>那么在 $(a,b)$ 内至少有一点 $\xi $ ，使等式</p><script type="math/tex; mode=display">\displaystyle\frac{f(b)-f(a)}{F(b)-F(a)}  = \frac{ {f}'(\xi) }{ {F}'(\xi) }</script><p>成立。</p><h1 id="3-2-洛必达法则-🎉🎉"><a href="#3-2-洛必达法则-🎉🎉" class="headerlink" title="3.2 洛必达法则 🎉🎉"></a>3.2 洛必达法则 🎉🎉</h1><p><strong>定理 1</strong> ：设（1）当 $\displaystyle x \to a$ 时，函数 $f(x)$ 和 $F(x)$ 都趋于零；（2）在点 $a$ 的某去心邻域内， $\displaystyle {f}’(x)$ 和 $\displaystyle {F}’ (x)$ 都存在且 $\displaystyle {F}’ (x)\ne 0$ ；（3） $\displaystyle {\large \lim_{x \to a} \frac{ {f}’ (x)}{ {F}’ (x)} } $ 存在（或为无穷大），则</p><script type="math/tex; mode=display">{\color{Red} \mathbf{\lim_{x \to a} \frac{f (x)}{F (x)} =\lim_{x \to a} \frac{ {f}' (x)}{ {F}' (x)}} }</script><p>这种在一定条件下通过分子分母分别求导在求极限的来确定未定式的值的方法称为<font color='red'>洛必达法则（L’ Hospital）</font> 。</p><p><strong>定理 2</strong> ：设（1）当 $\displaystyle x \to \infty $ 时，函数 $f(x)$ 和 $F(x)$ 都趋于零；（2）当 $\displaystyle \left | x \right |&gt; N$ 时， $\displaystyle {f}’ (x)$ 和 $\displaystyle {F}’ (x)$ 都存在且 $\displaystyle {F}’ (x)\ne 0$ ；（3） $\displaystyle {\large \lim_{x \to a} \frac{ {f}’ (x)}{ {F}’ (x)} } $ 存在（或为无穷大），则</p><script type="math/tex; mode=display">\displaystyle \lim_{x \to \infty } \frac{ f(x)}{ F(x)} =\lim_{x \to \infty } \frac{ {f}' (x)}{ {F}' (x)}</script><h1 id="3-3-泰勒公式-☣️☣️"><a href="#3-3-泰勒公式-☣️☣️" class="headerlink" title="3.3 泰勒公式 ☣️☣️"></a>3.3 泰勒公式 ☣️☣️</h1><p>为什么要引出泰勒公式？或者泰勒的作用是什么？</p><p>泰勒公式的作用之一就是：近似计算。</p><hr><p>已知函数 $f(x)$ 在 $x_{0}$ 处有 $n$ 阶导，并且存在一个多项式：</p><script type="math/tex; mode=display">P_{n} (x)=a_{0} +a_{1} (x-x_{0} )+a_{2} (x-x_{0} )^{2} +\dots +a_{n} (x-x_{0} )^{n}</script><p>令：</p><script type="math/tex; mode=display">\begin{align}P_{n}(x_{0})& = f(x_{0} )\\{P_{n}}^{(1)} (x_{0})& = {f}^{(1)} (x_{0} )\\{P_{n}}^{(2)} (x_{0})& = {f}^{(2)} (x_{0} )\\&\cdots \\{P_{n}}^{(n)} (x_{0})& = {f}^{(n)} (x_{0} )\\\end{align}</script><p>那么，这时候就可以得到 $P_{n}(x)\approx f(x)$ 的关系，也就是说，能用他近似计算，并且</p><script type="math/tex; mode=display">\begin{align}a_{0} &=f(x_{0})\\a_{1} &={f}^{(1)} (x_{0})\\a_{2} &=2!{f}^{(2)} (x_{0})\\&\cdots \\a_{n} &=n!{f}^{(n)} (x_{0})\\\end{align}</script><p>此时，为了得到一个相等的关系，引入误差项 $R_{n}(x)$ ，使得</p><script type="math/tex; mode=display">f(x) = P_{n}(x) + R(x)</script><p>而当 $n\to +\infty $ 时，$f(x) = P_{n}(x)$ ，即 $R(x)$ 是 $(x-x_{0})^{n}$ 的高阶无穷小。</p><hr><p><strong>泰勒中值定理 1</strong> ：如果函数 $f(x)$ 在 $\displaystyle x_{0}$ 处具有 $n$ 阶导数，那么存在 $x_{0}$ 的一个邻域，对于该邻域内的任一 $x$ ，有</p><script type="math/tex; mode=display">\begin{align}\displaystyle f(x) & = f(x_{0}) +{f}'(x_{0})(x-x_{0}) +\frac{ {f}'' (x_{0})}{2!} (x-x_{0}) ^{2} +\dots \\&+\frac{  {f}^{(n)}  (x_{0})}{n!} (x-x_{0}) ^{n}+R_{n}(x) \end{align}</script><p>其中</p><script type="math/tex; mode=display">\displaystyle R_{n}(x) = o ((x-x_{0})^{n} )</script><hr><p><strong>泰勒中值定理 2</strong> ：如果函数 $f(x)$ 在 $x_{0}$ 的某个邻域 $U(x_{0} )$ 具有 $(n+1)$ 阶导数，那么对任一 $x\in U(x_{0} )$​ ，有</p><script type="math/tex; mode=display">\begin{align}\displaystyle f(x) & = f(x_{0}) +{f}'(x_{0})(x-x_{0}) +\frac{ {f}'' (x_{0})}{2!} (x-x_{0}) ^{2} +\dots \\&+\frac{ {f}^{(n)}  (x_{0})}{n!} (x-x_{0}) ^{n}+R_{n}(x) \end{align}</script><p>其中</p><script type="math/tex; mode=display">\displaystyle R_{n} = \frac{ {f}^{(n+1)}(\xi ) }{(n+1)!} (x-x_{0} )^{n+1}</script><p>这里 $\xi $ 是 $x_{0}$ 与 $x$ 之间的某个值，即满足 $\xi =(1-\theta )x + \theta x_{0} \quad (0&lt;\theta &lt;1)$ 。</p><hr><p><strong>泰勒中值定理 2</strong> 中的公式称为 $f(x)$ 在 $x_{0} $ 处的带有拉格朗日余项的 $n$ 阶泰勒公式，而 $R_{n}$ 的表达式称为<font color='red'>拉格朗日余项</font> 。</p><p>当 $n=0$ 时，泰勒公式变为拉格朗日中值公式：</p><script type="math/tex; mode=display">\displaystyle f(x)=f(x_{0})+{f}'(\xi )(x-x_{0})\quad (\xi\text{在} x_{0}\text{和} x\text{之间} )</script><p>因此，<strong>泰勒中值定理 2 是拉格朗日中值定理的推广</strong>。</p><p>在泰勒公式中，如果取 <script type="math/tex">x_{0} = 0</script> ，那么带有<strong>佩亚诺</strong>余项的<font color='red'>麦克劳伦公式</font>如下</p><script type="math/tex; mode=display">\begin{align}\displaystyle f(x) & = f(0) +{f}'(0)x+\frac{ {f}'' (0)}{2!} x ^{2} +\dots \\&+\frac{ {f}^{(n)}  (0)}{n!} x ^{n}+ o (x^{n} )\end{align}</script><h1 id="3-4-函数单调性与曲线凹凸性"><a href="#3-4-函数单调性与曲线凹凸性" class="headerlink" title="3.4 函数单调性与曲线凹凸性"></a>3.4 函数单调性与曲线凹凸性</h1><h2 id="3-4-1-函数单调性的判定法"><a href="#3-4-1-函数单调性的判定法" class="headerlink" title="3.4.1 函数单调性的判定法"></a>3.4.1 函数单调性的判定法</h2><p><strong>定理 1</strong> ：设函数 $\displaystyle y = f(x)$ 在 $\left [ a,b \right ] $ 上连续，在 $(a,b)$ 内可导。</p><ul><li>如果在 $\displaystyle (a,b)$ 内 $\displaystyle {f}’ (x)\ge 0$ ，且<strong>等号仅在有限多个点处成立</strong> ，那么函数 $\displaystyle y = f(x)$ 在 $\displaystyle \left [ a,b \right ] $ 上<font color='red'>单调增加</font> ；</li><li>如果在 $\displaystyle (a,b)$ 内 $\displaystyle {f}’ (x)\le  0$ ，且<strong>等号仅在有限多个点处成立</strong> ，那么函数 $\displaystyle y = f(x)$ 在 $\displaystyle \left [ a,b \right ] $ 上<font color='red'>单调减少</font> 。</li></ul><blockquote><p>当 $\displaystyle {f}’ (x_{0} ) = 0$ 时，点 $x=x_{0}$ 称为函数 $f(x)$ 的<strong>驻点</strong>。</p></blockquote><h2 id="3-4-2-曲线凹凸性与拐点"><a href="#3-4-2-曲线凹凸性与拐点" class="headerlink" title="3.4.2 曲线凹凸性与拐点"></a>3.4.2 曲线凹凸性与拐点</h2><p><strong>定义</strong> ：</p><p>设 $f(x)$ 在区间 $I$ 上连续。如果对于 $I$ 上任意两点 $x_{1} ,x_{2}$ ，恒有</p><script type="math/tex; mode=display">\displaystyle f(\frac{x_{1}+x_{2} }{2} )<\frac{f(x_{1})+f(x_{2} ) }{2}</script><p>那么称 $f(x)$ 在 $I$ 上的图形是（向上）凹的（或凹弧）；如果恒有</p><script type="math/tex; mode=display">\displaystyle f(\frac{x_{1}+x_{2} }{2} )>\frac{f(x_{1})+f(x_{2} ) }{2}</script><p>那么称 $f(x)$ 在 $I$ 上的图形是（向上）凸的（或凸弧）。</p><p><strong>定理 2</strong> 设 $f(x)$ 在 $\displaystyle \left [ a,b \right ]$ 上连续，在 $(a,b)$ 内具有一阶和二阶导数，那么</p><ul><li>若在 $(a,b)$ 内 ${f}’’(x)&gt; 0$ ，则 $f(x)$ 在 $\left [ a,b \right ] $ 上的图形是<font color='red'>凹的</font>；</li><li>若在 $\displaystyle (a,b)$ 内 ${f}’’(x)&lt; 0$ ，则 $f(x)$ 在 $\displaystyle \left [ a,b \right ] $ 上的图形是<font color='red'>凸的</font>。</li></ul><p>一般地，设 $\displaystyle y = f(x)$ 在区间 $I$ 上连续， $x_{0}$ 是 <script type="math/tex">I</script> 内的点。如果曲线 $y = f(x)$ 在经过点 $(x_{0},f(x_{0}))$ 时，曲线的凹凸性发生变化，那么就称点 $(x_{0},f(x_{0} ) )$ 为这曲线的 <font color='red'>拐点</font> 。</p><blockquote><p>注意：零点和驻点指的是 $x$ 值；而拐点指的是一个点。</p></blockquote><h1 id="3-5-极值及求法"><a href="#3-5-极值及求法" class="headerlink" title="3.5 极值及求法"></a>3.5 极值及求法</h1><h2 id="3-5-1-极值的定义"><a href="#3-5-1-极值的定义" class="headerlink" title="3.5.1 极值的定义"></a>3.5.1 极值的定义</h2><p><strong>定义</strong>：设函数 $f(x)$ 在在点 $x_{0}$ 的邻域内有定义，那么对 $\forall x\in \overset{\circ }{U} (x)$ ，恒有</p><script type="math/tex; mode=display">f(x)\le f(x_{0} )</script><p>那么称函数在点 $x_{0}$ 处取得<strong>极大值</strong>；如果恒有</p><script type="math/tex; mode=display">f(x)\ge  f(x_{0} )</script><p>那么称函数在点 $x_{0}$ 处取得<strong>极小值</strong>。</p><p><strong>定理 1（必要条件）</strong>： $f(x)$ 在 $x_{0}$ 处可导。如果 $x_{0}$ 处取得极值，那么 ${f}’ (x_{0} )=0$ 。</p><p><strong>定理 2（第一充分条件）</strong>： $f(x)$ 在 $x_{0}$ 处连续，在 $\overset{\circ }{U} (x)$ 可导：</p><ol><li>当 $x\in \left ( x_{0}-\delta  ,x_{0}  \right ) $ 时， ${f}’ (x)&gt;0$ ，当 $x\in \left ( x_{0}  ,x_{0}+\delta  \right )$ 时，有 $ {f}’ (x)&lt;0$ ，那么在 $x_{0}$ 处取得极大值；</li><li>当 $x\in \left ( x_{0}-\delta  ,x_{0}  \right ) $ 时， ${f}’ (x)&lt;0$ ，当 $x\in \left ( x_{0}  ,x_{0}+\delta  \right )$ 时，有 $ {f}’ (x)&gt;0$ ，那么在 $x_{0}$ 处取得极小值；</li></ol><p><strong>定理 3（第二充分条件）</strong>： $f(x)$ 有二阶导，且 ${f}’ (x)=0,{f}’’ (x)\ne 0$  ：</p><ol><li>当 ${f}’’ (x)&lt; 0$ ，在 $x_{0}$ 处取得极大值；</li><li>当 ${f}’’ (x)&gt;0$ ，在 $x_{0}$ 处取得极小值；</li></ol><h1 id="3-6-函数图形的绘制"><a href="#3-6-函数图形的绘制" class="headerlink" title="3.6 函数图形的绘制"></a>3.6 函数图形的绘制</h1><p>[略]</p><h1 id="3-7-曲率"><a href="#3-7-曲率" class="headerlink" title="3.7 曲率"></a>3.7 曲率</h1><p>描述曲线的弯曲程度，使用<strong>曲率</strong>。</p><p><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E6%9B%B2%E7%8E%87%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="曲率函数图像" style="zoom:50%" /></p><p>观察切线与 $x$ 轴夹角的变化率，在弧长相等的情况下，曲线越弯曲，那么夹角变化率越大。因此，定义曲率</p><script type="math/tex; mode=display">k = \lim_{\Delta s \to 0} \left | \frac{\Delta \alpha }{\Delta s}  \right |  =  \left | \frac{\mathrm{d}\alpha  }{\mathrm{d} s}  \right |</script><p>并且定义 $\displaystyle \rho = \frac{1}{K}  $ 为曲率半径。</p><p>特殊曲线的曲率：</p><ol><li>直线的曲率：$k = 0$ ；</li><li>圆的曲率（半径为 $a$ ）： $\displaystyle k = \frac{1}{a} $ 。</li></ol><hr><p>直角坐标系下，曲率计算公式：</p><script type="math/tex; mode=display">\begin{align}\displaystyle \mathrm{d}s & = \sqrt{1+({y}' )^{2} } \mathrm{d}x \\\displaystyle K & = \frac{\left | {y}''  \right | }{(1+{y}'^{2}  )^{\frac{3}{2} }} \end{align}</script><p>参数方程 $\displaystyle \left\{\begin{matrix} x &amp; = &amp; x(t)\\ y &amp; = &amp;y(t)\end{matrix}\right.$ ，曲率计算公式：</p><script type="math/tex; mode=display">\displaystyle K=\frac{\left | {x}'{y}''-{x}''{y}'     \right | }{({x}'^{2}+{y}'^{2})^{\frac{3}{2} } }</script><h1 id="3-8-渐近线-补充"><a href="#3-8-渐近线-补充" class="headerlink" title="3.8 渐近线[补充]"></a>3.8 渐近线[补充]</h1><p>渐近线是用极限思想最简单的运用，当曲线趋于无穷远的时候，就近似等于一条直线。</p><p>首先，直线的一般方程是：</p><script type="math/tex; mode=display">y = kx+b</script><p>当 $k=0$ 是，直线平行于 $x$ 轴，称平行于 $x$ 轴的渐近线，是一条<strong>水平渐近线</strong>；当 $k\to \infty $ 时，直线平行于 $y$ 轴，称平行于 $y$ 轴（垂直于 $x$ 轴）的渐近线为<strong>垂直渐近线</strong>。</p><h2 id="3-8-1-水平渐近线"><a href="#3-8-1-水平渐近线" class="headerlink" title="3.8.1 水平渐近线"></a>3.8.1 水平渐近线</h2><p>函数 $f(x)$ 在 $\left ( -\infty,+\infty  \right ) $ 上有有定义</p><ul><li>如果极限 $\displaystyle \lim_{x \to +\infty} f(x)$ 存在，且 $\displaystyle \lim_{x \to \infty} f(x) = C_{1} $ ，那么称 $y = C_{1}$ 是函数 $f(x)$ 的一条水平渐近线；</li><li>如果极限 $\displaystyle \lim_{x \to -\infty} f(x)$ 存在，且 $\displaystyle \lim_{x \to \infty} f(x) = C_{2} $ ，那么称 $y = C_{2}$ 是函数 $f(x)$ 的一条水平渐近线。</li><li>如果 $C_{1}=C_{2}$ ，那么这是<strong>一条渐近线</strong>。</li></ul><h2 id="3-8-2-垂直渐近线"><a href="#3-8-2-垂直渐近线" class="headerlink" title="3.8.2 垂直渐近线"></a>3.8.2 垂直渐近线</h2><p>函数 $f(x)$ 在区间 $(a,b)$ 上有有定义，存在 $x_{0} \in \left [ a,b \right ]$ ，使得 $\displaystyle \lim_{x \to x_{0} } f(x) = \infty $ 成立，则称 $x =x_{0}$ 是函数 $f(x)$ 的一条垂直渐近线。</p><ul><li>上述极限存在且成立，只需要左、右极限成立其一即可。</li><li>特别地，当 $x_{0}=a$ 时，只能是 $\displaystyle \lim_{x \to x_{0}^{+}  } f(x) = \infty $ 成立；当 $x_{0}=b$ 时，只能是 $\displaystyle \lim_{x \to x_{0}^{-}} f(x) = \infty $ 。</li></ul><h2 id="3-9-3-斜渐近线"><a href="#3-9-3-斜渐近线" class="headerlink" title="3.9.3 斜渐近线"></a>3.9.3 斜渐近线</h2><p>渐近线满足两个必要条件：当 $x \to \infty$ 时</p><ol><li>极限 $\displaystyle \lim_{x \to \infty } \frac{f(x)}{x}  = k_{1} $ 存在且等式成立（斜率相等）；</li><li>在 1 成立的前提下，极限 $\displaystyle \lim_{x \to \infty } (f(x)-k_{1} x) = b_{1} $ 存在且等式成立（斜率相等的前提下，“相位”也相等）；</li></ol><p>满足上述两个条件后，就说明函数 $f(x)$ 存在一条斜渐近线，并且渐近线方程是 $y = k_{1} x+b_{1} $ 。</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 导数与微分【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/02.%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/02.%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-导数与微分"><a href="#第二章-导数与微分" class="headerlink" title="第二章 导数与微分"></a>第二章 导数与微分</h1><blockquote><p>高等数学快速导航：</p><ul><li><a href="./01.函数与极限">第一章 函数与极限</a></li><li><strong><a href="./02.导数与微分">第二章 导数与微分</a></strong></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><p>微分学是微积分的重要组成部分，它的基本概念是导数和微分。</p><h1 id="2-1-导数概念"><a href="#2-1-导数概念" class="headerlink" title="2.1 导数概念"></a>2.1 导数概念</h1><h2 id="2-1-1-引例"><a href="#2-1-1-引例" class="headerlink" title="2.1.1 引例"></a>2.1.1 引例</h2><ol><li>物理学中直线运动的速度问题</li><li>几何学中切线的问题</li></ol><h2 id="2-1-2-导数的定义"><a href="#2-1-2-导数的定义" class="headerlink" title="2.1.2 导数的定义"></a>2.1.2 导数的定义</h2><p><strong>定义</strong>：设函数 $f(x)$ 在点 $x_{0}$ 的<strong>某个邻域</strong>内有定义，当自变量 $x$ 在 $x_{0}$ 处取得增量 $\Delta x$ （点 $x_{0}+\Delta x$ 仍在该邻域内）时，相应地，因变量取得的增量 $\Delta y= f(x_{0}+\Delta x)-f(x_{0})$ 。如果 $\displaystyle \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} $ 存在，那么称函数 $y = f(x)$ 在点 $x_{0}$ 处可导，并称这个极限为函数 $y=f(x)$ 在点 $x_{0}$ 处的导数，记为 $\displaystyle {f}’ (x_{0} )$ ，即</p><script type="math/tex; mode=display">\displaystyle {f}' (x_{0} ) = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}= \lim_{\Delta x \to 0}\frac{f(x_{0}+\Delta x)-f(x_{0})}{\Delta x}</script><hr><p><strong>单侧导数</strong>：根据函数 $f(x)$ 在点 $\displaystyle x_{0}$ 处的导数 ${f}’(x_{0})$ 的定义，导数</p><script type="math/tex; mode=display">{f}' (x_{0} ) = \displaystyle \lim_{h \to 0} \frac{f(x_{0}+h)-f(x_{0})}{h}</script><p>是一个极限，而<strong>极限存在的充分必要条件是左、右极限都存在并且相等</strong>，因此 ${f}’(x_{0})$ 存在即 $f(x)$ 在点 $x_{0}$ 处可导的充分必要条件是左、右极限</p><script type="math/tex; mode=display">\displaystyle \lim_{h \to 0^{-} } \frac{f(x_{0}+h)-f(x_{0})}{h}\quad \text{及} \quad \displaystyle \lim_{h \to 0^{+} } \frac{f(x_{0}+h)-f(x_{0})}{h}</script><p>都存在且相等。这两个极限分别称为函数 $f(x)$ 在点 $x_{0}$ 处的<strong>左导数</strong>和<strong>右导数</strong>，记作 ${f}’_{-}(x_{0})$ 及 ${f}’_{+}(x_{0})$ ，即</p><script type="math/tex; mode=display">\begin{align}{f}' _{-} (x_{0} ) & = \displaystyle \lim_{h \to 0^{-} } \frac{f(x_{0}+h)-f(x_{0})}{h}\\{f}' _{+} (x_{0} ) & =\displaystyle \lim_{h \to 0^{+} } \frac{f(x_{0}+h)-f(x_{0})}{h}\end{align}</script><p>左导数和右导数统称为<strong>单侧导数</strong>。</p><h2 id="2-1-3-导数的几何意义"><a href="#2-1-3-导数的几何意义" class="headerlink" title="2.1.3 导数的几何意义"></a>2.1.3 导数的几何意义</h2><p>函数图像上的某点的导数与该点的切线的斜率相等。</p><p>应用：可以求解代数几何中的切线方程问题</p><p>根据导数的几何意义并应用直线的点斜式方程，可知曲线 $y=f(x)$ 在 $M(x_{0},y_{0})$ 处的<strong>切线方程</strong>为</p><script type="math/tex; mode=display">y-y_{0} ={f}' (x_{0} )(x-x_{0} )</script><p>过切点 $M(x_{0},y_{0})$ 且与切线垂直的直线叫做曲线 $y=f(x)$ 在点 $M$ 处的法线。如果 $ {f}’(x_{0})\ne 0$ ，则法线的斜率为 $\displaystyle -\frac{1}{ {f}’(x_{0}) }$ ，从而<strong>法线方程</strong>为</p><script type="math/tex; mode=display">y-y_{0} =-\frac{1}{ {f}'(x_{0} ) } (x-x_{0} )</script><blockquote><p>可导函数的曲线是光滑的。</p><p><strong>割线</strong>的极限位置就是切线。</p></blockquote><h2 id="2-1-3-函数可导性与连续性"><a href="#2-1-3-函数可导性与连续性" class="headerlink" title="2.1.3 函数可导性与连续性"></a>2.1.3 函数可导性与连续性</h2><blockquote><p>直观上来讲，可导就是光滑，且切线不能垂直于 $x$ 轴；连续就是不间断。</p><p><strong>可导一定连续</strong>。</p></blockquote><p><strong>连续</strong>：极限 $\displaystyle \lim_{\Delta x \to 0} \Delta y=0$ 存在。</p><p><strong>可导</strong>：极限 $\displaystyle \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}  = {f}’ (x)$ 存在</p><p>由具有极限的函数与无穷小的关系知道：</p><script type="math/tex; mode=display">\displaystyle \frac{\Delta y}{\Delta x}  = {f}' (x)  + \alpha</script><p>其中， $\alpha$ 是当 $\Delta x\to 0$ 的<strong>高阶无穷小</strong>。上式两边同乘 $\Delta x$ ，得</p><script type="math/tex; mode=display">\displaystyle \Delta y  = {f}' (x) \Delta x+ \alpha \Delta x</script><p>由此可见，当 $\Delta x\to 0$ 时， $\Delta y\to 0$ 。这就是说，函数 $y = f(x)$ 在点 $x$ 处是连续的。所以，<strong>如果函数 $f(x)$ 在点 $x$ 处可导，那么函数在该点必定连续</strong>。</p><hr><p><strong>例如</strong>： 函数 $\displaystyle y=\sqrt[3]{x} $ 在 $\displaystyle \left ( -\infty ,+\infty  \right ) $ 上是连续的，但是在 $x=0$ 处不可导。</p><h1 id="2-2-函数的求导法则"><a href="#2-2-函数的求导法则" class="headerlink" title="2.2 函数的求导法则"></a>2.2 函数的求导法则</h1><h2 id="2-2-1-函数的和、差、积、商的求导法则"><a href="#2-2-1-函数的和、差、积、商的求导法则" class="headerlink" title="2.2.1 函数的和、差、积、商的求导法则"></a>2.2.1 函数的和、差、积、商的求导法则</h2><p><strong>定理 1</strong> ：如果函数 $u= u(x)\text{和} v=v(x)$ 都在点 $x$ 具有导数，那么他们的和、差、积、商都在该点具导数。</p><ol><li><p>和差：</p><script type="math/tex; mode=display"> \displaystyle \left [ u(x)\pm v(x) \right ] ^{'} = u(x)^{'}\pm v(x)^{'}</script></li><li><p>积：</p><script type="math/tex; mode=display"> \displaystyle \left [ u(x)\cdot v(x) \right ] ^{'} = u(x)^{'}\cdot v(x)+ u(x)\cdot v(x)^{'}</script></li><li><p>商：</p><script type="math/tex; mode=display"> \displaystyle \left [ \frac{u(x)}{v(x)} \right ] ^{'} = \frac{ u(x)^{'}\cdot v(x)- u(x)\cdot v(x)^{'} }{v^{2}(x)}</script></li></ol><h2 id="2-2-2-反函数"><a href="#2-2-2-反函数" class="headerlink" title="2.2.2 反函数"></a>2.2.2 反函数</h2><p><strong>定理 2</strong>：如果函数 $x = f(y)$ 在区间 $I$ 内单调、可导且 $f^{‘}(y)\ne 0$ ，那么它的反函数 $y = f^{-1}(y)$ 在区间 $I$ 内也可导，且</p><script type="math/tex; mode=display">\displaystyle \left [ f^{-1}(x) \right ] ^{'} = \frac{1}{f^{'}(y)} 或\frac{dy}{dx} = \frac{1}{\frac{dx}{dy} }</script><h2 id="2-2-3-复合函数"><a href="#2-2-3-复合函数" class="headerlink" title="2.2.3 复合函数"></a>2.2.3 复合函数</h2><p><strong>定理 3</strong> ：如果 $\displaystyle u = g(x)$ 在点 $x$ 处可导，而且 $\displaystyle y = f(u)$ 在点 $\displaystyle u = g(x)$ 处可导，那么复合函数 $\displaystyle y = f\left [ g(x) \right ] $ 在点 $x$ 处可导，且其导数为</p><script type="math/tex; mode=display">\displaystyle \frac{dy}{dx} = f^{'}(u)\cdot u^{'}(x)\text{或} \frac{dy}{dx}  = \frac{dy}{du} \cdot \frac{du}{dx}</script><blockquote><p>复合函数的求导，类似于剥洋葱的方法。依次将复合函数中的导数相乘。</p></blockquote><h1 id="2-3-高阶导数"><a href="#2-3-高阶导数" class="headerlink" title="2.3 高阶导数"></a>2.3 高阶导数</h1><p>二阶及二阶以上的导数统称<font color='red'>高阶导数</font>。比如二阶导数如下：</p><script type="math/tex; mode=display">{y}''={({y}')}' \text{或}\frac{\mathrm{d}^{2}y}{\mathrm{d}x^{2} } =\frac{\mathrm{d}(\frac{\mathrm{d}y}{\mathrm{d}x})}{\mathrm{d}x}</script><h1 id="2-4-隐函数及由参数方程所确定的函数的导数"><a href="#2-4-隐函数及由参数方程所确定的函数的导数" class="headerlink" title="2.4 隐函数及由参数方程所确定的函数的导数"></a>2.4 隐函数及由参数方程所确定的函数的导数</h1><p><strong>显函数</strong>：形如 $y=f(x)$ 的函数，称为<strong>显函数</strong>。</p><p><strong>隐函数</strong>：不能化为<strong>显函数</strong>或者不能直观的化为<strong>显函数</strong>，称为<strong>隐函数</strong>。</p><h2 id="2-4-1-隐函数的导数"><a href="#2-4-1-隐函数的导数" class="headerlink" title="2.4.1 隐函数的导数"></a>2.4.1 隐函数的导数</h2><p><strong>方法 1（隐函数的显化）</strong>：把一个隐函数化成显函数，例如：$x +y^{3}-1=0$ 化为 $ \displaystyle y= \sqrt[3]{1-x} $ 。</p><blockquote><p>但是隐函数显化有时是困难的，甚至是不可能的</p></blockquote><p><strong>方法 2</strong>：<strong>通法</strong> ：</p><p>例 1：求方程 $e^{y}+xy-e=0$ 确定的隐函数的导数</p><script type="math/tex; mode=display">\begin{align}\displaystyle \frac{d\left ( e^{y}+xy-e \right)}{dx}&=e^{y} \frac{dy}{dx}+y+x\tfrac{dy}{dx} = 0\\\displaystyle \frac{dy}{dx} &= -\frac{y}{x+  e^{y} }\end{align}</script><p>在某些场合，利用所谓的对数求导法则求导数，比通常的方法简单，例如：求 $\displaystyle y=x^{\sin x}(x&gt;0)$ 的导数，我们可以先两边<strong>取对数</strong>，再求导数。</p><h2 id="2-4-2-参数方程确定的函数的导数"><a href="#2-4-2-参数方程确定的函数的导数" class="headerlink" title="2.4.2 参数方程确定的函数的导数"></a>2.4.2 参数方程确定的函数的导数</h2><p>一般地，若参数方程为</p><script type="math/tex; mode=display">\left\{\begin{matrix}\displaystyle x = \varphi (t) \\\displaystyle y = \psi (t)\end{matrix}\right.</script><p>该参数方程所确定的函数的导数为</p><script type="math/tex; mode=display">\displaystyle \frac{\mathrm{d} y}{\mathrm{d} x}  =\frac{\mathrm{d} y}{\mathrm{d} t} \cdot \frac{\mathrm{d} t}{\mathrm{d} x}= \frac{ {\psi }'(x) }{ {\varphi }'(x)}</script><h1 id="2-5-函数的微分"><a href="#2-5-函数的微分" class="headerlink" title="2.5 函数的微分"></a>2.5 函数的微分</h1><h2 id="2-5-1-微分的定义"><a href="#2-5-1-微分的定义" class="headerlink" title="2.5.1 微分的定义"></a>2.5.1 微分的定义</h2><p><strong>定义</strong> ：设函数 $\displaystyle y=f(x)$ 在某区间内有定义， $x_{0} $ 和 $x_{0}+ \Delta x$ 在这区间内，如果函数的增量</p><script type="math/tex; mode=display">\displaystyle \Delta y = f(x_{0}+\Delta x )-f(x_{0})</script><p>可表示为</p><script type="math/tex; mode=display">\displaystyle \Delta y = A\Delta x+ o (\Delta x)</script><p>其中 $A$ 是不依赖于 $\Delta x$ 的项，$o (\Delta x)$ 是 $\Delta x$ 的<strong>高阶无穷小</strong>。那么称函数 $y=f(x)$ 在点 $x_{0}$ 处是可微的，而 $\Delta y$ 叫做函数 $y = f(x)$ 在点 $x_{0}$ 相应于自变量增量 $\Delta x$ 的微分，记作 $\mathrm{d} y$ ，即</p><script type="math/tex; mode=display">\displaystyle \mathrm{d} y = A\Delta x</script><hr><p><strong>可微的条件</strong>：</p><p>设函数 $y=f(x)$ 在点 $x_{0}$ 可微，按照定义，可得</p><script type="math/tex; mode=display">\displaystyle \frac{\Delta y}{\Delta x}  = A +\frac{o(\Delta x)}{\Delta x}</script><p>于是，当 $\Delta x\to 0$ 时，上式就能得到</p><script type="math/tex; mode=display">A = \displaystyle \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}  = {f}' (x_{0} )</script><p>因此，如果函数 $f(x)$ 在点 $x_{0}$ 可微，那么 $f(x)$ 在点 $x_{0}$ 也一定可导，且 $A={f}’(x_{0})$ 。反之，如果 $y=f(x)$ 在点 $x_{0}$ 可导，即</p><script type="math/tex; mode=display">\displaystyle \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}  = {f}' (x_{0} )</script><p>存在，那么根据<strong>极限与无穷小的关系</strong>，可得</p><script type="math/tex; mode=display">\displaystyle  \frac{\Delta y}{\Delta x}  = {f}' (x_{0} )+\alpha</script><p>其中 $\alpha \to 0(\text{当}\Delta x\to 0 )$ 。因此又有</p><script type="math/tex; mode=display">\Delta y = {f}' (x_{0} )\Delta x+\alpha \Delta x</script><p><strong>由此可见，函数 $f(x)$ 在点 $x_{0}$ 处可微的充分必要条件为：函数 $f(x)$ 在点 $x_{0}$ 处可导</strong>。且当函数 $f(x)$ 在点 $x_{0}$ 处可微时，其微分一定是</p><script type="math/tex; mode=display">\mathrm{d}y ={f}' (x_{0} )\Delta x</script><p>通常把自变量 $x$ 的增量 $\Delta x$ 称为<strong><font color='red'>自变量的微分</font></strong>，记作 $\mathrm{d}x $ 。于是函数 $y=f(x)$ 的微分又可记作</p><script type="math/tex; mode=display">\mathrm{d}y={f}'(x) \mathrm{d}x</script><p>并且称 $\displaystyle \frac{\mathrm{d} y}{\mathrm{d} x} ={f}’(x) $ 为<strong>微商</strong>。</p><blockquote><p>其实，可以把 $\displaystyle \Delta x$ 理解为很小的变化量，而 $\displaystyle \mathrm{d}x $ 是无穷小的变化量，即 $\displaystyle \lim_{\Delta x \to 0} \Delta x=\mathrm{d}x \text{或者}\Delta x=\mathrm{d} x +  \alpha $ 。</p></blockquote><h2 id="2-5-2-微分的几何意义"><a href="#2-5-2-微分的几何意义" class="headerlink" title="2.5.2 微分的几何意义"></a>2.5.2 微分的几何意义</h2><p>形如 $y=ax+b$ 的函数称为<strong>一次函数</strong>，也被称为线性函数。线性函数在计算时较为方便。但是实际工程中，大量的都是非线性函数，研究起来比较困难。而微分的作用就是<strong>：在局部范围内用线性函数近似代替非线性函数</strong>，即 $\displaystyle \mathrm{d}y ={f}’ (x)\mathrm{d}x$ ，从函数形式上来看，这是一个线性函数，不同的是，这是在微观上进行研究。在几何上就是局部用切线段近似代替曲线段，这在数学上称为非线性函数的局部线性化，这是微分学的基本思想方法之一。这种思想方法在自然科学和工程问题的研究中是经常采用的。</p><blockquote><p>非线性函数 $\displaystyle \longrightarrow $ 局部线性化（微观） $\displaystyle \longrightarrow $ 研究微观性质 $\displaystyle \longrightarrow $ 推广到宏观。</p><ul><li>微分的思想是：微观研究宏观。</li></ul></blockquote><h2 id="2-5-3-基本初等函数的微分公式"><a href="#2-5-3-基本初等函数的微分公式" class="headerlink" title="2.5.3 基本初等函数的微分公式"></a>2.5.3 基本初等函数的微分公式</h2><p><a href="https://blog.yuilexi.cn/2023/04/26/大学学习/高等数学/高等数学常用公式/#导数与微分">高等数学常用公式 | 🪐星空鸟🪐 (yuilexi.cn)</a></p><h2 id="2-5-4-微分在近似计算中的应用"><a href="#2-5-4-微分在近似计算中的应用" class="headerlink" title="2.5.4 微分在近似计算中的应用"></a>2.5.4 微分在近似计算中的应用</h2><p><strong>精确计算</strong>：</p><script type="math/tex; mode=display">\displaystyle \Delta y=f(x_{0}+\Delta x )-f(x_{0})</script><p>已知 $\displaystyle \mathrm{d}y ={f}’(x)\Delta x$ 且 $\displaystyle \mathrm{d}y \approx \Delta x $ ，那么，上述式子近似为：</p><script type="math/tex; mode=display">\displaystyle f(x_{0}+\Delta x )={f}' (x_{0} )\Delta x+f(x_{0} )</script>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 函数与极限【高等数学】</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/01.%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/01.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/01.%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-函数与极限"><a href="#第一章-函数与极限" class="headerlink" title="第一章 函数与极限"></a>第一章 函数与极限</h1><blockquote><p>高等数学快速导航：</p><ul><li><strong><a href="./01.函数与极限">第一章 函数与极限</a></strong></li><li><a href="./02.导数与微分">第二章 导数与微分</a></li><li><a href="./03.微分中值定理与导数的应用">第三章 微分中值定理与导数的应用</a></li><li><a href="./04.不定积分">第四章 不定积分</a></li><li><a href="./05.定积分">第五章 定积分</a></li><li><a href="./06.定积分的应用">第六章 定积分的应用</a></li><li><a href="./07.微分方程">第七章 微分方程</a></li><li><a href="./08.向量代数与空间解析几何">第八章 向量代数与空间解析几何</a></li><li><a href="./09.多元函数微分法及其应用">第九章 多元函数微分法及其应用</a></li><li><a href="./10.重积分">第十章 重积分</a></li><li><a href="./11.曲线积分和曲面积分">第十一章 曲线积分和曲面积分</a></li><li><a href="./12.无穷级数">第十二章 无穷级数</a></li><li><a href="./13.高等数学常用公式">附录 高等数学常用公式</a></li></ul></blockquote><p><strong>初等数学的研究对象基本上是不变的量，而高等数学的研究对象则是变动的量</strong>。所谓函数关系就是变量之间的依赖关系，极限方法是研究变量的一种基本方法。</p><h1 id="1-1-映射与函数"><a href="#1-1-映射与函数" class="headerlink" title="1.1 映射与函数"></a>1.1 映射与函数</h1><p>映射是现代数学中的一个基本概念，而函数是微积分的研究对象，也是映射的一种。</p><h2 id="1-1-1-映射"><a href="#1-1-1-映射" class="headerlink" title="1.1.1 映射"></a>1.1.1 映射</h2><ol><li><p>映射的概念</p><p> 定义：设 $X、Y$ 是两个<strong>非空集合</strong>（没说是数集），如果存在一个法则 $ f $ ，使得对 $ X $ 中的每个元素 $ x $，按法则 $ f $ ，在 $Y$ 中有<strong>唯一确定</strong>的元素 $y$ 与之对应，那么称 $ f $ 为从 $X$ 到 $Y$ 的映射，记作</p><script type="math/tex; mode=display">f:X→Y</script><p> 其中 $y$ 称为元素 $x$ （在映射 $f$ 下）的<strong>像</strong>，并记作 $f(x)$ ，即</p><script type="math/tex; mode=display">y = f(x)</script><p> 而元素 $x$ 称为（在映射 $f$ 下）的一个<strong>原像</strong>；集合 $X$ 称为映射 $f$ 的定义域，记作 $D_{f} $ ，即 $D_{f} = X$ （<code>Domain</code>）； $X$ 中所有元素的像所组成的集合称为映射 $f$ 的值域，记作 $R_{f}$ 或 $f(x)$ （<code>Range</code>），即</p><script type="math/tex; mode=display">R_{f}  = f(X) = \left \{f(x)|x\in X \right \}</script><p> 注意：</p><ul><li>映射三要素：定义域、值域、对应法则。<ul><li>对于每个$x\in X$，元素 $x$ 的像 $y$ 是唯一的；而对于每个 $y\in R_{f} $  ，元素 $y$ 的原像不一定是唯一的；映射 $f$ 的值域 $ R_{f}$ 是 $Y$ 的一个子集。</li><li><strong>满射</strong>： $Y$ 中任一元素 $y$ 都是 $X$ 中某元素的像，即 $R_{f}=Y$ 。</li><li><strong>单射</strong>：对 $X$ 中任意的两个不同的元素 $x_{1},x_{2}$ ，它们的像 $f(x_{1})\ne f(x_{2})$ 。</li><li><strong>一一映射</strong>：既是单射，又是满射的映射</li></ul></li></ul></li><li><p>逆映射</p><p> 设 $f$ 是 $X$ 到 $Y$ 的单射，则由定义，对每个 $y\in R_{f} $ ，有唯一的 $x\in X$ ，适合 $f(x) =y$ 。于是，我们可以定义一个从 $R_{f} $ 到 $X$ 的新映射 $g$ ，即</p><script type="math/tex; mode=display">g :R_{f} \to X</script><p> 对每个 $y \in R_{f} $ ，规定 $g(y)=x$ ，这 $x$ 满足 $f(x) =y$ 。这个映射 $g$ 称为 $f$ 的<u>逆映射</u>，记作：$f^{-1} $ 。其定义域 ${\large D_{f^{-1} } =R_{f} }$ ，值域为 $\displaystyle R_{f^{-1} } =X$ 。</p><blockquote><p>只有单射才有逆映射。</p></blockquote></li><li><p>复合映射</p><p>（略）</p></li></ol><h2 id="1-1-2-函数"><a href="#1-1-2-函数" class="headerlink" title="1.1.2 函数"></a>1.1.2 函数</h2><ol><li><p>函数的概念</p><p> <strong>定义</strong>：设<strong>数集</strong> $D\subset R$ （<code>R</code>指的是实数集），则称映射 $ f:D\to R $ 定义在 $D$ 上的函数，通常</p><script type="math/tex; mode=display">y = f(x),x\in D</script><p> 其中 $x$ 称为自变量，$y$ 称为因变量，$D$ 称为定义域，记作 $ D_{f} $ ，即 $D_{f} = D$ 。</p><blockquote><p>函数两要素：值域和对应关系。</p></blockquote><hr><p> 函数的表示方法：表格法、图形法、解析式法。</p><p> 几种典型的函数：</p><ul><li><p>绝对值函数</p><script type="math/tex; mode=display">\displaystyle y = \left | x \right |  =\left\{\begin{matrix}  -x,& x<0\\x,  &x\ge 0\end{matrix}\right.</script></li><li><p>符号函数</p><script type="math/tex; mode=display">\displaystyle y = \text{sgn }  x =\left\{\begin{matrix}-1,  &x<0 \\0,  & x=0\\1,  &x>0\end{matrix}\right.</script></li><li><p>取整函数</p><script type="math/tex; mode=display">\displaystyle y = \left [ x \right ]</script></li><li><p>分段函数</p><p> 有时一个函数需要用到几个式子表示。这种自变量的不同变化范围中，对应法则用不同的式子来表示的函数，通常称为<strong>分段函数</strong>。</p></li></ul></li><li><p>函数的特性</p><ol><li><p><strong>有界性</strong></p><p> 设函数 $ f(x) $ 的定义域为 $D$ ，数集 $ X\subset D $ 。如果存在 $ K $ ，使得</p><script type="math/tex; mode=display">  f(x)\le K_{1}</script><p> 对任一 $x\in X$ 都成立，那么称函数 $ f(x) $ 在 $X$ 上有上界，而 $K$ 称为函数 $ f(x) $ 在 $X$ 上的<code>一个</code><strong>上界</strong>。同理：下界。</p><p> 存在正数 $M$ ，使得 $ \left | f(x) \right | \le M $ 对任一 $x\in X$ 都成立，那么成函数 $ f(x) $ 在 $X$ 上<font color='red'>有界</font>，反之，则无界。</p></li><li><p><strong>单调性</strong></p><p> 设 $f(x)$ 的定义域为 $D$ ，区间 $ I\subset D $ 。对区间任意两点 $ x_{1} $ 和 $ x_{2} $ 时，恒有 $ f(x_{1} )&lt; f(x_{2} ) $，那么称函数 $ f(x) $ 在区间 $I$ 上是单调增加的。对区间任意两点 $x_{1}$ 和 $ x_{2} $ 时，恒有$ f(x_{1} )&gt; f(x_{2} )$，那么称函数 $f(x) $ 在区间 $I$ 上是单调减少的。</p><p> 单调增加和单调减少函数统称为<font color='red'>单调函数</font>。</p></li><li><p><strong>奇偶性</strong></p><p> 设 $f(x) $ 的定义域 $D$ 关于原点对称。</p><ul><li><p>如果对任一 $x\in D$ ， $f(-x)=f(x)$ 恒成立，那么称 $f(x)$ 为<font color='red'>偶函数</font>。</p></li><li><p>如果对任一 $x\in D$ ， $f(-x)=-f(x)$ 恒成立，那么称 $f(x)$ 为<font color='red'>奇函数</font>。</p></li></ul></li><li><p><strong>周期性</strong></p><p> 设 $f(x)$ 的定义域 $D$ 。如果存在一个正数 $l$ ，使得对任一 $x\in D$ 有 $(x\pm l)\in D$ ，且 $f(x+l)=f(x)$ 恒成立那么称 $f(x)$ 为<font color='red'>周期函数</font>，$l$ 称为函数 $f(x)$ 的周期（最小正周期）。</p><blockquote><p><strong>并非每个周期函数都有最小周期</strong></p></blockquote></li></ol></li></ol><h2 id="1-1-3-反函数与复合函数"><a href="#1-1-3-反函数与复合函数" class="headerlink" title="1.1.3 反函数与复合函数"></a>1.1.3 反函数与复合函数</h2><p>作为逆映射的特例，我们有以下反函数的概念：</p><p>设函数： $f:D\to f(D)$ 是单射，则它存在逆映射 $f^{-1} :f(D)\to D $ ，称此映射 $f^{-1} $ 为函数 $f$ 的<font color='red'>反函数</font>。按此定义，对每个 $y\in f(D)$ ，有唯一的 $x\in D$ ，使得 $f(x)=y$ ，于是有</p><script type="math/tex; mode=display">f^{-1} (y)=x</script><p>这就是说，反函数 $f^{-1}$ 对应的法则是完全由函数 $f$ 的对应法则所确定的。</p><hr><p>复合函数是复合映射的一种特例，按照通常函数的记号，复合函数的概念可如下表述：</p><p>设函数 $y = f(u)$ 的定义域为 $D_{f} $ ，函数 $u = g(x)$ 的定义域为 $D_{g}$ ，且其值域 $R\subseteq D_{f} $ ，则由下式确定的函数</p><script type="math/tex; mode=display">y = f[g(x)],\quad x\in D_{g}</script><p>称为由函数 <script type="math/tex">u = g(x)</script> 与函数 <script type="math/tex">y = f(u)</script> 构成的<font color='red'><strong>复合函数</strong></font>，它的定义域为 <script type="math/tex">D_{g}</script> ，变量 <script type="math/tex">u</script> 称为中间变量。</p><h2 id="1-1-4-函数的运算"><a href="#1-1-4-函数的运算" class="headerlink" title="1.1.4 函数的运算"></a>1.1.4 函数的运算</h2><ol><li><p>和差 $\displaystyle f\pm g$：</p><script type="math/tex; mode=display">\displaystyle(f\pm g)(x)=f(x)\pm g(x),x\subseteq D</script></li><li><p>积 $\displaystyle f\ast g$ ：</p><script type="math/tex; mode=display">\displaystyle(f\ast  g)(x)=f(x)\ast g(x),x\subseteq D</script></li><li><p>商 $\displaystyle \frac{f}{g} $ ：</p><script type="math/tex; mode=display">\displaystyle (\frac{f}{g} )(x) = \frac{f(x)}{g(x)}</script></li></ol><h2 id="1-1-5-初等函数"><a href="#1-1-5-初等函数" class="headerlink" title="1.1.5 初等函数"></a>1.1.5 初等函数</h2><p><font color='red'>基本初等函数</font>：</p><ul><li><p><strong>幂函数</strong>：</p><script type="math/tex; mode=display">\displaystyle y = x^{u} (u\subseteq \text{R是常数} )</script></li><li><p><strong>指数函数</strong>：</p><script type="math/tex; mode=display">\displaystyle y = a^{x} (a>0且a\ne 1)</script></li><li><p><strong>对数函数</strong>：</p><script type="math/tex; mode=display">\displaystyle y = log_{a} x (a>0\text{且} a\ne 1,\text{特别当}a=e\text{时，记为}y=lnx)</script></li><li><p><strong>三角函数</strong>：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\displaystyle y = \sin x,y=\cos x,y=\tan x \\\displaystyle y=\sec x,y=\csc x,y=\cot x\end{matrix}\right.</script></li><li><p><strong>反三角函数</strong>：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\displaystyle y = \arcsin  x,y=\arccos  x,y=\arctan  x \\\displaystyle y=\operatorname{arcsec}  x,y=\operatorname{arccos}  x,y=\operatorname{arccot} s  x\end{matrix}\right.</script></li></ul><p><font color='red'>初等函数</font>：由<code>常数</code>和<code>基本初等函数</code><strong>经过有限次的四则运算和有限次的函数复合步骤</strong>并构成一个式子表示的函数</p><hr><p><em>扩展</em>：</p><ul><li><p>双曲正弦：</p><script type="math/tex; mode=display">\displaystyle \sinh a = \frac{e^{x} - e^{-x}}{2}</script></li><li><p>双曲余弦：</p><script type="math/tex; mode=display">\displaystyle \cosh  a = \frac{e^{x} + e^{-x}}{2}</script></li><li><p>双曲正切：</p><script type="math/tex; mode=display">\displaystyle \tanh  = \frac{\sinh x}{\cosh x} = \frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}</script></li><li><p>反双曲正弦：</p></li><li><p>反双曲余弦：</p></li><li><p>反双曲正切：</p></li></ul><h1 id="1-2-数列的极限"><a href="#1-2-数列的极限" class="headerlink" title="1.2 数列的极限"></a>1.2 数列的极限</h1><p>极限概念是在探求某些实际问题的精确解答过程中产生的。</p><p><strong>数列的概念</strong>：如果按照某一法则，对每个 $n\subseteq N_{+}$ 对应着一个确定的实数 $x_{n}$ ，这些实数 $x_{n}$ 按照下标 $n$ 从小到大排列得到的一个序列，就叫做<strong>数列</strong>，简记为数列 $\begin{Bmatrix}x_{n}\end{Bmatrix}$ 。数列中每一个数叫做数列的<strong>项</strong>，第 $n$ 项 $x_{n}$ 叫做数列的<strong>一般项（或通项）</strong> 。</p><h2 id="1-2-1-数列极限的定义"><a href="#1-2-1-数列极限的定义" class="headerlink" title="1.2.1 数列极限的定义"></a>1.2.1 数列极限的定义</h2><p><strong>定义</strong>：设 $\displaystyle \begin{Bmatrix} x_{n} \end{Bmatrix}$ 为一数列，如果存在常数 $a$ ，对任意给定的正数 $\varepsilon$ （不论它多么小），总参在正整数 $N$ ，使得当 $n&gt;N$ 时，不等式</p><script type="math/tex; mode=display">\displaystyle \left | x_{n}-a \right | <\varepsilon</script><p>都成立，那么就称常数 $a$ 是数列 <script type="math/tex">\begin{Bmatrix}x_{n}\end{Bmatrix}</script> 的极限，或者称数列 $\begin{Bmatrix}x_{n}\end{Bmatrix}$ 收敛于 $a$ ，记作 $\displaystyle \lim_{n \to \infty} x_n=a$ ，或者 $\displaystyle x_{n}\to a(n\to \infty )$ 。</p><h2 id="1-2-2-收敛数列的性质"><a href="#1-2-2-收敛数列的性质" class="headerlink" title="1.2.2 收敛数列的性质"></a>1.2.2 收敛数列的性质</h2><p><strong>定理一</strong>（极限的<font color='red'>唯一性</font>）：如果数列 $\begin{Bmatrix}x_{n}\end{Bmatrix}$ 收敛，那么它的极限唯一。</p><ul><li>证明：（反证法）</li></ul><p><strong>定理二</strong>（收敛数列的<font color='red'>有界性</font>）： 如果数列 $\begin{Bmatrix}x_{n}\end{Bmatrix}$ 收敛，那么数列 $\begin{Bmatrix}x_{n}\end{Bmatrix}$ 一定有界。</p><p><strong>定理三</strong>（收敛数列的<font color='red'>保号性</font>）：如果 $\displaystyle \lim_{n \to \infty}  = a,\text{且} a&gt; 0(\text{或} a&lt; 0)$，那么存在正整数 $N$ ，当 $n&gt;N$ 时，都有 $x_{n}&gt;0$ 或（$x_{n}&lt;0$ ）。</p><ul><li><p>证明：</p><p> 就 $a&gt;0$ 而言。由数列极限的定义可得，取 $\displaystyle\varepsilon =\frac{a}{2}&gt;0 $ ， 存在正整数 $N$ ，当 $n&gt;N$ 时，有</p><script type="math/tex; mode=display">\displaystyle \left | x_{n}-a  \right | < \frac{a}{2}</script><p> 从而有</p><script type="math/tex; mode=display">\displaystyle x_{n} > a-\frac{a}{2}  = \frac{a}{2} > 0</script></li><li><p><strong>推论</strong>：</p><p> 如果数列 $\left\{ x_{n}\right\}$ 从某项起有 $x_{n}\ge 0(\text{或者}x_{n} \le 0)$ ，且 $\displaystyle \lim_{n \to \infty} x_{n} =a$ ，那么 $a\ge 0(\text{或者}a\le 0)$ 。</p></li></ul><p><strong>定理四</strong>（收敛数列与其<font color='red'>子数列</font>的关系）：如果数列 <script type="math/tex">\displaystyle \left \{ x_{n}  \right \}</script> 收敛于 <script type="math/tex">\displaystyle a</script>，那么它的任一子数列也收敛，且极限也是 <script type="math/tex">\displaystyle a</script> 。</p><h1 id="1-3-函数的极限"><a href="#1-3-函数的极限" class="headerlink" title="1.3 函数的极限"></a>1.3 函数的极限</h1><h2 id="1-3-1-函数极限的定义"><a href="#1-3-1-函数极限的定义" class="headerlink" title="1.3.1 函数极限的定义"></a>1.3.1 函数极限的定义</h2><p>自变量趋于有限值时函数的极限：</p><p><strong>定义 1</strong>：设函数 $\displaystyle f(x)$ 在点 $\displaystyle x_{0} $ 的某一<font color='red'>去心邻域</font>内有定义。如果存在常数 $\displaystyle A$ ，对任意给定的正数 $\varepsilon $ (不论它多么小)，总存在正数 $\delta$ ，使得当 $x$ 满足不等式 $0&lt;\left | x-x_{0}  \right | &lt;\delta $ 时，对应的函数值  $\displaystyle f(x)$ 都满足不等式</p><script type="math/tex; mode=display">\displaystyle \left | f(x)-A \right | <\varepsilon</script><p>那么常数 $\displaystyle A$ 就叫做函数 $f(x)$ 当 $x→x_{0}$ 时的极限，记作</p><script type="math/tex; mode=display">\displaystyle \lim_{x \to x_{0}} f(x)=A\quad \text{或} f(x)→A(\text{当} x→x_{0})</script><blockquote><p>注意：函数不一定在 $\displaystyle x_{0} $ 处有定义</p><p><strong>补充去心邻域</strong>：以 $x_{0}$ 为中心的任何<strong>开区间</strong>称为 $x_{0}$ 的邻域，记作 $U(x_{0})$ ；在 $U(x_{0})$ 中去掉中心 $x_{0}$ 后，称为 $x_{0}$ 的去心邻域，记作 $\overset{\circ}{U}(x_{0})$ 。</p></blockquote><hr><div align="center">----------👑👑相当重要👑👑----------</div><ul><li><p>左极限</p><p> 在 $\displaystyle \lim_{x\to x_{0}}f(x)=A$ 定义中，把 $0&lt; \left | x-x_{0}\right | &lt; \delta $ 改为 $x_{0}-\delta<x<x_{0}$ ，那么 $A$ 就叫做函数 $f(x)$ 当 $x→x_{0}$ 时的<font color='red'>左极限&lt;/font&gt;，记作</p><script type="math/tex; mode=display">\displaystyle \lim_{x \to x_{0}^{-} } f(x)=A\quad \text{或} f(x_{0}^{-})=A</script></li><li><p>右极限</p><p> 类似的，在 $\displa\lim_{x\to x_{0}}f(x)=A$ 定义中，把 $0&lt; \left | x-x_{0}  \right | &lt; \delta $ 改为 $x_{0} &lt; x&lt; x_{0}+\delta$ ，那么 $A$ 就叫做函数 $f(x)$ 当 $x→x_{0}$ 时的<font color='red'>右极限</font>，记作</p><script type="math/tex; mode=display">\displaystyle \lim_{x \to x_{0}^{+} } f(x)=A\quad \text{或} f(x_{0}^{+})=A</script></li></ul><p><strong>左极限与右极限统称为<font color='red'>单侧极限</font></strong>。</p><blockquote><p><strong>极限存在的充要条件是：左右极限存在且相等</strong></p></blockquote><hr><p>自变量趋于无穷大时函数的极限：</p><p><strong>定义 2</strong>：设函数 $f(x)$ 当 $\left | x \right | $ 大于某一正数时有定义。如果存在常数 $A$，对于任意给定的正数 $\varepsilon$ （不论它有多么小），总存在着正数 $X$ ，使得当 $x$ 满足不等式 $\left | x \right | &gt;X$ 时，对应的函数值 $f(x)$ 都满足不等式</p><script type="math/tex; mode=display">\displaystyle \left | f(x)-A \right |<\varepsilon</script><p>那么常数 $A$ 就叫做函数 $f(x)$ 当 $x\longrightarrow \infty $ 时的极限，记作</p><script type="math/tex; mode=display">\displaystyle \lim_{x \to \infty} f(x) = A或f(x)\to A(当x \to \infty)</script><h2 id="1-3-2-函数极限的性质"><a href="#1-3-2-函数极限的性质" class="headerlink" title="1.3.2 函数极限的性质"></a>1.3.2 函数极限的性质</h2><p><strong>定理 1</strong> （函数极限的<font color='red'>唯一性</font>）：如果 $\displaystyle \lim_{x \to \infty} f(x)$ 存在，那么这个极限唯一。</p><p><strong>定理 2</strong>（函数极限的<font color='red'>局部有界性</font>）：如果 $\displaystyle \lim_{x \to \infty} f(x) = A$ 那么存在常数 $M&gt;0$ 和 $\delta&gt;0$ ，使得当 $0&lt;\left | x-x_{0} \right |&lt;\delta  $ 时，有 $\displaystyle \left | f(x) \right | \le M$ 。</p><p><strong>定理 3</strong>（函数极限的<font color='red'>局部保号性</font>） 如果 $\displaystyle \lim_{x \to \infty} f(x)=A$ ，且 $A&gt;0(\text{或}A<0)$ ，那么存在常数 $\displaystyle M>0\text{或} \delta &gt;0$ ，使得当 $0&lt;\left | x-x_{0} \right |&lt;\delta  $ 时，有 $\displaystyle f(X)&gt;0\quad(\text{或}f(X)&lt;0)$ 。</p><p><strong>定理 4</strong>（函数极限与数列极限的关系）：如果极限 $\displaystyle \lim_{x \to x_{0}}f(x) $ 存在，$\left \{ x_{n} \right \} $ 是 $f(x)$ 定义域内任一收敛于 $x_{0}$ 的数列，并且满足：$\displaystyle x_{n}\ne x_{0} (n\in N)$ ，那么相应的函数值数列 $\displaystyle \left \{ f(x_{n}) \right \} $ 必收敛，且 $\displaystyle \lim_{n \to \infty} f(x_{n}) = \lim_{x \to x_{0}}f(x) $ 。</p><h2 id="1-3-2-函数极限的性质-1"><a href="#1-3-2-函数极限的性质-1" class="headerlink" title="1.3.2 函数极限的性质"></a>1.3.2 函数极限的性质</h2><p><strong>定理 1</strong> （函数极限的<font color='red'>唯一性</font>）：如果 $\displaystyle \lim_{x \to \infty} f(x)$ 存在，那么这个极限唯一。</p><p><strong>定理 2</strong>（函数极限的<font color='red'>局部有界性</font>）：如果 $\displaystyle \lim_{x \to \infty} f(x) = A$ 那么存在常数 $M&gt;0$ 和 $\delta&gt;0$ ，使得当 $0&lt;\left | x-x_{0} \right |&lt;\delta  $ 时，有 $\displaystyle \left | f(x) \right | \le M$ 。</p><p><strong>定理 3</strong>（函数极限的<font color='red'>局部保号性</font>） 如果 $\displaystyle \lim_{x \to \infty} f(x)=A$ ，且 $A&gt;0(\text{或}A<0)$ ，那么存在常数 $\displaystyle M>0\text{或} \delta &gt;0$ ，使得当 $0&lt;\left | x-x_{0} \right |&lt;\delta  $ 时，有 $\displaystyle f(X)&gt;0\quad(\text{或}f(X)&lt;0)$ 。</p><p><strong>定理 4</strong>（函数极限与数列极限的关系）：如果极限 $\displaystyle \lim_{x \to x_{0}}f(x) $ 存在，$\left \{ x_{n} \right \} $ 是 $f(x)$ 定义域内任一收敛于 $x_{0}$ 的数列，并且满足：$\displaystyle x_{n}\ne x_{0} (n\in N)$ ，那么相应的函数值数列 $\displaystyle \left \{ f(x_{n}) \right \} $ 必收敛，且 $\displaystyle {\large \lim_{n \to \infty} f(x_{n}) = \lim_{x \to x_{0}}f(x)} $ 。</p><h1 id="1-4-无穷小与无穷大"><a href="#1-4-无穷小与无穷大" class="headerlink" title="1.4 无穷小与无穷大"></a>1.4 无穷小与无穷大</h1><h2 id="1-4-1-无穷小"><a href="#1-4-1-无穷小" class="headerlink" title="1.4.1 无穷小"></a>1.4.1 无穷小</h2><p><strong>定义 1</strong>：如果函数 $f(x)$ 当 $x\to x_{0}$ 或（$x\to \infty $）时极限为零，那么成函数 $f(x)$ 为当 $x\to x_{0}$ 或（$x\to \infty $）时的无穷小。</p><blockquote><p>特别地，以零为极限的数列 $\left \{x_{n}\right \}$ 称为 $n\to\infty $ 时的无穷小。</p></blockquote><p><strong>定理 1</strong> ：在自变量的统一变化过程 $x\to x_{0}$ 或（$x\to \infty $）中，函数 $f(x)$ 具有极限 $A$ 的充要条件时 $f(x) = A + \alpha $ ，其中 $\alpha $ 时无穷小。</p><h2 id="1-4-2-无穷大"><a href="#1-4-2-无穷大" class="headerlink" title="1.4.2 无穷大"></a>1.4.2 无穷大</h2><p><strong>定义 2</strong>：设函数 $f(x)$ 在 $x_{0}$ 的某一去心邻域内有定义。如果对于任意给定的正数 $M$ （不论它多么大），总存在正数 $\delta$ ，只要 $x$ 适合不等式 $0&lt;\left | x-x_{0} \right | &lt;\delta $ ，对应的函数值 $f(x)$ 总满足不等式</p><script type="math/tex; mode=display">\left | f(x) \right | >M</script><p>那么称函数 $f(x)$ 是当 $x\to x_{0}$ 或（$x\to \infty $）时的无穷大。</p><blockquote><p><strong>必须要注意：无穷大不是数，不可与很大的数（如：1 千万、一亿、一亿亿等）混为一谈</strong>。</p><p>无穷大分为：正无穷和负无穷。</p></blockquote><p><strong>定理 2</strong> ：在自变量的统一变化过程中，如果 $f(x)$ 为无穷大，那么 $\displaystyle\frac{1}{f(x)} $ 为无穷小，反之，如果 $f(x)$ 为无穷小，且 $f(x)\neq 0$ ，那么 $\displaystyle\frac{1}{f(x)} $ 为无穷大。</p><h1 id="1-5-极限的运算法则"><a href="#1-5-极限的运算法则" class="headerlink" title="1.5 极限的运算法则"></a>1.5 极限的运算法则</h1><p><strong>定理 1</strong>：两个无穷小的和是无穷小。（<strong>有限个</strong>无穷小之和也是无穷小）。</p><p><strong>定理 2</strong>：<strong>有界函数与无穷小的乘积是无穷小</strong>。（<strong>极其重要</strong>）</p><ul><li><p><strong>推论 1</strong>：</p><p> 常数与无穷小的乘积是无穷小。</p></li><li><p><strong>推论 2</strong>：</p><p> 有限个无穷小的乘积是无穷小。</p></li></ul><p><strong>定理 3</strong> 如果 $\lim  f(x) = A，\lim  g(x) =B，$ ，那么</p><ol><li><p>$\displaystyle\lim [f(x)\pm g(x)] = \lim f(x)\pm \lim g(x) = A\pm B$ ；</p></li><li><p>$\displaystyle \lim [f(x)\cdot   g(x)] = \lim f(x)\cdot \lim g(x) = A\cdot B$；</p></li><li><p>$B \neq 0$ 时；</p><script type="math/tex; mode=display">\displaystyle \lim  \frac{f(x)}{g(x)} = \frac{\lim  f(x)}{\lim g(x)} = \frac{A}{B}</script><ul><li><strong>推论 1</strong>：如果 $\lim  f(x)$ 存在，而 $c$ 为常数，那么</li></ul><script type="math/tex; mode=display">\lim  cf(x) = c\lim f(x)</script><ul><li><strong>推论 2</strong>：如果 $\lim  f(x)$ 存在，而 $n$ 为正整数，那么</li></ul><script type="math/tex; mode=display">\displaystyle \lim  [f(x)]^{n}  = [\lim f(x)]^{n}</script></li></ol><p><strong>定理 4</strong> ：设有数列 $\left \{ x_{n} \right \}\text{和} \left \{ y_{n} \right \}$ 。如果 $\displaystyle \lim_{n \to \infty} x_{n} = A$ ， $\displaystyle \lim_{n \to \infty} y_{n} = B$ ，那么</p><ol><li>$\displaystyle {\large \lim_{n \to \infty} (x_{n}\pm y_{n}) = A\pm B} $ ；</li><li>$\displaystyle {\large \lim_{n \to \infty} (x_{n}\cdot y_{n}) = A\cdot B} $ ；</li><li>当 $y_{n}\neq 0(n = 1,2,\cdot \cdot \cdot )$ 且 $B\neq 0 $ 时，$\displaystyle {\large \lim_{n \to \infty} \frac{x-{n}}{y_{n}} =\frac{A}{B}} $；</li></ol><p><strong>定理 5</strong>：如果 $\varphi (x)\ge \psi (x)$ ， 而 $\lim \varphi(x)=A$ 且 $\lim\psi(x)=B$ ，那么 $A\ge B$ 。</p><p><strong>定理 6</strong> （复合函数的极限运算法则）：设函数 $y=f[g(x)]$ 是由函数 $u=g(x)$ 与函数 $y=f(u)$ 复合而成， $f[g(x)]$ 在点 $x_{0}$ 的某去心邻域内有定义，若 $\displaystyle \lim_{x\to x_{0}}g(x)=u_{0}$ ，$\displaystyle\lim_{u\to u_{0}}f(u)=A$ ，且存在 $\delta_{0}&gt;0$ ，当 $x\in \overset{\circ }{U}  (x_{0} ,\delta _{0} )$ 时，有 $g(x)\ne u_{0} $ ，则</p><script type="math/tex; mode=display">\displaystyle \lim_{x \to x_{0} } f[g(x)] = \lim_{u \to u_{0} } f(u) = A</script><h1 id="1-6-极限存在准则-两个重要极限"><a href="#1-6-极限存在准则-两个重要极限" class="headerlink" title="1.6 极限存在准则 两个重要极限"></a>1.6 极限存在准则 两个重要极限</h1><p><strong>准则 1</strong>：如果数列 $\left \{ x_{n} \right \} $ 、$\left \{ y_{n} \right \} $ 及 $\left \{ z_{n} \right \}$ 满足下列条件：</p><ol><li><p>从某项起，即 $\exists n_{0}\in N$ ，当 $n&gt;n_{0}$ 时，有</p><script type="math/tex; mode=display">y_{n}\le x_{n}\le z_{n}</script></li><li><p>$\displaystyle {\large \lim_{n \to \infty}y_{n} = a, \lim_{n \to \infty} z_{n} = a} $ </p></li></ol><p>那么数列 $\left \{ x_{n} \right \} $ 的极限存在，且 $\displaystyle \lim_{n \to \infty} x_{n} = a$ 。</p><p><strong>准则 1-1</strong>：如果</p><ol><li>$\displaystyle{\large\text{当} x\in \overset{\circ}{U}(x_{0},r)(\text{或}\left | x \right |&gt; M )\text{时},g(x)\le f(x)\le h(x)} $ </li><li>$\displaystyle {\large \lim_{x \to x_{0} (\text{或} x \to\infty )} g(x)=A,\quad \lim_{x \to x_{0} (\text{或} x \to\infty )} h(x)=A} $ </li></ol><p>那么：$\displaystyle {\large \lim_{x \to x_{0} (\text{或} x \to\infty )} f(x)} $ 存在，且等于 $A$ 。</p><p><strong>准则 Ⅰ 和准则 Ⅰ-1 称为<font color='red'>夹逼准则</font></strong>。</p><hr><p><strong>准则 2</strong>：<strong>单调有界数列必有极限</strong>。</p><p><strong>准则 2-1</strong> 设 $f(x)$ 在点 $x_{0}$ 的某个左邻域内单调且有界，则 $f(x)$ 在 $x_{0}$ 的左极限 $f(x^{-}_{0})$ 必定存在。</p><p><strong><font color='red'>柯西极限存在准则</font></strong>：数列 $\left \{ x_{n} \right \}$ 收敛的充要条件是：对于任意给定的正数 $\varepsilon$ ，存在正整数 $N$ ，使得当 $m&gt;N,n&gt;N$ 时，有</p><script type="math/tex; mode=display">\left | x_{n}-x_{m} \right | <\varepsilon</script><hr><p><strong>常用的极限</strong>：</p><ol><li><p>第一个：</p><script type="math/tex; mode=display"> \lim_{x \to \infty} (1+\frac{1}{x} )^{x} =e</script></li><li><p>第二个：</p><script type="math/tex; mode=display"> \lim_{x \to \infty} (1-\frac{1}{x} )^{x} =e^{-1}</script></li></ol><h1 id="1-7-无穷小的比较"><a href="#1-7-无穷小的比较" class="headerlink" title="1.7 无穷小的比较"></a>1.7 无穷小的比较</h1><p><strong>定义</strong></p><ul><li>如果 $\displaystyle\lim\frac{\beta}{\alpha}=0$ ，那么就说 $\beta$ 是 $\alpha$ 的高阶无穷小，记作 $\beta =O(\beta )$ 。</li><li>如果 $\displaystyle\lim\frac{\beta}{\alpha}=\infty$ ，那么就说 $\beta$ 是 $\alpha$ 的低阶无穷小。</li><li>如果 $\displaystyle\lim\frac{\beta}{\alpha}=c\quad(c\in R\text{且}c\ne0)$ ，那么就说 $\beta$ 是 $\alpha$ 的同阶无穷小。</li><li>如果 $\displaystyle\lim\frac{\beta}{\alpha^{k} }=c\quad(c\in R\text{且}c\ne0\text{且}k&gt;0)$ ，那么就说 $\beta$ 是 $\alpha$ 的 $k$ 阶无穷小。</li><li>如果 $\displaystyle\lim\frac{\beta}{\alpha}=1$ ，那么就说 $\beta$ 是 $\alpha$ 的等价无穷小，记作 $\alpha \sim \beta$ 。</li></ul><p><strong>定理 1</strong>： $\beta$ 是 $\alpha$ 的等价无穷小的<strong>充要条件</strong>是</p><script type="math/tex; mode=display">\beta =\alpha +o(\alpha )</script><p><strong>定理 2</strong>：设 $\alpha \sim \widetilde{\alpha }$ 且 $\beta \sim \widetilde{\beta }$ ，并且 $\displaystyle \lim  \frac{\widetilde{\beta } }{\widetilde{\alpha } }$ 存在，则</p><script type="math/tex; mode=display">\displaystyle\lim\frac{\beta}{\alpha}=\lim\frac{\widetilde{\beta}}{\widetilde{\alpha}}</script><blockquote><p>使用<strong>定理 2</strong>时需要注意，必须满足分子、分母同时为无穷小，才能进行替换；分子或者分母是若干因子的乘积，可对其中的一个或几个银子进行替换。</p></blockquote><h1 id="1-8-函数的连续性和间断点"><a href="#1-8-函数的连续性和间断点" class="headerlink" title="1.8 函数的连续性和间断点"></a>1.8 函数的连续性和间断点</h1><h2 id="1-8-1-函数的连续性"><a href="#1-8-1-函数的连续性" class="headerlink" title="1.8.1 函数的连续性"></a>1.8.1 函数的连续性</h2><p><strong>定义</strong>：设函数 $f(x)$ 在点 $x_{0}$ 的某一邻域内有定义，如果</p><script type="math/tex; mode=display">\displaystyle \lim_{\Delta x \to 0} \Delta y = \lim_{\Delta x \to 0}\left [ f(x_{0}+\Delta x)-f(x_{0}) \right ]  = 0</script><p>那么就称函数 $y=f(x)$ 在点 $x_{0}$ 连续。</p><p>设函数 $y = f(x)$ 在点 $x_{0}$ 的某一邻域内有定义，如果</p><script type="math/tex; mode=display">\lim_{x \to x_{0} } f(x)=f(x_{0} )</script><p>那么就称函数 $f(x)$ 在点 $x_{0}$ 处连续。</p><p>如果 $\displaystyle {\large \lim_{x \to x_{0}^{-}  }}  f(x) = f(x_{0}^{-} )$ 存在，且等于 $f(x_{0})$ ，即</p><script type="math/tex; mode=display">f(x_{0}^{-} )=f(x_{0})</script><p>那么就说函数 $f(x)$ 在点 $x_{0}$ <strong>左连续</strong>。如果 $\displaystyle {\large \lim_{x\to x_{0}^{+}}}f(x)=f(x_{0}^{+})$ 存在，且等于 $f(x_{0})$ ，即</p><script type="math/tex; mode=display">f(x_{0}^{+} )=f(x_{0})</script><p>那么就说函数 $f(x)$ 在点 $x_{0}$ <strong>右连续</strong>。</p><h2 id="1-8-2-函数的间断点"><a href="#1-8-2-函数的间断点" class="headerlink" title="1.8.2 函数的间断点"></a>1.8.2 函数的间断点</h2><p>设函数 $f(x)$ 在点 $x_{0}$ 的某去心邻域内有定义。在此前提下，如果函数 <script type="math/tex">\displaystyle f(x)</script> ：</p><ol><li>在 $x=x_{0}$ 没有定义；</li><li>在 $x=\overset{\circ}{U}(x_{0})$ 有定义，但是 $\displaystyle \lim_{x\to x_{0}}f(x)$ 不存在；</li><li>在 $x=x_{0}$ 有定义，且 $\displaystyle \lim_{x \to x_{0}}f(x) $ 存在，但是 $\displaystyle  \lim_{x \to x_{0}}f(x) \ne f(x_{0})$；</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">图像</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">无穷间断点</td><td style="text-align:center"><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E6%97%A0%E7%A9%B7%E9%97%B4%E6%96%AD%E7%82%B9.png" alt="无穷间断点" style="zoom:10%" /></td><td style="text-align:center">$\displaystyle \tan x(x\rightarrow \frac{\pi }{2} )$</td></tr><tr><td style="text-align:center">震荡间断点</td><td style="text-align:center"><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E9%9C%87%E8%8D%A1%E9%97%B4%E6%96%AD%E7%82%B9.png" alt="震荡间断点" style="zoom:20%" /></td><td style="text-align:center">$\displaystyle \sin \frac{1}{x} ,x\longrightarrow 0$</td></tr><tr><td style="text-align:center">可去间断点</td><td style="text-align:center"><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E5%8F%AF%E5%8E%BB%E9%97%B4%E6%96%AD%E7%82%B9.png" alt="可去间断点" style="zoom:20%" /></td><td style="text-align:center">$\displaystyle y = f(x) = \left\{\begin{matrix}x,  &amp; x\ne 1\\\frac{1}{2}   &amp;x = 1\end{matrix}\right.$</td></tr><tr><td style="text-align:center">跳跃间断点</td><td style="text-align:center"><img src="https://imageshack.yuilexi.cn/University/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E5%90%8C%E6%B5%8E%E7%AC%AC%E4%B8%83%E7%89%88/%E8%B7%B3%E8%B7%83%E9%97%B4%E6%96%AD%E7%82%B9.png" alt="跳跃间断点" style="zoom:20%" /></td><td style="text-align:center">$\displaystyle f(x) = \left\{\begin{matrix}x-1,  &amp; x<0\\0,  & x = 0\\x+1,  &x>0\end{matrix}\right.$</td></tr></tbody></table></div><p><strong>间断点的分类</strong>：</p><ul><li><strong>第一类间断点</strong>：左右极限存在的间断点。</li><li><strong>第二类间断点</strong>：不是第一类间断点的任何间断点</li></ul><h1 id="1-9-连续函数的运算与初等函数的连续性"><a href="#1-9-连续函数的运算与初等函数的连续性" class="headerlink" title="1.9 连续函数的运算与初等函数的连续性"></a>1.9 连续函数的运算与初等函数的连续性</h1><h2 id="1-9-1-连续函数的和、差、积、商的连续性"><a href="#1-9-1-连续函数的和、差、积、商的连续性" class="headerlink" title="1.9.1 连续函数的和、差、积、商的连续性"></a>1.9.1 连续函数的和、差、积、商的连续性</h2><p><strong>定理 1</strong>：设函数 $f(x)$ 和 $g(x)$ 在点 $x_{0}$ 处连续，则他们的和、差、积以及商（$g(x_{0})\ne 0$）都在点 $x_{0}$ 处连续。</p><h2 id="1-9-2-反函数与复合函数的连续性"><a href="#1-9-2-反函数与复合函数的连续性" class="headerlink" title="1.9.2 反函数与复合函数的连续性"></a>1.9.2 反函数与复合函数的连续性</h2><p><strong>定理 2</strong>：如果函数 $y=f(x)$ 在区间 $I_{x}$ 上单调增加（或单调减少）且连续，那么它的反函数 $x=f^{-1}(y)$ 也在对应的区间 $I_{y}=\left \{y|y=f(x),x\in I_{x}  \right \}$ 上单调增加（或单调减少）且连续。</p><p><strong>定理 3</strong>：设函数 $y=f[g(x)] $ 由函数 $u=g(x)$ 与函数 $y=f(u)$ 复合而成， $\overset{\circ}{U}(x_{0})\subseteq D_{f,g}$ 。若 $\displaystyle \lim_{x \to x_{0} } g(x)=u_{0}$ ，而函数 $y=f(u)$ 在 $u=u_{0}$ 连续，则</p><script type="math/tex; mode=display">\lim_{x \to x_{0} } f[g(x)] = \lim_{u \to u_{0} } f(u) = f(u_{0} )</script><p><strong>定理 4 </strong>：设函数 $y=f[g(x)] $ 是由函数 $u=g(x)$ 与函数 $y=f(u)$ 复合而成， $\overset{\circ}{U}(x_{0})\subseteq D_{f,g}$ 。 若函数 $u=g(x)$ 在 $x=x_{0}$ 连续，且 $g(x_{0})=u_{0}$ ，而函数 $y=f(u)$ 在 $u=u_{0}$ 连续，则复合函数 $y=f[g(x)]$ 在 $x=x_{0}$ 连续。</p><h2 id="1-9-3-初等函数的连续性"><a href="#1-9-3-初等函数的连续性" class="headerlink" title="1.9.3 初等函数的连续性"></a>1.9.3 初等函数的连续性</h2><p><strong>基本初等函数在它们的定义域内时连续的</strong>。<strong>一切初等函数在其定义区间内都是连续的</strong>。</p><h1 id="1-10-闭区间上连续函数的性质"><a href="#1-10-闭区间上连续函数的性质" class="headerlink" title="1.10 闭区间上连续函数的性质"></a>1.10 闭区间上连续函数的性质</h1><h2 id="1-10-1-有界性与最大值最小值定理"><a href="#1-10-1-有界性与最大值最小值定理" class="headerlink" title="1.10.1 有界性与最大值最小值定理"></a>1.10.1 有界性与最大值最小值定理</h2><p><strong>定理 1</strong> （<font color='red'>有界性</font>与<font color='red'>最大值最小值定理</font>）：在<strong>闭区间</strong>上<strong>连续函数</strong>在该区间上有界且一定能取得它的最大值和最小值。</p><h2 id="1-10-2-零点定理与介值定理"><a href="#1-10-2-零点定理与介值定理" class="headerlink" title="1.10.2 零点定理与介值定理"></a>1.10.2 零点定理与介值定理</h2><p><strong>定理 2</strong>（<font color='red'>零点定理</font>）：函数 $f(x)$ 在 $\left[ a ,b\right ]$ 上连续，$f(a)f(b)&lt;0$ ，那么在 $\left (a,b\right )$ 内至少存在一个零点（$f(\zeta )=0,(\zeta \in (a,b))$）。</p><p><strong>定理 3</strong>（<font color='red'>介值定理</font>）：设函数 $f(x)$ 在闭区间 $\left [ a,b \right ] $ 上连续且在端点取不同的函数值</p><script type="math/tex; mode=display">\displaystyle f(a) = A,f(b) = B</script><p>则对于 $A$ 与 $B$ 之间的任意一个数 $C$ ，在开区间 $\left ( a,b \right ) $ 内至少有一点 $\xi$ 使得</p><script type="math/tex; mode=display">\displaystyle f(\xi) = C(a<\xi<b)</script><ul><li><p><strong>推论</strong>：</p><p> 在闭区间 $\left [ a,b \right ]$ 上连续的函数 $f(x)$ 的值域为闭区间 $\displaystyle \left [ m,M \right ]$ ，其中 $m$ 与 $M$ 依次为 $f(x)$ 在 $\left [ a,b \right ]$ 上的最大值和最小值。</p></li></ul><h2 id="1-10-3-一致连续性"><a href="#1-10-3-一致连续性" class="headerlink" title="1.10.3 一致连续性"></a>1.10.3 一致连续性</h2><p><strong>定义</strong>：设函数 $f(x)$ 在区间 $I$ 上有定义。如果对于任意给定的正数 $\varepsilon$ ，总存在正数 $\delta$ ，使得对于区间 $I$ 上的任意两点 $x_{1} ,x_{2} $ ，当 $\left | x_{1}-x_{2} \right | &lt; \delta $ 时，有</p><script type="math/tex; mode=display">\displaystyle \left |f( x_{1})-f(x_{2})   \right | < \varepsilon</script><p>那么称函数 $f(x)$ 在区间 $I$ 上<font color='red'><strong>一致连续</strong></font>。</p><p>一致连续性表示，不论在区间 $I$ 的任何部分，只要自变量的两个数值接近到一定程度，就可以使对应函数值到达所指定的接近程度。</p><p><strong>定理 4</strong>（<strong><font color='red'>一致连续性定理</font></strong>）：如果函数在闭区间上连续，那么它在该区间上一致连续。</p><ul><li>所以，根据夹逼准则可得， ${f}’ (x_{0} )=0$ 。证毕。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学学习 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/02.C%E8%AF%AD%E8%A8%80/01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/02.C%E8%AF%AD%E8%A8%80/01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-认识-C-语言"><a href="#第一章-认识-C-语言" class="headerlink" title="第一章 认识 C 语言"></a>第一章 认识 C 语言</h1><p>C 语言是一种通用的、面向过程式的计算机程序设计语言。</p><h2 id="1-1-C-语言的历史"><a href="#1-1-C-语言的历史" class="headerlink" title="1.1 C 语言的历史"></a>1.1 C 语言的历史</h2><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p><p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p><p>UNIX 操作系统，C 编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p><ul><li>易于学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以处理底层的活动。</li><li>它可以在多种计算机平台上编译。</li></ul><h2 id="1-2-C-语言的作用"><a href="#1-2-C-语言的作用" class="headerlink" title="1.2 C 语言的作用"></a>1.2 C 语言的作用</h2><p>语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：</p><ul><li>操作系统</li><li>语言编译器</li><li>汇编器</li><li>文本编辑器</li><li>打印机</li><li>网络驱动器</li><li>现代程序</li><li>数据库</li><li>语言解释器</li><li>实体工具</li></ul><h2 id="1-3-环境设置"><a href="#1-3-环境设置" class="headerlink" title="1.3 环境设置"></a>1.3 环境设置</h2><p>如果您想要设置 C 语言环境，您需要确保电脑上有以下两款可用的软件：文本编辑器和 C 编译器。</p><h2 id="1-4-算法"><a href="#1-4-算法" class="headerlink" title="1.4 算法"></a>1.4 算法</h2><p>程序 = 数据结构 + 算法</p><h1 id="第二章-C-语言基础"><a href="#第二章-C-语言基础" class="headerlink" title="第二章 C 语言基础"></a>第二章 C 语言基础</h1><h2 id="2-1-C-语言程序结构"><a href="#2-1-C-语言程序结构" class="headerlink" title="2.1 C 语言程序结构"></a>2.1 C 语言程序结构</h2><p>一个完整的 C 语言代码文件，至少包含两部分：头文件和主函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello , world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头文件：里面定义了 C 语言常用的常量，以及一些函数</li><li>主函数：是 C 语言代码文件的入口，主程序所运行的源文件必须包含主函数</li></ul><p>例如，下面完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预处理命令，（1）导入头文件；（2）宏定义；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;XXX.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> datetype int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义函数区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h2><p>在代码中添加的标注行文字，从而帮助程序员更好的阅读代码。注释的内容将被编译器忽略，并不会在执行结果种体现出来。</p><p>在 C 语言中，主要有两种注释方式：单行注释和多行注释。</p><ol><li><p>单行注释</p><p>语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是注释君</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>多行注释</p><p>语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我是注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在限定符之间的所有内容均是注释。</p></li></ol><h2 id="2-3-头文件和宏定义"><a href="#2-3-头文件和宏定义" class="headerlink" title="2.3 头文件和宏定义"></a>2.3 头文件和宏定义</h2><h3 id="2-3-1-头文件"><a href="#2-3-1-头文件" class="headerlink" title="2.3.1 头文件"></a>2.3.1 头文件</h3><p>头文件是扩展名为 <strong>.h</strong> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p><p>在程序中要使用头文件，需要使用 C 预处理指令 <strong>#include</strong> 来引用它。前面我们已经看过 <strong>stdio.h</strong> 头文件，它是编译器自带的头文件。</p><p>引用头文件有两种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#including<span class="string">&lt;file&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file&quot;</span></span></span><br></pre></td></tr></table></figure><p>上述两种引用头文件的方式用法不同。</p><ul><li>使用 &lt;&gt; ：程序会从标准头文件目录中，搜索对应的头文件。因此，一般引用系统头文件，采用这种方式</li><li>使用引号：程序先从当前目录中，搜索对应的头文件。因此，自定义的头文件会采用这种方式。</li></ul><h3 id="2-3-2-宏定义"><a href="#2-3-2-宏定义" class="headerlink" title="2.3.2 宏定义"></a>2.3.2 宏定义</h3><p>宏定义又称为宏替换、宏代换，简称“宏”，是 C 提供的三种预处理功能的其中一种。其主要目的是为程序员在编程时提供一定的方便，并能在一定程度上提高程序的运行效率。</p><p> #define 命令是 C 语言中的一个宏定义命令，它用来讲一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。该命令有两种格式：一种是简单的宏定义（不带参数的宏定义），另一种是带参数的宏定义。</p><p> 基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;宏名/标识符&gt;</span> <span class="string">&lt;字符串&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;宏名&gt;</span>(<span class="string">&lt;参数表&gt;</span>) <span class="string">&lt;字符串&gt;</span></span></span><br></pre></td></tr></table></figure><p> 无参的宏定义：</p><ul><li>宏名一般用大写，宏定义末尾<strong>不加分号</strong></li><li>可以用 #undef 命令终止宏定义的作用域</li><li>宏定义可以嵌套，&lt;内容&gt;中永远不要包含宏</li><li>宏替换在编译前进行，不分配内存，变量定义分配内存，函数调用在编译后程序运行时进行，并且分配内存</li><li>预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查</li><li><p>使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义</p><p>有参的宏定义：</p></li><li><p>实参如果是表达式容易出问题</p></li><li>宏名和参数的括号间不能有空格</li><li>宏替换之作替换不做计算，不做表达式求解</li><li>宏的哑实结合不存在类型，也没有类型转换</li><li>宏展开不占用运行时间，只占用编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）</li></ul><h2 id="2-4-关键字和标识符"><a href="#2-4-关键字和标识符" class="headerlink" title="2.4 关键字和标识符"></a>2.4 关键字和标识符</h2><h3 id="2-4-1-关键字"><a href="#2-4-1-关键字" class="headerlink" title="2.4.1 关键字"></a>2.4.1 关键字</h3><p>关键字是 C 语言中已经被赋予特定含义的一些单词，开发程序时，不可以把这些保留字作为变量、函数、类、模块和其他对象的名称来使用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:left">说明</th><th style="text-align:center">关键字</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">auto</td><td style="text-align:left">声明自动变量</td><td style="text-align:center">int</td><td style="text-align:left">声明整型变量或函数</td></tr><tr><td style="text-align:center">break</td><td style="text-align:left">跳出当前循环</td><td style="text-align:center">long</td><td style="text-align:left">声明长整型变量或函数返回值类型</td></tr><tr><td style="text-align:center">case</td><td style="text-align:left">开关语句分支</td><td style="text-align:center">register</td><td style="text-align:left">声明寄存器变量</td></tr><tr><td style="text-align:center">char</td><td style="text-align:left">声明字符型变量或函数返回值类型</td><td style="text-align:center">return</td><td style="text-align:left">子程序返回语句（可以带参数，也可不带参数）</td></tr><tr><td style="text-align:center">const</td><td style="text-align:left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td><td style="text-align:center">short</td><td style="text-align:left">声明短整型变量或函数</td></tr><tr><td style="text-align:center">continue</td><td style="text-align:left">结束当前循环，开始下一轮循环</td><td style="text-align:center">signed</td><td style="text-align:left">声明有符号类型变量或函数</td></tr><tr><td style="text-align:center">default</td><td style="text-align:left">开关语句中的”其它”分支</td><td style="text-align:center">sizeof</td><td style="text-align:left">计算数据类型或变量长度（即所占字节数）</td></tr><tr><td style="text-align:center">do</td><td style="text-align:left">循环语句的循环体</td><td style="text-align:center">static</td><td style="text-align:left">声明静态变量</td></tr><tr><td style="text-align:center">double</td><td style="text-align:left">声明双精度浮点型变量或函数返回值类型</td><td style="text-align:center">struct</td><td style="text-align:left">声明结构体类型</td></tr><tr><td style="text-align:center">else</td><td style="text-align:left">条件语句否定分支（与 if 连用）</td><td style="text-align:center">switch</td><td style="text-align:left">用于开关语句</td></tr><tr><td style="text-align:center">enum</td><td style="text-align:left">声明枚举类型</td><td style="text-align:center">typedef</td><td style="text-align:left">用以给数据类型取别名</td></tr><tr><td style="text-align:center">extern</td><td style="text-align:left">声明变量或函数是在其它文件或本文件的其他位置定义</td><td style="text-align:center">unsigned</td><td style="text-align:left">声明无符号类型变量或函数</td></tr><tr><td style="text-align:center">float</td><td style="text-align:left">声明浮点型变量或函数返回值类型</td><td style="text-align:center">union</td><td style="text-align:left">声明共用体类型</td></tr><tr><td style="text-align:center">for</td><td style="text-align:left">一种循环语句</td><td style="text-align:center">void</td><td style="text-align:left">声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td style="text-align:center">goto</td><td style="text-align:left">无条件跳转语句</td><td style="text-align:center">volatile</td><td style="text-align:left">说明变量在程序执行中可被隐含地改变</td></tr><tr><td style="text-align:center">if</td><td style="text-align:left">条件语句</td><td style="text-align:center">while</td><td style="text-align:left">循环语句的循环条件</td></tr></tbody></table></div><p>C99 新增关键字：</p><div class="table-container"><table><thead><tr><th>_Bool</th><th>_Complex</th><th>_Imaginary</th><th>inline</th><th>restrict</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>C11 新增关键字：</p><div class="table-container"><table><thead><tr><th>_Alignas</th><th>_Alignof</th><th>_Atomic</th><th>_Generic</th><th>_Noreturn</th></tr></thead><tbody><tr><td>_Static_assert</td><td>_Thread_local</td><td></td><td></td></tr></tbody></table></div><h3 id="2-4-2-标识符"><a href="#2-4-2-标识符" class="headerlink" title="2.4.2 标识符"></a>2.4.2 标识符</h3><p>标识符：标识符简单理解为一个名字</p><p> C 语言的标识符命名规则如下：</p><ul><li>由字母、下划线和数字组成，并且不能以数字开</li><li>不能使用关键字</li></ul><h2 id="2-5-基础数据类型"><a href="#2-5-基础数据类型" class="headerlink" title="2.5 基础数据类型"></a>2.5 基础数据类型</h2><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p><p>C 中的类型可分为以下几种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">基本数据类型</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">枚举类型</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">void 类型</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">派生类型</td></tr></tbody></table></div><h3 id="2-5-1-整型"><a href="#2-5-1-整型" class="headerlink" title="2.5.1 整型"></a>2.5.1 整型</h3><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储大小</th><th style="text-align:center">值范围</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1 字节</td><td style="text-align:center">-128 到 127 或 0 到 255</td></tr><tr><td style="text-align:center">unsigned char</td><td style="text-align:center">1 字节</td><td style="text-align:center">0 到 255</td></tr><tr><td style="text-align:center">signed char</td><td style="text-align:center">1 字节</td><td style="text-align:center">-128 到 127</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">2 或 4 字节</td><td style="text-align:center">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td style="text-align:center">unsigned int</td><td style="text-align:center">2 或 4 字节</td><td style="text-align:center">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2 字节</td><td style="text-align:center">-32,768 到 32,767</td></tr><tr><td style="text-align:center">unsigned short</td><td style="text-align:center">2 字节</td><td style="text-align:center">0 到 65,535</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4 字节</td><td style="text-align:center">-2,147,483,648 到 2,147,483,647</td></tr><tr><td style="text-align:center">unsigned long</td><td style="text-align:center">4 字节</td><td style="text-align:center">0 到 4,294,967,295</td></tr></tbody></table></div><blockquote><p>注意：各种类型的存储大小与系统位数有关，但目前通用的以 64 位系统为主。</p></blockquote><p>为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 <strong>sizeof</strong> 运算符。语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-2-浮点型"><a href="#2-5-2-浮点型" class="headerlink" title="2.5.2 浮点型"></a>2.5.2 浮点型</h3><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储大小</th><th style="text-align:center">值范围</th><th style="text-align:center">精度</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4 字节</td><td style="text-align:center">1.2E-38 到 3.4E+38</td><td style="text-align:center">6 位有效位</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8 字节</td><td style="text-align:center">2.3E-308 到 1.7E+308</td><td style="text-align:center">15 位有效位</td></tr><tr><td style="text-align:center">long double</td><td style="text-align:center">16 字节</td><td style="text-align:center">3.4E-4932 到 1.1E+4932</td><td style="text-align:center">19 位有效位</td></tr></tbody></table></div><h3 id="2-5-3-类型转换"><a href="#2-5-3-类型转换" class="headerlink" title="2.5.3 类型转换"></a>2.5.3 类型转换</h3><p>类型转换是将一个数据类型的值转换为另一种数据类型的值。C 语言中有两种类型转换：</p><ul><li><p><strong>隐式类型转换：</strong>隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d = i + f; <span class="comment">// 隐式将int类型转换为double类型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>显式类型转换：</strong>显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)d; <span class="comment">// 显式将double类型转换为int类型</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-6-运算符"><a href="#2-6-运算符" class="headerlink" title="2.6 运算符"></a>2.6 运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。</p><h3 id="2-6-1-算术运算符"><a href="#2-6-1-算术运算符" class="headerlink" title="2.6.1 算术运算符"></a>2.6.1 算术运算符</h3><p>下表显示了 C 语言支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">把两个操作数相加</td><td style="text-align:left">A + B 将得到 30</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">从第一个操作数中减去第二个操作数</td><td style="text-align:left">A - B 将得到 -10</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">把两个操作数相乘</td><td style="text-align:left">A * B 将得到 200</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">分子除以分母</td><td style="text-align:left">B / A 将得到 2</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取模运算符，整除后的余数</td><td style="text-align:left">B % A 将得到 0</td></tr><tr><td style="text-align:left">++</td><td style="text-align:left">自增运算符，整数值增加 1</td><td style="text-align:left">A++ 将得到 11</td></tr><tr><td style="text-align:left">—</td><td style="text-align:left">自减运算符，整数值减少 1</td><td style="text-align:left">A— 将得到 9</td></tr></tbody></table></div><h3 id="2-6-2-关系运算符"><a href="#2-6-2-关系运算符" class="headerlink" title="2.6.2 关系运算符"></a>2.6.2 关系运算符</h3><p>下表显示了 C 语言支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td style="text-align:left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td style="text-align:left">(A == B) 为假。</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td style="text-align:left">(A != B) 为真。</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td style="text-align:left">(A &gt; B) 为假。</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td style="text-align:left">(A &lt; B) 为真。</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:left">(A &gt;= B) 为假。</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:left">(A &lt;= B) 为真。</td></tr></tbody></table></div><h3 id="2-6-3-逻辑运算符"><a href="#2-6-3-逻辑运算符" class="headerlink" title="2.6.3 逻辑运算符"></a>2.6.3 逻辑运算符</h3><p>下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td style="text-align:left">(A &amp;&amp; B) 为假。</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td style="text-align:left">(A&#124;B) 为真。</td></tr><tr><td style="text-align:center">!</td><td style="text-align:left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td style="text-align:left">!(A &amp;&amp; B) 为真。</td></tr></tbody></table></div><h3 id="2-6-4-位运算符"><a href="#2-6-4-位运算符" class="headerlink" title="2.6.4 位运算符"></a>2.6.4 位运算符</h3><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">p</th><th style="text-align:left">q</th><th style="text-align:left">p &amp; q</th><th style="text-align:left">p&#124;q</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:left">按位与操作，按二进制位进行”与”运算。</td><td style="text-align:left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td style="text-align:center">$\vert$</td><td style="text-align:left">按位或运算符，按二进制位进行”或”运算。</td><td style="text-align:left">(A$\vert$B) 将得到 61，即为 0011 1101</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">异或运算符，按二进制位进行”异或”运算。</td><td style="text-align:left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td style="text-align:center">~</td><td style="text-align:left">取反运算符，按二进制位进行”取反”运算。</td><td style="text-align:left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:left">二进制左移运算符。</td><td style="text-align:left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:left">二进制右移运算符。</td><td style="text-align:left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table></div><h3 id="1-6-5-赋值运算符"><a href="#1-6-5-赋值运算符" class="headerlink" title="1.6.5 赋值运算符"></a>1.6.5 赋值运算符</h3><p>下表列出了 C 语言支持的赋值运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td style="text-align:left">C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td style="text-align:left">C += A 相当于 C = C + A</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td style="text-align:left">C -= A 相当于 C = C - A</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td style="text-align:left">C _= A 相当于 C = C _ A</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td style="text-align:left">C /= A 相当于 C = C / A</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td style="text-align:left">C %= A 相当于 C = C % A</td></tr><tr><td style="text-align:left">&lt;&lt;=</td><td style="text-align:left">左移且赋值运算符</td><td style="text-align:left">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td style="text-align:left">&gt;&gt;=</td><td style="text-align:left">右移且赋值运算符</td><td style="text-align:left">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td style="text-align:left">&amp;=</td><td style="text-align:left">按位与且赋值运算符</td><td style="text-align:left">C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td style="text-align:left">^=</td><td style="text-align:left">按位异或且赋值运算符</td><td style="text-align:left">C ^= 2 等同于 C = C ^ 2</td></tr><tr><td style="text-align:left">&#124;=</td><td style="text-align:left">按位或且赋值运算符</td><td style="text-align:left">C &#124;= 2 等同于 C = C $\vert$ 2</td></tr></tbody></table></div><h3 id="1-6-6-杂项运算符"><a href="#1-6-6-杂项运算符" class="headerlink" title="1.6.6 杂项运算符"></a>1.6.6 杂项运算符</h3><p>下表列出了 C 语言支持的其他一些重要的运算符，包括 <strong>sizeof</strong> 和 <strong>? :</strong>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">sizeof()</td><td style="text-align:left">返回变量的大小。</td><td style="text-align:left">sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:left">返回变量的地址。</td><td style="text-align:left">&a; 将给出变量的实际地址。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">指向一个变量。</td><td style="text-align:left">*a; 将指向一个变量。</td></tr><tr><td style="text-align:center">? :</td><td style="text-align:left">条件表达式</td><td style="text-align:left">如果条件为真 ? 则值为 X : 否则值为 Y</td></tr></tbody></table></div><h3 id="1-6-7-运算优先级"><a href="#1-6-7-运算优先级" class="headerlink" title="1.6.7 运算优先级"></a>1.6.7 运算优先级</h3><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">运算符</th><th style="text-align:left">结合性</th></tr></thead><tbody><tr><td style="text-align:left">后缀</td><td style="text-align:left">() [] -&gt; . ++ - -</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">一元</td><td style="text-align:left">+ - ! ~ ++ - - (type) * &amp; sizeof</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">乘除</td><td style="text-align:left">* / %</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">加减</td><td style="text-align:left">+ -</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left">&lt;&lt; &gt;&gt;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left">&lt; &lt;= &gt; &gt;=</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">相等</td><td style="text-align:left">== !=</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位与 AND</td><td style="text-align:left">&amp;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位异或 XOR</td><td style="text-align:left">^</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位或 OR</td><td style="text-align:left">&#124;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">逻辑与 AND</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">逻辑或 OR</td><td style="text-align:left">&#124;&#124;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left">?:</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">赋值</td><td style="text-align:left">= += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= &#124;=</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">逗号</td><td style="text-align:left">,</td><td style="text-align:left">从左到右</td></tr></tbody></table></div><h2 id="1-7-变量与常量"><a href="#1-7-变量与常量" class="headerlink" title="1.7 变量与常量"></a>1.7 变量与常量</h2><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p><p>变量的名称可以由字母、数字和下划线字符组成。</p><h3 id="1-7-1-变量定义"><a href="#1-7-1-变量定义" class="headerlink" title="1.7.1 变量定义"></a>1.7.1 变量定义</h3><p>变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure><h3 id="1-7-2-变量声明"><a href="#1-7-2-变量声明" class="headerlink" title="1.7.2 变量声明"></a>1.7.2 变量声明</h3><p>变量的声明有两种情况：</p><ol><li>需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li><li>不需要建立存储空间的，通过使用 extern 关键字声明变量名而不定义它。</li><li>除非有 extern 关键字，否则都是变量的定义。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明，不是定义</span><br><span class="line">int i; //声明，也是定义</span><br></pre></td></tr></table></figure><h3 id="1-7-3-常量"><a href="#1-7-3-常量" class="headerlink" title="1.7.3 常量"></a>1.7.3 常量</h3><p>在 C 中，有两种简单的定义常量的方式：</p><ol><li>使用 <strong>#define</strong> 预处理器。</li><li>使用 <strong>const</strong> 关键字。</li></ol><p>下面是使用 #define 预处理器定义常量的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define identifier value</span><br></pre></td></tr></table></figure><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const type variable = value;</span><br></pre></td></tr></table></figure><h2 id="1-8-输入和输出"><a href="#1-8-输入和输出" class="headerlink" title="1.8 输入和输出"></a>1.8 输入和输出</h2><p>当我们提到<strong>输入</strong>时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。</p><p>当我们提到<strong>输出</strong>时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。</p><h3 id="1-8-1-scanf-和-printf-函数"><a href="#1-8-1-scanf-和-printf-函数" class="headerlink" title="1.8.1 scanf() 和 printf() 函数"></a>1.8.1 scanf() 和 printf() 函数</h3><p><code>int scanf(const char \*format, ...)</code>函数从标准输入流 <code>stdin</code> 读取输入，并根据提供的 <code>format</code> 来浏览输入。</p><p><code>int printf(const char \*format, ...)</code> 函数把输出写入到标准输出流 <code>stdout</code> ，并根据提供的格式产生输出。</p><p><code>format</code> 可以是一个简单的常量字符串，但是您可以分别指定 <code>%s、%d、%c、%f</code>等来输出或读取字符串、整数、字符或浮点数。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入值：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nYou entered: %s %d &quot;</span>, str, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-2-getchar-和-putchar-函数"><a href="#1-8-2-getchar-和-putchar-函数" class="headerlink" title="1.8.2 getchar() 和 putchar() 函数"></a>1.8.2 getchar() 和 putchar() 函数</h3><p><strong><code>int getchar(void)</code></strong> 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p><p><strong><code>int putchar(int c)</code></strong> 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p><h3 id="1-8-3-gets-和-puts-函数"><a href="#1-8-3-gets-和-puts-函数" class="headerlink" title="1.8.3 gets() 和 puts() 函数"></a>1.8.3 gets() 和 puts() 函数</h3><p><strong><code>char \*gets(char \*s)</code></strong> 函数从 <strong><code>stdin</code></strong> 读取一行到 <strong>s</strong> 所指向的缓冲区，直到一个终止符或 EOF。</p><p><strong><code>int puts(const char \*s)</code></strong> 函数把字符串 s 和一个尾随的换行符写入到 <strong><code>stdout</code></strong>。</p><h1 id="第三章-流程控制语句"><a href="#第三章-流程控制语句" class="headerlink" title="第三章 流程控制语句"></a>第三章 流程控制语句</h1><h2 id="3-1-顺序结构"><a href="#3-1-顺序结构" class="headerlink" title="3.1 顺序结构"></a>3.1 顺序结构</h2><h2 id="3-2-选择结构"><a href="#3-2-选择结构" class="headerlink" title="3.2 选择结构"></a>3.2 选择结构</h2><p>选择结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p><h3 id="3-2-1-if-语句"><a href="#3-2-1-if-语句" class="headerlink" title="3.2.1 if 语句"></a>3.2.1 if 语句</h3><p>单个 if 的语句，当表达式 1 为真时，执行代码块 1。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if…else 语句：当表达式 1 为真时，执行代码块 1；反之，执行代码块 2。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    代码块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环之间可以相互嵌套</p></blockquote><h3 id="3-2-2-switch-语句"><a href="#3-2-2-switch-语句" class="headerlink" title="3.2.2 switch 语句"></a>3.2.2 switch 语句</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(value)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;B</span><span class="number">&#x27;</span>:a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传入的值 value 为 A 时，“a = 0”代码，其余同理。</p><h3 id="3-2-3-三元运算符"><a href="#3-2-3-三元运算符" class="headerlink" title="3.2.3 三元运算符"></a>3.2.3 三元运算符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&gt;b? max = a: max = b;<span class="comment">//如果a&gt;b为真，则执行max = a;反之，则执行max = b;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-循环结构"><a href="#3-3-循环结构" class="headerlink" title="3.3 循环结构"></a>3.3 循环结构</h2><h3 id="3-3-1-while-循环"><a href="#3-3-1-while-循环" class="headerlink" title="3.3.1 while 循环"></a>3.3.1 while 循环</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)</span><br><span class="line">&#123;</span><br><span class="line">    xxx;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-do-while-循环"><a href="#3-3-2-do-while-循环" class="headerlink" title="3.3.2 do-while 循环"></a>3.3.2 do-while 循环</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (循环条件);</span><br></pre></td></tr></table></figure><p>与 while 的区别是，该循环是：先执行，后判断；而 while 是：先判断，后执行。</p><h3 id="3-3-3-for-循环"><a href="#3-3-3-for-循环" class="headerlink" title="3.3.3 for 循环"></a>3.3.3 for 循环</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-循环控制语句"><a href="#3-3-4-循环控制语句" class="headerlink" title="3.3.4 循环控制语句"></a>3.3.4 循环控制语句</h3><div class="table-container"><table><thead><tr><th style="text-align:left">控制语句</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/cprogramming/c-break-statement.html">break 语句</a></td><td style="text-align:left">终止<strong>循环</strong>或 <strong>switch</strong> 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cprogramming/c-continue-statement.html">continue 语句</a></td><td style="text-align:left">告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cprogramming/c-goto-statement.html">goto 语句</a></td><td style="text-align:left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr></tbody></table></div><h1 id="第四章-复杂数据类型"><a href="#第四章-复杂数据类型" class="headerlink" title="第四章 复杂数据类型"></a>第四章 复杂数据类型</h1><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>C 语言支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p><p>数组中的元素的地址是连续的。</p><h3 id="4-1-1-声明数组"><a href="#4-1-1-声明数组" class="headerlink" title="4.1.1 声明数组"></a>4.1.1 声明数组</h3><p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型名 变量名[常量表达式]</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li>定义数组时，需指明数组长度</li><li>中括号 [ ] 里为常量，不能为变量</li></ul><h3 id="4-1-2-初始化数组"><a href="#4-1-2-初始化数组" class="headerlink" title="4.1.2 初始化数组"></a>4.1.2 初始化数组</h3><p>在声明时进行初始化。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全部赋值</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以部分赋值，未赋值的默认为0</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>还可以对数组中的单个元素进行赋值。例如;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line">num[<span class="number">6</span>] = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-访问数组元素"><a href="#4-1-3-访问数组元素" class="headerlink" title="4.1.3 访问数组元素"></a>4.1.3 访问数组元素</h3><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组名[下标]</span></span><br><span class="line"><span class="comment">//下标的范围0-max</span></span><br><span class="line">num[<span class="number">0</span>];</span><br><span class="line">num[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="4-1-4-二维数组"><a href="#4-1-4-二维数组" class="headerlink" title="4.1.4 二维数组"></a>4.1.4 二维数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型名 变量名[常量表达式][常量表达式]</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名[下标][下标]</span></span><br><span class="line"><span class="comment">//下标的范围0-max</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">num[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">    &#123;<span class="number">12</span>,<span class="number">32</span>,<span class="number">23</span>,<span class="number">321</span>&#125;</span><br><span class="line">    &#123;<span class="number">23</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">32</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">321</span>,<span class="number">23</span>,<span class="number">23</span>,<span class="number">32</span>,<span class="number">12</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-字符数组-字符串"><a href="#4-2-字符数组-字符串" class="headerlink" title="4.2 字符数组-字符串"></a>4.2 字符数组-字符串</h2><p>在 C 语言中，<strong>字符串</strong>实际上是使用空字符 <strong>\0</strong> 结尾的一维字符数组。因此，<strong>\0</strong> 是用于标记字符串的结束。</p><p><img src="https://raw.githubusercontent.com/YuiLexi/Imageshack/main/E-books/Programming/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E6%A8%A1%E5%9E%8B.png" alt="C/C++ 中的字符串表示"></p><h3 id="4-2-1-字符数组的声明和初始化"><a href="#4-2-1-字符数组的声明和初始化" class="headerlink" title="4.2.1 字符数组的声明和初始化"></a>4.2.1 字符数组的声明和初始化</h3><p>语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;!&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-字符数组的输出"><a href="#4-2-2-字符数组的输出" class="headerlink" title="4.2.2 字符数组的输出"></a>4.2.2 字符数组的输出</h3><p>使用 printf() 函数，对字符数组进行输出。语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[] = &#123;<span class="string">&quot;China&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,c);</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>输出的字符中不包含结束符’\0’</li><li>如果数组长度大于字符串的实际长度，也只输出遇到’\0’</li><li>如果一个字符数组中包含一个以上的’\0’，则遇到第一个时输出就结束</li><li>可以用<strong>scanf_s</strong>输入一个字符串</li></ul><h3 id="4-2-2-操作字符数组"><a href="#4-2-2-操作字符数组" class="headerlink" title="4.2.2 操作字符数组"></a>4.2.2 操作字符数组</h3><p>C 中有大量操作字符串的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数 &amp; 目的</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table></div><h2 id="4-3-结构体"><a href="#4-3-结构体" class="headerlink" title="4.3 结构体"></a>4.3 结构体</h2><p><strong>结构</strong>是 C 编程中一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。</p><h3 id="4-3-1-结构体的定义"><a href="#4-3-1-结构体的定义" class="headerlink" title="4.3.1 结构体的定义"></a>4.3.1 结构体的定义</h3><p>结构体定义由关键字 struct 和结构体名组成，结构体名可以根据需要自行定义。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span></span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Struct 结构体名</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">结构体成员列表;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-结构体变量初始化"><a href="#4-3-2-结构体变量初始化" class="headerlink" title="4.3.2 结构体变量初始化"></a>4.3.2 结构体变量初始化</h3><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。例如，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; book = &#123;<span class="string">&quot;C 语言&quot;</span>, <span class="string">&quot;RUNOOB&quot;</span>, <span class="string">&quot;编程语言&quot;</span>, <span class="number">123456</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;</span>, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-访问结构体成员"><a href="#4-3-3-访问结构体成员" class="headerlink" title="4.3.3 访问结构体成员"></a>4.3.3 访问结构体成员</h3><p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。您可以使用 <strong>struct</strong> 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> str[];</span><br><span class="line">&#125;Tom = &#123;<span class="number">9</span>,<span class="number">10.56</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line"><span class="keyword">struct</span> Student *pt;</span><br><span class="line">pt = &amp;Tom</span><br><span class="line"><span class="comment">//方法一：结构体变量名.结构体成员</span></span><br><span class="line">Tom.str;</span><br><span class="line"><span class="comment">//方法二：（*结构体指针变量).结构体成员</span></span><br><span class="line">(*pt).str;</span><br><span class="line"><span class="comment">//方法三：结构体指针变量-&gt;结构体成员</span></span><br><span class="line">pt-&gt;str</span><br></pre></td></tr></table></figure><h3 id="4-3-4-结构作为函数参数"><a href="#4-3-4-结构作为函数参数" class="headerlink" title="4.3.4 结构作为函数参数"></a>4.3.4 结构作为函数参数</h3><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p><h2 id="4-4-共用体"><a href="#4-4-共用体" class="headerlink" title="4.4 共用体"></a>4.4 共用体</h2><p><strong>共用体</strong>是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。</p><h3 id="4-4-1-定义共用体"><a href="#4-4-1-定义共用体" class="headerlink" title="4.4.1 定义共用体"></a>4.4.1 定义共用体</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one or more <span class="class"><span class="keyword">union</span> <span class="title">variables</span>];</span></span><br></pre></td></tr></table></figure><h3 id="4-4-2-访问共用体成员"><a href="#4-4-2-访问共用体成员" class="headerlink" title="4.4.2 访问共用体成员"></a>4.4.2 访问共用体成员</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.element</span><br></pre></td></tr></table></figure><h3 id="4-4-3-共用体类型的特点"><a href="#4-4-3-共用体类型的特点" class="headerlink" title="4.4.3 共用体类型的特点"></a>4.4.3 共用体类型的特点</h3><ol><li>同一段内存能存放不不同类型成员，但是在每一瞬间只能存放某一种类型成员</li><li>可以进行初始化，但是初始化表中只能有一个常量</li><li>共用体变量起作用的成员是最后一次被赋值的成员，每一次赋值后，原有变量存储单元中的值就被取代</li><li>共用体变量的地址和它各成员的地址都是同一地址</li><li>不能对共用体变量名赋值也不能引用变量名来获取一个值</li><li>C99 允许共用体变量作为函数参数</li></ol><h2 id="4-5-枚举"><a href="#4-5-枚举" class="headerlink" title="4.5 枚举"></a>4.5 枚举</h2><h1 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h1><p>函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p><p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p><h2 id="5-1-函数的使用"><a href="#5-1-函数的使用" class="headerlink" title="5.1 函数的使用"></a>5.1 函数的使用</h2><h3 id="5-1-1-定义函数"><a href="#5-1-1-定义函数" class="headerlink" title="5.1.1 定义函数"></a>5.1.1 定义函数</h3><p>C 语言中的函数定义的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类型名 函数名(参数)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">函数体</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li><li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li></ul><h3 id="5-1-2-函数声明"><a href="#5-1-2-函数声明" class="headerlink" title="5.1.2 函数声明"></a>5.1.2 函数声明</h3><p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><p>函数声明包括以下几个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span>;</span><br></pre></td></tr></table></figure><p>针对上面定义的函数 max()，以下是函数声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br></pre></td></tr></table></figure><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p><h3 id="5-1-3-调用函数"><a href="#5-1-3-调用函数" class="headerlink" title="5.1.3 调用函数"></a>5.1.3 调用函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数列表);</span><br></pre></td></tr></table></figure><h2 id="5-2-参数传递"><a href="#5-2-参数传递" class="headerlink" title="5.2 参数传递"></a>5.2 参数传递</h2><ul><li>形式参数：定义函数时括号里面的参数</li><li>实际参数：调用函数时括号里面的参数</li></ul><h3 id="5-2-1-传值调用"><a href="#5-2-1-传值调用" class="headerlink" title="5.2.1 传值调用"></a>5.2.1 传值调用</h3><p>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</p><p>默认情况下，C 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p><h3 id="5-2-2-引用调用"><a href="#5-2-2-引用调用" class="headerlink" title="5.2.2 引用调用"></a>5.2.2 引用调用</h3><p>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p><h2 id="5-3-函数的递归"><a href="#5-3-函数的递归" class="headerlink" title="5.3 函数的递归"></a>5.3 函数的递归</h2><p>在调用函数的过程中又出现<strong>直接或间接调用该函数本身</strong>，称为<font color='red'>函数的递归</font>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">name</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y,z;</span><br><span class="line">    z = name(y);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，打印任意乘法表。具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> <span class="title function_">chengfabiao</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要打印的乘法表的阶数：\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">chengfabiao(number);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chengfabiao</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">chengfabiao(n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d X %d = %d ,  &quot;</span>, n, i, n * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第六章-指针"><a href="#第六章-指针" class="headerlink" title="第六章 指针"></a>第六章 指针</h1><p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 <strong>&amp;</strong> 运算符访问的地址，它表示了在内存中的一个地址。</p><p><strong>指针也就是内存地址，指针变量是用来存放内存地址的变量</strong>。</p><h2 id="6-1-指针变量"><a href="#6-1-指针变量" class="headerlink" title="6.1 指针变量"></a>6.1 指针变量</h2><h3 id="6-1-1-指针变量的定义"><a href="#6-1-1-指针变量的定义" class="headerlink" title="6.1.1 指针变量的定义"></a>6.1.1 指针变量的定义</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var_name;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-指针的使用"><a href="#6-1-2-指针的使用" class="headerlink" title="6.1.2 指针的使用"></a>6.1.2 指针的使用</h3><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 <strong>*</strong> 来返回位于操作数所指定地址的变量的值。例如，下面代码;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//定义整型变量 a</span></span><br><span class="line"><span class="type">int</span>* ap;<span class="comment">//定义整型指针变量 ap</span></span><br><span class="line">ap = &amp;a;<span class="comment">//让指针 ap 指向 a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a的地址是：%d\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a的地址是：%d\n&quot;</span>, ap);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a的值是：%d\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a的值是：%d\n&quot;</span>, *ap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-NULL-指针"><a href="#6-2-NULL-指针" class="headerlink" title="6.2 NULL 指针"></a>6.2 NULL 指针</h2><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p><p>NULL 指针是一个定义在标准库中的值为零的常量。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p><h2 id="6-3-指针详解"><a href="#6-3-指针详解" class="headerlink" title="6.3 指针详解"></a>6.3 指针详解</h2><h3 id="6-3-1-指针的算数运算"><a href="#6-3-1-指针的算数运算" class="headerlink" title="6.3.1 指针的算数运算"></a>6.3.1 指针的算数运算</h3><p>指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、—、+、- 。</p><p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr++;</span><br></pre></td></tr></table></figure><p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p><p>我们概括一下：</p><ul><li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li><li>指针的每一次递减，它都会指向前一个元素的存储单元。</li><li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</li></ul><h3 id="6-3-2-指针数组"><a href="#6-3-2-指针数组" class="headerlink" title="6.3.2 指针数组"></a>6.3.2 指针数组</h3><h3 id="6-3-3-多重指针"><a href="#6-3-3-多重指针" class="headerlink" title="6.3.3 多重指针"></a>6.3.3 多重指针</h3><h2 id="6-4-通过指针引用数组"><a href="#6-4-通过指针引用数组" class="headerlink" title="6.4 通过指针引用数组"></a>6.4 通过指针引用数组</h2><h3 id="6-4-1-数组元素的指针"><a href="#6-4-1-数组元素的指针" class="headerlink" title="6.4.1 数组元素的指针"></a>6.4.1 数组元素的指针</h3><p><strong>所谓数组元素的指针就是数组元素的地址</strong>。</p><p>引用数组元素可以用下标法，也可用指针法。使用指针法能使目标程序质量高（占内存少，运算快）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><p>注意：数组名不代表整个数组，只代表数组首元素的我地址。</p><h3 id="6-4-2-在引用数组元素时的指针运算"><a href="#6-4-2-在引用数组元素时的指针运算" class="headerlink" title="6.4.2 在引用数组元素时的指针运算"></a>6.4.2 在引用数组元素时的指针运算</h3><p>在指针以指向一个数组元素时，可以对指针进行一下运算：</p><ul><li>p + 1;</li><li>p - 1;</li><li>p++,++p;</li><li>p—,—p;</li></ul><h3 id="6-4-3-指针引用数组元素"><a href="#6-4-3-指针引用数组元素" class="headerlink" title="6.4.3 指针引用数组元素"></a>6.4.3 指针引用数组元素</h3><ol><li><p>下标法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">b = a[<span class="number">4</span>];<span class="comment">//b == 5</span></span><br></pre></td></tr></table></figure></li><li><p>指针法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">0</span>];<span class="comment">//或者 p=a; 将数组a的初地址赋给p指针</span></span><br><span class="line">b = *(p+<span class="number">4</span>);<span class="comment">//b==5</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="第七章-动态内存和链表"><a href="#第七章-动态内存和链表" class="headerlink" title="第七章 动态内存和链表"></a>第七章 动态内存和链表</h1><h2 id="7-1-建立动态内存的方式"><a href="#7-1-建立动态内存的方式" class="headerlink" title="7.1 建立动态内存的方式"></a>7.1 建立动态内存的方式</h2><h3 id="7-1-1-开辟动态存储区-malloc-函数"><a href="#7-1-1-开辟动态存储区-malloc-函数" class="headerlink" title="7.1.1 开辟动态存储区 malloc() 函数"></a>7.1.1 开辟动态存储区 malloc() 函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>在内存的动态存储区中分配一个长度为 size 的连续空间。</li><li>函数返回值为内存第一个字节的地址</li><li>未能成功执行（例如：内存空间不足），则返回 NULL</li></ul><h3 id="7-1-2-开辟动态存储区-calloc-函数"><a href="#7-1-2-开辟动态存储区-calloc-函数" class="headerlink" title="7.1.2 开辟动态存储区 calloc() 函数"></a>7.1.2 开辟动态存储区 calloc() 函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>在内存的动态存储区中分配 n 个长度为 size 的连续空间。</li><li>函数返回值为内存第一个字节的地址</li><li>未能成功执行（例如：内存空间不足），则返回 NULL</li></ul><h3 id="7-1-3-重新分配动态存储区-realloc-函数"><a href="#7-1-3-重新分配动态存储区-realloc-函数" class="headerlink" title="7.1.3 重新分配动态存储区 realloc() 函数"></a>7.1.3 重新分配动态存储区 realloc() 函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *p,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>能够重新分配 malloc 或 calloc 函数开辟的动态空间</li><li>realloch 函数将 p 所指向的动态空间的大小改变为 size 。</li><li>p 的值不变</li><li>未能成功执行，则返回 NULL</li></ul><h3 id="7-1-4-释放动态存储区-free-函数"><a href="#7-1-4-释放动态存储区-free-函数" class="headerlink" title="7.1.4 释放动态存储区 free() 函数"></a>7.1.4 释放动态存储区 free() 函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">free</span>（<span class="type">void</span> *p;</span><br></pre></td></tr></table></figure><h2 id="7-2-链表"><a href="#7-2-链表" class="headerlink" title="7.2 链表"></a>7.2 链表</h2><h3 id="7-2-1-静态链表"><a href="#7-2-1-静态链表" class="headerlink" title="7.2.1 静态链表"></a>7.2.1 静态链表</h3><p>建立简单的静态链表。具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 6</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">&#125;component;</span><br><span class="line"><span class="comment">//将结构体数组中所有分量链接到备用链表中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserveArr</span><span class="params">(component *<span class="built_in">array</span>)</span>;</span><br><span class="line"><span class="comment">//初始化静态链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initArr</span><span class="params">(component *<span class="built_in">array</span>)</span>;</span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayArr</span><span class="params">(component * <span class="built_in">array</span>, <span class="type">int</span> body)</span>;</span><br><span class="line"><span class="comment">//从备用链表上摘下空闲节点的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallocArr</span><span class="params">(component * <span class="built_in">array</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    component <span class="built_in">array</span>[maxSize];</span><br><span class="line">    <span class="type">int</span> body = initArr(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;静态链表为：\n&quot;</span>);</span><br><span class="line">    displayArr(<span class="built_in">array</span>, body);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建备用链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserveArr</span><span class="params">(component *<span class="built_in">array</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i].cur = i + <span class="number">1</span>;<span class="comment">//将每个数组分量链接到一起</span></span><br><span class="line">        <span class="built_in">array</span>[i].data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[maxSize - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">//链表最后一个结点的游标值为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提取分配空间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallocArr</span><span class="params">(component * <span class="built_in">array</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//若备用链表非空，则返回分配的结点下标，否则返回 0（当分配最后一个结点时，该结点的游标值为 0）</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">array</span>[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>].cur) &#123;</span><br><span class="line">        <span class="built_in">array</span>[<span class="number">0</span>].cur = <span class="built_in">array</span>[i].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化静态链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initArr</span><span class="params">(component *<span class="built_in">array</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tempBody = <span class="number">0</span>, body = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    reserveArr(<span class="built_in">array</span>);</span><br><span class="line">    body = mallocArr(<span class="built_in">array</span>);</span><br><span class="line">    <span class="comment">//建立首元结点</span></span><br><span class="line">    <span class="built_in">array</span>[body].data = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">array</span>[body].cur = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//声明一个变量，把它当指针使，指向链表的最后的一个结点，当前和首元结点重合</span></span><br><span class="line">    tempBody = body;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = mallocArr(<span class="built_in">array</span>); <span class="comment">//从备用链表中拿出空闲的分量</span></span><br><span class="line">        <span class="built_in">array</span>[j].data = i;      <span class="comment">//初始化新得到的空间结点</span></span><br><span class="line">        <span class="built_in">array</span>[tempBody].cur = j; <span class="comment">//将新得到的结点链接到数据链表的尾部</span></span><br><span class="line">        tempBody = j;             <span class="comment">//将指向链表最后一个结点的指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[tempBody].cur = <span class="number">0</span>;<span class="comment">//新的链表最后一个结点的指针设置为0</span></span><br><span class="line">    <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">displayArr</span><span class="params">(component * <span class="built_in">array</span>, <span class="type">int</span> body)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tempBody = body;<span class="comment">//tempBody准备做遍历使用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">array</span>[tempBody].cur) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="built_in">array</span>[tempBody].data, <span class="built_in">array</span>[tempBody].cur);</span><br><span class="line">        tempBody = <span class="built_in">array</span>[tempBody].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="built_in">array</span>[tempBody].data, <span class="built_in">array</span>[tempBody].cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-动态链表"><a href="#7-2-2-动态链表" class="headerlink" title="7.2.2 动态链表"></a>7.2.2 动态链表</h3><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">Bp</span>;</span></span><br><span class="line">&#125;Books;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Books* <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Books * fbp)</span>;</span><br><span class="line">Books* p;</span><br><span class="line">p = init(<span class="number">10</span>);</span><br><span class="line">print(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 生成对应结点数链表</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;n&quot;&gt;链表的结点数&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;返回表头指针&lt;/returns&gt;</span></span><br><span class="line">Books* <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">Books* fBp = <span class="literal">NULL</span>;</span><br><span class="line">Books* tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">fBp = (Books*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Books));</span><br><span class="line"></span><br><span class="line">tmp = fBp;</span><br><span class="line"><span class="keyword">for</span> (a = <span class="number">0</span>; a &lt; n; a++)</span><br><span class="line">&#123;</span><br><span class="line">(*tmp).id = a;</span><br><span class="line">(*tmp).Bp = (Books*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Books));</span><br><span class="line">tmp = (*tmp).Bp;</span><br><span class="line">(*tmp).Bp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fBp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 将链表的内容输出出来（正序和倒序）</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;fbp&quot;&gt;指向表头的指针&lt;/param&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Books* fbp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*fbp).Bp == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*fbp).id);</span><br><span class="line">print((*fbp).Bp);</span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;, (*fbp).id);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第八章-对文件的输入输出"><a href="#第八章-对文件的输入输出" class="headerlink" title="第八章 对文件的输入输出"></a>第八章 对文件的输入输出</h1><h2 id="8-1-C-文件的有关知识"><a href="#8-1-C-文件的有关知识" class="headerlink" title="8.1 C 文件的有关知识"></a>8.1 C 文件的有关知识</h2><h3 id="8-1-1-什么是文件"><a href="#8-1-1-什么是文件" class="headerlink" title="8.1.1 什么是文件"></a>8.1.1 什么是文件</h3><p>程序文件</p><p>数据文件</p><h3 id="8-1-2-文件类型指针"><a href="#8-1-2-文件类型指针" class="headerlink" title="8.1.2 文件类型指针"></a>8.1.2 文件类型指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE f1;</span><br><span class="line">FILE * f1;</span><br></pre></td></tr></table></figure><h2 id="8-2-打开与关闭文件"><a href="#8-2-打开与关闭文件" class="headerlink" title="8.2 打开与关闭文件"></a>8.2 打开与关闭文件</h2><div class="table-container"><table><thead><tr><th style="text-align:center">mode</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center">以只读方式打开文件，该文件必须存在</td></tr><tr><td style="text-align:center">r+</td><td style="text-align:center">以可读写方式打开文件，该文件必须存在</td></tr><tr><td style="text-align:center">rb+</td><td style="text-align:center">读写打开一个二进制文件，允许读数据</td></tr><tr><td style="text-align:center">rw+</td><td style="text-align:center">读写打开一个文本文件，允许读和写</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">打开只写文件，若文件存在则文件长度清为 0，即该文件内容会消失。若文件不存在则建立该文件</td></tr><tr><td style="text-align:center">w+</td><td style="text-align:center">打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留（EOF 符保留）</td></tr><tr><td style="text-align:center">a+</td><td style="text-align:center">以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留（原来的 EOF 符不保留）</td></tr><tr><td style="text-align:center">wb</td><td style="text-align:center">只写打开或新建一个二进制文件；只允许写数据</td></tr><tr><td style="text-align:center">wb+</td><td style="text-align:center">读写打开或建立一个二进制文件，允许读和写</td></tr><tr><td style="text-align:center">ab+</td><td style="text-align:center">读写打开一个二进制文件，允许读或在文件末追加数据</td></tr></tbody></table></div><h3 id="8-2-1-用-fopen-函数打开数据文件"><a href="#8-2-1-用-fopen-函数打开数据文件" class="headerlink" title="8.2.1 用 fopen 函数打开数据文件"></a>8.2.1 用 fopen 函数打开数据文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen(<span class="string">&quot;文件名&quot;</span>,<span class="string">&quot;操作文件方式&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="8-2-2-用-fclose-函数关闭数据文件"><a href="#8-2-2-用-fclose-函数关闭数据文件" class="headerlink" title="8.2.2 用 fclose 函数关闭数据文件"></a>8.2.2 用 fclose 函数关闭数据文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(文件指针);</span><br></pre></td></tr></table></figure><h2 id="8-3-顺序读写数据文件"><a href="#8-3-顺序读写数据文件" class="headerlink" title="8.3 顺序读写数据文件"></a>8.3 顺序读写数据文件</h2><h3 id="8-3-1-向文件读写字符"><a href="#8-3-1-向文件读写字符" class="headerlink" title="8.3.1 向文件读写字符"></a>8.3.1 向文件读写字符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">调用形式</th><th style="text-align:center">功能</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">getc()</td><td style="text-align:center">getc(fp)</td><td style="text-align:center">从 fp 所指向的输入文件中读取一个字符</td><td style="text-align:center">返回值是读取的字符，如果发生错误则返回<strong>EOF = -1</strong></td></tr><tr><td style="text-align:center">fputc()</td><td style="text-align:center">fputc(ch,fp)</td><td style="text-align:center">字符 ch 写入到 fp 所指向的输出流中</td><td style="text-align:center">如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF = -1</strong></td></tr></tbody></table></div><h3 id="8-3-2-向文件读写字符串"><a href="#8-3-2-向文件读写字符串" class="headerlink" title="8.3.2 向文件读写字符串"></a>8.3.2 向文件读写字符串</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">调用形式</th><th style="text-align:center">功能</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">gets()</td><td style="text-align:center">gets(str,n,fp)</td><td style="text-align:center">从 fp 所指向的输入流中读取 n - 1 个字符</td><td style="text-align:center">返回值是地址 str，如果发生错误则返回<strong>NULL</strong></td></tr><tr><td style="text-align:center">fputs()</td><td style="text-align:center">fputs(str,fp)</td><td style="text-align:center">字符串 <strong>s</strong> 写入到 fp 所指向的输出流中</td><td style="text-align:center">如果写入成功，它会返回 0，如果发生错误，则会返回 <strong>非 0 值</strong></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> C语言基础 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html"/>
      <url>/03.%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/01.%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0/02.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、矩阵及应用"><a href="#一、矩阵及应用" class="headerlink" title="一、矩阵及应用"></a>一、矩阵及应用</h1><h2 id="1-1-高斯消元法"><a href="#1-1-高斯消元法" class="headerlink" title="1.1 高斯消元法"></a>1.1 高斯消元法</h2><p>引例：</p><p>分析，根据题意得到的方程组的如下：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\displaystyle x_{1} & + & x_{2} & + & x_{3} & + & x_{4} & = & 1\\\displaystyle 20x_{1} & + & 16x_{2} & + & 10x_{3} & + &15 x_{4} & = & 15\\\displaystyle 3x_{1} & + & 8x_{2} & + & 2x_{3} & + & 5x_{4} & = & 5\\\displaystyle 10x_{1} & + & 25x_{2} & + & 20x_{3} & + & 5x_{4} & = & 12\\\end{matrix}\right.</script><p>在方程组中每一个方程的左端是未知量的一次齐次式，右端是常数，这样的方程组称为<font color='red'>线性方程组</font> 。</p><p>线性方程组中的解的全体构成的集合称为解集合，解方程组就是求其全部解，亦即求出解集合。如果两个方程组有相同的解集合，则称他们<font color='red'>同解</font> 。</p><h2 id="1-2-矩阵的定义与运算"><a href="#1-2-矩阵的定义与运算" class="headerlink" title="1.2 矩阵的定义与运算"></a>1.2 矩阵的定义与运算</h2><h3 id="1-2-1-矩阵的定义"><a href="#1-2-1-矩阵的定义" class="headerlink" title="1.2.1 矩阵的定义"></a>1.2.1 矩阵的定义</h3><p><strong>定义 1.1</strong> ：有 $ m\times n $ 个数 $\displaystyle a_{ij} (i = 1,2,\dots ,m;j=1,2,\dots ,n)$ 排成的 $m$ 行 $n$ 列的矩形数表：</p><script type="math/tex; mode=display">\displaystyle A = \begin{vmatrix} a_{11}  & a_{12} & \dots  & a_{1n}\\ a_{21} & a_{22} & \dots  &a_{2n} \\ \vdots  & \vdots  &  &\vdots  \\ a_{m1} & a_{m2} & \dots  &a_{mn}\end{vmatrix}</script><p>称为 $m$ 行 $n$ 列<font color='red'>矩阵</font> （matrix），简称 $m\times n$ 矩阵，通常用大写字母表示。元素全是实数的矩阵称为<strong>实矩阵</strong>；元素全是复数的矩阵称为<strong>复矩阵</strong>。</p><h3 id="1-2-2-几种特殊矩阵"><a href="#1-2-2-几种特殊矩阵" class="headerlink" title="1.2.2 几种特殊矩阵"></a>1.2.2 几种特殊矩阵</h3><ul><li><p>行矩阵，又称<font color='red'>行向量</font> 。只有一行的矩阵。</p><script type="math/tex; mode=display">\displaystyle A = \begin{bmatrix}a_{1}   & a_{2}  & \dots  &a_{n}\end{bmatrix}</script></li><li><p>列矩阵，又称<font color='red'>列向量</font> 。只有一列的矩阵。</p><script type="math/tex; mode=display">\displaystyle B = \begin{bmatrix}b_{1}   \\ b_{2}  \\ \vdots  \\b_{m}\end{bmatrix}</script></li><li><p><font color='red'>零矩阵</font>：元素全为零的矩阵。记作：<script type="math/tex">O</script> 。</p></li><li><p>$n$ 阶方阵：行数和列数相等的矩阵。</p></li><li><p><font color='red'>上三角矩阵</font>：主对角线一下的元素全为零的<strong>方阵</strong>。</p><script type="math/tex; mode=display">\displaystyle A = \begin{vmatrix} a_{11}  & a_{12} & \dots  & a_{1n}\\0 & a_{22} & \dots  &a_{2n} \\ \vdots  & \vdots  &  &\vdots  \\0 & 0 & \dots  &a_{nn}\end{vmatrix}</script></li><li><p><font color='red'>下三角矩阵</font>：主对角线以上的元素全为零的<strong>方阵</strong>。</p><script type="math/tex; mode=display">\displaystyle A = \begin{vmatrix} a_{11}  & 0 & \dots  & 0\\ a_{21} & a_{22} & \dots  & 0 \\ \vdots  & \vdots  &  &\vdots  \\ a_{n1} & a_{n2} & \dots  &a_{nn}\end{vmatrix}</script></li><li><p><font color='red'>对角阵</font>：主对角线以外的元素全为零的<strong>方阵</strong>。</p><script type="math/tex; mode=display">\displaystyle A = \begin{vmatrix} a_{11}  & 0 & \dots  & 0\\ 0 & a_{22} & \dots  & 0 \\ \vdots  & \vdots  &  &\vdots  \\ 0 & 0 & \dots  &a_{nn}\end{vmatrix}</script></li><li><p><font color='red'>单位矩阵</font>：主对角线上全为 1 的 $n$ 阶对角矩阵。记作： $E_{n}$ 。</p><script type="math/tex; mode=display">\displaystyle A = \begin{bmatrix} 1 &  &  & \\  & 1 &  & \\  &  &  \ddots & \\  &  &  &1\end{bmatrix}</script></li><li><p>系数矩阵：线性方程组所有系数所构成的矩阵，称为线性方程组的<font color='red'>系数矩阵</font>。</p></li><li><p>增广矩阵：由线性方程组所有系数和常数项所构成阿矩阵，称为线性方程组的<font color='red'>增广矩阵</font> ，并记作 $\displaystyle \widetilde{A} =(A,b)$ 或者 $\widetilde{A}=[A,b]$ 。</p></li></ul><h3 id="1-2-3-矩阵的运算"><a href="#1-2-3-矩阵的运算" class="headerlink" title="1.2.3 矩阵的运算"></a>1.2.3 矩阵的运算</h3><p><strong>定义 1.2</strong> ：设有两个同型的矩阵 $\displaystyle A,B$ ，它们的<strong>和</strong>记作 $\displaystyle A+B$ 。规定</p><script type="math/tex; mode=display">\displaystyle A+B = \begin{bmatrix} a_{11}+b_{11}   & a_{12}+b_{12} & \cdots  & a_{1n}+b_{1n}\\a_{21}+b_{21}  & a_{22}+b_{22} &  \cdots & a_{2n}+b_{2n}\\\vdots  & \vdots  & \ddots  &\vdots  \\ a_{m1}+b_{m1} & a_{m2}+b_{m2} & \dots  &a_{mn}+b_{mn}\end{bmatrix}</script><p><strong>定义 1.3</strong> ：数 $\lambda$ 与矩阵 $A$ 的乘积，简称 <strong>数乘</strong> ，记作 $\lambda A$ 。规定</p><script type="math/tex; mode=display">\displaystyle \lambda A = \begin{bmatrix} \lambda a_{11}& \lambda a_{12} & \cdots  & \lambda a_{1n}\\\lambda a_{21} & \lambda a_{22} &  \cdots & \lambda a_{2n}\\\vdots  & \vdots  & \ddots  &\vdots  \\ \lambda a_{m1} & \lambda a_{m2}& \dots  &\lambda a_{mn}\end{bmatrix}</script><p>矩阵的<strong>加法</strong>和<strong>数乘</strong>统称为矩阵的<font color='red'>线性运算</font>。不难验证，矩阵的<strong>线性运算</strong>法则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>运算法则</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>$\displaystyle A+B=B+A$</td></tr><tr><td style="text-align:center">2</td><td>$\displaystyle (A+B)+C=A+(B+C)$</td></tr><tr><td style="text-align:center">3</td><td>$\displaystyle A+O = A$</td></tr><tr><td style="text-align:center">4</td><td>$\displaystyle A+(-A) = O$</td></tr><tr><td style="text-align:center">5</td><td>$\displaystyle 1A= A$</td></tr><tr><td style="text-align:center">6</td><td>$\displaystyle (\lambda \mu )A= \lambda (\mu A)=\mu (\lambda A)$</td></tr><tr><td style="text-align:center">7</td><td>$\displaystyle (\lambda +\mu )A= \lambda A+\mu A$</td></tr><tr><td style="text-align:center">8</td><td>$\displaystyle \lambda (A+B) = \lambda A+\lambda B$</td></tr></tbody></table></div><p><strong>定义 1.4</strong> ：设矩阵 $\displaystyle a_{ij} (i = 1,2,\dots ,m;j=1,2,\dots ,n)$</p><script type="math/tex; mode=display">\displaystyle c_{ij} = \sum_{k=1}^{s} a_{ik} b_{kj}</script><p><strong>只有左边矩阵的列数等于右边矩阵的行数，两个矩阵才能相乘</strong>。</p><p><img src="https://imageshack.yuilexi.cn/University/线性代数/矩阵的乘积.png" alt="线代矩阵相乘"></p><p>矩阵的乘法运算法则：</p><div class="table-container"><table><thead><tr><th>序号</th><th>运算法则</th></tr></thead><tbody><tr><td>1</td><td>$\displaystyle (AB)C = A(BC)$</td></tr><tr><td>2</td><td>$\displaystyle A(B+C) = AB+AC$</td></tr><tr><td>3</td><td>$\displaystyle \lambda (AB)= (\lambda A)B=A(\lambda B)$</td></tr><tr><td>4</td><td>$\displaystyle A_{m\times n} E_{_{n} }  = E_{n} A_{m\times n}=A_{m\times n}$</td></tr><tr><td>5</td><td>$\displaystyle A^{k} A^{l} = A^{k+l} ,(A^{k})^{l} =A^{kl} $</td></tr></tbody></table></div><p><strong>定义 1.5</strong> ：对于变量 $\displaystyle y<em>{1},y</em>{2} ,\dots,y<em>{m} $ ，若它们均能由变量 $\displaystyle x</em>{1} ,x<em>{2} ,\dots ,x</em>{n} $ 线性表示，即有：</p><script type="math/tex; mode=display">\left\{\begin{matrix} y_{1}  & = & a_{11}x_{1} & + & a_{12}x_{2} & + & \cdots  & + & a_{1n}x_{n}\\  y_{2} & = & a_{21}x_{1} & + & a_{22}x_{2} & + & \cdots  & + &a_{2n}x_{n} \\  & \vdots  &  &  &  &  &  &  & \\  y_{n} & = & a_{m1}x_{1} & + & a_{m2}x_{2} & + & \dots  & + &a_{mn}x_{n}\end{matrix}\right.</script><p>则称此关系式为变量到变量的<font color='red'>线性变换</font> ，可以用矩阵乘积来表示：</p><script type="math/tex; mode=display">y = \begin{bmatrix}y_{1}  \\y_{2} \\ \vdots \\y_{m}\end{bmatrix} = \begin{vmatrix} a_{11}  & a_{12} & \dots  & a_{1n}\\ a_{21} & a_{22} & \dots  &a_{2n} \\ \vdots  & \vdots  &  &\vdots  \\ a_{m1} & a_{m2} & \dots  &a_{mn}\end{vmatrix}\begin{bmatrix}x_{1}  \\ x_{2}\\ \vdots \\x_{n}\end{bmatrix} = Ax</script><p><strong>定义 1.6</strong> ：将矩阵 $A$ 的行换成同序列数的列而得到的矩阵，称为 $A$ 的<font color='red'>转置矩阵</font>，记作 $\displaystyle A^{T} \text{或者} A^{‘} $ 。即：</p><script type="math/tex; mode=display">A = \begin{bmatrix} a_{11}  &  a_{12} & \dots  &  a_{1n}\\ a_{21} &  a_{22} & \dots  &  a_{2n}\\\vdots   & \vdots  & \ddots  &\vdots  \\ a_{m1} &  a_{m2} & \dots  & a_{mn}\end{bmatrix},\quad A^{T} =\begin{bmatrix} a_{11}  &  a_{21} & \dots  &  a_{n1}\\ a_{12} &  a_{22} & \dots  &  a_{n2}\\\vdots   & \vdots  & \ddots  &\vdots  \\ a_{1m} &  a_{2m} & \dots  & a_{nm}\end{bmatrix}</script><p>如果 $n$ 阶方阵 $A$ 满足 $\displaystyle  A^{T} =A$ ，则称 $A$ 为 <font color='red'>对称矩阵</font> ；如果 $n$ 阶方阵 $A$ 满足 $\displaystyle  A^{T} =-A$ ，则称 $A$ 为 <font color='red'>反对称矩阵</font> 。</p><p>转置矩阵的运算法则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>运算法则</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>$\displaystyle  (A^{T})^{T}  = A$</td></tr><tr><td style="text-align:center">2</td><td>$\displaystyle (A+B)^{T} = A^{T} +B^{T} $</td></tr><tr><td style="text-align:center">3</td><td>$\displaystyle (\lambda A)^{T} = \lambda A^{T} $</td></tr><tr><td style="text-align:center">4</td><td>$\displaystyle (AB)^{T} = B^{T} A^{T} $</td></tr></tbody></table></div><h2 id="1-3-可逆矩阵"><a href="#1-3-可逆矩阵" class="headerlink" title="1.3 可逆矩阵"></a>1.3 可逆矩阵</h2><p>我们已经介绍了矩阵的加法、减法、数乘以及乘法运算，那么矩阵有没有除法运算呢？</p><h3 id="1-3-1-可逆矩阵的定义"><a href="#1-3-1-可逆矩阵的定义" class="headerlink" title="1.3.1 可逆矩阵的定义"></a>1.3.1 可逆矩阵的定义</h3><p><strong>定义 1.7</strong>：设 $A$ 为 $n$ 阶方阵，若存在 $n$ 阶方阵 $B$ ，使得 $\displaystyle AB = BA = E_{n} $ ，其中 $\displaystyle  E_{n} $ 为 $n$ 阶<strong>单位矩阵</strong>，则称 $A$ 为<font color='red'>可逆矩阵</font>（或称 $A$ 是 <strong>可逆的</strong>），并称 $B$ 是 $A$ 的逆矩阵。</p><h3 id="1-3-2-可逆矩阵的性质"><a href="#1-3-2-可逆矩阵的性质" class="headerlink" title="1.3.2 可逆矩阵的性质"></a>1.3.2 可逆矩阵的性质</h3><p><strong>性质 1.1</strong> ：若矩阵 $A$ 可逆，则 $A$ 的逆矩阵唯一。</p><ul><li><p>证明：</p><p>假设 $ B,C $ 都是 $A$ 的逆矩阵，则有 $AB = BA = E$ 和 $AC = CA = E$ 。则有</p><script type="math/tex; mode=display">B =BE=B(AC)=(BA)C=C</script><p>因此， $A$ 的逆矩阵是唯一的。</p></li></ul><p><strong>性质 1.2</strong> ：若矩阵 $A$ 可逆，则 $A^{-1}$ 也是可逆的 $(A^{-1})^{-1} =A$ 。</p><p><strong>性质 1.3</strong> ：若矩阵 $A$ 可逆，数 $\displaystyle \lambda  \ne 0$ ，则 $\displaystyle \lambda A $ 是可逆的，且 $\displaystyle \left ( \lambda A \right ) ^{-1} = \frac{1}{\lambda } A^{-1} $ 。</p><p><strong>性质 1.4</strong> ：若 $A,B$ 均为可逆方阵，则 $AB$ 也是可逆的，且 $\displaystyle (AB)^{-1} = B^{-1} A^{-1} $ 。</p><p><strong>性质 1.5</strong> ：若 $A$ 可逆，则 $A^{T}$ 也是可逆的，且 $\displaystyle (A^{T} )^{-1} = (A^{-1} )^{T} $ 。</p><h2 id="1-4-分块矩阵"><a href="#1-4-分块矩阵" class="headerlink" title="1.4 分块矩阵"></a>1.4 分块矩阵</h2><p>在矩阵运算中，特别是针对高阶矩阵，常常采用矩阵分块的方法将其简化为较低阶的矩阵进行计算。我们用若干条纵、横线将高阶矩阵 $A$ 分成若干个小矩阵，每一个小矩阵称为 $A$ 的子块，以子块为元素的矩阵称为 <font color='red'>分块矩阵</font> 。</p><p><img src="https://imageshack.yuilexi.cn/University/线性代数/分块矩阵.png" alt="分块矩阵"></p><ol><li><p>加法运算：与一般矩阵加法运算形式一致</p></li><li><p>数乘运算：与一般矩阵数乘运算形式一致</p></li><li><p>乘法运算：与一般矩阵乘法运算形式一致</p></li><li><p>分块矩阵的转置：</p><script type="math/tex; mode=display">\begin{align}\displaystyle 设A = \begin{bmatrix} A_{11}  &  A_{12} & \cdots  & A_{1s} \\  A_{21} &  A_{22} & \cdots  & A_{2s} \\ \vdots  & \vdots   & \ddots   & \vdots \\ A_{r1}  &  A_{r2} & \cdots  & A_{rs}\end{bmatrix},则有A^{T}  = \begin{bmatrix} A_{11}^{T}   &  A_{21}^{T}  & \cdots  & A_{r1}^{T}  \\  A_{12}^{T}  &  A_{22}^{T}  & \cdots  & A_{r2}^{T}  \\ \vdots  & \vdots   & \ddots   & \vdots \\ A_{1s}^{T}   &  A_{2s}^{T}  & \cdots  & A_{rs}^{T} \end{bmatrix}\end{align}</script></li><li><p>分块对角矩阵</p><script type="math/tex; mode=display">\begin{align}\displaystyle A =\begin{bmatrix} A_{1}  &   &   &  \\   &  A_{2} &   &  \\   &   & \ddots   &  \\   &  &   & A_{r}\end{bmatrix}\end{align}</script><p>主对角线上的子块 $\displaystyle A_{i} (i=1,2,\dots ,r)$ 均是方阵，其余子块全是零矩阵，则称 $A$ 为分块对角矩阵，记为： $\displaystyle A = diag(A_{1} ,A_{2} ,\dots ,A_{r} )$ 。</p></li></ol><h2 id="1-5-初等变换与初等矩阵"><a href="#1-5-初等变换与初等矩阵" class="headerlink" title="1.5 初等变换与初等矩阵"></a>1.5 初等变换与初等矩阵</h2><h3 id="1-5-1-初等变换"><a href="#1-5-1-初等变换" class="headerlink" title="1.5.1 初等变换"></a>1.5.1 初等变换</h3><p><strong>定义 1.8</strong> ：下面三种变换称为 <strong>矩阵的初等行变换</strong> ：</p><ol><li>交换两行的位置</li><li>以非零数 $k$ 乘以某行</li><li>把某行的 $k$ 倍加到另一行上</li></ol><p>将定义 1.8 的“行”换为“列”，就得到<strong>矩阵的初等列变换</strong> 。矩阵的初等行变换与初等列变换统称为矩阵的<font color='red'>初等变换</font> 。</p><p>如果矩阵<script type="math/tex">A</script> 经过有限次初等变换，得到矩阵 $B$ ，就称矩阵 $A$ 和矩阵 $B$ <strong>等价</strong>，记作：$\displaystyle A\sim B$ 。</p><p><strong>矩阵的等价关系具有以下性质</strong>：</p><ol><li>反身性： $\displaystyle A\sim A$</li><li>对称性： $\displaystyle 若A\sim B,则B\sim A$</li><li>传递性： $\displaystyle 若A\sim B,B\sim C,则A\sim C$</li></ol><p><font color='red'>行阶梯矩阵</font> 是指满足下面两个条件的矩阵：</p><ol><li>如果有零行（元素全为零的行），则零行位于非零行的下方；</li><li>非零行的首个非零元素（亦称为基准或主元素），前面零元的个数从上往下依次增加。</li></ol><p>当行阶梯矩阵进一步满足：非零行的首非零元均为 1 ，且所在列的其余元素均为 0 ，则称为 <font color='red'>最简行阶梯矩阵</font>（或称<font color='red'>行最简形</font>） 。</p><h3 id="1-5-2-初等矩阵"><a href="#1-5-2-初等矩阵" class="headerlink" title="1.5.2 初等矩阵"></a>1.5.2 初等矩阵</h3><p><strong>定义 1.9</strong> ： $n$ 阶单位矩阵 $E$ 经过一次初等变换所得到的矩阵称为 <font color='red'>初等矩阵</font> 或 <font color='red'>初等方阵</font> 。</p><p><strong>定理 1.2</strong> ：设 $A$ 是一个 $m\times n$ 的矩阵，<strong>对 $A$ 施行一次初等行变换，其结果相当于在 $A$ 的左边乘以相应的 $m$ 阶初等矩阵</strong>；对 $A$ 施行一次初等列变换，其结果相当于在 $A$ 的右边乘以相应的 $n$ 阶初等矩阵。</p><p><strong>定理 1.3</strong> ：设 $A$ 为 $n$ 阶方阵，那么下面命题等价：</p><ol><li>$A$ 是可逆矩阵；</li><li>线性方程组 $Ax=0$ 只有零解；</li><li>$A$ 可以经过有限次初等行变换化为单位矩阵；</li><li>$A$ 可以表示为有限个初等矩阵的乘积。</li></ol><p><strong>逆矩阵的求法（方法一）</strong>：</p><script type="math/tex; mode=display">\begin{align}\begin{bmatrix} A & \vdots   & E\end{bmatrix} &\sim  \begin{bmatrix} E & \vdots   & A^{-1} \end{bmatrix}\\\begin{bmatrix} A\\ \dots \\E\end{bmatrix} &\sim  \begin{bmatrix} E\\ \dots \\A^{-1} \end{bmatrix}\end{align}</script><p>对 $n \times 2n$ 矩阵 $\displaystyle \begin{bmatrix}A &amp; \vdots  &amp;B \end{bmatrix} $ 施行若干次初等行变化，当子块 $A$ 化为单位矩阵 $E$ 时，另一个子块 $B$ 就化为了 $A^{-1}B$ 。形式如下：</p><h3 id="1-5-3-矩阵的秩"><a href="#1-5-3-矩阵的秩" class="headerlink" title="1.5.3 矩阵的秩"></a>1.5.3 矩阵的秩</h3><p><strong>定义 1.10</strong> ：设 $A$ 为 $m\times n$ 矩阵， $B$ 是与 $A$ 等价的行阶梯矩阵。若矩阵 $B$ 的非零行的个数为 $r$ ，则称矩阵 $B$ 的<font color='red'>秩</font>为 $r$ ，矩阵 $A$ 的之也为 $r$ ，记作 $\displaystyle R(A) = R(B)  = r$ 。</p><p><strong>矩阵秩的性质</strong>如下：</p><ol><li><p>$\displaystyle R(A) =R(A^{T} )$ ；</p></li><li><p>$R(A)=0\iff A=O$ ；</p></li><li><p>$\displaystyle 0\le R(A_{m\times n} )\le \text{min} \left \{ m,n \right \} $ ；</p></li><li><p>若 $A\sim B$ ，则 $\displaystyle R(A) = R(B)$ ；</p></li><li><p>$\displaystyle R\begin{bmatrix}A &amp; O\\O &amp; B\end{bmatrix} = R(A) +R(B)$ ；</p></li><li><p>${\color{Red} \displaystyle \text{max}\left \{ R(A),R(B) \right \} \le R(A,B)\le R(A)+R(B)} $</p></li><li><p>$\displaystyle R(A\pm B)\le R(A)+R(B)$ ；</p></li></ol><ul><li>证明：<script type="math/tex; mode=display">\begin{align}\displaystyle \begin{bmatrix} A & O\\ O &B\end{bmatrix}\sim \displaystyle \begin{bmatrix} A & O\\ A &B\end{bmatrix}\sim \displaystyle \begin{bmatrix} A & A\\ A &A+B\end{bmatrix}\end{align}</script>所以<script type="math/tex; mode=display">\displaystyle R(A)+R(B) = R\begin{bmatrix} A & A\\ A &A+B\end{bmatrix}\ge R(A+B)</script>同理可证<script type="math/tex; mode=display">\displaystyle R(A)+R(B)\ge R(A- B)</script></li></ul><ol><li><p>若 $A$ 为 $n$ 阶方阵，则 $\displaystyle R(A)=n\Longleftrightarrow A 是可逆矩阵$ ；</p></li><li><p>$\displaystyle R(AB)\le\text{min} \left \{ R(A),R(B) \right \} $ （<strong>乘法矩阵的秩在减小，只有都是满秩才取等</strong>）；</p></li><li><p>若 $P,Q$ 可逆，则 $\displaystyle R(A) = R(PA)=R(AQ)=R(PAQ)$ （可逆矩阵不影响矩阵的秩，可逆矩阵一定是满秩）；</p></li><li><p>若 $A,B$ 均为 $n$ 阶方阵，则 $\displaystyle R(AB)\ge R(A)+R(B)-n$ ；</p><p>（ $\displaystyle R(A)+R(B)-n\le R(AB)\le \text{min}\left \{ R(A),R(B) \right \} $ ，上式被称为<font color='red'>西尔维斯特不等式</font>）；</p></li><li><p>若 $\displaystyle A_{m\times n}B_{n\times l} =O$ ，则 $\displaystyle R(A)+R(B)\le n$ ；</p></li><li><script type="math/tex; mode=display">\begin{align}\displaystyle A_{m\times n} \text{行满秩}\Longleftrightarrow  R(A) & = n\Longleftrightarrow A的标准等价性\begin{bmatrix}I_{m} &O\end{bmatrix}\\\displaystyle A_{m\times n} \text{列满秩}\Longleftrightarrow  R(A) & = n\Longleftrightarrow A的标准等价性\begin{bmatrix}I_{n}  \\O\end{bmatrix}\end{align}</script></li><li><p><code>Frobenius</code>不等式： $\displaystyle R(ABC)\ge R(AB)+R(BC)-R(B)$ ；</p></li><li><p>$\displaystyle R(A_{m\times n} )=n\Longleftrightarrow \text{齐次方程组}  Ax=0 \text{只有零解}$ 。</p></li></ol><h2 id="1-6-线性方程组的解"><a href="#1-6-线性方程组的解" class="headerlink" title="1.6 线性方程组的解"></a>1.6 线性方程组的解</h2><p><strong>定理 1.4</strong> ：齐次线性方程组 $\displaystyle A_{m\times n}X=0$ 有非零解的<strong>充分必要</strong>条件是 $\displaystyle R(A) =r$ ，且有无穷多解，自由量为 $n-r$ 个。</p><p><strong>定理 1.5</strong> ：非齐次线性方程组 $\displaystyle A_{m\times n}X=b$ 有解的<strong>充分必要</strong>条件是 $\displaystyle R(A) = R(\widetilde{A} ) = r$ ，其中 $\displaystyle \widetilde{A} =[A,b]$ 为增广矩阵，且当</p><ol><li>$r=n$ 时有唯一解，称为<font color='red'>适定线性方程组</font>；</li><li>$r&lt;n$ 时有无穷多解，自由量为 $n-r$ 个，称为<strong>欠定线性方程组</strong>；</li></ol><p>由上述定理可知：当 $\displaystyle R(A) \ne R(\widetilde{A} )$ ，则线性方程组 $\displaystyle A_{m\times n}X=b$ 无解，称为<font color='red'>超定线性方程组</font>。</p><p>对于无界的线性方程，可求其近似解。</p><h1 id="二、行列式与线性方程组"><a href="#二、行列式与线性方程组" class="headerlink" title="二、行列式与线性方程组"></a>二、行列式与线性方程组</h1><h2 id="2-1-行列式的概念及性质"><a href="#2-1-行列式的概念及性质" class="headerlink" title="2.1 行列式的概念及性质"></a>2.1 行列式的概念及性质</h2><h3 id="2-1-1-二、三阶行列式"><a href="#2-1-1-二、三阶行列式" class="headerlink" title="2.1.1 二、三阶行列式"></a>2.1.1 二、三阶行列式</h3><p>考虑求二元线性方程组</p><script type="math/tex; mode=display">\left\{\begin{matrix} a_{11}x_{1}   & + &  a_{12}x_{2}  & = & b_{1} \\  a_{21}x_{1}  & + &  a_{22}x_{2}  & = & b_{2} \end{matrix}\right.</script><p>的解。当 $a_{1} a_{2}$ 时，由消元法得方程组得唯一解为</p><script type="math/tex; mode=display">\displaystyle \left\{\begin{matrix}\displaystyle  x_{1}  & = & {\large \frac{b_{1}a_{22} -b_{2} a_{12}  }{a_{11} a_{22} -a_{12} a_{21}} } \\\displaystyle  x_{2}  & = & {\large \frac{b_{2}a_{11} -b_{1} a_{21}  }{a_{11} a_{22} -a_{12} a_{21}}}  \end{matrix}\right.</script><p>为了便于记忆，引入记号 $\displaystyle D = \begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}$ ，他表示 $\displaystyle a_{11} a_{22} - a_{12} a_{21}$ ，称为<font color='red'>二阶行列式</font>，即</p><script type="math/tex; mode=display">D = \begin{vmatrix} a_{11}  &  a_{12}  & a_{13}  \\  a_{21}  &  a_{22}  &  a_{23} \\  a_{31}  &  a_{32}  & a_{33} \end{vmatrix}</script><p>称上式中得 $D$ 为<font color='red'>三阶行列式</font>。</p><h3 id="2-1-2-n-阶行列式"><a href="#2-1-2-n-阶行列式" class="headerlink" title="2.1.2 $n$ 阶行列式"></a>2.1.2 $n$ 阶行列式</h3><p><strong>定义 2.1</strong> ：由 $n^{2}$ 个元素 $a_{ij}(i,j=1,2,3,\dots ,n)$ 组成的记号：</p><script type="math/tex; mode=display">\begin{vmatrix} a_{11}  &  a_{12} & \dots  &  a_{1n}\\  a_{21} &  a_{22} & \dots  &  a_{2n}\\ \vdots  & \vdots  & \ddots  &\vdots  \\  a_{n1} &  a_{n2} & \dots  & a_{nn}\end{vmatrix}</script><p>称为<font color='red'> $n$ 阶行列式</font>，该行列式表示一个数，其中横排称为行，竖排称为列。一般地，行列式记作$\displaystyle D,D<em>{n} ,D</em>{n} =\left | a_{ij} \right | ,\quad det(A)\text{或者}\left | A \right | $ 。</p><p><strong>定义 2.2</strong> ：在 $n$ 阶行列式</p><script type="math/tex; mode=display">D=\begin{vmatrix} a_{11}  &  a_{12} & \dots  &  a_{1n}\\  a_{21} &  a_{22} & \dots  &  a_{2n}\\ \vdots  & \vdots  & \ddots  &\vdots  \\  a_{n1} &  a_{n2} & \dots  & a_{nn}\end{vmatrix}</script><p>中划掉元素 $a_{ij}$ 所在的第 $i$ 行与第 $j$ 列所有元素后，剩下的 $(n-1)^{2}$ 个元素按原来的次序构成的 $n-1$ 阶的行列式称为元素 $a_{ij}$ 的<font color='red'>余子式</font>，记作 $\displaystyle M_{ij}$ ，并且称 $\displaystyle (-1)^{i+j}M_{ij} $ 为元素 $a_{ij}$ 的<font color='red'>代数余子式</font>，记作 $A_{ij}$ 。</p><p><strong>定义 2.3</strong> 当 $n=1$ 时，一阶行列式 $\displaystyle D_{1} =\left | a_{11}  \right | =a_{11}$ ，假设 $n-1$ 阶行列式已定义，则 $n$ 阶行列式可定义为：</p><script type="math/tex; mode=display">\displaystyle D = a_{11} A_{11} +a_{12} A_{12}+\dots +a_{1n} A_{1n} = \sum_{k=1}^{n} a_{1k} A_{1k}</script><p>其中 $\displaystyle A_{1k} $ 是元素 $a_{1k}$ 的代数余子式，且全为 $n-1$ 阶行列式，上式也称为 <strong>$n$ 阶行列式按第一行的展开定义</strong>。</p><h3 id="2-1-3-行列式的性质"><a href="#2-1-3-行列式的性质" class="headerlink" title="2.1.3 行列式的性质"></a>2.1.3 行列式的性质</h3><p><strong>性质 2.1</strong> ：行列式与其转置行列式相等，即</p><script type="math/tex; mode=display">\left | A \right |= \left | A^{T}  \right |</script><p><strong>性质 2.2</strong> ：行列式中某行（或列）元素的公因子可以提到行列式之外；</p><p><strong>推论 2.1</strong> ：对于 $n$ 阶矩阵 $A$ ，有 $\displaystyle \left | kA \right | = k^{n} \left | A \right | $ ；</p><p><strong>推论 2.2</strong> ：<strong>某行（或列）元素全为零的行列式等于零</strong>；</p><p><strong>性质 2.3</strong> ：<strong>交换某两行（或列）的位置，行列式的值变号</strong>；</p><p><strong>推论 2.3</strong> ：如果行列式中有两行（或两列）元素相同，则行列式等于零；</p><p><strong>推论 2.4</strong> ：如果行列式中有两行（或两列）对应元素成比例，则行列式等于零；</p><p><strong>性质 2.4</strong> ：若行列式某一行（或列）的元素是两项之和，则该行列式可以写成两个行列式之和，即</p><p><strong>性质 2.5</strong> ：将某一行（或列）的任意 $k$ 倍加到另一行（或列）上去，行列式的值不变。</p><p><strong>定理 2.1（<font color='red'>行列式展开定理</font>）</strong> ： $n$ 阶行列式 $\displaystyle D<em>{n} = \left | a</em>{ij} \right | $ 等于它的任一行（列）的各元素与其对应的代数余子式乘积之和，即</p><script type="math/tex; mode=display">\displaystyle D_{n}  = \sum_{k=1}^{n} a_{ik} A_{ik} \quad (i = 1,2,\dots ,m)</script><p><strong>性质 2.6</strong> ：对于 $n$ 阶行列式 $\displaystyle D_{n} $ ，有</p><script type="math/tex; mode=display">\left\{\begin{matrix}\displaystyle \sum_{j=1}^{n}a_{ij}A_{kj} ,   &\text{当} i\ne k\text{时} \\ \displaystyle \sum_{i=1}^{n}a_{ij}A_{ik},  &\text{当}j\ne k\text{时}\end{matrix}\right.</script><p><strong>性质 2.7（<font color='red'>行列式乘积法则</font>）</strong> ： <script type="math/tex">\displaystyle \left | AB \right | =\left | A \right | \left | B \right |</script> ；</p><h2 id="2-2-行列式的计算"><a href="#2-2-行列式的计算" class="headerlink" title="2.2 行列式的计算"></a>2.2 行列式的计算</h2><p>_暂时省略_</p><h2 id="2-3-行列式的应用"><a href="#2-3-行列式的应用" class="headerlink" title="2.3 行列式的应用"></a>2.3 行列式的应用</h2><h3 id="2-3-1-逆矩阵的计算"><a href="#2-3-1-逆矩阵的计算" class="headerlink" title="2.3.1 逆矩阵的计算"></a>2.3.1 逆矩阵的计算</h3><p>（有关逆矩阵的计算，还有<a href="#1-5-2-初等矩阵">线性代换法</a>）</p><p><strong>定理 2.2</strong> ：矩阵 $A$ 的各个元素的代数余子式$A_{ij}$ 构成如下矩阵</p><script type="math/tex; mode=display">\displaystyle A^{*}  = \begin{bmatrix} A_{11}  & A_{21} & \dots  &A_{n1}\\ A_{12} & A_{22} & \dots  & A_{n2}\\ \vdots  & \vdots  & \ddots  &\vdots  \\ A_{1n} & A_{21} & \dots  &A_{nn}\end{bmatrix}</script><p>即 $\displaystyle A^{\ast } = (A_{ij})^{T} _{n\times n} $ ，称 $\displaystyle A^{\ast }$ 为矩阵 $A$ 的<font color='red'>伴随矩阵</font>，或记作 $\displaystyle \text{adj} A$ ，（也就是代数余子式矩阵的转置矩阵），且伴随矩阵满足下面关系式：</p><script type="math/tex; mode=display">\displaystyle AA^{\ast }  = A^{\ast } A = \left | A \right | E</script><p><strong>推论 2.5</strong> ：当 $\displaystyle \left | A \right | \ne 0$ 时，有 $\displaystyle \left | A^{\ast } \right | = \left | A \right | ^{n-1} $ ；（ $\displaystyle \left | A \right | \left | A^{*} \right | = \left | A \right | ^{n} $ ）</p><p><strong>定理 2.3</strong> ： $A$ 为可逆矩阵的<strong>充分必要</strong>条件为： $\displaystyle \left | A \right |\ne 0$ ，并且有以下关系</p><script type="math/tex; mode=display">\displaystyle  A^{-1}   = \frac{1}{\left | A \right | } A^{*}</script><p>当 $\displaystyle  \left | A \right | \ne 0$ 时，也称矩阵 $A$ 为<font color='red'>非奇异矩阵或非退化矩阵</font>；当 $\displaystyle  \left | A \right | = 0$ 时，称矩阵为<font color='red'>奇异矩阵或退化矩阵</font>。显然，可逆矩阵是非奇异矩阵。</p><p><strong>定理 2.4</strong> ：设 $\displaystyle A,B\in P^{n\times n} $ ，若 $\displaystyle AB = E_{n} $ ，则 $A$ 和 $B$ 都可逆，并且</p><script type="math/tex; mode=display">\displaystyle A^{-1} =B,B^{-1}  =A</script><h3 id="2-3-2-克莱默（Cramer）法则"><a href="#2-3-2-克莱默（Cramer）法则" class="headerlink" title="2.3.2 克莱默（Cramer）法则"></a>2.3.2 克莱默（<code>Cramer</code>）法则</h3><p><strong>定理 2.4（<code>Cramer</code>）</strong> ：对线性方程组，当系数行列式 $\displaystyle D\ne 0$ 时，该方程组有唯一解，其解为</p><p>（_暂时略_）</p><p><strong>推论 2.6</strong> ：齐次线性方程组 $\displaystyle Ax =0$ 有非零解的充分必要条件是 $\displaystyle\left | A \right | =0$ 。系数行列式 $\displaystyle\left | A \right | \ne 0$ 时，该方程只有一个零解。零解也被称为<strong>平凡解</strong>；不全为零的解被称为<strong>非零解</strong>。</p><h1 id="三、向量与向量空间"><a href="#三、向量与向量空间" class="headerlink" title="三、向量与向量空间"></a>三、向量与向量空间</h1><h2 id="3-1-向量及其运算"><a href="#3-1-向量及其运算" class="headerlink" title="3.1 向量及其运算"></a>3.1 向量及其运算</h2><h3 id="3-1-1-n-维向量"><a href="#3-1-1-n-维向量" class="headerlink" title="3.1.1 $n$ 维向量"></a>3.1.1 $n$ 维向量</h3><p><strong>定义 3.1</strong> ： $n$ 个有序的数 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{n} $ 构成的数组称为 <font color='red'>$n$ 维向量</font>。这 $n$ 个数成为该向量的 $n$ 个分量， $n$ 也称为该向量的长度， $n$ 维向量为</p><script type="math/tex; mode=display">\begin{align}a &= \begin{bmatrix}a_{1}   & a_{2}  &  \cdots &a_{n} \end{bmatrix}\\a &= \begin{bmatrix}a_{1}   \\ a_{2} \\  \cdots \\a_{n} \\\end{bmatrix}\end{align}</script><p>称其为<font color='red'>行向量</font>或<font color='red'>列向量</font>。如果没有指明是行向量还是列向量，均以列向量对待。</p><h3 id="3-1-2-向量的运算"><a href="#3-1-2-向量的运算" class="headerlink" title="3.1.2 向量的运算"></a>3.1.2 向量的运算</h3><p>向量加法和数乘称为<strong>向量的线性运算</strong>。向量的线性运算法则：</p><ol><li>$\displaystyle \alpha +\beta = \beta+\alpha $ ；</li><li>$\displaystyle (\alpha +\beta )+\gamma =\alpha +(\beta +\gamma)$ ；</li><li>$\displaystyle \alpha +O = \alpha $ ；</li><li>$\displaystyle  \alpha +(-\alpha ) =O$ ；</li><li>$\displaystyle  1\alpha =\alpha$ ；</li><li>$\displaystyle (kl)\alpha =k\left ( l\alpha \right ) =l\left ( k\alpha \right ) $ ；</li><li>$\displaystyle  (k+l)\alpha =k\alpha  +l\alpha$ ；</li><li>$\displaystyle k(\alpha + \beta ) = k\alpha +k\beta $ ；</li></ol><h2 id="3-2-向量组的线性相关"><a href="#3-2-向量组的线性相关" class="headerlink" title="3.2 向量组的线性相关"></a>3.2 向量组的线性相关</h2><h3 id="3-2-1-向量组的线性表示"><a href="#3-2-1-向量组的线性表示" class="headerlink" title="3.2.1 向量组的线性表示"></a>3.2.1 向量组的线性表示</h3><p><strong>定义 3.2</strong> ：</p><ol><li>设 $n$ 维向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{s} $ ，对于任意一组实数 $\displaystyle k_{1} ,k_{2} ,\dots  ,k_{s} $ ，称 $\displaystyle k_{1}a_{1} +k_{2}a_{2} +\dots +k_{s}a_{s}$ 是向量组的一个<font color='red'>线性组合</font>，其中 $\displaystyle k<em>{1} ,k</em>{2} ,\dots ,k_{s} $ 为组合系数。</li><li>设 $b$ 为 $n$ 维向量，若存在一组数 $\displaystyle \lambda _{1} ,\lambda _{2} ,\dots ,\lambda _{s} $ ，使得 $\displaystyle b = \lambda _{1}a_{1} +\lambda _{2}a_{2} +\dots +\lambda _{s}a_{s}$ ，则称向量 $b$ 可以由向量组 $\displaystyle a<em>{1} ,a</em>{2} ,\dots ,a_{s} $ <font color='red'>线性表示</font>。</li><li>易知，零向量可由任何一向量组线性表示</li></ol><p><strong>$n$ 维向量组 $\displaystyle e_{1}  = \left [ 1,0,\dots ,0 \right ]^{T},e_{2}  = \left [ 0,1,\dots ,0 \right ] ^{T} ,\dots ,e_{n}  = \left [ 0,0,\dots ,1 \right ] ^{T} ,$ 为 $n$ 维<font color='red'>基本单位向量组</font></strong>。</p><h3 id="3-2-2-向量组与矩阵及线性方程组间的关系"><a href="#3-2-2-向量组与矩阵及线性方程组间的关系" class="headerlink" title="3.2.2 向量组与矩阵及线性方程组间的关系"></a>3.2.2 向量组与矩阵及线性方程组间的关系</h3><ol><li><p>向量组与矩阵的关系</p><script type="math/tex; mode=display">\displaystyle A = \begin{vmatrix} a_{11}  & a_{12} & \dots  & a_{1n}\\ a_{21} & a_{22} & \dots  &a_{2n} \\ \vdots  & \vdots  &  &\vdots  \\ a_{m1} & a_{m2} & \dots  &a_{mn}\end{vmatrix} = \begin{bmatrix}\beta _{1}  \\\beta _{2} \\\vdots  \\\beta _{m}\end{bmatrix}=\begin{bmatrix}\alpha _{1}   & \alpha _{2} & \dots  &\alpha _{n}\end{bmatrix}</script></li><li><p>向量组与线性方程组的关系</p><p>（_暂时略_）</p></li></ol><h3 id="3-2-3-向量组的线性相关性定义及性质"><a href="#3-2-3-向量组的线性相关性定义及性质" class="headerlink" title="3.2.3 向量组的线性相关性定义及性质"></a>3.2.3 向量组的线性相关性定义及性质</h3><p><strong>定义 3.3</strong> ：设有 $n$ 维向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{m} $ ，如果存在<strong>不全为零</strong>的一组数 $\displaystyle k_{1},k_{2},\dots ,k_{m}$ ，使得</p><script type="math/tex; mode=display">\displaystyle k_{1}a_{1}+k_{2}a_{2}+\dots +k_{m}a_{m}=0</script><p>则称向量组 $\displaystyle a<em>{1} ,a</em>{2} ,\dots ,a<em>{m} $ <font color='red'>线性相关</font>；反之，称向量组 $\displaystyle a</em>{1} ,a<em>{2} ,\dots ,a</em>{m} $ <font color='red'>线性无关</font>。</p><p>根据 <code>定义 3.3</code>，我们能得到以下结论：</p><ol><li>包含零向量的向量组必定线性相关；</li><li>当向量组只有一个向量 $\displaystyle \alpha $ 时，若 $\displaystyle \alpha =0$ ，则线性相关；反之，则线性无关；</li><li>非零向量组 $\displaystyle a_{1},a_{2}  $ 线性相关的<strong>充分必要</strong>条件为 $\displaystyle a_{1} = ka_{2}  $ ，即向量 $\displaystyle a_{1}$ 与向量 $\displaystyle a_{2}$ 对应分量成比例。</li></ol><p><strong>定理 3.1</strong> ：向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{m} $ 线性相关的<strong>充分必要</strong>条件为，至少存在一个向量 $a_{i}$ 可以用其余向量线性表示。</p><p><strong>定理 3.2</strong> ：设 $A$ 是 $m\times n$ 矩阵，则矩阵 $A$ 的列向量组线性相关（无关）的<strong>充分必要</strong>条件为齐次线性方程组 $Ax=0$ 有非零解（只有零解）</p><h2 id="3-3-向量组的秩与极大无关组"><a href="#3-3-向量组的秩与极大无关组" class="headerlink" title="3.3 向量组的秩与极大无关组"></a>3.3 向量组的秩与极大无关组</h2><p><strong>定义 3.4</strong> ：设有向量组 Ⅰ：$\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ 和Ⅱ：$\displaystyle \beta _{1},\beta _{2},\cdots ,\beta _{s} $ 。若<strong>向量组 Ⅰ 中的每一个向量都能用向量组 Ⅱ 线性表示</strong>，则称<strong>向量组 Ⅰ 可由向量组 Ⅱ 线性表示</strong>。如果向量组 Ⅰ 与 Ⅱ 可以相互线性表示，则称<strong>向量组 Ⅰ 和 Ⅱ 等价</strong>。</p><p><strong>定义 3.5</strong> ：设有向量组：$\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ ，而 $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{r}$ 是向量组 Ⅰ 中的 $r$ 个向量（$r\le s$），若满足：</p><ol><li>向量组 $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{r} $ 线性无关；</li><li>向量组 $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ 中任 $r+1$ 个向量（如果向量组中有 $r+1$ 个向量）线性相关；</li></ol><p>则称向量组 $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{r} $ 是向量组Ⅰ $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ 的一个<font color='red'>最大线性无关向量组</font>，简称<font color='red'>极大无关组</font>，极大无关组的个数 <script type="math/tex">r</script> 称为向量组的秩，记作 $\displaystyle R(a_{1},a_{2},\cdots ,a_{s} ) = r$ 。</p><p>对于 $m\times n$ 阶矩阵 $A$ ， $A$ 的行（列）向量组的秩称为 $A$ 的<font color='red'>行（列）秩</font>。</p><hr><p><strong>定理 3.3</strong> ：阶梯形矩阵 $J$ 的行秩和列秩相等，恰等于 $J$ 的非零行数，并且 $J$ 的主元所在列构成列向量的一个极大无关组。</p><p><strong>定理 3.4</strong> ：矩阵的初等行（列）变换不改变矩阵的列（行）向量的线性相关性，从而不改变矩阵的列（行）秩。</p><p><strong>定理 3.5</strong> ：矩阵 $A$ 的秩等于 $A$ 的行秩，也等于 $A$ 的列秩。</p><p><strong>定理 3.6</strong> ：设 $A$ 是 $m\times n$ 阶矩阵，则</p><ul><li>矩阵 $A$ 的列向量组线性相关（无关）的<strong>充分必要</strong>条件为 $\displaystyle R(A)$</li><li>矩阵 $A$ 的行向量组线性相关（无关）的<strong>充分必要</strong>条件为 $\displaystyle R(A)$</li></ul><h2 id="3-4-向量空间"><a href="#3-4-向量空间" class="headerlink" title="3.4 向量空间"></a>3.4 向量空间</h2><h3 id="3-4-1-向量空间的定义"><a href="#3-4-1-向量空间的定义" class="headerlink" title="3.4.1 向量空间的定义"></a>3.4.1 向量空间的定义</h3><p><strong>定义 3.6</strong> ：设 $V$ 是非空 $n$ 维向量的集合。如果 $V$ 对向量的<strong>加法</strong>和<strong>数乘</strong>运算封闭，即：（1）若 $\displaystyle a,b\in V$ ，有 $\displaystyle a+b\in V$ ；（2）若 $\displaystyle a\in V\quad\lambda \in R(实数)$ ，有 $\displaystyle a\in V\quad\lambda \in R(实数)$ ；则称 $V$ 为一个<font color='red'>向量空间</font>。</p><p><strong>定义 3.7</strong> ：设 $V$ 与 $H$ 都是向量空间，如果 $\displaystyle H\subseteq V$ ，则称 $H$ 是 $V$ 的<font color='red'>子空间</font>。</p><p>特别地，向量空间 $V$ 中仅有零向量组成的集合是 $V$ 的一个子空间，称为<strong>零子空间</strong>。由任何 $n$ 维向量组成的向量空间 $V$ 都是 $\displaystyle R^{n} $ 的子空间。</p><p><strong>定义 3.8</strong> ：已知 $A$ 为 $n$ 阶<strong>方阵</strong>，称映射 $\displaystyle f:R^{n} \longrightarrow R^{n} ,x\longrightarrow  y,y =Ax$ 为 $\displaystyle R^{n} $ 上的线性变换。 $A$ 称为线性变换矩阵。</p><h3 id="3-4-2-向量的内积与正交矩阵"><a href="#3-4-2-向量的内积与正交矩阵" class="headerlink" title="3.4.2 向量的内积与正交矩阵"></a>3.4.2 向量的内积与正交矩阵</h3><p><strong>定义 3.9</strong> ：设 $n$ 维向量 $\displaystyle x = [x_{1},x_{2},\dots ,x_{n} ]^{T} ,y = [y_{1},y_{2},\dots ,y_{n} ]^{T} $ ，称</p><script type="math/tex; mode=display">\displaystyle \left \langle x,y \right \rangle  = x^{T} y=x_{1}y_{1} +x_{2}y_{2}+\dots +x_{n}y_{n}</script><p>为向量 $x,y$ 的<font color='red'>内积</font>。</p><p><strong>内积的性质</strong>：</p><ol><li>$\displaystyle \left \langle x,y \right \rangle = \left \langle y,x \right \rangle $ ；</li><li>$\displaystyle \left \langle kx,y \right \rangle  = \left \langle x,ky \right \rangle =k \left \langle x,y \right \rangle$ ；</li><li>$\displaystyle \left \langle x+y,z \right \rangle = \left \langle x,z \right \rangle +\left \langle y,z \right \rangle $ ；</li><li>$\displaystyle \left \langle x,x \right \rangle  \ge 0(\text{ 当且仅当}x=0\text{时取等} )$ ；</li></ol><p><strong>定义 3.10</strong> ：设 $n$ 维向量 $\displaystyle x = [x_{1},x_{2},\dots ,x_{n} ]^{T}$ ，称</p><script type="math/tex; mode=display">\left \| x \right \|  = \sqrt{x^{T} x}  = \sqrt{\left \langle x,x \right \rangle } =\sqrt{x_{1}^{2}+x_{2}^{2}+\dots +x_{n}^{2}}</script><p>为向量 $x$ 的<font color='red'>范数</font>。</p><p><strong>向量的范数的性质</strong>：</p><ol><li>非负性： $\displaystyle \left | x \right | \ge 0(当且仅当x=0时取等)$ ；</li><li>齐次性： $\displaystyle \left | kx \right | =k\left | x \right | $ ；</li><li>三角不等式： $\displaystyle \left | x+y \right | \le \left | x \right | +\left | y \right | $ ；</li><li>特别地，范数为 1 的向量被称为<font color='red'>单位向量</font>；称 $\displaystyle \frac{1}{\left | x \right | } x(x\ne 0)$ 为 $x$ 的单位向量，也称将向量$x$ 单位化，记 $\displaystyle x^{\circ}   =  \frac{1}{\left | x \right | } x$ 。</li></ol><p><strong>定义 3.11</strong> ：设 $x,y$ 是 $n$ 维非零向量，称</p><script type="math/tex; mode=display">\displaystyle \theta  = \arccos \frac{\left \langle x^{T} y \right \rangle }{\left \| x \right \|+\left \| y \right \|  }</script><p>为<font color='red'>向量 $x,y$ 的夹角</font>。特别地，当 $\displaystyle x^{T} y=0$ 时， <script type="math/tex">\displaystyle \theta  = \pm \frac{\pi }{2}</script> ，这时，称向量 $x$ 与 $y$ <font color='red'>正交（或垂直）</font>。显然，零向量与任何向量正交。</p><p>两两正交的向量组称为<font color='red'>正交向量组</font>。由单位向量构成的正交向量组称为标准（规范）正交向量组。</p><p><strong>定理 3.7</strong> ：<strong>不含零向量</strong>的正交向量组 $\displaystyle a<em>{1},a</em>{2} ,\dots ,a_{m} $ 必定<strong>线性无关</strong>。</p><p>⭐<font color='red'>施密特（Schmidt）正交化方法</font>：</p><p>设向量组 $\displaystyle a<em>{1},a</em>{2} ,\dots ,a_{m} $ 线性无关，令</p><script type="math/tex; mode=display">\begin{align}\displaystyle \beta _{1} & =a_{1} \\\displaystyle \beta _{2} & =a_{2} -\frac{\beta _{1}^{T}a_{2}}{\beta _{1}^{T} \beta _{1}}\beta _{1}\\\displaystyle \beta _{3} & =a_{3} -\frac{\beta _{1}^{T}a_{3}}{\beta _{1}^{T} \beta _{1}}\beta _{1}-\frac{\beta _{2}^{T}a_{3}}{\beta _{2}^{T} \beta _{2}}\beta _{2}\\\displaystyle &\dots \\\displaystyle \beta _{m} & =a_{m} -\sum_{j=1}^{m-1} \frac{\beta _{j}^{T}a_{m}}{\beta _{j}^{T} \beta _{j}}\beta _{j}\\\end{align}</script><p>则 $\displaystyle \beta _{1} ,\beta _{2} ,\dots ,\beta _{m} $ 是与 $\displaystyle a_{1},a<em>{2} ,\dots ,a</em>{m} $ 等价的正交向量组。</p><p><strong>定理 3.12</strong> ：设 $A$ 为 $n$ 阶方阵。若满足 $\displaystyle A^{T} A=E$ ，则称 $A$ 为正交矩阵。</p><p><strong>定理 3.8</strong> ： $n$ 阶方阵 $A$ 为正交矩阵的<strong>充分必要</strong>条件为$A$ 的列（行）向量组是标准正交组。</p><h2 id="3-5-基、维数与坐标"><a href="#3-5-基、维数与坐标" class="headerlink" title="3.5 基、维数与坐标"></a>3.5 基、维数与坐标</h2><h3 id="3-5-1-向量空间的基与维数"><a href="#3-5-1-向量空间的基与维数" class="headerlink" title="3.5.1 向量空间的基与维数"></a>3.5.1 向量空间的基与维数</h3><p><strong>定义 3.13</strong> ：设 $V$ 是向量空间，如果向量 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}  \in V$ ，满足</p><ol><li>$\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 线性无关；</li><li>$V$ 中的任一向量都可由 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 线性表示；</li></ol><p>则称向量组 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 是向量空间 $V$ 的一组<font color='red'>基</font>， $r$ 称为向量空间 $V$ 的<font color='red'>维数</font>，记为 $\displaystyle \text{dim}V=r $ ，<strong>规定零向量构成的向量空间维数为零</strong>。</p><p>若 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 是向量空间 $V$ 的<strong>两两正交</strong>的一组基，则称 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 是向量空间 $V$ 的<strong>正交基</strong>。当 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 是单位向量时，称 <script type="math/tex">\displaystyle a_{1},a_{2} ,\dots ,a_{r}</script> 是向量空间 $V$ 的<font color='red'>标准正交基（或规范正交基）</font>。如 $\displaystyle e_{1} ,e_{2},\dots ,e_{n}$ 是向量空间 $R^{n}$ 的一组标准正交基。</p><h3 id="3-5-2-向量的坐标"><a href="#3-5-2-向量的坐标" class="headerlink" title="3.5.2 向量的坐标"></a>3.5.2 向量的坐标</h3><p><strong>定义 3.14</strong> ：设 $V$ 是 $n$ 维向量空间， $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 是 $V$ 的一组基，则 $V$ 中的任一向量 $x$ 可由$\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ <strong>唯一线性表示</strong>为 $\displaystyle x = x_{1} a_{1} +x_{2}a_{2}+\dots +x_{n}a_{n}$ ，数组 $\displaystyle x_{1} ,x_{2},\dots ,x_{n}$ 称为向量 $x$ 在基 $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 下的<font color='red'>坐标</font>，记为 $\displaystyle [x_{1} ,x_{2},\dots ,x_{n}]^{T} $ 。</p><p>设 $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 与 $\displaystyle \beta _{1} ,\beta _{2} ,\dots  ,\beta _{n} $ 是 $n$ 维向量空间 $V$ 的两组基，则 $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 与 $\displaystyle \beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 等价，从而 $\displaystyle \beta _{j} = k<em>{1j}a</em>{1} +k<em>{2j}a</em>{2} +\dots +k<em>{nj}a</em>{n}\quad (j = 1,2,\dots ,n) $ ，即</p><script type="math/tex; mode=display">\displaystyle \left [ \beta _{1},\beta _{2},\dots ,\beta _{n}  \right ]=\left [ \alpha  _{1},\alpha_{2},\dots ,\alpha _{n}  \right ]\begin{bmatrix} k_{11}  & \dots  &  k_{1n}\\ \vdots  & \ddots  & \vdots \\  k_{n1} & \dots  & k_{nn}\end{bmatrix}=\left [ \alpha  _{1},\alpha_{2},\dots ,\alpha _{n}  \right ] K</script><p>称矩阵 $K$ 为由基 $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 到基 $\displaystyle \beta _{1} ,\beta _{2} ,\dots  ,\beta _{n} $ 的<font color='red'>过渡矩阵</font>，并称上式为由基 <script type="math/tex">\displaystyle a*{1} ,a*{2},\dots ,a*{n}</script> 到基 $\displaystyle \beta <em>{1} ,\beta _{2} ,\dots ,\beta _{n} $ 的<font color='red'>基变换公式</font>，<em>*过度矩阵 $K$ 是可逆的</em></em>。🍁</p><h2 id="3-6-线性方程组解的结构"><a href="#3-6-线性方程组解的结构" class="headerlink" title="3.6 线性方程组解的结构"></a>3.6 线性方程组解的结构</h2><p><strong>定理 3.9</strong> ：（1）线性方程$\displaystyle Ax=b$ 有解的充分必要条件为 $\displaystyle R(A) = R(\widetilde{A} )$ ；（2）若 $\displaystyle R(A) = R(\widetilde{A} ) = r$ ，则 $\displaystyle Ax=b$ 当且仅当 $r = n$ 时，有<strong>唯一解</strong>。</p><h3 id="3-6-1-齐次方程方程组解的结构"><a href="#3-6-1-齐次方程方程组解的结构" class="headerlink" title="3.6.1 齐次方程方程组解的结构"></a>3.6.1 齐次方程方程组解的结构</h3><p><strong>性质 3.1</strong> ：设 $\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n} $ 是 $Ax=0$ 的解，则 $\displaystyle c_{1} \xi _{1} +c_{2}\xi _{2} +\dots +c_{n}\xi _{n} $ 也是 $Ax=0$ 的解，其中 $c_{i}$ 为任意常数。</p><p>证明：因为$\displaystyle A(c_{1} \xi _{1} +c_{2}\xi _{2} +\dots +c_{n}\xi _{n} ) = c_{1}A\xi _{1} +c_{2}A\xi _{2}+\dots +c_{n}A\xi _{n}=0$ ，所以</p><script type="math/tex; mode=display">\displaystyle c_{1} \xi _{1} +c_{2}\xi _{2} +\dots +c_{n}\xi _{n}</script><p>也是 $Ax=0$ 的解。</p><p>🔥 由此性质可知，对齐次线性方程组 $Ax=0$ 的任意两个解$x,y$ ，有 $x+y$ 和 $\lambda x$ 仍然为齐次方程组的解，即 $Ax=0$ 的解集 $N(A)$ 为向量空间，称之为齐次线性方程组 $Ax=0$ 的<font color='red'>解空间</font>。</p><p>齐次线性方程组 $Ax=0$ 的解空间的一组基 $\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n-r} $ 也称为 $Ax=0$ 的一个<font color='red'>基础解系</font>。换言之，基础解系 $\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n-r} $ 是 $Ax=0$ 的解向量，且满足</p><ol><li>$\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n-r} $ 线性无关；</li><li>$Ax=0$ 的任一解均由 $\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n-r} $ 线性表示；</li></ol><p><strong>定理 3.10</strong> ：设 $n$ 元齐次线性防尘组 $\displaystyle A_{m\times n} x=0,R(A)=r\le n$ ，则 $Ax=0$ 的解空间的维数为 $n-r$</p><p><strong>推论 3.2</strong> ：若 $\displaystyle A_{m\times n} B_{n\times s} =0$ ，则 $\displaystyle R(A)+R(B)\le n$ 。</p><h3 id="3-6-2-非齐次线性方程组解的结构"><a href="#3-6-2-非齐次线性方程组解的结构" class="headerlink" title="3.6.2 非齐次线性方程组解的结构"></a>3.6.2 非齐次线性方程组解的结构</h3><p><strong>性质 3.2</strong> ：设 $\displaystyle \eta _{1},\eta _{2},\dots ,\eta _{n} $ 为 $\displaystyle Ax=b$ 的解，且 $\displaystyle \eta = c<em>{1}\eta </em>{1}+c<em>{2}\eta </em>{2}+\dots +c<em>{n}\eta </em>{n} $ 。</p><ul><li>当 $\displaystyle c_{1} +c_{2}+\dots +c_{n}=0$ 时， $\eta $ 为 $\displaystyle Ax=0$ 的解；</li><li>当 $\displaystyle c_{1} +c_{2}+\dots +c_{n}=1$ 时， $\eta $ 为 $\displaystyle Ax=b$ 的解；</li><li>特别地， $\displaystyle \frac{1}{n}\sum_{k=1}^{n} \eta _{k}$ 为 $\displaystyle Ax=b$ 的解。</li></ul><p><strong>性质 3.3</strong> ：设 $\xi $ 为 $\displaystyle Ax=0$ 的解， $\eta $ 为 $\displaystyle Ax=b$ 的解，那么 $x = \xi +  \eta $  仍为 $\displaystyle Ax=b$ 的解。</p><h2 id="3-7-超定线性方程组的最小二乘解"><a href="#3-7-超定线性方程组的最小二乘解" class="headerlink" title="3.7 超定线性方程组的最小二乘解"></a>3.7 超定线性方程组的最小二乘解</h2><p>（_略_）</p><h1 id="四、相似矩阵与二次型"><a href="#四、相似矩阵与二次型" class="headerlink" title="四、相似矩阵与二次型"></a>四、相似矩阵与二次型</h1><h2 id="4-1-特征值与特征向量"><a href="#4-1-特征值与特征向量" class="headerlink" title="4.1 特征值与特征向量"></a>4.1 特征值与特征向量</h2><h3 id="4-1-1-定义与计算"><a href="#4-1-1-定义与计算" class="headerlink" title="4.1.1 定义与计算"></a>4.1.1 定义与计算</h3><p><strong>定义 4.1</strong> ：设 $\displaystyle A = (a_{ij} )$ 为 $n$ 阶方阵，如果存在数 $\lambda $ 和 $n$ 维<strong>非零列向量</strong> $a$ ，使得</p><script type="math/tex; mode=display">\displaystyle Aa = \lambda a</script><p>则称数 $\lambda $ 为矩阵 $A$ 的<font color='red'>特征值</font>，非零列向量 $a$ 称为矩阵 $A$ 的对应于特征值 $\lambda $ 的<font color='red'>特征向量</font>。</p><p>由上式可知， $a$ 是矩阵 $A$ 对应于特征值 $\lambda $ 的特征向量，则 $a$ 必定是 $n$ 元齐次线性方程组</p><script type="math/tex; mode=display">\displaystyle (\lambda E-A)x = 0</script><p>的非零解；反过来，齐次线性方程组的任一非零解，也一定是 <script type="math/tex">A</script> 对应于特征值 <script type="math/tex">\lambda</script> 的特征向量。由线性方程组解的理论可知，齐次线性方程组有非零解的充分必要条件是其系数矩阵的行列式 <script type="math/tex">\displaystyle \left | \lambda E-A \right |</script> 的值等于零，即</p><script type="math/tex; mode=display">\displaystyle \left | \lambda E-A \right |  =\begin{vmatrix} \lambda -a_{11}  & -a_{12} & \dots  & -a_{1n}\\ -a_{21} &\lambda-a_{22} & \cdots  &-_{2n}  \\\vdots  & \vdots  & \ddots  & \vdots \\ -a_{n1} & -a_{n2} & \cdots  &\lambda-a_{nn}\end{vmatrix}=0</script><p>设 <script type="math/tex">A</script> 为 <script type="math/tex">n</script> 阶矩阵，那么矩阵 <script type="math/tex">\displaystyle \lambda E-A</script> 称为 <script type="math/tex">A</script> 的<font color='red'>特征矩阵</font>，其行列式 <script type="math/tex">\displaystyle \left | \lambda E-A \right |</script> 是 <script type="math/tex">\displaystyle \lambda</script> 的一元 <script type="math/tex">n</script> 次多项式，称为 <script type="math/tex">A</script> 的<font color='red'>特征多项式</font>，方程 <script type="math/tex">\displaystyle \left | \lambda E-A \right | =0</script> 称为 <script type="math/tex">A</script> 的特征方程。</p><h3 id="4-1-2-特征值与特征向量的性质"><a href="#4-1-2-特征值与特征向量的性质" class="headerlink" title="4.1.2 特征值与特征向量的性质"></a>4.1.2 特征值与特征向量的性质</h3><p><strong>性质 4.1</strong> ：设 $\lambda $ 是 $n$ 阶矩阵 $A$ 的任一特征值， $a$ 为其对应的特征向量，则 $f(\lambda)$ 是矩阵多项式 $f(A)$ 的特征值，其对应的特征向量仍为 $a$ ，其中 $\displaystyle f(x) = a_{0} x^{m}+\dots + a_{m-1} x+a_{m} $ ，即为 $x$ 的 $m$ 次多项式。</p><p><strong>性质 4.2</strong> ：设 $\lambda $ 为 $n$ 阶矩阵$A$ 的任一非零特征值， $a$ 为其对应的特征向量，则 $A$ 的伴随矩阵 $\displaystyle A^{\ast }$ 的特征值为 $\displaystyle \frac{\left | A \right | }{\lambda } $ 。</p><p><strong>性质 4.3</strong> ：若矩阵 $A$ 可逆，则 $\displaystyle \frac{1 }{\lambda } $ 是 $A^{-1}$ 的特征值。</p><p><strong>性质 4.4</strong> ：设 $n$ 阶矩阵$\displaystyle A=(a_{ij} )$ 的 $n$ 个特征值为 $\displaystyle \lambda _{1} , \lambda _{2}, \dots , \lambda _{n}$ （重根按重数计算），则</p><ol><li>$\displaystyle \lambda _{1} +\lambda _{2}+\dots +\lambda _{n} = a_{1}+a<em>{2}+\dots +a</em>{n} $ ；</li><li>$\displaystyle \lambda _{1}\lambda _{2}\dots\lambda _{n} = \left | A \right | $ ；</li></ol><p><strong>推论 4.1</strong> ：设 <script type="math/tex">A</script> 为 $n$ 阶矩阵，则 $A$ 可逆的充分必要条件是 $A$ 的所有特征值均<strong>非零</strong>。</p><p>$n$ 阶方阵 $A$ 的<strong>主对角线</strong>上所有元素之和 $\displaystyle a_{11}+a_{22}+\dots +  a_{nn}$ 称为 $A$ 的<font color='red'>迹</font>，记作 $\displaystyle \text{tr}(A) $ ，即</p><script type="math/tex; mode=display">\displaystyle \text{tr}(A) =a_{11}+a_{22}+\dots +  a_{nn}</script><p><strong>定理 4.1</strong> ：若 $\displaystyle \lambda _{1} , \lambda _{2}, \dots , \lambda _{m}$ 是矩阵 $A$ 互不相同的特征值， $\displaystyle a_{1} ,a_{2},\dots ,a_{m}$ 是对应的特征向量，则 $\displaystyle a_{1} ,a_{2},\dots ,a_{m}$ 线性无关。</p><p><strong>定理 4.2</strong> ：设 $\lambda $ 为 $n$ 阶矩阵 $A$ 的一个 $k$ 重特征值，对应于特征值 $\lambda $ 的线性无关的特征向量的最大个数为 $l$ ，则 $k\ge l$ 。</p><p><strong>推论 4.2</strong> ：设 $\displaystyle \lambda _{1} , \lambda _{2}, \dots , \lambda _{m}$ 是 $n$ 阶矩阵 $A$ 的 $m$ 个互不相同的特征值， $\displaystyle a_{i1},a_{i2},\cdots ,a_{ik_{i} }$ 是矩阵 $A$ 对应于特征值 $\displaystyle\lambda _{i} $ 的线性无关的特征向量，则向量组</p><script type="math/tex; mode=display">\displaystyle a_{11},\dots ,a_{1k_{1} },a_{21},\dots ,a_{2k_{2} },\cdots ,a_{m1},\dots ,a_{mk_{m} }</script><p>线性无关。</p><h2 id="4-2-相似矩阵"><a href="#4-2-相似矩阵" class="headerlink" title="4.2 相似矩阵"></a>4.2 相似矩阵</h2><h3 id="4-2-1-相似矩阵的定义与性质"><a href="#4-2-1-相似矩阵的定义与性质" class="headerlink" title="4.2.1 相似矩阵的定义与性质"></a>4.2.1 相似矩阵的定义与性质</h3><p><strong>定义 4.2</strong> ：设 $A,B$ 为 $n$ 阶矩阵，若存在 $n$ 阶可逆矩$P$ ，使得</p><script type="math/tex; mode=display">\displaystyle P^{-1} AP=B</script><p>则称 $A$ 与 $B$ <font color='red'>相似</font>，记作 $\displaystyle A\sim B$ 。相似是矩阵之间的一种等价关系，并且具有以下性质：</p><ol><li>自反性： 对任意 $n$ 阶矩阵 $A$ ，有 $\displaystyle A\sim A$ ；</li><li>对称性： 若 $\displaystyle A\sim B$ ，则 $\displaystyle B\sim A$ ；</li><li>传递性：若 $\displaystyle A\sim B,B\sim C$ ，则 $\displaystyle A\sim C$ 。<br>4.</li></ol><p><strong>定理 4.3</strong> ：如果 $n$ 阶矩阵$A,B$ 相似，则$A$ 与 $B$ 有相同的特征多项式，从而有相同的特征值。</p><p><strong>注意：特征多项式相等是矩阵相似的必要条件，而不是充分条件</strong>。</p><p><strong>性质 4.5</strong> ：若 $A$ 与 $B$ 相似，则有以下结论：</p><ol><li>$A$ 与 $B$ 有相同的<strong>秩</strong>，即 $\displaystyle R(A)=R(B)$ ；</li><li>$A$ 与 $B$ 有相同的<strong>迹</strong>，即 $\displaystyle \text{tr} (A)=\text{tr}(B)$ ；</li><li>$A$ 与$B$ 有相同的<strong>行列式</strong>，即 $\displaystyle \left | A \right | =\left | B \right | $ ；</li><li>若 $\displaystyle A\sim B$ ，且矩阵 $A$ 可逆，则矩阵$B$ 也可逆，且 $\displaystyle A^{-1} \sim B^{-1} $ 。</li></ol><h3 id="4-2-2-矩阵对角化的条件"><a href="#4-2-2-矩阵对角化的条件" class="headerlink" title="4.2.2 矩阵对角化的条件"></a>4.2.2 矩阵对角化的条件</h3><p><strong>定义 4.3</strong> ：设$A$ 为 $n$ 阶矩阵，如果存在一个 $n$ 阶可逆矩阵 $P$ ，使得 $\displaystyle P^{-1}  AP$ 为对角矩阵，则称 $A$ <font color='red'>可对角化</font>。</p><p><strong>定理 4.4</strong> ： $n$ 阶矩阵 $A$ 可对角化的充分必要条件是 $A$ 有 $n$ 个线性无关的特征向量。</p><p><strong>推论 4.3</strong> ：如果 $n$ 阶矩阵 $A$ 的 $n$ 个特征值互不相同，则 $A$ 一定可以对角化。</p><p><strong>定理 4.5</strong> ： $n$ 阶矩阵 $A$ 可对角化的充分必要条件是对于 $A$ 的每个 $k$ 重特征值 $\lambda $ ，则有 $\displaystyle R(\lambda E-A) = n-k$ 。</p><h2 id="4-3-实对称矩阵的对角化"><a href="#4-3-实对称矩阵的对角化" class="headerlink" title="4.3 实对称矩阵的对角化"></a>4.3 实对称矩阵的对角化</h2><p><strong>定理 4.6</strong> ：实对称矩阵的特征值都为实数。</p><p><strong>定理 4.7</strong> ：<strong>实对称矩阵不同特征值所对应的特征向量必定正交</strong>。</p><p><strong>定理 4.8</strong> ：设 $A$ 为 $n$ 阶实对称矩阵，则存在正交矩阵 $Q$ ，使得</p><script type="math/tex; mode=display">\displaystyle Q^{T} AQ = Q^{-1} AQ =\begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script><p>其中 $\displaystyle \lambda _{1},\lambda _{2},\dots ,\lambda _{n} $ 为 $A$ 的特征值。</p><p><strong>推论 4.4</strong> ：设 $A$ 为 $n$ 阶实对称矩阵， $\lambda$ 为 $A$ 的 $k$ 重特征值，则 $A$ 必有 $k$ 个对应于特征值 $\lambda$ 的线性无关的特征向量。</p><p>🔥🔥🔥 对于实对称矩阵 $A$ ，求正交矩阵 $Q$ ，使 $\displaystyle Q^{T} AQ$ 为对角矩阵的步骤如下：</p><ol><li><p>求 <script type="math/tex">A</script> 的全部不同的特征值 $\displaystyle \lambda _{1},\lambda _{2},\dots ,\lambda _{s} $ ；</p></li><li><p>对每个特征值 $\displaystyle \lambda _{i}$ ，求出齐次线性方程组 $\displaystyle \left ( \lambda _{i}E-A \right ) x=0$ 的基础解系，将其正交化、单位化；</p></li><li><p>所得到的正交单位特征向量组构成的正交矩阵 $Q$ ，则</p><script type="math/tex; mode=display">\displaystyle Q^{T} AQ = Q^{-1} AQ =\begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script></li></ol><h2 id="4-4-二次型及其标准形"><a href="#4-4-二次型及其标准形" class="headerlink" title="4.4 二次型及其标准形"></a>4.4 二次型及其标准形</h2><h3 id="4-4-1-二次型定义"><a href="#4-4-1-二次型定义" class="headerlink" title="4.4.1 二次型定义"></a>4.4.1 二次型定义</h3><p><strong>定义 4.4</strong> ： $n$ 个变量 $\displaystyle x<em>{1},x</em>{2},\cdots ,x_{n} $ 的二次齐次多项式</p><script type="math/tex; mode=display">\begin{align}\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )  = &a_{11}x_{1}^{2}+2a_{12}x_{1}x_{2}+\dots +2a_{1n}x_{1}x_{n}\\&+a_{22}x_{2}^{2}+\dots + 2a_{2n}x_{2}x_{n}\\&+\dots +a_{nn}x_{n}^{2}\end{align}</script><p>称为 $n$ 元<font color='red'>二次型</font>。 $a_{ij}$ 称为二次型 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 的系数，当 $a_{ij}$ 为实数时，称 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 为<strong>实二次型</strong>；当 $a_{ij}$ 为复数时，称 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 为<strong>复二次型</strong>。</p><p>二次型可以表示为</p><script type="math/tex; mode=display">\displaystyle f(x) =x^{T} Ax</script><p>其中 $\displaystyle A = A^{T} $ 为实对称矩阵，将上式称为二次型的矩阵形式，对称矩阵 $A$ 称为二次型的矩阵， $A$ 的秩称为<strong>二次型的秩</strong>。</p><p><strong>仅含平方项的二次型称为<font color='red'>标准形</font></strong>。很显然，二次型 $\displaystyle x^{T} Ax$ 为标准形的<strong>充分必要</strong>条件是 $A$ 为对角矩阵。研究二次型的目的之一，就是寻找一个线性变化将其化为标准形。</p><h3 id="4-4-2-矩阵的合同"><a href="#4-4-2-矩阵的合同" class="headerlink" title="4.4.2 矩阵的合同"></a>4.4.2 矩阵的合同</h3><p><strong>定义 4.5</strong> ：设 $A,B$ 为 $n$ 阶矩阵。如果存在可逆矩阵$C$ ，使 $\displaystyle C^{T} AC=B$ ，则称 $A$ 与 $B$ 是<font color='red'>合同的</font>，记作 $\displaystyle A\simeq B$ 。</p><p>矩阵的合同也是一种等价关系，它具有下面性质：</p><ol><li>自反性：对任意 $n$ 阶矩阵，有 $\displaystyle A\simeq A$ ；</li><li>对称性：若 $\displaystyle A\simeq B$ ，则$\displaystyle B\simeq A$ ；</li><li>传递性：若 $\displaystyle A\simeq B,B\simeq C$ ，则 $\displaystyle A\simeq C$ 。</li></ol><p><strong>定理 4.9</strong> ：设 $n$ 阶矩阵$A$ 与 $B$ 合同，且 $A$ 为对称矩阵，则 $B$ 也是对称矩阵，且</p><script type="math/tex; mode=display">\displaystyle R(A) = R(B)</script><h3 id="4-4-3-化二次型为标准形"><a href="#4-4-3-化二次型为标准形" class="headerlink" title="4.4.3 化二次型为标准形"></a>4.4.3 化二次型为标准形</h3><ol><li><p>正交变换法</p><p>若 $Q$ 为正交矩阵，则称线性变换 $\displaystyle x = Qy$ 为<font color='red'>线性变换</font>。容易验证，正交变换保持向量的内积、长度和夹角不变，因而正交变换保持几何图形的大小和形状不变。</p><p><strong>定义 4.10</strong> ：对于任意 $n$ 元实二次型</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\cdots ,x_{n} ) = x^{T} Ax</script><p>总存在正交变换 $\displaystyle x = Qy$ ，使</p><script type="math/tex; mode=display">\displaystyle f(x)\overset{x=Qy}{= } \lambda _{1}y_{1}^{2} +\lambda _{2}y_{2}^{2}+\dots +\lambda _{n}y_{n}^{2}</script><p>其中 $\displaystyle \lambda _{1},\lambda _{2},\dots ,\lambda _{n} $ 为 $A$ 的全部特征值。</p></li><li><p>配方法</p><p>利用公式 $\displaystyle (a\pm b)^{2} = a^{2}\pm 2ab+b^{2} $ 和 $\displaystyle (a-b)(a+b) = a^{2}-b^{2}$ 将二次型配成标准形的方法，称为<strong>配方法</strong>。</p></li><li><p>初等变换法</p></li></ol><p><strong>定理 4.11</strong> ：任何实二次型 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} ) = x^{T} Ax$ 总可以经过适当的可逆线性变换化为规范形，而且规范形是唯一的。</p><p><strong>定义 4.6</strong> ：实二次型 $\displaystyle f(x) = x^{T} Ax$ 的标准形中正平方项的个数 $p$ 称为二次型 $f$ 的<font color='red'>正惯性指数</font>；负平方项的个数 $q$ 称为二次型 $f$ 的<font color='red'>负惯性指数</font>；它们的差 $p-q$ 称为二次型 $f$ 的<font color='red'>符号差</font>。</p><h2 id="4-5-正定二次型"><a href="#4-5-正定二次型" class="headerlink" title="4.5 正定二次型"></a>4.5 正定二次型</h2><p>在数学、物理、力学领域中都有广泛应用的实二次型———<font color='red'>正定二次型</font>。</p><p><strong>定义 4.7</strong> ：设 $\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax$ 为 $n$ 个变量的实二次型。</p><p>（1）如果对任何非零向量 $x = (x_{1},x_{2},\dots ,x_{n} )$ ，都有</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax >0\quad(<0)</script><p>则称 $f = x^{T} Ax$ 为<strong>正定（负定）二次型</strong>，并称二次型矩阵 $A$ 为<strong>正定（负定）矩阵</strong>。</p><p>（2）如果对任何非零向量 $x = (x_{1},x_{2},\dots ,x_{n} )$ ，都有</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax \ge 0\quad(\le 0)</script><p>则称 $f = x^{T} Ax$ 为<strong>半正定（半负定）二次型</strong>，并称二次型矩阵 $A$ 为<strong>半正定（半负定）矩阵</strong>。</p><p>（3）如果二次型 $\displaystyle f(x_{1},x_{2},\dots ,x_{n} )$ 既不是半正定，也不是半负定的，就称 $f = x^{T} Ax$ 为不定的，矩阵 $A$ 称为<strong>不定矩阵</strong>。</p><hr><p><strong>定理 4.13</strong>：可逆的线性变换不改变二次型的正定性。</p><p><strong>推论 4.5</strong>：设 $n$ 阶实矩阵 $A$ 与 $B$ 合同，则 $A$ 正定的充分必要条件是 $B$ 也正定。</p><p><strong>定理 4.14</strong>：设 $\displaystyle f(x_{1},x_{2},\dots ,x_{n}) = x^{T} Ax$ 是 $n$ 元实二次型，则下面命题等价：</p><ol><li>$\displaystyle f = x^{T} Ax$ 是正定二次型，即矩阵 $A$ 是正定矩阵；</li><li>$A$ 的特征值均为正数；</li><li>$\displaystyle f = x^{T} Ax$ 的正惯性指数为 $n$ ；</li><li>$A$ 与单位矩阵 $E$ 合同；</li><li>存在可逆矩阵 $B$ ，使得 $\displaystyle A = B^{T} B$ 。</li></ol><p><strong>推论 4.6</strong>：设 $\displaystyle A = (a_{ij} )$ 是 $n$ 阶正定矩阵，则：</p><ol><li>矩阵 $A$ 的主对角线元 $\displaystyle a_{ij}&gt; 0$ ；</li><li>矩阵 $A$ 的行列式 $\displaystyle \left | A \right | &gt; 0$ 。</li></ol><p><strong>定义 4.8</strong>：设 $\displaystyle A = (a_{ij} )$ 是 $n$ 阶方阵，依次取 $A$ 的前 $k$ 行与前 $k$ 列所构成的子式</p><script type="math/tex; mode=display">\Delta _{k}  = \begin{bmatrix} a_{11}  & a_{12} & \dots  &a_{1k}\\ a_{21} & a_{22} & \dots  &a_{2k} \\\vdots   & \cdots  & \ddots  &\vdots  \\ a_{k1} &  a_{k2} & \dots  & a_{kk}\end{bmatrix},\quad k = 1,2,\dots ,n</script><p>称为矩阵 $A$ 的 <strong>$k$ 阶顺序主子式</strong>。</p><p><strong>定理 4.1.5</strong>： $n$ 元实二次型 $\displaystyle f(x_{1},x_{2},\dots ,x_{n}) = x^{T} Ax$ 正定的充要条件是 $A$ 的 $n$ 个顺序主子式均大于零，该定理也称为<strong>霍尔维茨定理</strong>。</p><p><strong>推论 4.7</strong>：对于 $n$ 元实二次型 $\displaystyle f = x^{T} Ax$ ，则下面命题等价：</p><ol><li>$f$ 是负定二次型；</li><li>$f$ 的负惯性指数为 $n$ ；</li><li>$A$ 的特征值全为负数；</li><li>$A$ 合同于 $-E$ ；</li><li>$A$ 的奇数阶顺序主子式全为负数，偶数阶顺寻主子式全为正数。</li></ol><h1 id="五、线性空间与线性变换"><a href="#五、线性空间与线性变换" class="headerlink" title="五、线性空间与线性变换"></a>五、线性空间与线性变换</h1><h2 id="5-1-线性空间"><a href="#5-1-线性空间" class="headerlink" title="5.1 线性空间"></a>5.1 线性空间</h2><h3 id="5-1-1-线性变换"><a href="#5-1-1-线性变换" class="headerlink" title="5.1.1 线性变换"></a>5.1.1 线性变换</h3><p><strong>定义 5.1</strong>：设 $F$ 是一个包含数 0 和 1 的集合，如果 $F$ 中任意两个数的和、差、积、商都在 $F$ 中，则称 $F$ 是一个<strong><font color='red'>数域</font></strong>。</p><p>有理数集 $Q$ 、实数集 $R$、复数集 $C$ 都是数域，他们分别称为<strong>有理数域</strong>、<strong>实数域</strong>、<strong>复数域</strong>。</p><p>若集合 $V$ 中定义了某种运算， $V$ 中的任意元素进行运算所得到的结果均在 $V$ 中，则称这种运算是封闭的。</p><h3 id="5-1-2-线性空间"><a href="#5-1-2-线性空间" class="headerlink" title="5.1.2 线性空间"></a>5.1.2 线性空间</h3><p><strong>定义 5.2</strong>：设 $V$ 是一个非空集合。其元素用 $\displaystyle \alpha ,\beta, \gamma ,\delta ,\dots $ 表示，$F$ 是一个数域，其元素用 $\displaystyle k,l,m,n,\dots $ 表示。并且满足下面条件：</p><ol><li>在集合 $V$ 的元素之间定义了一种运算，叫做加法。即对于 $V$ 中任意两个元素 $\alpha$ 和 $\beta  $  ，在 $V$ 中都有唯一的元素 $\gamma $ 与之对应，称为 $\alpha$ 和 $\beta $ 的和，记作 $\gamma = \alpha +\beta $ 。</li><li>在数域 $F$ 的数与集合 $V$ 的元素之间定义了一种运算，叫做数量乘法，也就是说，对于 $F$ 任意一个数 $k$ 与 $V$ 中任一元素 $\alpha$ ，在 $V$ 中都有唯一的元素 $\delta $ 与之对应，$\delta = k\alpha $ 称为 $k$ 与 $\alpha$ 的数量积。</li><li>$V$ 中定义的加法与数量乘法满足下列运算律：<ol><li>$\alpha +\beta = \beta +\alpha $ ；</li><li>$(\alpha +\beta)+ \gamma  = \alpha +(\beta +\gamma )$ ；</li><li>在 $V$ 中有一个元素 <strong>0</strong> ，对 $V$ 中任一元素 $\alpha$ ，都有 $\alpha +0 = \alpha $ （具有这性质的元素称为零元素）；</li><li>对于 $V$ 中每一元素 $\alpha$ ，都有 $V$ 中元素 $\beta $ ，使 $\alpha +\beta =0$ ，称 $\beta $ 为 $\alpha$ 的负元素；</li><li>$k(\alpha +\beta ) = k\alpha +k\beta $ ；</li><li>$(k+l)\alpha = k\alpha +l\alpha $ ；</li><li>$k(l\alpha ) = (kl)\alpha $ ；</li><li>$1\alpha = \alpha $ ；</li></ol></li></ol><p>则称 $V$ 为数域 $F$ 上的<font color='red'><strong>线性空间（或向量空间）</strong></font>，简称 $V$ 的<strong>线性空间</strong>或<strong>向量空间</strong>。</p><p>$V$ 中所定义的加法以及数量乘法运算统称为 $V$ 的<strong>线性运算</strong>。 $V$ 中的元素也称为向量， $F$ 中的元素也称为<strong>数量</strong>或<strong>标量</strong>。当 $F$ 为实数域 $R$ 时，称 $V$ 为<strong>实线性空间</strong>；当 $F$ 为复数域 $C$ 时，称 $V$ 为<strong>复线性空间</strong>。</p><h3 id="5-1-3-线性空间的性质"><a href="#5-1-3-线性空间的性质" class="headerlink" title="5.1.3 线性空间的性质"></a>5.1.3 线性空间的性质</h3><p><strong>性质 5.1</strong>：零向量是唯一的。</p><p><strong>性质 5.2</strong>：向量空间 $V$ 中的每个向量的复向量是唯一的。</p><p><strong>性质 5.3</strong>：对向量空间 $V$ 中任一向量 $\alpha $ 与任一数 $k$ ，有 $0\alpha =0$ ；$k0=0$ ；$(-1)\alpha =\alpha $ 。</p><h3 id="5-1-4-线性子空间"><a href="#5-1-4-线性子空间" class="headerlink" title="5.1.4 线性子空间"></a>5.1.4 线性子空间</h3><p><strong>定义 5.3</strong>：若 $W$ 为数域 $F$ 上的线性空间 $V$ 的非空子集，且 $W$ 满足如下条件：</p><ol><li>对任意的 $k\in F$ ，$a\in W$ ，则 $k\alpha \in W$ ；</li><li>对任意的 $\alpha ,\beta \in W$ ，则 $\alpha+\beta \in W$ ；</li></ol><p>则称 $W$ 为 $V$ 的<font color='red'>线性子空间</font>，简称<strong>子空间</strong>。换句话说，当且仅当 $W$ 对 $V$ 中的加法与数乘运算是封闭的，$W$ 是向量空间 $V$ 的子空间。</p><p>若 $W$ 是线性空间 $V$ 的子空间，由定义 <code>5.3</code> 不难得出，它也是线性空间。</p><h2 id="5-2-线性空间的基与向量坐标"><a href="#5-2-线性空间的基与向量坐标" class="headerlink" title="5.2 线性空间的基与向量坐标"></a>5.2 线性空间的基与向量坐标</h2><h3 id="5-2-1-基、维数、坐标"><a href="#5-2-1-基、维数、坐标" class="headerlink" title="5.2.1 基、维数、坐标"></a>5.2.1 基、维数、坐标</h3><p><strong>定义 5.4</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 是数域 $F$ 上的线性空间 $V$ 中的 $m$ 个向量， $k_{1} ,k_{2} ,\cdots ,k_{m} $ 是 $F$ 中的数，则称 $k<em>{1}a</em>{1}+k<em>{2}a</em>{2}+\cdots +k<em>{m}a</em>{m} = \beta $ 为向量组 $\displaystyle a<em>{1} ,a</em>{2} ,\dots, a<em>{m} $ 的一个线性组合，或者 $\beta $ 可由向量组 $\displaystyle a</em>{1} ,a<em>{2} ,\dots, a</em>{m} $ 线性表示。</p><p><strong>定义 5.5</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 是数域 $F$ 上的线性空间 $V$ 中向量，若存在 $F$ 中不全为零的数 $k_{1},k_{2},\dots ,k_{m}$ ，使 $k_{1}a_{1}+k_{2}a_{2}+\cdots +k_{m}a_{m} = 0$ ，则称向量组 $\displaystyle a<em>{1} ,a</em>{2} ,\dots, a_{m} $ <strong>线性相关</strong>；否则称向量组<strong>线性无关</strong>。</p><p><strong>定义 5.6</strong>：设 $V$ 是数域 $F$ 上的线性空间， $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 是 $V$ 中 $n$ 个线性无关的向量，若 $V$ 中任一向量 $a$ 均可由 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 线性表示，则称线性空间 $V$ 是 <strong>$n$ 维线性空间</strong>， $n$ 称为 $V$ 的<strong>维数</strong>，记作： $\text{dim} V = n$ ，而称 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 为 $V$ 的一组<strong>基</strong>。如果 $V$ 中有任意多个线性无关向量，则称 <script type="math/tex">V</script> 是<strong>无限维线性空间</strong>。</p><p><strong>定义 5.7</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 是 $n$ 维线性空间 $V$ 的一组基，$\beta \in V$ 且有</p><script type="math/tex; mode=display">\beta = x_{1}a_{1}+x_{2}a_{2} +\dots  +x_{n}a_{n}</script><p>则称 $(x<em>{1},x</em>{2},\dots ,x<em>{n} )^{T} $ 为 $\beta $ 在基 $\displaystyle a</em>{1} ,a<em>{2} ,\dots, a</em>{n} $ 下的坐标向量。</p><h3 id="5-2-2-基变换与坐标变换"><a href="#5-2-2-基变换与坐标变换" class="headerlink" title="5.2.2 基变换与坐标变换"></a>5.2.2 基变换与坐标变换</h3><p>设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 与 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 为 $n$ 维线性空间 $V$ 的两组基，则 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 可由 $V$ 的基 $\displaystyle a<em>{1} ,a</em>{2} ,\dots, a_{n} $ 表示：</p><script type="math/tex; mode=display">\left\{\begin{matrix} \beta _{1}  & = & b_{11}a _{1}   & + & b_{21}a _{2} & + & \dots  & + & b_{n1}a _{n}\\ \beta _{2} & = & b_{12}a _{1} & + & b_{22}a _{2} & + & \dots  & + & b_{n2}a _{n}\\  &  & \vdots  &  &  &  &  &  & \\ \beta _{n} & = & b_{1n}a _{1}   & + & b_{2n}a _{2}   & + & \dots  & + &b_{nn}a _{n}  \end{matrix}\right.</script><p>或者写成矩阵形式</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) \begin{bmatrix} b_{11}  & b_{12}  &  \cdots &  b_{1n}\\ b_{21}  &  b_{22} &  \cdots  &  b_{2n}\\ \vdots  &  \vdots& \ddots  & \vdots\\  b_{n1} &  b_{n2} &  \cdots & b_{nn}\end{bmatrix}</script><p>若记 $B = (b<em>{ij} )</em>{n\times n} $ ，那么就可以简写为：</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) B</script><p>则称 $n$ 阶矩阵 $B$ 为由基 $\displaystyle a<em>{1} ,a</em>{2} ,\dots, a<em>{n} $ 到基 $\beta </em>{1},\beta _{2},\dots ,\beta _{n} $ 的<strong>过渡矩阵</strong>。</p><p>过渡矩阵有以下性质：</p><ol><li>过渡矩阵 $B$ 的第 $j$ 列恰为 $\beta _{j} $ 在基 $\displaystyle a_{1} ,a<em>{2} ,\dots, a</em>{n} $ 下的坐标；</li><li>过渡矩阵 $B$ 可逆。事实上，由 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 线性无关，则 $A$ 的列向量组线性无关，故 $B$ 为可逆矩阵。</li></ol><p><strong>定理 5.1</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 与 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 为 $n$ 维线性空间 $V$ 的两组基，由 $\displaystyle a<em>{1} ,a</em>{2} ,\dots, a<em>{n} $ 到基 $\beta </em>{1},\beta _{2},\dots ,\beta _{n} $ 的过渡矩阵为 $B = (b<em>{ij} )</em>{n\times n} $ ，即</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) B</script><p>若向量 $\eta $ 在这两组基下的坐标分别为 $x = (x<em>{1},x</em>{2},\dots ,x<em>{n} )^{T} $ 和 $y = (y</em>{1},y<em>{2},\dots ,y</em>{n} )^{T} $ ，那么</p><script type="math/tex; mode=display">\mathbf{x}  = \mathbf{Ay} \text{或者} \mathbf{y}  =\mathbf{ A^{-1}x }</script><p>上式被称为<strong>坐标变换公式</strong>。</p><h2 id="5-3-线性变换"><a href="#5-3-线性变换" class="headerlink" title="5.3 线性变换"></a>5.3 线性变换</h2><h3 id="5-3-1-映射"><a href="#5-3-1-映射" class="headerlink" title="5.3.1 映射"></a>5.3.1 映射</h3><p><strong>定义 5.8</strong>：设 $M$ 与 $N$ 是两个非空集合，如果有一个法则 $f$ ，使得对 $M$ 中的每个元素 $a$ 都有 $N$ 中唯一确定的 $b$ 与之对应，那么就称 $f$ 是 $M$ 到 $N$ 的一个<strong>映射</strong>，记作</p><script type="math/tex; mode=display">f:\mathbf{M} \to \mathbf{N}</script><p>并称 $b$ 为 $a$ 在 $f$ 下的<strong>像</strong>，而 $a$ 称为 $b$ 在映射 $f$ 下的一个<strong>原像</strong>，记作</p><script type="math/tex; mode=display">f:a\to b\quad \textbf{或} f(a) = b</script><p>集合 $M$ 称为映射 $f$ 的<strong>定义域</strong>。如果对于任意的 $\displaystyle a,b\in M$ ，都有 $f(a)\ne f(b)\quad (a\ne b)$ ，则称 $f$ 是<strong>单射</strong>；如果对于任意的 $b\in N,a\in M$ ，都有 $f(a)=b$ ，则称 $f$ 是<strong>满射</strong>；如果 $f$ 既是单射又是满射，则称 $f$ 是<strong>双射</strong>（或称为<strong>一一映射</strong>）。</p><h3 id="5-3-2-线性变换的定义"><a href="#5-3-2-线性变换的定义" class="headerlink" title="5.3.2 线性变换的定义"></a>5.3.2 线性变换的定义</h3><p><strong>定义 5.9</strong>：设数域 $F$ 上的线性空间 $V_{1} $ 和 $V_{2} $ 分别是 $n$ 和 $m$ 维的。 $T$ 是 $V_{1} $ 到 $V_{2} $$ 的一个映射，且满足：</p><ol><li>对任意的 $\alpha ,\beta \in V_{1} $ ，有 $T(\alpha +\beta )=T(\alpha )+T(\beta )$ ；</li><li>对任意的 $\alpha \in V,k\in F$ ，有 $T( k\alpha)=kT(\alpha )$ ；</li></ol><p>则称 $T$ 是从线性空间 $V_{1} $ 到 $V_{2} $ 的<strong>线性映射</strong>。若 $V_{2} =F$ ，则称该线性映射为<strong>线性函数</strong>；若 $V_{1} =V_{2} $ ，则称该线性映射为线性空间$V_{1}$ 上的线性变换，简称<strong>线性变换</strong>。</p><h3 id="5-3-3-线性变换的性质"><a href="#5-3-3-线性变换的性质" class="headerlink" title="5.3.3 线性变换的性质"></a>5.3.3 线性变换的性质</h3><p><strong>性质 5.5</strong>： $T(0) = 0$ 。</p><p><strong>性质 5.6</strong>： $T(-\alpha ) = -T(\alpha )$ 。</p><p><strong>性质 5.7</strong>：若 $\beta = k<em>{1}\alpha </em>{1}+k<em>{2}\alpha </em>{2}+\dots +k<em>{m}\alpha </em>{m} $ ，则</p><script type="math/tex; mode=display">T(\beta ) = k_{1}T\left ( \alpha_{1} \right )+k_{2}T\left ( \alpha _{2} \right ) +\dots +k_{m}T\left ( \alpha _{m}   \right )</script><p><strong>性质 5.8</strong>：若向量组 $\alpha _{1},\alpha _{2},\dots ,\alpha _{m}  $ 线性相关，则向量组 $T\left ( \alpha _{1}\right ),T\left ( \alpha _{2} \right ) ,\dots,T\left ( \alpha _{m}   \right )$ 也线性相关。</p><h2 id="5-4-线性变换的矩阵表示"><a href="#5-4-线性变换的矩阵表示" class="headerlink" title="5.4 线性变换的矩阵表示"></a>5.4 线性变换的矩阵表示</h2><h3 id="5-4-1-线性变换的矩阵"><a href="#5-4-1-线性变换的矩阵" class="headerlink" title="5.4.1 线性变换的矩阵"></a>5.4.1 线性变换的矩阵</h3><p>设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 是 $n$ 维线性空间 $V$ 的一组基，$T$ 是 $V$ 上的线性变换，那么对 $V$ 中的向量</p><script type="math/tex; mode=display">{\color{Red}  \xi =x_{1} \alpha _{1}+x_{2} \alpha _{2}+\dots +x_{n} \alpha _{n}}</script><p>由线性变换的性质，有</p><script type="math/tex; mode=display">{\color{blue} T\left ( \xi \right )  =x_{1} T\left ( \alpha _{1} \right ) +x_{2} T\left ( \alpha _{2} \right ) +\dots +x_{n} T\left ( \alpha _{n} \right ) }</script><p>因此，对于线性变换 $T$ ，如果知道 $T$ 关于基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 的像 $T\left ( \alpha _{1} \right ) , T\left ( \alpha _{2} \right ),\dots ,T\left ( \alpha _{n} \right )$ ，则 $V$ 中任一向量 $\xi $ 的像 $T\left ( \xi \right ) $ 就完全确定。</p><p>由于 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 的像 $T\left ( \alpha _{1} \right ) , T\left ( \alpha _{2} \right ),\dots ,T\left ( \alpha _{n} \right )$ 可由 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 线性表示，即有：</p><script type="math/tex; mode=display">\left\{\begin{matrix} T(\alpha _{1} ) & = & {\color{Violet} a_{11}} \alpha _{1} & + &  {\color{Violet} a_{21}} \alpha _{2}  & + & \dots  & + &  {\color{Violet} a_{n1}} \alpha _{n} \\  T(\alpha _{2} ) & = &  {\color{Violet} a_{12}} \alpha _{1}  & + &  {\color{Violet} a_{22}} \alpha _{2}  & + & \dots & + &  {\color{Violet} a_{n2}} \alpha _{n} \\  &  &  & \vdots  &  &  &  &  & \\  T(\alpha _{n} ) & = &  {\color{Violet} a_{1n}} \alpha _{1}  & + &  {\color{Violet} a_{2n}} \alpha _{2}  & + & \dots & + & {\color{Violet} a_{nn}} \alpha _{n} \end{matrix}\right.</script><p>若记</p><script type="math/tex; mode=display">\begin{align}T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} ) & = T(\alpha _{1})+T(\alpha _{2})+\dots +T(\alpha _{n})\\ \displaystyle & = (\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\begin{bmatrix}{\color{Violet}  a_{11}}   & {\color{Violet}  a_{12}} & \dots  & {\color{Violet}  a_{1n}}\\ {\color{Violet}  a_{121}} & {\color{Violet}  a_{22}} & \cdots  & {\color{Violet}  a_{2n}}\\ \vdots  & \vdots  &  \ddots &\vdots  \\ {\color{Violet}  a_{n1}} & {\color{Violet}  a_{n2}} & \dots  &{\color{Violet}  a_{nn}}\end{bmatrix}\end{align}</script><p>或者</p><script type="math/tex; mode=display">T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )  =(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\mathbf{A}</script><p><strong>定义 5.10</strong>：设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 为 $n$ 维线性空间 $V$ 的一组基， $T$ 为 $V$ 的一个线性变换。若 $n$ 阶矩阵 $A$ 满足</p><script type="math/tex; mode=display">T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )  =(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\mathbf{A}</script><p>则称 $n$ 阶矩阵 $A$ 为线性变换 $T$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的<strong>表示矩阵</strong>。</p><p><strong>定理 5.2</strong>：设 $T$ 是 $n$ 维线性空间 $V$ 上的线性变换， $T$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，向量 $\xi$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标为 $\mathbf{x} =(x_{1},x_{2},\dots ,x_{n})^{T} $ ， $T(\xi )$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标为 $\mathbf{y} =(y<em>{1},y</em>{2},\dots ,y_{n})^{T} $ ，则</p><script type="math/tex; mode=display">\mathbf{y = Ax}</script><h3 id="5-4-2-线性变换在不同矩阵基下矩阵的关系"><a href="#5-4-2-线性变换在不同矩阵基下矩阵的关系" class="headerlink" title="5.4.2 线性变换在不同矩阵基下矩阵的关系"></a>5.4.2 线性变换在不同矩阵基下矩阵的关系</h3><p><strong>定理 5.3</strong>：设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 和 $\beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 是 $n$ 维线性空间 $V$ 的两组基， $V$ 上的线性变换 $T$ 在这两种基下的矩阵分别为 $A$ 和 $B$ ，且从基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 到基 $\beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 的过渡矩阵为  $P$ ，那么</p><script type="math/tex; mode=display">\mathbf{B = P^{-1} AP}</script><h2 id="5-5-线性变换的特征值与特征向量"><a href="#5-5-线性变换的特征值与特征向量" class="headerlink" title="5.5 线性变换的特征值与特征向量"></a>5.5 线性变换的特征值与特征向量</h2><h3 id="5-5-1-特征值与特征向量"><a href="#5-5-1-特征值与特征向量" class="headerlink" title="5.5.1 特征值与特征向量"></a>5.5.1 特征值与特征向量</h3><p><strong>定义 5.11</strong>：设 $T$ 是数域 $F$ 上线性空间 $V$ 的线性变换，若存在数 $\lambda \in \mathbf{F} $ 和非零向量 $\alpha \in V$ ，使得</p><script type="math/tex; mode=display">T(\alpha ) = \lambda \alpha</script><p>则称 $ \lambda$ 为 $T$ 的一个特征值，而 $\alpha $ 称为 $T$ 属于特征值 $\lambda $ 的特征向量。</p><p><strong>定理 5.4</strong>：设 $T$ 是 $n$ 维线性空间 $V$ 上的线性变换，$T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，则：</p><ol><li>$\lambda $ 是 $T$ 的特征值得充要条件是$\lambda $ 为 $A$ 的特征值；</li><li>$\alpha \in V$ 是 $T$ 的属于特征值 $\lambda $ 的特征向量的充要条件是 $\alpha $ 在基  $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标是矩阵 $A$ 的属于特征值 $\lambda $ 的特征向量。</li></ol><h3 id="5-5-2-值域与核"><a href="#5-5-2-值域与核" class="headerlink" title="5.5.2 值域与核"></a>5.5.2 值域与核</h3><p><strong>定义 5.12</strong>：设 $T$ 是线性空间 $V$ 中的线性变换，$V$ 中所有元素在 $T$ 下的像所组成的集合。</p><script type="math/tex; mode=display">\left \{ \beta |\beta  = T(\alpha ) ,\alpha \in V\right \}</script><p>称为 $T$ 的<strong>值域</strong>，记作 $\text{Im} T\quad \text{或者} T(V)$ 。零向量的所有原像的集合：</p><script type="math/tex; mode=display">\left \{ \alpha | T(\alpha )=0 ,\alpha \in V\right \}</script><p>称为 $T$ 的<strong>核</strong>，记作 $\text{Ker} T\quad \text{或者} T^{-1} (V)$ 。</p><p>关于线性变换的值域与核有以下性质：</p><ol><li>线性变换 $T$ 的值域 $\text{Im} T$ 是 $V$ 的子空间；</li><li>线性变换 $T$ 的核 $\text{Ker} T$ 是 $V$ 的子空间。</li></ol><p><strong>定理 5.5</strong>：设 $V$ 是 $n$ 维线性空间， $V$ 上的线性变换 $T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵 $A$ ，则</p><ol><li>$\text{Im} T$ 的维数等于向量组 $T(\alpha_{1}  ),T(\alpha_{2}  ),\dots ,T(\alpha_{n}  )$ 的<strong>秩</strong>，也等于矩阵 $A$ 的秩；</li><li>$\text{Im} T$ 的基是向量组 $T(\alpha_{1}  ),T(\alpha_{2}  ),\dots ,T(\alpha_{n}  )$ 的一个极大无关组。</li></ol><p><strong>定理 5.6</strong>：设 $V$ 是 $n$ 维线性空间， $V$ 上的线性变换 $T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，则</p><ul><li>$T$ 的核 $\text{Ker} T$ 的维数等于 $n-R(A)$ ；</li><li>$V$ 中齐次线性方程组 $Ax = 0$ 的基础解系构成 $T$ 的核 $\text{Ker} T$的基。</li></ul><h1 id="😁-说明-😁"><a href="#😁-说明-😁" class="headerlink" title="😁 说明 😁"></a>😁 说明 😁</h1><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>线性代数及应用（第二版）</p><ul><li>编著：高淑萍、杨威、张剑湖、马建荣</li><li>出版社：西安电子科技大学出版社</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础语法</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/01.Csharp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/03.CSharp/01.Csharp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>此文章是 C#基础语法部分，涵盖了注释、变量类型、基础数据类型、运算符、流程控制语句、复杂数据类型、方法、面向对象程序设计等内容。</p><p>C#系列教程：</p><ol><li><a href="https://blog.yuilexi.cn/2023/04/26/编程/Csharp知识库/Csharp基础/Csharp基础语法/">C#基础语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a>⬅️ 当前的位置 °꒰๑’ꀾ’๑꒱°</li><li><a href="https://blog.yuilexi.cn/2023/04/30/编程/Csharp知识库/Csharp基础/Csharp高级语法/">C#高级语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a></li><li><a href="https://blog.yuilexi.cn/2023/05/19/编程/Csharp知识库/Csharp基础/Csharp规范/">C#代码规范 | 🪐 星空鸟 🪐 (yuilexi.cn)</a></li></ol></blockquote><h1 id="一、认识-C"><a href="#一、认识-C" class="headerlink" title="一、认识 C"></a>一、认识 C</h1><h2 id="1-1-什么是-NET？"><a href="#1-1-什么是-NET？" class="headerlink" title="1.1 什么是 .NET？"></a>1.1 什么是 .NET？</h2><p>.NET 是由 Microsoft 创建的开源开发人员平台，用于生成许多不同类型的应用程序。使用 .NET，可以使用多种语言、编辑器和库来构建 Web、移动、桌面、游戏和 IoT 等。<a href="https://learn.microsoft.com/zh-cn/dotnet/">.NET 文档 | Microsoft Learn</a>。</p><ul><li><p>编程语言</p><p>可以使用 C#、F# 或 Visual Basic 编写 .NET 应用。<a href="https://dotnet.microsoft.com/zh-cn/languages">了解.NET 编程语言</a>。</p><ul><li>C# 是一种简单、现代、面向对象和类型安全的编程语言。</li><li><p>F# 是一种编程语言，利用它可轻松编写简洁、可靠且性能出色的代码。</p></li><li><p>Visual Basic 是一种易于使用的语言，简单语法便于生成类型安全、面向对象的应用。</p></li></ul></li><li><p>跨平台</p><p>无论是使用 C#、F# 还是 Visual Basic，代码都会在任何兼容的操作系统上本机运行。可以使用 .NET 生成多种类型的应用。有些是跨平台的，有些则针对特定的一组操作系统和设备。</p></li><li><p>一致的 API</p><p>.NET 提供一组标准的基类库和 API，这些库和 API 对所有 .NET 应用程序都是通用的。每个应用模型还可以公开特定于其运行的操作系统或它提供的功能的其他 API。例如，ASP.NET 是跨平台 Web 框架，它提供用于生成在 Linux 或 Windows 上运行的 Web 应用的其他 API。</p></li><li><p>库</p><p>为了扩展功能，Microsoft 和其他公司维护着一个正常的 .NET 软件包生态系统。<a href="https://nuget.org/">NuGet</a>是专为包含了 100,000 多个包的 .NET 构建的包管理器。</p></li><li><p>应用程序模型</p><p>可以使用 .NET 生成多种类型的应用。为了帮助你更快地生成应用，应用模型基于基础库构建。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Web</th><th>为 Windows、Linux、macOS、Docker 构建 Web 应用和服务。</th></tr></thead><tbody><tr><td style="text-align:center">手机</td><td>使用单一代码库生成适用于 iOS、Android 和 Windows 等的本机移动应用。</td></tr><tr><td style="text-align:center">桌面</td><td>创建适用于 Windows 和 macOS 的本机应用，或使用 Web 技术生成随时随地运行的应用。</td></tr><tr><td style="text-align:center">微服务</td><td>创建可在 Docker 容器上运行的可独立部署的微服务。</td></tr><tr><td style="text-align:center">云</td><td>使用现有云服务，或创建和部署自己的云服务。</td></tr><tr><td style="text-align:center">机器学习</td><td>为应用添加视觉算法、语音处理、预测模型等。</td></tr><tr><td style="text-align:center">游戏开发</td><td>为最热门的台式机、手机和控制台开发 2D 和 3D 游戏。</td></tr><tr><td style="text-align:center">物联网</td><td>使用 Raspberry Pi 和其他单板计算机的本机支持创建 IoT 应用。</td></tr></tbody></table></div><h2 id="1-2-什么是-C-？"><a href="#1-2-什么是-C-？" class="headerlink" title="1.2 什么是 C#？"></a>1.2 什么是 C#？</h2><p>一种编程语言，可以开发基于.NET 平台的应用。</p><h2 id="1-3-NET-两种交互模式"><a href="#1-3-NET-两种交互模式" class="headerlink" title="1.3 .NET 两种交互模式"></a>1.3 .NET 两种交互模式</h2><ul><li>C/S：客户端（Client）/服务器（Server） 模式（需安装客户端软件）</li><li>B/S：浏览器（Browser）/服务器 模式（只需要浏览器）</li></ul><h2 id="1-4-开发工具"><a href="#1-4-开发工具" class="headerlink" title="1.4 开发工具"></a>1.4 开发工具</h2><ul><li><a href="https://visualstudio.microsoft.com/">Visual Studio</a></li></ul><h1 id="二、C-语法基础"><a href="#二、C-语法基础" class="headerlink" title="二、C#语法基础"></a>二、C#语法基础</h1><h2 id="2-1-C-程序一般结构"><a href="#2-1-C-程序一般结构" class="headerlink" title="2.1 C#程序一般结构"></a>2.1 C#程序一般结构</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System; <span class="comment">//调用命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//项目开始的地方</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="comment">//构造命名空间，作用：区别相同名称但是作用不同的类</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">YourNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">YourClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//字段</span></span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        <span class="comment">//方法或函数</span></span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> YourStruct</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义接口</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IYourInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义委托类型</span></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">YourDelegate</span>()</span>;</span><br><span class="line">    <span class="comment">//枚举类型变量</span></span><br><span class="line">    <span class="built_in">enum</span> YourEnum</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子命名空间</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">YourNestedNamespace</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> YourStruct</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>代码中出现的所有标点都是英文半角；</li><li>在 C# 代码中，每行代码的结束，都以<strong>分号</strong>结束。</li></ol><h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h2><ol><li><p>单行注释</p><p>一般放在<strong>代码语句</strong>的后面，或者放在<strong>代码块</strong>的前面。基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a;<span class="comment">//定义变量a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义变量 b，c</span></span><br><span class="line"><span class="built_in">int</span> b;</span><br><span class="line"><span class="built_in">int</span> c;</span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Console.WriteLine();</span></span><br><span class="line"><span class="comment">Console.ReadKey();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>文本注释</p><p>多用来解释类或方法的功能及参数。基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>text</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-基本数据类型"><a href="#2-3-基本数据类型" class="headerlink" title="2.3 基本数据类型"></a>2.3 基本数据类型</h2><p>在 C# 中，变量分为以下几种类型：</p><ul><li>值类型</li><li>引用类型</li><li>指针类型</li></ul><h3 id="2-3-1-值类型"><a href="#2-3-1-值类型" class="headerlink" title="2.3.1 值类型"></a>2.3.1 值类型</h3><p>它们是从类 <code>System.ValueType</code> 中派生的。值类型变量可以直接分配给一个值，即当前变量所在地址里的数据就是当前变量的值。值类型直接包含数据。</p><div class="table-container"><table><thead><tr><th style="text-align:center">关键字</th><th>描述</th><th>范围</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">sbyte</td><td>8 位有符号整数类型</td><td>-128 到 127</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">short</td><td>16 位有符号整数类型</td><td>-32,768 到 32,767</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>int</strong></td><td>32 位有符号整数类型</td><td>-2,147,483,648 到 2,147,483,647</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">long</td><td>64 位有符号整数类型</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td style="text-align:center">0L</td></tr><tr><td style="text-align:center">byte</td><td>8 位无符号整数</td><td>0 到 255</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ushort</td><td>16 位无符号整数类型</td><td>0 到 65,535</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">uint</td><td>32 位无符号整数类型</td><td>0 到 4,294,967,295</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ulong</td><td>64 位无符号整数类型</td><td>0 到 18,446,744,073,709,551,615</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">float</td><td>32 位单精度浮点型</td><td>-3.4 x 1038 到 + 3.4 x 1038</td><td style="text-align:center">0.0F</td></tr><tr><td style="text-align:center">double</td><td>64 位双精度浮点型</td><td>(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308</td><td style="text-align:center">0.0D</td></tr><tr><td style="text-align:center">decimal</td><td>128 位精确的十进制值，28-29 有效位数</td><td>(-7.9 x 1028 到 7.9 x 1028) / 100 到 28</td><td style="text-align:center">0.0M</td></tr><tr><td style="text-align:center">char</td><td>16 位 Unicode 字符</td><td>U +0000 到 U +ffff</td><td style="text-align:center">‘\0’</td></tr><tr><td style="text-align:center">bool</td><td>布尔值</td><td>true 或 false</td><td style="text-align:center">False</td></tr></tbody></table></div><blockquote><p>字符不可为空，字符只能存一个字符。</p></blockquote><p>如需得到一个类型或一个变量在特定平台上的准确字节大小，可以使用 <code>sizeof()</code> 方法。下面举例获取任何机器上 <code>int</code> 类型的字节大小：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataTypeApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="keyword">sizeof</span>(<span class="built_in">int</span>));<span class="comment">//</span></span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值类型还包括<a href="#4-3-枚举">枚举</a>和结构体。</p><h3 id="2-3-1-引用类型"><a href="#2-3-1-引用类型" class="headerlink" title="2.3.1 引用类型"></a>2.3.1 引用类型</h3><p>引用类型变量不包含存储在变量中的实际数据，但它们包含对变量的引用（地址）。换句话说，<strong>它们实际存储的是一个地址（栈区）</strong>，并指向变量的实际值所在的内存空间（堆区）。内置的引用类型有：<code>object</code>、<code>dynamic</code>和<code>string</code>。</p><ul><li><p>对象（Object）类型</p><p><strong>对象</strong>：是所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><ul><li>当一个值类型转换为对象类型时，则被称为<strong>装箱</strong>；</li><li>当一个对象类型转换为值类型时，则被称为<strong>拆箱</strong>。</li></ul></li><li><p>动态（Dynamic）类型</p><p>任何类型的值可以存储在动态数据类型变量中。这些变量的类型检查是在运行时发生的。声明动态类型的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dynamic &lt;variable_name&gt; = value;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串（String）类型</p><p><strong>字符串（String）类型</strong>：允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。</p></li></ul><h3 id="2-3-3-指针类型"><a href="#2-3-3-指针类型" class="headerlink" title="2.3.3 指针类型"></a>2.3.3 指针类型</h3><p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。声明指针类型的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type* name;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="built_in">char</span>* cp;</span><br><span class="line"><span class="built_in">int</span>* ip;</span><br></pre></td></tr></table></figure><blockquote><p>指针具体的使用，请参照<a href="">不安全代码</a></p></blockquote><h3 id="2-3-4-数据类型的转换"><a href="#2-3-4-数据类型的转换" class="headerlink" title="2.3.4 数据类型的转换"></a>2.3.4 数据类型的转换</h3><p>数据类型的转换有两种：<strong>隐式类型转换</strong>和<strong>显式类型转换</strong>。前者是自动进行，而后者是强制进行。</p><ul><li><p>隐式类型转换</p><p>需要满足的条件是：两种兼容类型；目标类型等级高于源类型。例如：int 和 double 兼容（都是数字类型），而 double &gt; int 。</p></li><li><p>显式类型转换</p><ul><li><p>兼容类型</p><p>高阶转换成低阶，可能会造成数据丢失。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> num = <span class="number">521.1314</span>;</span><br><span class="line"><span class="built_in">int</span> num_1;</span><br><span class="line">num_1 = (<span class="built_in">int</span>)num;<span class="comment">//此时 num_1 的值为 521</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：浮点型向整型转换时，会直接<strong>舍弃</strong>小数部分</p></blockquote></li><li><p>不兼容类型/Convert 类型转换</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">double</span> num;</span><br><span class="line">num = Convert.ToDouble(str);</span><br></pre></td></tr></table></figure><blockquote><p>转换的内容必须合理，比如 <code>14A</code> 中的 <code>A</code>不能转换成数字。</p></blockquote></li></ul></li><li><p><code>Convert</code>类型转换对应的所有方法如下：</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">ToBoolean</td><td style="text-align:left">如果可能的话，把类型转换为布尔型。</td></tr><tr><td style="text-align:center">ToByte</td><td style="text-align:left">如果可能的话，把类型转换为字节类型。</td></tr><tr><td style="text-align:center">ToChar</td><td style="text-align:left">如果可能的话，把类型转换为单个 Unicode 字符类型。</td></tr><tr><td style="text-align:center">ToDateTime</td><td style="text-align:left">如果可能的话，把类型（整数或字符串类型）转换为 日期-时间 结构。</td></tr><tr><td style="text-align:center">ToDecimal</td><td style="text-align:left">如果可能的话，把浮点型或整数类型转换为十进制类型。</td></tr><tr><td style="text-align:center">ToDouble</td><td style="text-align:left">如果可能的话，把类型转换为双精度浮点型。</td></tr><tr><td style="text-align:center">ToInt16</td><td style="text-align:left">如果可能的话，把类型转换为 16 位整数类型。</td></tr><tr><td style="text-align:center">ToInt32</td><td style="text-align:left">如果可能的话，把类型转换为 32 位整数类型。</td></tr><tr><td style="text-align:center">ToInt64</td><td style="text-align:left">如果可能的话，把类型转换为 64 位整数类型。</td></tr><tr><td style="text-align:center">ToSbyte</td><td style="text-align:left">如果可能的话，把类型转换为有符号字节类型。</td></tr><tr><td style="text-align:center">ToSingle</td><td style="text-align:left">如果可能的话，把类型转换为小浮点数类型。</td></tr><tr><td style="text-align:center">ToString</td><td style="text-align:left">如果可能的话，把类型转换为字符串类型。</td></tr><tr><td style="text-align:center">ToType</td><td style="text-align:left">如果可能的话，把类型转换为指定类型。</td></tr><tr><td style="text-align:center">ToUInt16</td><td style="text-align:left">如果可能的话，把类型转换为 16 位无符号整数类型。</td></tr><tr><td style="text-align:center">ToUInt32</td><td style="text-align:left">如果可能的话，把类型转换为 32 位无符号整数类型。</td></tr><tr><td style="text-align:center">ToUInt64</td><td style="text-align:left">如果可能的话，把类型转换为 64 位无符号整数类型。</td></tr></tbody></table></div><h2 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。分类如下：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h3 id="2-4-1-算数运算符"><a href="#2-4-1-算数运算符" class="headerlink" title="2.4.1 算数运算符"></a>2.4.1 算数运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">加</th><th style="text-align:center">减</th><th style="text-align:center">乘</th><th style="text-align:center">除</th><th style="text-align:center">取余</th><th style="text-align:center">自增</th><th style="text-align:center">自减</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">-</td><td style="text-align:center">*</td><td style="text-align:center">/</td><td style="text-align:center">%</td><td style="text-align:center">++</td><td style="text-align:center">—</td></tr></tbody></table></div><p>自增和自减有两种，前置和后置。分别对应如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i;</span><br><span class="line">i++;</span><br><span class="line">++i;</span><br></pre></td></tr></table></figure><p>二者的区别是：</p><ul><li><code>++i</code>：表示取<code>i</code>的地址，增加它的内容，然后把值放在寄存器中（<strong>先加后用</strong>）</li><li><code>i++</code>：表示取<code>i</code>的地址，把它的值装入寄存器，然后增加内存中的 a 的值（<strong>先用后加</strong>）</li></ul><p><strong>而前置自增 (<code>++i</code>) 通常要比后置自增 (<code>i++</code>) 效率更高</strong>。理由如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置++</span></span><br><span class="line">Age&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    ++i</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line"><span class="keyword">const</span> Age <span class="keyword">operator</span>++(<span class="built_in">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Age tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);  <span class="comment">//利用前置++</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前置直接对源数据进行加 1 操作；而后置需要先创建一个临时变量，源数据保存一个副本后，再加 1</li><li>时间上来看：后置的语句更多，占用的时间更多</li><li>空间上来看：后置需要创建临时变量（用完释放），因此占用的内存更多</li></ul><h3 id="2-4-2-关系运算符"><a href="#2-4-2-关系运算符" class="headerlink" title="2.4.2 关系运算符"></a>2.4.2 关系运算符</h3><p>下表显示了 C# 支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td style="text-align:center">(A == B) 不为真。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td style="text-align:center">(A != B) 为真。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &gt; B) 不为真。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &lt; B) 为真。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &gt;= B) 不为真。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &lt;= B) 为真。</td></tr></tbody></table></div><h3 id="2-4-3-逻辑运算符"><a href="#2-4-3-逻辑运算符" class="headerlink" title="2.4.3 逻辑运算符"></a>2.4.3 逻辑运算符</h3><p>下表显示了 C# 支持的所有逻辑运算符。假设变量 A 为布尔值 true，变量 B 为布尔值 false，则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td style="text-align:center">(A &amp;&amp; B) 为假。</td></tr><tr><td style="text-align:center">&#124;&#124;</td><td style="text-align:left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td style="text-align:center">(A&#124;&#124; B) 为真。</td></tr><tr><td style="text-align:center">!</td><td style="text-align:left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td style="text-align:center">!(A &amp;&amp; B) 为真。</td></tr></tbody></table></div><h3 id="2-4-4-位运算符"><a href="#2-4-4-位运算符" class="headerlink" title="2.4.4 位运算符"></a>2.4.4 位运算符</h3><p>位逻辑运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">p</th><th style="text-align:center">q</th><th style="text-align:center">p &amp; q</th><th style="text-align:center">p&#124; q</th><th style="text-align:center">p ^ q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p>以及位操作符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td style="text-align:left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td style="text-align:left">(A &#124;B) 将得到 61，即为 0011 1101</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td style="text-align:left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td style="text-align:center">~</td><td style="text-align:left">二进制补码运算符是一元运算符，具有”翻转”位效果。</td><td style="text-align:left">(~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td style="text-align:left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td style="text-align:left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table></div><h3 id="2-4-5-赋值运算符"><a href="#2-4-5-赋值运算符" class="headerlink" title="2.4.5 赋值运算符"></a>2.4.5 赋值运算符</h3><p>下表列出了 C# 支持的赋值运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td style="text-align:center">C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td style="text-align:center">+=</td><td style="text-align:left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td style="text-align:center">C += A 相当于 C = C + A</td></tr><tr><td style="text-align:center">-=</td><td style="text-align:left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td style="text-align:center">C -= A 相当于 C = C - A</td></tr><tr><td style="text-align:center">*=</td><td style="text-align:left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td style="text-align:center">C _= A 相当于 C = C _ A</td></tr><tr><td style="text-align:center">/=</td><td style="text-align:left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td style="text-align:center">C /= A 相当于 C = C / A</td></tr><tr><td style="text-align:center">%=</td><td style="text-align:left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td style="text-align:center">C %= A 相当于 C = C % A</td></tr><tr><td style="text-align:center">&lt;&lt;=</td><td style="text-align:left">左移且赋值运算符</td><td style="text-align:center">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td style="text-align:center">&gt;&gt;=</td><td style="text-align:left">右移且赋值运算符</td><td style="text-align:center">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td style="text-align:center">&amp;=</td><td style="text-align:left">按位与且赋值运算符</td><td style="text-align:center">C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td style="text-align:center">^=</td><td style="text-align:left">按位异或且赋值运算符</td><td style="text-align:center">C ^= 2 等同于 C = C ^ 2</td></tr><tr><td style="text-align:center">&#124;=</td><td style="text-align:left">按位或且赋值运算符</td><td style="text-align:center">C&#124;= 2 等同于 C = C \</td><td>2</td></tr></tbody></table></div><h3 id="2-4-6-其他运算符"><a href="#2-4-6-其他运算符" class="headerlink" title="2.4.6 其他运算符"></a>2.4.6 其他运算符</h3><p>下表列出了 C# 支持的其他一些重要的运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">sizeof()</td><td style="text-align:left">返回数据类型的大小。</td><td style="text-align:left">sizeof(int)，将返回 4.</td></tr><tr><td style="text-align:center">typeof()</td><td style="text-align:left">返回变量的类型。</td><td style="text-align:left">typeof(StreamReader);</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:left">返回变量的地址。</td><td style="text-align:left">&a; 将得到变量的实际地址。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">变量的指针。</td><td style="text-align:left">*a; 将指向一个变量。</td></tr><tr><td style="text-align:center">? :</td><td style="text-align:left">条件表达式</td><td style="text-align:left">如果条件为真 ? 则为 X : 否则为 Y</td></tr><tr><td style="text-align:center">is</td><td style="text-align:left">判断当前对象是否为 XXX 类型</td><td style="text-align:left">返回 ture 或 false</td></tr><tr><td style="text-align:center">as</td><td style="text-align:left">强制转换，即使转换失败也不会抛出异常。</td><td style="text-align:left">转换成功，返回转换后的对象；反之，返回 NULL</td></tr></tbody></table></div><h3 id="2-4-7-lambda-运算符"><a href="#2-4-7-lambda-运算符" class="headerlink" title="2.4.7 lambda 运算符"></a>2.4.7 lambda 运算符</h3><p>在 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-expressions">lambda 表达式</a>中，lambda 运算符 <code>=&gt;</code> 将左侧的输入参数与右侧的 lambda 主体分开。</p><p>使用 Lambda 表达式来创建匿名函数。 使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-operator">lambda 声明运算符<code>=&gt;</code></a> 从其主体中分离 lambda 参数列表。 Lambda 表达式可采用以下任意一种形式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(input-parameters) =&gt; expression;</span><br><span class="line">(input-parameters) =&gt; &#123; &lt;sequence-of-statements&gt; &#125;;</span><br></pre></td></tr></table></figure><p>若要创建 Lambda 表达式，需要在 Lambda 运算符左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>&gt; greet = (name) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> greeting = <span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>!&quot;</span>;</span><br><span class="line">    Console.WriteLine(greeting);</span><br><span class="line">&#125;;</span><br><span class="line">greet(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure><h2 id="2-5-特殊字符"><a href="#2-5-特殊字符" class="headerlink" title="2.5 特殊字符"></a>2.5 特殊字符</h2><h3 id="2-5-1-转义字符"><a href="#2-5-1-转义字符" class="headerlink" title="2.5.1 转义字符"></a>2.5.1 转义字符</h3><p><code>\\</code> + <code>特殊字符</code> = <code>具有特殊意义的字符</code>。例如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">转义符</th><th style="text-align:center">字符名</th></tr></thead><tbody><tr><td style="text-align:center">\\’</td><td style="text-align:center">单引号</td></tr><tr><td style="text-align:center">\\”</td><td style="text-align:center">双引号</td></tr><tr><td style="text-align:center">\\\</td><td style="text-align:center">反斜杠</td></tr><tr><td style="text-align:center">\\0</td><td style="text-align:center">空字符</td></tr><tr><td style="text-align:center">\\a</td><td style="text-align:center">感叹号</td></tr><tr><td style="text-align:center">\\b</td><td style="text-align:center">退格</td></tr><tr><td style="text-align:center">\\f</td><td style="text-align:center">换页</td></tr><tr><td style="text-align:center">\\n</td><td style="text-align:center">新行</td></tr><tr><td style="text-align:center">\\r</td><td style="text-align:center">回车</td></tr><tr><td style="text-align:center">\\t</td><td style="text-align:center">水平 tab</td></tr><tr><td style="text-align:center">\\v</td><td style="text-align:center">垂直 tab</td></tr></tbody></table></div><h3 id="2-5-2-符"><a href="#2-5-2-符" class="headerlink" title="2.5.2 @ 符"></a>2.5.2 @ 符</h3><ol><li>取消字符串中转义字符的转义作用。用在字符串前时，字符串里面的转义字符不转义。将字符串按照原格式输出。</li></ol><h3 id="2-5-3-符"><a href="#2-5-3-符" class="headerlink" title="2.5.3 + 符"></a>2.5.3 + 符</h3><ul><li><p>当<code>+</code>两边至少有一边为字符串时，作用为拼接字符串的作用</p><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;AAAAA&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">string</span> email = <span class="string">&quot;XXXXX@xx.com&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> address = <span class="string">&quot;SSSSS&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> salary = <span class="number">10000</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁了，邮箱是：&quot;</span> + email + <span class="string">&quot;,住在&quot;</span> + address + <span class="string">&quot;,每月的收入是&quot;</span> + salary + <span class="string">&quot;日元&quot;</span>);</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure></li><li><p>数字相加</p><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> num_2 = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">int</span> num_3 = num_1 + num_2;</span><br><span class="line">Console.WriteLine(num_3);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-4-占位符"><a href="#2-5-4-占位符" class="headerlink" title="2.5.4 占位符"></a>2.5.4 占位符</h3><p>用在字符串内，增强代码的可读性。具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> c = <span class="number">3</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;第一个数字是：&quot;</span> + a + <span class="string">&quot;，第二个数字是：&quot;</span> + b + <span class="string">&quot;，第三个数字是：&quot;</span> + c);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;第一个数字是：&#123;0&#125;，第二个数字是：&#123;1&#125;，第三个数字是：&#123;2&#125;&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure><p>使用注意：</p><ul><li>挖几个坑，就要填几个坑。如果多填，不报错但没效果；如果少填，就会异常（语法没错误，只不过在程序运行期间，由于某些原因出现问题，使程序不在正常的运行）</li><li>输出顺序{0}，{1}，{2}… 对应 a, b, c, ….</li></ul><p>还可以使用 <code>$</code> 修饰字符串，然后使用占位符。例如下面的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> c = <span class="number">3</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;第一个数字是：<span class="subst">&#123;a&#125;</span>，第二个数字是：<span class="subst">&#123;b&#125;</span>，第三个数字是：<span class="subst">&#123;c&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>推荐在项目中使用 <code>$</code> 作为占位符修饰字。</p></blockquote><h2 id="2-6-可空类型-💖💖💖"><a href="#2-6-可空类型-💖💖💖" class="headerlink" title="2.6 可空类型 💖💖💖"></a>2.6 可空类型 💖💖💖</h2><p>在 C# 中，值类型例如 int 的默认值是 0 ，同时也不能进 <code>a = null</code> 的赋值操作。一般情况下所有 <code>if( a != null)</code> 永远为真。</p><p>C# 提供了一个特殊的数据类型，<code>nullable</code> 类型（<strong>可空类型</strong>），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</p><p><code>?</code> 单问号用于对 <code>int、double、bool</code>等无法直接赋值为 <code>null</code> 的数据类型进行 <code>null</code> 的赋值</p><h3 id="2-6-1-定义可空类型"><a href="#2-6-1-定义可空类型" class="headerlink" title="2.6.1 定义可空类型"></a>2.6.1 定义可空类型</h3><p>语法如下：声明一个 <code>nullable</code> 类型（可空类型）的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data_type&gt;? &lt;variable_name&gt; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? i = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-null-合并运算符（-）"><a href="#2-6-2-null-合并运算符（-）" class="headerlink" title="2.6.2 null 合并运算符（ ?? ）"></a>2.6.2 null 合并运算符（ ?? ）</h3><p><code>null</code>合并运算符用于定义<strong>可空类型</strong>和<strong>引用类型</strong>的默认值。<strong>null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 null</strong>。下面的实例演示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NullablesAtShow</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//定义可空类型</span></span><br><span class="line">          <span class="built_in">double</span>? num1 = <span class="literal">null</span>;</span><br><span class="line">          <span class="built_in">double</span>? num2 = <span class="number">3.14157</span>;</span><br><span class="line">          <span class="built_in">double</span> num3;</span><br><span class="line">          <span class="comment">//如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值</span></span><br><span class="line">          num3 = num1 ?? <span class="number">5.34</span>;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;num3 的值： &#123;0&#125;&quot;</span>, num3);</span><br><span class="line">          num3 = num2 ?? <span class="number">5.34</span>;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;num3 的值： &#123;0&#125;&quot;</span>, num3);</span><br><span class="line">          Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果左操作数的值不为 <code>null</code>，则 null 合并运算符 <code>??</code> 返回该值；否则，它会计算右操作数并返回其结果。 如果左操作数的计算结果为非 null，则 <code>??</code> 运算符不会计算其右操作数。</p><p>仅当左操作数的计算结果为 <code>null</code> 时，Null 合并赋值运算符 <code>??=</code> 才会将其右操作数的值赋值给其左操作数。 如果左操作数的计算结果为非 null，则 <code>??=</code> 运算符不会计算其右操作数。</p><h3 id="2-6-3-操作符"><a href="#2-6-3-操作符" class="headerlink" title="2.6.3 ?. 操作符"></a>2.6.3 <code>?.</code> 操作符</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A?.print();</span><br></pre></td></tr></table></figure><p>如果 <code>A</code> 不为 <code>null</code> ，则执行 <code>print()</code> 方法。</p><h1 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h1><h2 id="3-1-选择结构"><a href="#3-1-选择结构" class="headerlink" title="3.1 选择结构"></a>3.1 选择结构</h2><h3 id="3-1-1-单-if-语句"><a href="#3-1-1-单-if-语句" class="headerlink" title="3.1.1 单 if 语句"></a>3.1.1 单 if 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(逻辑表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 如果逻辑表达式为真将执行的语句 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-if-else-语句"><a href="#3-1-2-if-else-语句" class="headerlink" title="3.1.2 if/else 语句"></a>3.1.2 if/else 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 如果布尔表达式为真将执行的语句 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 如果布尔表达式为假将执行的语句 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-switch-语句"><a href="#3-1-3-switch-语句" class="headerlink" title="3.1.3 switch 语句"></a>3.1.3 switch 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression:</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant-expression:</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 您可以有任意数量的 case 语句 */</span></span><br><span class="line">    <span class="literal">default</span> : <span class="comment">/* 默认执行（除了上面情况之外） */</span></span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>语句必须遵循下面的规则：</p><ul><li><code>case</code> 的<code>constant-expression</code>必须与<code>switch</code>中的变量具有相同的数据类型，且必须是一个常量。</li><li>当遇到<code>break</code>语句时，<code>switch</code>终止，控制流将跳转到 <code>switch</code> 语句后的下一行。</li><li>C# 不允许从一个开关部分继续执行到下一个开关部分。如果 <code>case</code> 语句中有处理语句，则必须包含<code>break</code>或其他跳转语句。</li></ul><h3 id="3-1-4-三目运算符"><a href="#3-1-4-三目运算符" class="headerlink" title="3.1.4 三目运算符"></a>3.1.4 三目运算符</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑表达式 ? Exp2 : Exp3</span><br></pre></td></tr></table></figure><p>请注意，冒号的使用和位置。 <code>?</code> 表达式的值是由<strong>逻辑表达式</strong>决定的。</p><ul><li>如果逻辑表达式为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值</li><li>如果逻辑表达式为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值</li></ul><h2 id="3-2-循环结构"><a href="#3-2-循环结构" class="headerlink" title="3.2 循环结构"></a>3.2 循环结构</h2><h3 id="3-2-1-while-语句"><a href="#3-2-1-while-语句" class="headerlink" title="3.2.1 while 语句"></a>3.2.1 while 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(逻辑表达式/循环条件)</span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进行判断，满足判断条件后再循环。</p><h3 id="3-2-2-do-while-语句"><a href="#3-2-2-do-while-语句" class="headerlink" title="3.2.2 do-while 语句"></a>3.2.2 do-while 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;<span class="keyword">while</span>(逻辑表达式/循环条件);</span><br></pre></td></tr></table></figure><p>先进行循环，然后判断是否继续循环。</p><h3 id="3-2-3-for-语句"><a href="#3-2-3-for-语句" class="headerlink" title="3.2.3 for 语句"></a>3.2.3 for 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式1一般为声明循环变量</span></span><br><span class="line"><span class="comment">//循环条件</span></span><br><span class="line"><span class="comment">//改变循环条件</span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-循环控制语句"><a href="#3-2-4-循环控制语句" class="headerlink" title="3.2.4 循环控制语句"></a>3.2.4 循环控制语句</h3><ol><li><code>break</code>：跳出当前循环，如果有循环的嵌套，那么只会跳出<strong>一层</strong>循环</li><li><code>continue</code>：立即结束<strong>本次</strong>循环，然后判断循环条件，如果成立，则进入下一次循环，否则退出循环</li></ol><h1 id="四、复杂数据类型"><a href="#四、复杂数据类型" class="headerlink" title="四、复杂数据类型"></a>四、复杂数据类型</h1><h2 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4.1 字符串"></a>4.1 字符串</h2><p>字符串是引用类型。在 C# 中，您可以使用<strong>字符数组</strong>来表示字符串。但是，更常见的做法是使用 <code>string</code> 关键字来声明一个字符串变量。</p><h3 id="4-1-1-创建-String-对象"><a href="#4-1-1-创建-String-对象" class="headerlink" title="4.1.1 创建 String 对象"></a>4.1.1 创建 String 对象</h3><p>您可以使用以下方法之一来创建 string 对象：</p><ul><li>通过给 <code>String</code> 变量指定一个字符串</li><li>通过使用 <code>String</code> 类构造函数</li><li>通过使用字符串串联运算符（ + ）</li><li>通过检索属性或调用一个返回字符串的方法</li><li>通过<strong>格式化方法</strong>来转换一个值或对象为它的字符串表示形式</li></ul><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StringApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">//字符串，字符串连接</span></span><br><span class="line">            <span class="built_in">string</span> fname, lname;</span><br><span class="line">            fname = <span class="string">&quot;Rowan&quot;</span>;</span><br><span class="line">            lname = <span class="string">&quot;Atkinson&quot;</span>;</span><br><span class="line">            <span class="built_in">string</span> fullname = fname + lname;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Full Name: &#123;0&#125;&quot;</span>, fullname);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过使用 string 构造函数</span></span><br><span class="line">            <span class="built_in">string</span> greetings = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Greetings: &#123;0&#125;&quot;</span>, greetings);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法返回字符串</span></span><br><span class="line">            <span class="built_in">string</span>[] sarray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;From&quot;</span>, <span class="string">&quot;Tutorials&quot;</span>, <span class="string">&quot;Point&quot;</span> &#125;;</span><br><span class="line">            <span class="built_in">string</span> message = String.Join(<span class="string">&quot; &quot;</span>, sarray);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于转化值的格式化方法</span></span><br><span class="line">            DateTime waiting = <span class="keyword">new</span> DateTime(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">58</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> chat = String.Format(<span class="string">&quot;Message sent at &#123;0:t&#125; on &#123;0:D&#125;&quot;</span>,</span><br><span class="line">            waiting);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, chat);</span><br><span class="line">            Console.ReadKey() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2-String-类的属性"><a href="#4-1-2-String-类的属性" class="headerlink" title="4.1.2 String 类的属性"></a>4.1.2 String 类的属性</h3><p><code>String</code> 类有以下两个常用属性：</p><div class="table-container"><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Chars</td><td style="text-align:left">在当前 _String_ 对象中获取 _Char_ 对象的指定位置。</td></tr><tr><td style="text-align:center">Length</td><td style="text-align:left">在当前的 _String_ 对象中获取字符数。</td></tr></tbody></table></div><h3 id="4-1-3-String-类的方法"><a href="#4-1-3-String-类的方法" class="headerlink" title="4.1.3 String 类的方法"></a>4.1.3 String 类的方法</h3><p>具体可以参考：<a href="https://www.runoob.com/csharp/csharp-string.html">C# 字符串（String） | 菜鸟教程 (runoob.com)</a>。</p><h2 id="4-2-数组"><a href="#4-2-数组" class="headerlink" title="4.2 数组"></a>4.2 数组</h2><p>数组是一个引用类型。数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。</p><h3 id="4-2-1-声明数组"><a href="#4-2-1-声明数组" class="headerlink" title="4.2.1 声明数组"></a>4.2.1 声明数组</h3><p>在 C# 中声明一个数组，您可以使用下面的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">datatype[] arrayName;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="built_in">int</span>[] id;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>datatype</code>用于指定被存储在数组中的元素的类型</li><li><code>[ ]</code>指定数组的秩（维度）。秩指定数组的大小</li><li><code>arrayName</code> 指定数组的名称</li></ul><h3 id="4-2-2-初始化数组"><a href="#4-2-2-初始化数组" class="headerlink" title="4.2.2 初始化数组"></a>4.2.2 初始化数组</h3><p>声明一个数组不会在内存中初始化数组。当初始化数组变量时，您可以赋值给数组。数组是一个引用类型，所以您需要使用 <strong>new</strong> 关键字来创建数组的实例。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="4-2-3-赋值给数组"><a href="#4-2-3-赋值给数组" class="headerlink" title="4.2.3 赋值给数组"></a>4.2.3 赋值给数组</h3><p>您可以通过使用索引号赋值给一个单独的数组元素，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line">balance[<span class="number">0</span>] = <span class="number">4500.0</span>;</span><br></pre></td></tr></table></figure><p>您可以在声明数组的同时给数组赋值，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = &#123; <span class="number">2340.0</span>, <span class="number">4523.69</span>, <span class="number">3421.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>您也可以创建并初始化一个数组，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure><p>在上述情况下，你也可以省略数组的大小，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure><p>您也可以赋值一个数组变量到另一个目标数组变量中。在这种情况下，目标和源会指向相同的内存位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] score = marks;</span><br></pre></td></tr></table></figure><p>当您创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。</p><h3 id="4-2-4-访问数组元素"><a href="#4-2-4-访问数组元素" class="headerlink" title="4.2.4 访问数组元素"></a>4.2.4 访问数组元素</h3><p>元素是通过带索引的数组名称来访问的。这是通过把元素的索引放置在数组名称后的方括号中来实现的。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> salary = balance[<span class="number">9</span>];</span><br></pre></td></tr></table></figure><h2 id="4-3-枚举"><a href="#4-3-枚举" class="headerlink" title="4.3 枚举"></a>4.3 枚举</h2><p>枚举是值类型。enum：枚举的关键字，声明枚举的关键字。具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line">[<span class="meta">public</span>] <span class="built_in">enum</span> 枚举名</span><br><span class="line">&#123;</span><br><span class="line">    值<span class="number">1</span>,</span><br><span class="line">    值<span class="number">2</span>,</span><br><span class="line">    值<span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> Gender</span><br><span class="line">&#123;</span><br><span class="line">    男,</span><br><span class="line">    女</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Gender gender = Gender.男;</span><br></pre></td></tr></table></figure><h2 id="4-4-结构体"><a href="#4-4-结构体" class="headerlink" title="4.4 结构体"></a>4.4 结构体</h2><p>在 C# 中，结构体是<strong>值类型</strong>数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。<code>struct</code>关键字用于创建结构体。结构体是用来代表一个记录。</p><h3 id="4-4-1-构造结构体"><a href="#4-4-1-构造结构体" class="headerlink" title="4.4.1 构造结构体"></a>4.4.1 构造结构体</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">public</span>] <span class="keyword">struct</span> 结构名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> 成员;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-2-C-结构的特点"><a href="#4-4-2-C-结构的特点" class="headerlink" title="4.4.2 C# 结构的特点"></a>4.4.2 C# 结构的特点</h3><p>在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：</p><ul><li>结构可带有方法、字段、索引、属性、运算符方法和事件。</li><li>结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。</li><li>与类不同，结构不能继承其他的结构或类。</li><li>结构不能作为其他结构或类的基础结构。</li><li>结构可实现一个或多个接口。</li><li>结构成员不能指定为 abstract、virtual 或 protected。</li><li>当您使用 <strong>New</strong> 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。</li><li>如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li></ul><h1 id="五、函数-方法"><a href="#五、函数-方法" class="headerlink" title="五、函数/方法"></a>五、函数/方法</h1><p>一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类。</p><h2 id="5-1-定义方法"><a href="#5-1-定义方法" class="headerlink" title="5.1 定义方法"></a>5.1 定义方法</h2><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] [<span class="keyword">static</span>] 返回值类型 方法名([形式参数列表])</span><br><span class="line">&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-调用方法"><a href="#5-2-调用方法" class="headerlink" title="5.2 调用方法"></a>5.2 调用方法</h2><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.方法名([实际参数列表]);<span class="comment">//当方法和主函数在同一类下，则不用添加类名</span></span><br><span class="line">对象.方法名([实际参数列表]);</span><br></pre></td></tr></table></figure><h2 id="5-3-函数的递归"><a href="#5-3-函数的递归" class="headerlink" title="5.3 函数的递归"></a>5.3 函数的递归</h2><p>一个方法可以自我调用。这就是所谓的 <strong>递归</strong>。</p><blockquote><p>应当在工程中，避免使用递归方法。因为递归方法</p></blockquote><h2 id="5-4-参数传递与-💗高级参数💗"><a href="#5-4-参数传递与-💗高级参数💗" class="headerlink" title="5.4 参数传递与 💗高级参数💗"></a>5.4 参数传递与 💗<code>高级参数</code>💗</h2><div class="table-container"><table><thead><tr><th style="text-align:center">方式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">值参数</td><td style="text-align:left">这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</td></tr><tr><td style="text-align:center">引用参数</td><td style="text-align:left">这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。</td></tr><tr><td style="text-align:center">输出参数</td><td style="text-align:left">这种方式可以返回多个值。</td></tr></tbody></table></div><h3 id="5-4-1-按值传递参数"><a href="#5-4-1-按值传递参数" class="headerlink" title="5.4.1 按值传递参数"></a>5.4.1 按值传递参数</h3><p>这是参数传递的默认方式。在这种方式下，当调用一个方法时，会为每个值参数创建一个新的存储位置。</p><p>实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Add10</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a = a+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a,b,c;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = Add10(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把实际参数 a 传入到函数 Add10(a) 中去，在该函数中，对形式参数 a 进行赋值计算，但是形参 a 改变没有影响实参 a ，它们两个使用不同的内存空间。</p><h3 id="5-4-2-按引用传递参数——ref"><a href="#5-4-2-按引用传递参数——ref" class="headerlink" title="5.4.2 按引用传递参数——ref"></a>5.4.2 按引用传递参数——ref</h3><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。在 C# 中，使用 <code>ref</code> 关键字声明引用参数。</p><p>在以下示例中，<code>p</code>和<code>x</code>指的是相同的存储器位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span> (<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> p</span>)</span> &#123;</span><br><span class="line">       p = p + <span class="number">1</span>;             <span class="comment">// Increment p by 1</span></span><br><span class="line">       Console.WriteLine (p); <span class="comment">// Write p to screen</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span>&#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">8</span>;</span><br><span class="line">        myMethod (<span class="keyword">ref</span> x);      <span class="comment">// Ask myMethod to deal directly with x</span></span><br><span class="line">        Console.WriteLine (x); <span class="comment">// x is now 9</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-3-按输出传递参数——out"><a href="#5-4-3-按输出传递参数——out" class="headerlink" title="5.4.3 按输出传递参数——out"></a>5.4.3 按输出传递参数——out</h3><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个或多个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p><p>out 参数就像一个<code>ref</code>参数，但是它:</p><ul><li>在进入函数之前不需要赋值</li><li><strong>必须在它出来的函数之前赋值</strong></li><li>out 修饰符用于从方法获取多个返回值。</li></ul><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToWords</span> (<span class="params"><span class="built_in">string</span> name, <span class="keyword">out</span> <span class="built_in">string</span> firstNames, <span class="keyword">out</span> <span class="built_in">string</span> lastName</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//out参数要求在方法的内部必须为其赋值</span></span><br><span class="line">       <span class="built_in">int</span> i = name.LastIndexOf (<span class="string">&quot; &quot;</span>);</span><br><span class="line">       firstNames = name.Substring (<span class="number">0</span>, i);</span><br><span class="line">       lastName = name.Substring (i + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> a, b;</span><br><span class="line">        ToWords(<span class="string">&quot;this is a test&quot;</span>, <span class="keyword">out</span> a, <span class="keyword">out</span> b);</span><br><span class="line">        Console.WriteLine (a);</span><br><span class="line">        Console.WriteLine (b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-4-params-修饰符"><a href="#5-4-4-params-修饰符" class="headerlink" title="5.4.4 params 修饰符"></a>5.4.4 params 修饰符</h3><p>将实参列表中跟可变参数数组类型一致的元素都当作数组的元素去处理。<code>params</code>参数修饰符用于方法的<strong>最后一个参数</strong>，以便该方法接受任意数量的特定类型的参数。</p><p>参数类型必须声明为数组。</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Sum</span> (<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] ints</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ints.Length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">          sum += ints[i]; <span class="comment">// Increase sum by ints[i]</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = Sum (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        Console.WriteLine (total); <span class="comment">// 10</span></span><br><span class="line">        <span class="built_in">int</span> total = Sum (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>，<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine (total); <span class="comment">// 15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-5-命名参数"><a href="#5-4-5-命名参数" class="headerlink" title="5.4.5 命名参数"></a>5.4.5 命名参数</h3><p>我们可以通过名称识别参数，参考 Python 的位置参数。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span> (<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine (x + <span class="string">&quot;, &quot;</span> + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   myMethod (x:<span class="number">1</span>, y:<span class="number">2</span>); <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-匿名方法"><a href="#5-5-匿名方法" class="headerlink" title="5.5 匿名方法"></a>5.5 匿名方法</h2><p>在 C#中，匿名方法是一种没有名称且可以在运行时定义的方法，通常用于在需要时定义委托或事件的处理程序。下面是一个示例，演示如何使用匿名方法定义一个简单的委托：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">PrintDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PrintDelegate print = <span class="built_in">delegate</span> (<span class="built_in">string</span> message) &#123; Console.WriteLine(message); &#125;;</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，匿名方法在定义时可以访问包含它的方法中的变量，这些变量称为“捕获变量”。例如，下面是一个示例，演示如何使用匿名方法访问捕获变量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line">        Action print = <span class="built_in">delegate</span> () &#123; Console.WriteLine(x); &#125;;</span><br><span class="line">        x = <span class="number">20</span>;</span><br><span class="line">        print();  <span class="comment">// 输出20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为 print 的委托，它没有参数，返回类型为 void。在匿名方法中，我们输出了变量 x 的值，然后修改了变量 x 的值，最后调用了 print 方法。<strong>由于匿名方法访问的是变量的引用，因此输出的值为 20，而不是最 初的值 10</strong>。</p><p>Lambda 表达式主要用于实现匿名方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参</span></span><br><span class="line">() =&gt; &#123;  &#125;</span><br><span class="line"><span class="comment">//一个参数</span></span><br><span class="line">(x) =&gt; &#123; &#125;</span><br><span class="line">x =&gt; &#123; &#125;</span><br><span class="line"><span class="comment">//多参数</span></span><br><span class="line">(x,y,z) =&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单语句，可以不加 &#123; &#125;</span></span><br><span class="line">() =&gt; a = <span class="number">5</span>; <span class="comment">//执行 a = 5 ，但是没有任何返回值</span></span><br><span class="line">() =&gt; a; <span class="comment">// 单语句如果是一个值/引用，返回对应的的值/引用，可以省略return。例如：前面代码返回a的值</span></span><br><span class="line">(message) =&gt; Console.WriteLine(message); <span class="comment">// 单语句可以是一个函数，并且能接受对应的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多语句，必须加 &#123; &#125;</span></span><br><span class="line">(x,y) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、面向对象——类"><a href="#六、面向对象——类" class="headerlink" title="六、面向对象——类"></a>六、面向对象——类</h1><h2 id="6-1-类的成员"><a href="#6-1-类的成员" class="headerlink" title="6.1 类的成员"></a>6.1 类的成员</h2><p>C#中，类有三个成员：</p><ul><li>字段<ul><li>静态</li><li>非静态</li></ul></li><li>属性<ul><li>静态</li><li>非静态</li></ul></li><li>方法/函数<ul><li>构造方法</li><li>自定义方法</li><li>析构函数</li></ul></li></ul><p>一般格式如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">public</span>] [<span class="keyword">static</span>] <span class="keyword">class</span> <span class="title">ClassName</span>[&lt;泛型&gt;] [:<span class="title">Father</span>]</span><br><span class="line">&#123;</span><br><span class="line">    [字段];</span><br><span class="line">    [属性];</span><br><span class="line">    [方法];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>类名命名规则符合 Pascal 规范。每个单词的首字母都要大写，其余字母小写。比如：MyFirstClass</li><li>静态类和动态类有区别，成员也有就静态和动态的区别，默认为私有、动态类。（这里在随后进行详细说明）</li><li>如果要访问类的成员，你要使用点（.）运算符。</li><li>点运算符链接了对象（或类）的名称和成员的名称。</li></ol><h3 id="6-1-1-字段"><a href="#6-1-1-字段" class="headerlink" title="6.1.1 字段"></a>6.1.1 字段</h3><p>字段是在类或结构中直接声明的任意类型的变量。 字段是其包含类型的成员。</p><p>字段(field) 用来存储数值或对象的真正实体</p><p>注意：</p><ul><li><p>命名规则：</p><ul><li>Camel。骆驼命名规范。变量名中首单词的首字母要小写，其余单词的首字母要大写。</li><li>类的字段一般以<strong>下划线</strong>开头。</li></ul></li></ul><h3 id="6-1-2-属性"><a href="#6-1-2-属性" class="headerlink" title="6.1.2 属性"></a>6.1.2 属性</h3><p>属性从外部看起来像字段，但在内部它们包含逻辑。一个属性被声明为一个字段，但是添加了一个 get / set 块。</p><p>以下是如何实现 CurrentPrice 作为属性：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">decimal</span> _currentPrice;       <span class="comment">// The private &quot;backing&quot; field、</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> CurrentPrice <span class="comment">// The public property</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> _currentPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">          _currentPrice = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性的作用：保护字段，对字段的赋值、取值进行限定</p><ul><li>当给属性赋值时，会执行 set 方法</li><li>当给属性输出时，会执行 get 方法</li></ul><p>注意：</p><ul><li>命名规则符合 Pascal 规范。</li></ul><h3 id="6-1-3-构造方法"><a href="#6-1-3-构造方法" class="headerlink" title="6.1.3 构造方法"></a>6.1.3 构造方法</h3><p>作用：帮助我们给初始化对象（给每个属性依次赋值）</p><p>构造函数是一种特殊的方法；当在实例化类的时候，自动执行函数里面的内容（参考 python 的_<strong>_init__</strong>构造方法）</p><ol><li>构造方法没有返回值，连 void 也不能写</li><li>构造方法的名称必须跟类名一致</li><li>构造方法可以重载</li><li>每写好一个类，就会自带一个无参数的构造方法，<strong>当写了一个构造函数后，默认的无参构造方法就会消失</strong>。</li></ol><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stuident</span>()<span class="comment">//必须是public</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        xxxxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-4-💎this💎-关键字"><a href="#6-1-4-💎this💎-关键字" class="headerlink" title="6.1.4 💎this💎 关键字"></a>6.1.4 💎this💎 关键字</h3><p>this 是 C#中的保留字，</p><ol><li><p>作用 1 ：</p><ul><li>它允许一个对象指向它自己，即 this 表示当前正在被操作的对象本身。</li><li>在方法内部，this 引用可以用于指向任何当前执行的对象。</li><li>经常地，this 引用用于区分构造函数的参数和它们相对应的同名的实例变量。</li></ul><p>例如，当一个类有三个字段，实例化后的对象有<code>number、name、owner</code>三个属性。我们在初始化时，可以使用以下方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Money</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> _number;</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="built_in">string</span> _owner;</span><br><span class="line">    <span class="function">Public <span class="title">Money</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">string</span> b, <span class="built_in">string</span> c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _number = a;</span><br><span class="line">        _name = b;</span><br><span class="line">        _owner = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Money instance = <span class="keyword">new</span> Money(<span class="number">1</span>,<span class="string">&quot;w&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是上述方法存在一些问题：为了让类的字段和初始化时传入类的参数做区别，特别的将变量的名称写成不一样的，这样降低了程序代码的可读性。因此可以使用 this 关键字对当前对象进行引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Money</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> _number;</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="built_in">string</span> _owner;</span><br><span class="line">    <span class="function">Public <span class="title">Money</span>(<span class="params"><span class="built_in">int</span> number, <span class="built_in">string</span> name, <span class="built_in">string</span> owner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._number = number;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等号前面指的是当前操作对象的某一个类成员，后者是传入到类的参数。因此将二者进行了区分。</p></li><li><p>作用 2 ：</p><p>构造函数重载时，将重载的构造函数的参数传递给其他构造函数，并且使其初始化类。 例如，下面的 Person 类有三个构造方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">this</span>关键字测试</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> _id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> _name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> _gender;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">int</span> gender, <span class="built_in">int</span> age</span>)：</span></span><br><span class="line">        &#123;</span><br><span class="line">            _id = id;</span><br><span class="line">            _name = name;</span><br><span class="line">            _gender = gender;</span><br><span class="line">            _age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">int</span> gender</span>) : <span class="title">this</span>(<span class="params">id, <span class="string">&quot;www&quot;</span>, gender, <span class="number">20</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//_id = id;</span></span><br><span class="line">            <span class="comment">//_gender = gender;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">        &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">            Person person1 = <span class="keyword">new</span> Person(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，当我们 new 创建类的实例化对象时，会调用类的构造函数对类进行初始化。当有多个构造函数时，<strong>会根据传入的参数列表自动选择对应的构造函数</strong>。但是，我们不希望在每个构造函数中，都写一遍初始化语句。因此，我们可以使用 this 关键字，将当前选择的构造函数中已经接收到的参数列表，传给另一个构造函数，<u>多余的参数不用写，缺省的参数要补上</u>。然后<strong>先执行接收 this 传递的参数列表的构造函数，再执行 new 时自动选择的构造函数</strong>。</p></li></ol><h3 id="6-1-5-析构函数"><a href="#6-1-5-析构函数" class="headerlink" title="6.1.5 析构函数"></a>6.1.5 析构函数</h3><ul><li>当程序结束的时候或者类不在被调用的时候，析构函数才运行</li><li>该函数可以帮助我们释放资源</li><li>GC Garbage Collection 垃圾回收，因此，在实际开发中，析构函数并不常用</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~Student()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是析构函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-类的构造和实例化"><a href="#6-2-类的构造和实例化" class="headerlink" title="6.2 类的构造和实例化"></a>6.2 类的构造和实例化</h2><h3 id="6-2-1-类的构造"><a href="#6-2-1-类的构造" class="headerlink" title="6.2.1 类的构造"></a>6.2.1 类的构造</h3><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">public</span>] [<span class="keyword">static</span>] <span class="keyword">class</span> <span class="title">ClassName</span>[&lt;泛型&gt;] [:<span class="title">Father</span>]</span><br><span class="line">&#123;</span><br><span class="line">    [字段];</span><br><span class="line">    [属性];</span><br><span class="line">    [方法];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-类的实例化"><a href="#6-2-2-类的实例化" class="headerlink" title="6.2.2 类的实例化"></a>6.2.2 类的实例化</h3><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如有个类：Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的实例化</span></span><br><span class="line">Student zhangsan = <span class="keyword">new</span> Student([参数列表]);</span><br></pre></td></tr></table></figure><p>实例化的对象是：zhangsan，该对象的类型为：Student。括号里面是传入到类中的可选参数。</p><p><code>new</code>针对类实例化的作用：</p><ol><li>在内存中开辟一块<strong>新的空间</strong>（堆区）</li><li>调用类的构造方法</li><li><strong>所有的构造方法执行完毕，对象才会被创建</strong></li></ol><blockquote><p><code>new</code>还有其他的一些用法，比如创建变量等，具体功能根据实际代码而定。</p></blockquote><h2 id="6-3-封装"><a href="#6-3-封装" class="headerlink" title="6.3 封装"></a>6.3 封装</h2><h3 id="6-3-1-访问修饰符"><a href="#6-3-1-访问修饰符" class="headerlink" title="6.3.1 访问修饰符"></a>6.3.1 访问修饰符</h3><p><strong>封装</strong> 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。</p><p>抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。</p><p>C# 封装根据具体的需要，设置使用者的访问权限，并通过 <strong>访问修饰符</strong> 来实现。</p><p>一个 <strong>访问修饰符</strong> 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:left">所有对象都可以访问</td></tr><tr><td style="text-align:center">protected internal</td><td style="text-align:left">访问限于当前程序集或派生自包含类的类型</td></tr><tr><td style="text-align:center">internal</td><td style="text-align:left">同一个程序集的对象可以访问</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:left">只有该类对象及其子类对象可以访问</td></tr><tr><td style="text-align:center">private（默认）</td><td style="text-align:left">对象本身在对象内部可以访问</td></tr></tbody></table></div><ul><li>Public 访问修饰符：允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。</li><li>Protected Internal 访问修饰符：允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。</li><li>Internal 访问修饰符：允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有 internal 访问修饰符的任何成员，可以被定义在该成员所定义的<strong>应用程序内</strong>的任何类或方法访问。</li><li>Protected 访问修饰符：允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。</li><li>Private 访问修饰符：允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</li></ul><p>类比理解：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">比如说：一个人 A 为父类，他的儿子 B，妻子 C，私生子 D（注：D 不在他家里）</span><br><span class="line"></span><br><span class="line">如果我们给 A 的事情增加修饰符：</span><br><span class="line"></span><br><span class="line">public 事件，地球人都知道，全公开</span><br><span class="line">protected internal 事件，A，B，C，D 都知道,其它人不知道</span><br><span class="line">internal 事件，A，B，C 知道（A 家里人都知道，私生子 D 不知道）</span><br><span class="line">protected 事件，A，B，D 知道（A 和他的所有儿子知道，妻子 C 不知道）</span><br><span class="line">private 事件，只有 A 知道（隐私？心事？）</span><br></pre></td></tr></table></figure><hr><p>在 C# 中，不同类型的成员具有不同的默认访问修饰符。以下是各种类型的成员及其默认访问修饰符的列表：</p><ol><li><strong>类（Class）</strong>：如果没有指定访问修饰符，默认为 <code>internal</code>。这意味着这个类只能在定义它的程序集内部访问。</li><li><strong>结构体（Struct）</strong>：与类相同，如果没有指定访问修饰符，默认为 <code>internal</code>。结构体和它们的成员只能在定义它们的程序集内部访问。</li><li><strong>接口（Interface）</strong>：与类和结构体相同，如果没有指定访问修饰符，默认为 <code>internal</code>。接口和它们的成员只能在定义它们的程序集内部访问。</li><li><strong>枚举（Enum）</strong>：与类、结构体和接口相同，如果没有指定访问修饰符，默认为 <code>internal</code>。枚举类型和它们的成员只能在定义它们的程序集内部访问。</li><li><strong>委托（Delegate）</strong>：与类、结构体、接口和枚举相同，如果没有指定访问修饰符，默认为 <code>internal</code>。委托类型只能在定义它们的程序集内部访问。</li><li><strong>类和结构体的成员</strong>：类和结构体的成员具有不同的默认访问修饰符，具体如下：<ul><li><strong>字段（Field）</strong>：如果没有指定访问修饰符，默认为 <code>private</code>。这意味着字段只能在声明它的类或结构体内部访问。</li><li><strong>方法（Method）</strong>：如果没有指定访问修饰符，默认为 <code>private</code>。这意味着方法只能在声明它的类或结构体内部访问。</li><li><strong>属性（Property）</strong>：如果没有指定访问修饰符，默认为 <code>private</code>。这意味着属性只能在声明它的类或结构体内部访问。</li><li><strong>事件（Event）</strong>：如果没有指定访问修饰符，默认为 <code>private</code>。这意味着事件只能在声明它的类或结构体内部访问。</li><li><strong>构造函数（Constructor）</strong>：如果没有指定访问修饰符，默认为 <code>private</code>。这意味着构造函数只能在声明它的类或结构体内部访问。</li><li><strong>嵌套类型（Nested Type）</strong>：例如嵌套类、嵌套结构体、嵌套接口和嵌套枚举，默认访问修饰符为 <code>private</code>。这意味着嵌套类型只能在声明它的外部类型内部访问。</li></ul></li></ol><p>请注意，这些默认访问修饰符可以通过显式指定访问修饰符（例如 <code>public</code>、<code>protected</code>、<code>internal</code> 或 <code>private</code>）来修改。</p><h2 id="6-4-继承"><a href="#6-4-继承" class="headerlink" title="6.4 继承"></a>6.4 继承</h2><p>继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。</p><p>当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的 <strong>基类</strong>，这个新的类被称为<strong>派生类</strong>。</p><p>我们可能会在一些类中写重复的成员，我们可以将这些重复的成员，单独的封装到一个类中，作为这些类的<strong>父类</strong>（基类），那么，这些类就叫做<strong>父类</strong>的<strong>子类</strong>（派生类）。</p><p>类可以从另一个类继承以扩展或定制原始类。继承一个类会重用该类中的功能。类只能从一个类继承。</p><h3 id="6-4-1-继承的语法"><a href="#6-4-1-继承的语法" class="headerlink" title="6.4.1 继承的语法"></a>6.4.1 继承的语法</h3><p>继承的格式如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    xxxxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>子类可以从父类中继承：字段、属性、方法</p></li><li><p>子类不能继承父类的<strong>私有</strong>的字段、属性、方法</p></li><li><p>父类不能从子类中调用成员</p></li><li><p><strong>子类没有继承父类的构造函数，子类会默认的调用父类的无参构造方法</strong></p><ol><li><p>子类用 new 实例化时，首先会默认的调用父类的无参构造方法，这一过程是为了创建父类的实例化对象，让子类能使用父类中的成员</p></li><li><p>然后父类的无参构造函数执行完，才会执行自己的构造方法。</p></li><li><p>父类会默认地自带一个无参构造方法，但是<strong>父类中存在有参的构造函数时，默认的无参构造函数就会消失</strong>，这时候创建子类时，会报错。</p></li><li><p>因此，在定义含有<strong>有参构造函数</strong>的父类时，一般需手动定义一个无参的构造函数，以便于让子类调用。</p></li></ol></li><li><p>在子类中显示调用父类的构造函数，使用关键字：base</p><p>使用此方法一般不用手动构造无参的构造函数，因为子类这时会直接调用父类对应的构造方法（如果父类有有参构造方法，而子类 base 的是父类的无参构造方法，那么还是需要手动在父类中创建无参构造方法），而子类中，一旦含有不使用 base 的构造方法，那么父类就必须存在无参构造方法。</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span> (<span class="params"><span class="built_in">string</span> name , <span class="built_in">int</span> age , <span class="built_in">char</span> gender</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name ,<span class="built_in">int</span> age , <span class="built_in">char</span> gender</span>) : <span class="title">base</span> (<span class="params">name , age , gender</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>继承的单根性：一个子类只能有一个父类</li><li>继承的传递性：子类能继续被继承</li></ol><h3 id="6-4-2-里氏转换"><a href="#6-4-2-里氏转换" class="headerlink" title="6.4.2 里氏转换"></a>6.4.2 里氏转换</h3><ol><li>子类可以赋值给父类：如果有一个地方需要父类作为参数，我们可以给一个子类代替父类</li><li>如果父类对象参数中装的是子类对象，那么可以将这个父类对象强转为子类对象</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PersonSay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是父类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StudentSay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TeacherSay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是老师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//里氏转换</span></span><br><span class="line">        <span class="comment">//子类赋值给父类</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">/*或者*/</span></span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        Person p = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在父类p中装的是子类对象s，那么可以将这个父类对象强转为子类对象</span></span><br><span class="line">        Student ss = (Student)p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-3-is-与-as-关键字"><a href="#6-4-3-is-与-as-关键字" class="headerlink" title="6.4.3 is 与 as 关键字"></a>6.4.3 is 与 as 关键字</h3><ul><li><p><strong><code>is</code></strong>：表示类型转换，如果能够转换成功，则返回一个 ture，如果转换失败，则返回一个 false</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略上述 6.4.2 的代码</span></span><br><span class="line"><span class="keyword">if</span>（p <span class="keyword">is</span> teacher）</span><br><span class="line">&#123;</span><br><span class="line">    Teacher ss = (Teacher)p;</span><br><span class="line">    ss.TeacherSay();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是:转换失败</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>as</code></strong>：表示类型转换，如果能够转换成功，则返回<strong>对应的对象</strong>，否则返回一个 null</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略上述 6.4.2 的代码</span></span><br><span class="line"><span class="keyword">if</span>（p <span class="keyword">is</span> teacher）</span><br><span class="line">&#123;</span><br><span class="line">    Teacher ss = (Teacher)p;</span><br><span class="line">    ss.TeacherSay();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果是:转换失败</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-4-4-装箱与拆箱"><a href="#6-4-4-装箱与拆箱" class="headerlink" title="6.4.4 装箱与拆箱"></a>6.4.4 装箱与拆箱</h3><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型（引用类型）时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型（引用类型）转换为值类型时，则被称为 <strong>拆箱</strong>。能否装箱或拆箱，要看两种类型之间有无继承关系，有继承关系，就能发生装箱和拆箱。</p><blockquote><p>注意：装箱过程存在类型的转换，因此在程序运行时，需要更多的时间。</p></blockquote><h2 id="6-5-多态"><a href="#6-5-多态" class="headerlink" title="6.5 多态"></a>6.5 多态</h2><p>这里先通过一个例子，来展示父类对象变量装载的是子类对象时，父类、子类同名方法的调用问题。例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 多态之虚方法</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//父类对象</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> _name;<span class="comment">//字段</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Name = name;</span><br><span class="line">        &#125;<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;<span class="comment">//属性</span></span><br><span class="line">        <span class="comment">//父类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是人类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">China</span> : <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用父类的构造方法进行实例化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">China</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line">        <span class="comment">//子类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Japanese</span> : <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Japanese</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Korea</span> : <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Korea</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">American</span> : <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">American</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建子类对象</span></span><br><span class="line">            China ch1 = <span class="keyword">new</span> China(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">            Japanese j1 = <span class="keyword">new</span> Japanese(<span class="string">&quot;日本&quot;</span>);</span><br><span class="line">            Korea k = <span class="keyword">new</span> Korea(<span class="string">&quot;韩国&quot;</span>);</span><br><span class="line">            American a = <span class="keyword">new</span> American(<span class="string">&quot;美国人&quot;</span>);</span><br><span class="line">            <span class="comment">//创建父类对象数组，并把子类对象装载进去</span></span><br><span class="line">            Person[] person = &#123; ch1, j1, k, a &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                person[i].SayHello();</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是人类</span><br><span class="line">我是人类</span><br><span class="line">我是人类</span><br><span class="line">我是人类</span><br></pre></td></tr></table></figure><p>表明：如果父类和子类中有相同的方法时，那么根据当前操作的对象的类型，执行相应的方法。子类变量会执行子类的方法，父类变量执行父类的方法。</p><p>首先我们理解，<code>Person[] person = &#123; ch1, j1, k, a &#125;</code> 变量类型是<code>Person</code>，但是父类变量中装载的子类对象。</p><p>我们将 for 循环中，添加下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (person[i] <span class="keyword">is</span> China)</span><br><span class="line">&#123;</span><br><span class="line">    ((China)person[i]).SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (person[i] <span class="keyword">is</span> Japanese)</span><br><span class="line">&#123;</span><br><span class="line">    ((Japanese)person[i]).SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (person[i] <span class="keyword">is</span> Korea)</span><br><span class="line">&#123;</span><br><span class="line">    ((Korea)person[i]).SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (person[i] <span class="keyword">is</span> American)</span><br><span class="line">&#123;</span><br><span class="line">    ((American)person[i]).SayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我是中国人</span><br><span class="line">我是人类</span><br><span class="line">我是日本人</span><br><span class="line">我是人类</span><br><span class="line">我是韩国人</span><br><span class="line">我是人类</span><br><span class="line">我是美国人人</span><br><span class="line">我是人类</span><br></pre></td></tr></table></figure><p>表明：如果父类和子类中有相同的方法时，那么根据当前操作的对象的类型，执行相应的方法。子类变量会执行子类的方法，父类变量执行父类的方法。</p><hr><p>多态的直接定义：让一个类能够表现出多种类型的状态（类型）。实现多态的 3 种手段：</p><ol><li>虚方法</li><li>抽象类</li><li>接口</li></ol><p><strong>静态多态性</strong>：在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：</p><ul><li>函数重载</li><li>运算符重载</li></ul><p><strong>动态多态性</strong>：使用关键字 <strong><code>abstract</code></strong> 创建<strong>抽象类</strong>，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。</p><p>下面是有关抽象类的一些规则：</p><ul><li>您不能创建一个抽象类的实例，因此抽象类必须被继承才能实例化</li><li>您不能在一个抽象类外部声明一个抽象方法，即抽象方法只能写在抽象类中</li><li>通过在类定义前面放置关键字 <strong><code>sealed</code></strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong><code>sealed</code></strong> 时，它不能被继承。抽象类不能被声明为 <code>sealed</code>。</li></ul><h3 id="6-5-1-虚方法"><a href="#6-5-1-虚方法" class="headerlink" title="6.5.1 虚方法"></a>6.5.1 虚方法</h3><p>抽象方法是需要子类去实现的。<strong>虚方法是已经实现了的，可以被子类覆盖，也可以不覆盖，取决于需求</strong>。</p><p>虚方法可以有实现体，若一个实例方法的声明中含有 <code>virtual</code> 修饰符，则称该方法为虚方法。使用了 <code>virtual</code> 修饰符后，不允许再有 <code>static</code>、<code>abstract</code> 或者 <code>override</code> 修饰符。</p><p><strong>父类的虚方法，可以在子类中重写</strong>（<code>override</code>），此时，再在父类对象中执行该方法，就会只执行对应子类对象的重写的方法。</p><p>例如，将上面的 Person 父类的 <code>SayHello()</code> 方法写为：添加修饰符 <code>virtual</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是人类&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把每个子类里面的 <code>SayHello()</code> 方法写为：添加修饰符 <code>override</code> ：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行多态的代码，就会得到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是中国人</span><br><span class="line">我是日本人</span><br><span class="line">我是韩国人</span><br><span class="line">我是美国人</span><br></pre></td></tr></table></figure><p>表明：父类变量里装载的是子类对象，在把父类方法定义为虚方法，并且子类进行重写后，再调用父类对象的方法时，只会执行相应的子类对象的方法。</p><p>如果想不仅能执行子类中重写的方法，还能同时执行父类中的虚方法，我么可以在<strong>子类中重写的方法中调用父类的虚方法</strong>。基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public override void FunctionName()</span><br><span class="line">&#123;</span><br><span class="line">    base.FunctionName();</span><br><span class="line">    [方法体;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>总结：当父类变量里装载的是子类对象。在父类中定义虚方法，并在子类中重写这个方法，那么调用父类变量的方法时，就会只执行子类中重写的方法；如果子类没有重写，那么还是会调用自身的方法。</p><h3 id="6-5-2-抽象类"><a href="#6-5-2-抽象类" class="headerlink" title="6.5.2 抽象类"></a>6.5.2 抽象类</h3><p>例如，狗狗会叫，猫猫也会叫，但是狗狗不能作为猫猫的父类，猫猫也不能作为狗狗的父类，因此需要抽象出一个类：动物（<code>animal</code>）。与狗狗类和猫猫类不同的是，动物类不能直接实例化出一个对象，因为范围太大，不确定是狗狗还是猫猫还是其他等，而狗狗类就能实例化出对象（具体的某个狗狗）。</p><p>当父类中的方法不知道怎么去实现的时候，可以把父类定义为抽象类，将方法写成抽象方法。使用 <code>abstract</code> 修饰。</p><p>我们可以写下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 抽象类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">            animal.Bark();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//空实现的函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;狗狗会汪汪汪&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;猫猫会喵喵喵&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">狗狗会汪汪汪</span><br></pre></td></tr></table></figure><p>因此，我们知道，当一个抽象父类变量装载子类对象时，调用的方法均是子类的方法。</p><p>抽象类有以下性质：</p><ol><li>抽象类不允许创建该类实例对象，但可以创建该类的子类对象</li><li>抽象方法只能存在于抽象类中，并且没有方法体，即没有大括号，但是结尾要加分号 <code>;</code></li><li>抽象类包含<ol><li>字段</li><li>属性</li><li>抽象属性</li><li>方法</li><li>抽象方法</li><li>虚方法</li></ol></li></ol><p>抽象方法和虚方法的区别：</p><ol><li><p>抽象方法是没有实现的方法，需要由子类去实现，而虚方法是有默认实现的方法，子类可以选择覆盖或者不覆盖。</p></li><li><p>抽象方法用 abstract 关键字来定义，而虚方法用 virtual 关键字来定义。</p></li><li><p>抽象方法必须放在抽象类或者接口中，而虚方法可以放在普通的类中。</p></li><li><p><strong>抽象方法没有方法体，而虚方法有默认的方法体</strong>。</p></li><li><p><strong>子类继承抽象类或者实现接口时，必须实现抽象方法，否则子类也要声明为抽象类</strong>；而子类继承类中的虚方法时，可以选择性地覆盖或者不覆盖。</p></li></ol><p>总之，抽象方法和虚方法都是为了实现多态性而存在的，它们的主要区别在于抽象方法是强制性的，需要子类去实现，而虚方法是可选的，子类可以选择覆盖或者不覆盖。</p><h3 id="6-5-3-接口"><a href="#6-5-3-接口" class="headerlink" title="6.5.3 接口"></a>6.5.3 接口</h3><p>接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 <strong>“是什么”</strong> 部分，派生类定义了语法合同 <strong>“怎么做”</strong> 部分。</p><p>接口定义了属性、方法和事件，这些都是接口的成员。<strong>接口只包含了成员的声明</strong>。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。接口使得实现接口的类或结构在形式上保持一致。</p><p>抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。</p><p><strong>接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约</strong>。</p><p>接口的特点：</p><ul><li>接口命名一般在开头加上大写字母 “I”</li><li>接口中的方法，不允许写方法体，并且继<strong>承该接口的类中，必须有实现该方法的方法体</strong></li><li>接口成员不允许使用访问修饰符</li><li>接口没有字段，但是可以有常量</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">String <span class="title">GetName</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-部分类和密封类"><a href="#6-6-部分类和密封类" class="headerlink" title="6.6 部分类和密封类"></a>6.6 部分类和密封类</h3><h3 id="6-6-1-部分类"><a href="#6-6-1-部分类" class="headerlink" title="6.6.1 部分类"></a>6.6.1 部分类</h3><p>在同一个命名空间下，不允许创建两个名字相同的类，但是可以创建部分类。部分类使用 <code>partial</code> 关键字修饰，同一类的部分类的名字是相同的，基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分类其实本质上是一个类，只不过将一个类里面的内容分开描述，部分类之间互通的。</p><h3 id="6-6-2-密封类"><a href="#6-6-2-密封类" class="headerlink" title="6.6.2 密封类"></a>6.6.2 密封类</h3><p>当我们创建一个类，但是不想让这个类被继承，可以使用 <code>sealed</code> 关键字修饰，表示不能被继承的密封类。基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-6-base-与-this-关键字"><a href="#6-6-base-与-this-关键字" class="headerlink" title="6.6 base 与 this 关键字"></a>6.6 base 与 this 关键字</h2><h3 id="6-6-1-base-关键字"><a href="#6-6-1-base-关键字" class="headerlink" title="6.6.1 base 关键字"></a>6.6.1 base 关键字</h3><p>在 C# 中，当我们使用 new 关键字，创建一个子类对象的时候，会自动调用父类的无参构造方法。但是，如果父类中有多个构造方法，我们如何去调用其他类型的构造方法呢？</p><p><code>base</code> 关键字，能够使我们显式的调用父类中对应的构造方法，具体调用哪一个，是要根据传入的参数确定的。并且当我们使用 <code>base</code> 指定对应的构造方法后， 子类便不在自动调用父类的无参构造方法。</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span> _isBoy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">bool</span> isBoy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">        <span class="keyword">this</span>._isBoy = isBoy;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;父类构造函数(有参)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;父类构造函数(无参)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> _school;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类构造函数，使用base关键字调用父类对应的有参的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">bool</span> isBoy, <span class="built_in">string</span> school</span>) : <span class="title">base</span>(<span class="params">name, age, isBoy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._school = school;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;子类构造函数(有参)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;子类构造函数(无参)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="literal">true</span>, <span class="string">&quot;清华大学&quot;</span>); <span class="comment">//调用父类的有参构造函数</span></span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(); <span class="comment">//调用父类的无参构造函数</span></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父类构造函数(有参)</span><br><span class="line">子类构造函数(有参)</span><br><span class="line">父类构造函数(无参)</span><br><span class="line">子类构造函数(无参)</span><br></pre></td></tr></table></figure><h3 id="6-6-2-this-关键字"><a href="#6-6-2-this-关键字" class="headerlink" title="6.6.2 this 关键字"></a>6.6.2 this 关键字</h3><p><code>this</code> 关键字与 <code>base</code> 类似，不同的是，它是调用<strong>当前类</strong>中对应参数的构造方法，并且如果在子类中使用，那么 new 一个对象的时候，是 <code>父类构造方法 -&gt; 子类中被this的构造方法 -&gt; 子类中this构造方法</code> 。</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span> _isBoy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">bool</span> isBoy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">        <span class="keyword">this</span>._isBoy = isBoy;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;父类构造函数(有参)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;父类构造函数(无参)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> _school;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类构造函数，使用base关键字调用父类对应的有参的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">bool</span> isBoy, <span class="built_in">string</span> school</span>) : <span class="title">base</span>(<span class="params">name, age, isBoy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._school = school;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;子类构造函数(有参1)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params">String name</span>) : <span class="title">this</span>(<span class="params">name, <span class="number">0</span>, <span class="literal">true</span>, <span class="string">&quot;清华大学&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;子类构造函数(有参2)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="literal">true</span>, <span class="string">&quot;清华大学&quot;</span>); <span class="comment">//调用父类的有参构造函数</span></span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;小行&quot;</span>); <span class="comment">//调用父类的无参构造函数</span></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父类构造函数(有参)</span><br><span class="line">子类构造函数(有参<span class="number">1</span>)</span><br><span class="line">父类构造函数(有参)</span><br><span class="line">子类构造函数(有参<span class="number">1</span>)</span><br><span class="line">子类构造函数(有参<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>开发工具：<a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio 2022 专业版</a></li><li>.NET Framework ：4.7.2</li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-6-14</p></div></div><div class='timeline-item-content'><ol><li>在 <a href="#6-6-base与this关键字">6.6 base 与 this 关键字</a> 部分，添加了与构造方法有关的两个关键字：base 与 this</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-31</p></div></div><div class='timeline-item-content'><ol><li>在 <a href="#6-3-1-访问修饰符">6.3.1 访问修饰符</a> 部分，添加了各种类型的默认访问级别。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-30</p></div></div><div class='timeline-item-content'><ol><li>完善了抽象类的组成</li><li>增加了匿名方法的定义以及使用</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-23</p></div></div><div class='timeline-item-content'><ol><li>在 “前言” 部分，新增了对代码规范的链接</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-19</p></div></div><div class='timeline-item-content'><ol><li>在<a href="#2-6-可空类型-💖💖💖">2.6 可空类型 💖💖💖</a>中，添加了 <code>?.</code> 的使用方法</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-12</p></div></div><div class='timeline-item-content'><ol><li>在<a href="#2-6-可空类型-💖💖💖">2.6 可空类型 💖💖💖</a>中，添加了 <code>??=</code> 的用法</li><li>添加<a href="#2-4-7-lambda-运算符">2.4.7 lambda 运算符</a> 目录，并向其添加了<code>=&gt;</code> 运算符的用法</li><li>在<a href="#2-5-4-占位符">2.5.4 占位符</a>中，添加了 <code>$符</code> 的用法</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-10</p></div></div><div class='timeline-item-content'><ol><li>添加了文章 <strong>前言</strong> 部分</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp </category>
          
          <category> Unity3D基础 </category>
          
          <category> Csharp基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> Csharp </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> 教程 </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法</title>
      <link href="/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/04.Python/Python%E5%9F%BA%E7%A1%80/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
      <url>/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/04.Python/Python%E5%9F%BA%E7%A1%80/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-初识-Python"><a href="#第一章-初识-Python" class="headerlink" title="第一章 初识 Python"></a>第一章 初识 Python</h1><h2 id="1-1-Python-简介"><a href="#1-1-Python-简介" class="headerlink" title="1.1 Python 简介"></a>1.1 Python 简介</h2><h3 id="1-1-1-什么是-Python"><a href="#1-1-1-什么是-Python" class="headerlink" title="1.1.1 什么是 Python"></a>1.1.1 什么是 Python</h3><p>Python，发音是[ˈpaɪθɑn]，本意是“蟒蛇”（这里需要说明的是，Python 并不是以蟒蛇命名，而是以电视节目 Monty Python’s Flying Circus 来命名的）。它是 1989 年由荷兰人 Guido van Rossum 发明的一种<strong>面向对象的解释型高级语言</strong>。</p><p>Python 有着简单、开发速度快、节省时间和精力的特点。</p><p>Python 本身并非所有与的特性和功能都集成到语言核心，而是被设计为可扩充。它具有丰富和强大的库，能够把用其他语言（尤其是 C++）制作的各种模块很轻松的联结在一起。为此，Python 常称为”胶水“语言。</p><h3 id="1-1-2-Python-的版本"><a href="#1-1-2-Python-的版本" class="headerlink" title="1.1.2 Python 的版本"></a>1.1.2 Python 的版本</h3><p>Python 自发布以来，主要经历三个版本的变化。</p><ul><li>1994 年发布的 Python 1.0 版本（已过时）</li><li>2000 年发布的 Python 2.0 版本 （逐渐淘汰）</li><li>2008 年发布的 Python 3.0 版本（初学者首选）</li></ul><p>Python 在版本升级时，并不是向下兼容的。</p><h3 id="1-1-3-Python-都能做些什么"><a href="#1-1-3-Python-都能做些什么" class="headerlink" title="1.1.3 Python 都能做些什么"></a>1.1.3 Python 都能做些什么</h3><p>Python 作为一种功能强大，并且简单易学的编程语言而广受好评。</p><ol><li>Web 开发</li><li>大数据处理</li><li>人工智能</li><li>自动化运维开发</li><li>云计算</li><li>爬虫</li><li>游戏开发</li></ol><blockquote><p>以下代码将会使用 Pycharm2022.1.3 编译器以及 Python 3.7.2 版本</p></blockquote><h2 id="1-2-搭建-Python-开发环境"><a href="#1-2-搭建-Python-开发环境" class="headerlink" title="1.2 搭建 Python 开发环境"></a>1.2 搭建 Python 开发环境</h2><h3 id="1-2-1-开发环境概述"><a href="#1-2-1-开发环境概述" class="headerlink" title="1.2.1 开发环境概述"></a>1.2.1 开发环境概述</h3><h3 id="1-2-2-安装-Python-解释器"><a href="#1-2-2-安装-Python-解释器" class="headerlink" title="1.2.2 安装 Python 解释器"></a>1.2.2 安装 Python 解释器</h3><h1 id="第二章-Python-语言基础"><a href="#第二章-Python-语言基础" class="headerlink" title="第二章 Python 语言基础"></a>第二章 Python 语言基础</h1><h2 id="2-1-Python-语法的特点"><a href="#2-1-Python-语法的特点" class="headerlink" title="2.1 Python 语法的特点"></a>2.1 Python 语法的特点</h2><p>学习 Python 需要了解它的语法特点，如：注释规则、代码缩进、编码规范等。下面将对学习 Python 时首先需要了解的这些语法特点进行详细介绍。</p><h3 id="2-1-1-注释规则"><a href="#2-1-1-注释规则" class="headerlink" title="2.1.1 注释规则"></a>2.1.1 注释规则</h3><p>在代码中添加的标注行文字，从而帮助程序员更好的阅读代码。注释的内容将被 Python 解释器忽略，并不会在执行结果种体现出来。</p><p>在 Python 中，通常包括 3 种类型的注释，分别是：单行注释、多行注释和中文注释。</p><ol><li><p>单行注释</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br></pre></td></tr></table></figure><p>​    在 Python 中，使用 “#” 作为单行注释的符号。从符号“#”开始，直到换行结束，其后面所有的内容都会作为注释内容。</p></li><li><p>多行注释</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注释内容</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>​    或者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注释内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>​    多行注释通常用来为 Python 文件、模块、类或者函数（方法）等添加版权、功能信息。</p></li><li><p>中文注释</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:编码 -*-</span></span><br></pre></td></tr></table></figure><p>​    或者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding = 编码</span></span><br></pre></td></tr></table></figure><p>​    该注释的出现主要是为了解决 Python 2.x 中不支持直接写中文的情况。虽然在 Python 3.X 中，该问题已经不复存在。但是为了规范页面的编码，也为了方便其他人及时了解文件所使用的编码，建议在文件开头加上中文注释。</p></li></ol><h3 id="2-1-2-代码缩进"><a href="#2-1-2-代码缩进" class="headerlink" title="2.1.2 代码缩进"></a>2.1.2 代码缩进</h3><p>Python 不像其他程序语言一样，采用大括号“{ }”分隔代码块，而是采用代码缩进和冒号“:”区分代码之间的层次。</p><p>例如，下面的代码中的缩进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="built_in">float</span>( <span class="built_in">input</span>( <span class="string">&quot;请输入你的身高：&quot;</span> ) )</span><br><span class="line">weight = <span class="built_in">float</span>( <span class="built_in">input</span>( <span class="string">&quot;请输入你的体重：&quot;</span> ) )</span><br><span class="line">bmi = weight / (height * height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断身材是否合理</span></span><br><span class="line"><span class="keyword">if</span> bmi &lt; <span class="number">18.5</span> :</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;体重过轻&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bmi &gt;= <span class="number">18.5</span> <span class="keyword">and</span> bmi &lt; <span class="number">24.9</span> :</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;正常范围&quot;</span> )</span><br><span class="line"><span class="keyword">if</span> bmi &gt;= <span class="number">24.9</span> <span class="keyword">and</span> bmi &lt; <span class="number">29.9</span> :</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;体重过重&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="2-1-3-编码规范"><a href="#2-1-3-编码规范" class="headerlink" title="2.1.3 编码规范"></a>2.1.3 编码规范</h3><ol><li>编写规则<ul><li>每个 import 语句只导入一个模块，尽量避免一次导入多个模块</li><li>不要再行尾添加分号，也不要用分号将两条命令放在同一行</li><li>建议每行不超过 80 个字符</li><li>使用必要的空行可以增强代码的可读性</li><li>通常情况下，运算符两侧、函数参数之间、逗号 “,” 两侧，建议添加空格</li><li>应该避免在循环中使用 + 和 += 操作符累加字符串。这是因为字符串是不可变的，这样做会创造不必要的临时对象。</li><li>适当使用异常处理</li></ul></li><li>命名规范<ul><li>模块名尽量短小，并且全部使用小写字母，可以用下划线分隔多个单词</li><li>模块名尽量短小，并且全部使用小写字母，不推荐使用下划线</li><li>类名采用单词首字母大写形式（即 Pascal 风格）</li><li>模块内部的类采用下划线+Pascal 风格的类名组成</li><li>函数、类的属性和方法的命名规则同模块类似</li><li>常量命名时采用全部大写字母，可以使用下划线</li><li>单下划线“_”开头的模块变量或者函数时受保护的，在使用 import * from 语句从模块中导入时，这些变量或者函数不能被导入。</li><li>使用双下划线”__“开头的实例变量或方法是类私有的</li></ul></li></ol><h2 id="2-2-Python-中的变量"><a href="#2-2-Python-中的变量" class="headerlink" title="2.2 Python 中的变量"></a>2.2 Python 中的变量</h2><h3 id="2-2-1-保留字与标识符"><a href="#2-2-1-保留字与标识符" class="headerlink" title="2.2.1 保留字与标识符"></a>2.2.1 保留字与标识符</h3><ol><li><p>保留字</p><p> 保留字是 Python 语言中已经被赋予特定含义的一些单词，开发程序时，不可以把这些保留字作为变量、函数、类、模块和其他对象的名称来使用。</p><p> Python 中的保留的关键字可以通过以下方法查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line">keyword.kwlist</span><br></pre></td></tr></table></figure></li><li><p>标识符</p><p> 标识符简单理解为一个名字</p><p> Python 语言的标识符命名规则如下：</p><ul><li>由字母、下划线和数字组成，并且不能以数字开</li><li>不能使用 Python 中的保留字</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">and</th><th style="text-align:center">as</th><th style="text-align:center">assert</th><th style="text-align:center">break</th><th style="text-align:center">class</th><th style="text-align:center">continue</th></tr></thead><tbody><tr><td style="text-align:center">def</td><td style="text-align:center">del</td><td style="text-align:center">elif</td><td style="text-align:center">else</td><td style="text-align:center">except</td><td style="text-align:center">finally</td></tr><tr><td style="text-align:center">for</td><td style="text-align:center">from</td><td style="text-align:center">False</td><td style="text-align:center">global</td><td style="text-align:center">if</td><td style="text-align:center">import</td></tr><tr><td style="text-align:center">in</td><td style="text-align:center">is</td><td style="text-align:center">lambda</td><td style="text-align:center">nonlocal</td><td style="text-align:center">not</td><td style="text-align:center">None</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">pass</td><td style="text-align:center">raise</td><td style="text-align:center">return</td><td style="text-align:center">try</td><td style="text-align:center">Ture</td></tr><tr><td style="text-align:center">while</td><td style="text-align:center">with</td><td style="text-align:center">yield</td><td style="text-align:center">\\</td><td style="text-align:center">\\</td><td style="text-align:center">\\</td></tr></tbody></table></div><h3 id="2-2-2-变量"><a href="#2-2-2-变量" class="headerlink" title="2.2.2 变量"></a>2.2.2 变量</h3><p>在 Python 中，严格意义上变量应该称为“名字”，也可以理解为标签。</p><p>定义变量：</p><ul><li>变量名应该是一个有效的标识符</li><li>不能使用保留字</li><li>慎用小写字母 “l” 和大写字母“O”</li><li>应该选用有意义的单词作为变量名</li></ul><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = value</span><br></pre></td></tr></table></figure><p>另外，Python 是一种动态语言，也就是说，变量的类型可以随时变化。</p><blockquote><p>在 Python 中，使用内置函数 type()可以返回变量类型。</p></blockquote><p>在 Python 中，允许多个变量指向同一个值。</p><blockquote><p>在 Python 中，使用内置函数 <code>id()</code> 可以返回变量所指的内存地址。</p></blockquote><h2 id="2-3-基本数据类型"><a href="#2-3-基本数据类型" class="headerlink" title="2.3 基本数据类型"></a>2.3 基本数据类型</h2><h3 id="2-3-1-数字"><a href="#2-3-1-数字" class="headerlink" title="2.3.1 数字"></a>2.3.1 数字</h3><ol><li><p>整数</p><ol><li><p>十进制</p><p> 例如以下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1456151515151</span></span><br></pre></td></tr></table></figure><blockquote><p>不能以 0 作为十进制数的开头（ 0 除外）</p></blockquote></li><li><p>八进制</p><blockquote><p>在 Python3.X 中，对于八进制数，必须以 0o/0O 开头</p></blockquote></li><li><p>十六进制</p><blockquote><p>在 Python3.X 中，对于十六进制数，必须以 0x/0X 开头</p></blockquote></li><li><p>二进制</p></li></ol></li><li><p>浮点数</p><p>​    浮点数由整数部分和小数部分组成，主要用于处理包括小数的数。浮点数也可用科学计数法表示。</p></li><li><p>复数</p><p>​    Python 中的复数与数学中的复数形式完全一致，都是由实部和虚部组成。</p></li></ol><h3 id="2-3-2-字符串"><a href="#2-3-2-字符串" class="headerlink" title="2.3.2 字符串"></a>2.3.2 字符串</h3><p>字符串就是连续的字符序列，可以是计算机所能表示的一切字符集合。在 Python 中，字符串数以不可变序列，通常使用单引号、双引号或者三引号、六引号括起来。其中单引号和双引号祖父序列必须在同一行上，而三引号内的字符串可以分布在连续的多行上。</p><h3 id="2-3-3-布尔型"><a href="#2-3-3-布尔型" class="headerlink" title="2.3.3 布尔型"></a>2.3.3 布尔型</h3><h3 id="2-3-3-数据类型的转换"><a href="#2-3-3-数据类型的转换" class="headerlink" title="2.3.3 数据类型的转换"></a>2.3.3 数据类型的转换</h3><p>在 Python 中，提供了以下函数进行各数据类型的转换</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">int(x)</td><td style="text-align:center">将 x 转成整数类型</td></tr><tr><td style="text-align:center">float(x)</td><td style="text-align:center">将 x 转成浮点数类型</td></tr><tr><td style="text-align:center">complex(real ,imag)</td><td style="text-align:center">创建一个复数</td></tr><tr><td style="text-align:center">str(x)</td><td style="text-align:center">将 x 转成字符串</td></tr><tr><td style="text-align:center">repr(x)</td><td style="text-align:center">将 x 转成表达式字符串</td></tr><tr><td style="text-align:center">eval(str)</td><td style="text-align:center">计算 字符串中的有效 Python 表达式，并返回一个对象</td></tr><tr><td style="text-align:center">chr(x)</td><td style="text-align:center">将整数 x 转换成一个字符</td></tr><tr><td style="text-align:center">ord(x)</td><td style="text-align:center">将一个字符 x 转换为它对应的整数值</td></tr><tr><td style="text-align:center">hex(x)</td><td style="text-align:center">将一个整数 x 转换为一个十六进制字符串</td></tr><tr><td style="text-align:center">oct(x)</td><td style="text-align:center">将一个整数 x 转换为一个八进制字符串</td></tr></tbody></table></div><h2 id="2-4-基本输入和输出"><a href="#2-4-基本输入和输出" class="headerlink" title="2.4 基本输入和输出"></a>2.4 基本输入和输出</h2><h3 id="2-4-1-使用-input-函数"><a href="#2-4-1-使用-input-函数" class="headerlink" title="2.4.1 使用 input() 函数"></a>2.4.1 使用 input() 函数</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="built_in">input</span>(<span class="string">&quot;提示文字&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 Python 3.X 中，无论输入的是数字还是字符，都将被作为字符串读取。因此想要接收整数，需要把接受的字符串进行类型转换。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable =<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入整数&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="2-4-2-使用-print-函数输出"><a href="#2-4-2-使用-print-函数输出" class="headerlink" title="2.4.2 使用 print() 函数输出"></a>2.4.2 使用 print() 函数输出</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello world!\n&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="第三章-运算符与表达式"><a href="#第三章-运算符与表达式" class="headerlink" title="第三章 运算符与表达式"></a>第三章 运算符与表达式</h1><h2 id="3-1-运算符"><a href="#3-1-运算符" class="headerlink" title="3.1 运算符"></a>3.1 运算符</h2><p>运算符是一些特殊的符号，主要用于数学计算、比较大小和逻辑运算等。</p><h3 id="3-1-1-算数运算符"><a href="#3-1-1-算数运算符" class="headerlink" title="3.1.1 算数运算符"></a>3.1.1 算数运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">加</td><td style="text-align:center">12.45+16</td><td style="text-align:center">28.45</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减</td><td style="text-align:center">5.231-3.21</td><td style="text-align:center">2.021</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">乘</td><td style="text-align:center">5*0.1</td><td style="text-align:center">0.5</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">除</td><td style="text-align:center">7/2</td><td style="text-align:center">3.5</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">取余</td><td style="text-align:center">7%2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">//</td><td style="text-align:center">取整</td><td style="text-align:center">7//2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">**</td><td style="text-align:center">幂</td><td style="text-align:center">2**4</td><td style="text-align:center">16</td></tr></tbody></table></div><blockquote><ul><li>在算数操作符中使用 % 取余，如果除数是负数，那么取得的结果也是一个负值。</li><li>在 Python 中，<strong>除法运算，一律按照浮点数进行运算</strong>，因此两个整数相除，结果是浮点数。</li></ul><p>注意：在使用除法、取余和取整运算时，除数不能为 0 ，否则会出现异常。</p></blockquote><h3 id="3-1-2-赋值运算符"><a href="#3-1-2-赋值运算符" class="headerlink" title="3.1.2 赋值运算符"></a>3.1.2 赋值运算符</h3><p>赋值运算符主要用来为变量赋值。使用时，可以直接把等基本赋值运算符右边的值赋给左边的变量，也可以是进行某些运算后再赋值给左边。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-比较（关系）运算符"><a href="#3-1-3-比较（关系）运算符" class="headerlink" title="3.1.3 比较（关系）运算符"></a>3.1.3 比较（关系）运算符</h3><p>用于对变量或表达式的结果进行大小、真假等比较。如果比较为真，则返回 Ture；如果为假，则返回 False 。</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">作用</th><th style="text-align:center">举例</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="3-1-4-逻辑运算符"><a href="#3-1-4-逻辑运算符" class="headerlink" title="3.1.4 逻辑运算符"></a>3.1.4 逻辑运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th><th style="text-align:center">用法</th><th style="text-align:center">结合方向</th></tr></thead><tbody><tr><td style="text-align:center">and</td><td style="text-align:center">逻辑与</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">逻辑或</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">逻辑非</td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="3-1-5-位操作符"><a href="#3-1-5-位操作符" class="headerlink" title="3.1.5 位操作符"></a>3.1.5 位操作符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th><th style="text-align:center">举例</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">按位与</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">按位或</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">按位异或</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">按位取反</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移位运算符</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">右移位运算符</td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="3-2-运算优先级"><a href="#3-2-运算优先级" class="headerlink" title="3.2 运算优先级"></a>3.2 运算优先级</h2><p>由高到低依次是：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">**</td><td style="text-align:center">幂运算</td></tr><tr><td style="text-align:center">~、+、-</td><td style="text-align:center">取反、正号和负号</td></tr><tr><td style="text-align:center">*、/、%、//</td><td style="text-align:center">算数运算符</td></tr><tr><td style="text-align:center">+、-</td><td style="text-align:center">加、减</td></tr><tr><td style="text-align:center">&lt;&lt;、&gt;&gt;</td><td style="text-align:center">左移和右移</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">按位与</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">按位异或</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">按位或</td></tr><tr><td style="text-align:center">&lt;、&lt;=、&gt;、&gt;=、!=、==</td><td style="text-align:center">比较运算符</td></tr></tbody></table></div><h1 id="第四章-流程控制语句"><a href="#第四章-流程控制语句" class="headerlink" title="第四章 流程控制语句"></a>第四章 流程控制语句</h1><h2 id="4-1-程序结构"><a href="#4-1-程序结构" class="headerlink" title="4.1 程序结构"></a>4.1 程序结构</h2><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul><h2 id="4-2-选择语句"><a href="#4-2-选择语句" class="headerlink" title="4.2 选择语句"></a>4.2 选择语句</h2><p>在生活中，我们总是要做出许多选择，程序也是一样。</p><blockquote><p>Python 中，没有 switch 语句，因此为了实现多重选择的功能，只能使用 if……elif……else 分支语句或者 if 语句的嵌套</p></blockquote><h3 id="4-2-1-最简单的-if-语句"><a href="#4-2-1-最简单的-if-语句" class="headerlink" title="4.2.1 最简单的 if 语句"></a>4.2.1 最简单的 if 语句</h3><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">    语句块</span><br></pre></td></tr></table></figure><blockquote><p>如果只有一条语句，语句块可以直接写到冒号的右侧。但是，为了程序的可读性，建议不要这么做。</p></blockquote><h3 id="4-2-2-if……else-语句"><a href="#4-2-2-if……else-语句" class="headerlink" title="4.2.2 if……else 语句"></a>4.2.2 if……else 语句</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>在使用 else 时，else 一定不能单独使用。</p></blockquote><h3 id="4-2-3-if……elif……else-语句"><a href="#4-2-3-if……elif……else-语句" class="headerlink" title="4.2.3 if……elif……else 语句"></a>4.2.3 if……elif……else 语句</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 表达式<span class="number">2</span>:</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块n</span><br></pre></td></tr></table></figure><h3 id="4-2-4-if-语句的嵌套"><a href="#4-2-4-if-语句的嵌套" class="headerlink" title="4.2.4 if 语句的嵌套"></a>4.2.4 if 语句的嵌套</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> 表达式<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句块<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="4-3-循环语句"><a href="#4-3-循环语句" class="headerlink" title="4.3 循环语句"></a>4.3 循环语句</h2><h3 id="4-3-1-while-循环"><a href="#4-3-1-while-循环" class="headerlink" title="4.3.1 while 循环"></a>4.3.1 while 循环</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">    循环体</span><br></pre></td></tr></table></figure><h3 id="4-3-2-for-循环"><a href="#4-3-2-for-循环" class="headerlink" title="4.3.2 for 循环"></a>4.3.2 for 循环</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代变量 <span class="keyword">in</span> 对象:</span><br><span class="line">    循环体</span><br></pre></td></tr></table></figure><ol><li><p>进行数值循环</p><p>​    在使用 for 循环时，最基本的应用就是进行数值循环。例如，实现从 1 到 100 的累加。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = UTF-8</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;计算 1 到 100 的累加\n&quot;</span> )</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">1</span>, <span class="number">101</span>, <span class="number">1</span> ) :</span><br><span class="line">    <span class="built_in">sum</span> += i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;结果是：&quot;</span>, <span class="built_in">sum</span> )</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">计算 1 到 100 的累加</span></span><br><span class="line"><span class="string">结果是：5050</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>​    其中用到 <code>range()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(start,end,step)</span><br></pre></td></tr></table></figure><p>​    各参数说明如下：</p><ul><li>start：用于指定计数的起始值（包含该值），可以省略，默认值为 0 ；</li><li>end：用于指定计数的结束值（不包含该值），不能省略；</li><li>step：用于指定步长，即两个数之间的间隔，可以省略，默认值为 1 。</li></ul></li><li><p>遍历字符串</p><p>​    使用 for 循环语句除了可以循环数值，还可以逐个遍历字符串。例如，下面的代码可以将横向显示的字符串转换为纵向显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = UTF-8</span></span><br><span class="line">string = <span class="string">&quot;人生苦短，我用Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(string)</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> string:</span><br><span class="line">    <span class="built_in">print</span>(ch)</span><br></pre></td></tr></table></figure><blockquote><p>​    for 循环语句还可以用于迭代（遍历）列表、元组、集合和字典等。</p></blockquote></li></ol><h3 id="4-3-3-循环嵌套"><a href="#4-3-3-循环嵌套" class="headerlink" title="4.3.3 循环嵌套"></a>4.3.3 循环嵌套</h3><p>在 Python 中，允许一个循环体嵌入另一个循环，这称为<font color='red'>循环嵌套</font>。在 Python 中， for 循环和 while 循环都可以进行循环嵌套。</p><h2 id="4-4-break、continue-和-pass-语句"><a href="#4-4-break、continue-和-pass-语句" class="headerlink" title="4.4 break、continue 和 pass 语句"></a>4.4 break、continue 和 pass 语句</h2><ol><li>break：完全终止当前所有循环；</li><li>continue：终止当前循环，进入下一次循环迭代；</li><li>pass：表示空语句，不做任何事，一般起到占位作用。</li></ol><h1 id="第五章-复杂数据类型"><a href="#第五章-复杂数据类型" class="headerlink" title="第五章 复杂数据类型"></a>第五章 复杂数据类型</h1><h2 id="5-1-序列"><a href="#5-1-序列" class="headerlink" title="5.1 序列"></a>5.1 序列</h2><p>序列是一块用于存放多个值得连续内存空间，并且按一定得顺序，每个值（称为元素）都分配一个数字，称为索引或位置。通过该索引可以取出相应的值。</p><h3 id="5-1-1-索引"><a href="#5-1-1-索引" class="headerlink" title="5.1.1 索引"></a>5.1.1 索引</h3><p>序列中的每个元素都有一个编号，也称为索引（Indexing）。这个索引是从 0 开始递增的，即下标为 0 表示第一个元素，下标为 1 表示第二个元素，依次类推。</p><p>Python 比较神奇，它的索引可以是负数。这个索引从右向左计数，也就是从最后一个元素开始计数。最后一个元素的索引为 -1 ，倒数第二个元素的索引值为 -2 ，依此类推。</p><h3 id="5-1-2-切片"><a href="#5-1-2-切片" class="headerlink" title="5.1.2 切片"></a>5.1.2 切片</h3><p>切片（sliceing）操作时访问序列中元素的另一种方法，它可以访问一定范围内的元素。通过切片操作可以生成一个新的序列。</p><p>切片的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sname[start:end:step]</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>sname：表示被切序列的名称</li><li>start：表示切片的开始位置（包括该位置），可以省略，默认为 0 ；</li><li>end：表示切片的截至位置（不包括该位置），可以省略，默认为序列的长度</li><li>step：表示切片的步长，可以省略，默认为 1 。当省略步长时，最后一个冒号也可以省略。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verse = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(verse[<span class="number">1</span>:<span class="number">6</span>]) <span class="comment">#获取第 2 到 6 个元素</span></span><br><span class="line"><span class="built_in">print</span>(verse[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>]) <span class="comment">#获取第 2、4、6 个元素</span></span><br></pre></td></tr></table></figure><blockquote><p>如果想要复制整个序列，可以将 start 和 end 参数都省略，但是中间的冒号需要保留。</p></blockquote><h3 id="5-1-2-序列相加"><a href="#5-1-2-序列相加" class="headerlink" title="5.1.2 序列相加"></a>5.1.2 序列相加</h3><p>在 Python 中，支持两种相同类型的序列相加（adding）操作，即将两个序列进行连接，但是不会去掉重复的元素，使用 “+” 运算符实现。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verse1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">verse2 = [ <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">verse3 = verse1 + verse2</span><br></pre></td></tr></table></figure><h3 id="5-1-4-乘法"><a href="#5-1-4-乘法" class="headerlink" title="5.1.4 乘法"></a>5.1.4 乘法</h3><p>在 Python 中，使用整数 <script type="math/tex">n</script> 乘以一个序列会生成新的序列。新序列的内容为原来序列被重复 <script type="math/tex">n</script> 次的结果。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verse1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">verse3 = verse1 * <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="5-1-5-检查某个元素是否是序列成员"><a href="#5-1-5-检查某个元素是否是序列成员" class="headerlink" title="5.1.5 检查某个元素是否是序列成员"></a>5.1.5 检查某个元素是否是序列成员</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value <span class="keyword">in</span> sequence</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>value：表示要检查的元素</li><li>sequence：表示指定的序列</li></ul><p>结果：</p><ul><li>该结果为一个布尔型（bool）</li><li>如果该元素在序列里面，就返回 Ture；反之，就返回 False。</li></ul><blockquote><p>另外，在 Python 中，也可以使用 not in 关键字实现检查某个元素是否不包含在指定的序列中。</p></blockquote><h3 id="5-1-6-对序列进行操作的函数"><a href="#5-1-6-对序列进行操作的函数" class="headerlink" title="5.1.6 对序列进行操作的函数"></a>5.1.6 对序列进行操作的函数</h3><p>在 Python 中，提供了内置函数计算序列的长度、最大值和最小值。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>()<span class="comment">#序列的长度，即返回序列包含的元素的个数</span></span><br><span class="line"><span class="built_in">max</span>()<span class="comment">#返回序列元素中的最大值</span></span><br><span class="line"><span class="built_in">min</span>()<span class="comment">#返回序列元素中的最小值</span></span><br></pre></td></tr></table></figure><p>除了上面介绍 3 个内置函数， Python 还提供了下表所示函数</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">list()</td><td style="text-align:center">将序列转化为列表</td></tr><tr><td style="text-align:center">str()</td><td style="text-align:center">将序列转化为字符串</td></tr><tr><td style="text-align:center">sum()</td><td style="text-align:center">计算元素和</td></tr><tr><td style="text-align:center">sorted()</td><td style="text-align:center">对元素进行排序</td></tr><tr><td style="text-align:center">reversed()</td><td style="text-align:center">反向序列中的元素</td></tr><tr><td style="text-align:center">enumerate()</td><td style="text-align:center">将序列组合为一个索引序列，多用在 for 循环中</td></tr></tbody></table></div><h2 id="5-2-列表"><a href="#5-2-列表" class="headerlink" title="5.2 列表"></a>5.2 列表</h2><p>Python 中的列表，也是由一系列按特定顺序排列的元素组成。它是 Python 中内置的可变序列。在形式上，列表所有元素都放在一对中括号中，两个相邻元素之间使用逗号分隔。在内容上，可以将整数、实数、字符串、列表、元组等任何类型的内容放入列表中，并且<strong>同一个列表中元素的类型可以不同</strong>，因为他们之间没有任何联系。</p><h3 id="5-2-1-列表的创建和删除"><a href="#5-2-1-列表的创建和删除" class="headerlink" title="5.2.1 列表的创建和删除"></a>5.2.1 列表的创建和删除</h3><ol><li><p>使用赋值运算符直接创建列表</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname = [element1,element2,...,element n]</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>listname：表示列表的名字，可以是任何符合 Python 命名规范的标识符；</li><li>element：表示列表中的元素。</li></ul></li><li><p>创建空列表</p><p>​    在 Python 中，可以创建空列表。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emptylist = []</span><br></pre></td></tr></table></figure></li><li><p>创建数值列表</p><p>​    在 Python 中，数值列表很常用。可以使用 <code>list()</code> 函数直接将 <code>range()</code> 函数循环出来的结果转换成列表。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(data)</span><br></pre></td></tr></table></figure><p> 其中：</p><ul><li>data：表示可以转换成列表的数据，其类型可以是 range 对象、字符串、元组或者其他可迭代的类型的数据。</li></ul></li><li><p>删除列表</p><p>​    对于已经创建的列表，不在使用时，可以将其删除。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>( <span class="built_in">range</span>( <span class="number">11</span> ) )</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure><blockquote><p>​    del 在实际开发中，并不常用。因为 Python 自带的垃圾回收机制，会制动销毁不用的列表，所以即使我们不用手动将其删除， Python 也会自动将其收回。</p></blockquote></li></ol><h3 id="5-2-2-访问列表元素"><a href="#5-2-2-访问列表元素" class="headerlink" title="5.2.2 访问列表元素"></a>5.2.2 访问列表元素</h3><p>可以用索引来访问列表的某一个元素。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname[index]</span><br></pre></td></tr></table></figure><h3 id="5-2-3-遍历列表"><a href="#5-2-3-遍历列表" class="headerlink" title="5.2.3 遍历列表"></a>5.2.3 遍历列表</h3><ol><li><p>直接 for 循环实现</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> listname:</span><br><span class="line">    循环体<span class="comment">#输出item</span></span><br></pre></td></tr></table></figure></li><li><p>使用 for 循环和<code>enumerate()</code> 函数实现</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(listname):</span><br><span class="line">    <span class="comment">#输出 index 和 item</span></span><br></pre></td></tr></table></figure><p>​    参数说明：</p><ul><li>index：用于保存元素的索引值</li><li>item：用于保存获取的元素值，要输出元素内容时，直接输出该变量即可</li><li>listname：列表的名称</li></ul></li></ol><h3 id="5-2-4-添加、修改和删除列表元素"><a href="#5-2-4-添加、修改和删除列表元素" class="headerlink" title="5.2.4 添加、修改和删除列表元素"></a>5.2.4 添加、修改和删除列表元素</h3><p>添加、修改和删除列表元素也称为更新列表。在实际开发时，经常需要对列表进行更新。</p><ol><li><p>添加元素</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.append(obj)</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>listname：表示要添加的列表名称</li><li>obj：要添加到列表末尾的对象</li></ul><p>​    上面介绍的是向列表中添加一个元素。如果想要将一个列表中的全部元素添加到另一个列表中，可以使用列表对象的 <code>extend()</code> 方法实现。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.extend(seq)</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>listname：表示要添加的列表名称</li><li>seq：要添加到列表末尾的列表</li></ul></li><li><p>修改元素</p><p>​    修改列表中的元素只需要通过索引获取该元素，然后在为其重新赋值即可。</p></li><li><p>删除元素</p><p>​    删除元素主要由两种情况，一是<strong>根据索引删除</strong>，另一种是<strong>根据元素值进行删除</strong>。</p><ol><li><p>根据索引删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verse = [<span class="string">&quot;长亭外&quot;</span>, <span class="string">&quot;古道边&quot;</span>, <span class="string">&quot;芳草碧连天&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> verse[-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>( verse )</span><br></pre></td></tr></table></figure></li><li><p>根据元素值删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verse = [<span class="string">&quot;长亭外&quot;</span>, <span class="string">&quot;古道边&quot;</span>, <span class="string">&quot;芳草碧连天&quot;</span>]</span><br><span class="line">verse.remove(<span class="string">&quot;古道边&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(verse)</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="5-2-5-对列表进行统计"><a href="#5-2-5-对列表进行统计" class="headerlink" title="5.2.5 对列表进行统计"></a>5.2.5 对列表进行统计</h3><ol><li><p>获取指定元素出现的次数</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.count(obj)</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>listname：表示列表的名称</li><li>obj：要匹配的元素</li></ul></li><li><p>获取指定元素首次出现的索引</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.index(obj)</span><br></pre></td></tr></table></figure></li><li><p>统计数值列表的元素和</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(listname[,start])</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>listname：表示列表的名称</li><li>start：表示统计开始的位置，可选参数，默认为 0 。</li></ul></li></ol><h3 id="5-2-6-对列表进行排序"><a href="#5-2-6-对列表进行排序" class="headerlink" title="5.2.6 对列表进行排序"></a>5.2.6 对列表进行排序</h3><ol><li><p>使用列表对象的 <code>sort()</code> 方法实现</p><p>​    列表对象提供了 <code>sort()</code> 方法对原列表中的元素进行排序。排序后原列表中的元素顺序将发生改变。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.sort(key = <span class="literal">None</span>, reverse = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>listname：表示要进行排序的列表</li><li>key：表示指定一个从每个序列元素中提取一个比较键</li><li>reverse：可选参数。如果为 Ture，则表示降序排列，如果为 False，则表示升序排列。默认为 Falses 。</li></ul></li><li><p>使用内置的 <code>sorted()</code> 函数实现</p><p>​     在 Python 中，提供一个内置的 sorted() 函数，用于对列表进行排序。使用该函数进行排序后，原列表的元素顺序不变，而是返回一个新的列表。sorted() 函数语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable,key=<span class="literal">None</span>,reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>iterable：表示要进行排序的列表的名称</li><li>key：表示指定一个从每个序列元素中提取一个比较键</li><li>reverse：可选参数。如果为 Ture，则表示降序排列，如果为 False，则表示升序排列。默认为 Falses 。</li></ul></li></ol><h3 id="5-2-7-列表推导式"><a href="#5-2-7-列表推导式" class="headerlink" title="5.2.7 列表推导式"></a>5.2.7 列表推导式</h3><p>使用列表推导式可以快速生成一个列表，或者根据某个列表生成满足指定需求的列表。列表推导式通常有以下几种常用的语法格式</p><ol><li><p>生成指定范围的数值列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [Expression <span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">range</span>]</span><br></pre></td></tr></table></figure><p>​    参数说明：</p><ul><li>list：表示生成的列表名称</li><li>Expression：表达式，用于计算新列表的元素</li><li>var：循环变量</li><li>range：采用 range() 函数生成的 range 对像</li></ul><p>​    例如，要生成一个包含 10 个随机数的列表，要求数的范围在 10-100 之间（包括 100），具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">randomnumber = [random.randint( <span class="number">10</span>, <span class="number">100</span> ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">10</span> )]</span><br><span class="line"><span class="built_in">print</span>( randomnumber )</span><br></pre></td></tr></table></figure></li><li><p>根据列表生成指定需求的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newlist = [Expression <span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">list</span>]</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>newlist：表示新生成的列表名称</li><li>Expression：表达式，用于计算新列表的元素</li><li>var：循环变量</li><li>list：用于生成新列表的原列表</li></ul><p>​    例如，定义一个记录商品价格的列表，然后应用列表推导式，生成一个将全部商品价格打五折的列表，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">price = [<span class="number">3124</span>, <span class="number">2134</span>, <span class="number">1400</span>, <span class="number">800</span>, <span class="number">500</span>]</span><br><span class="line">sale = [<span class="built_in">int</span>( x / <span class="number">2</span> ) <span class="keyword">for</span> x <span class="keyword">in</span> price]</span><br><span class="line"><span class="built_in">print</span>( price )</span><br><span class="line"><span class="built_in">print</span>( sale )</span><br></pre></td></tr></table></figure></li><li><p>从列表中选择符合条件的元素组成新的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newlist = [Expression <span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">list</span> <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>newlist：表示新生成的列表名称</li><li>Expression：表达式，用于计算新列表的元素</li><li>var：循环变量</li><li>list：用于生成新列表的原列表</li><li>condition：条件表达式，用于指定筛选条件</li></ul></li></ol><h3 id="5-2-8-二维列表"><a href="#5-2-8-二维列表" class="headerlink" title="5.2.8 二维列表"></a>5.2.8 二维列表</h3><ol><li><p>直接定义二列列表</p><p>​    例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​    每一行为一个一维列表，列表直接用逗号隔开。</p></li><li><p>使用嵌套的 for 循环创建</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    arr.append([])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        arr[i].append(j)</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>使用列表推导式创建</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [[i <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p>如果要访问二维列表中的元素，使用索引的方式。</p></li></ol><h2 id="5-3-元组"><a href="#5-3-元组" class="headerlink" title="5.3 元组"></a>5.3 元组</h2><p>元组（tuple）是 Python 中另一个重要的序列结构，与列表类似，也是由一系列按照特定顺序排列的元素组成。<strong>但是它是不可变序列</strong>。因此元组也称为不可变列表。在形式上，元组的所有元素都放在一对小括号内，两个相邻的元素用逗号隔开。</p><h3 id="5-3-1-元组的创建"><a href="#5-3-1-元组的创建" class="headerlink" title="5.3.1 元组的创建"></a>5.3.1 元组的创建</h3><ol><li><p>使用赋值运算符直接创建</p><p>​    同其他类型的 Python 语法一样，创建元组时，也可以用赋值运算符直接将一个元组赋值给变量。具体的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuplename = (element <span class="number">1</span>,element <span class="number">2</span>,element <span class="number">3</span>,...,element n)</span><br></pre></td></tr></table></figure></li><li><p>创建空元组</p><p>​    在 Python 中，也可以创建空元组。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">empty = （）</span><br></pre></td></tr></table></figure></li><li><p>创建数值元组</p><p>​    在 Python 中，可以使用 tuple() 函数直接将 range() 函数循环出来的结果转换为数值元组。</p><blockquote><p> 有关 range() 函数的详细介绍，请参见 <a href="#4-3-2-for-循环">4.3.2</a> 节</p></blockquote><p>​    <code>tuple()</code> 函数的用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span>(data)</span><br><span class="line"><span class="built_in">tuple</span>(<span class="built_in">range</span>)</span><br></pre></td></tr></table></figure></li><li><p>删除元组</p><p>​    对于已经创建的元组，不再使用时，可以用 del 语句将其删除。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> tuplename</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-3-2-访问元组元素"><a href="#5-3-2-访问元组元素" class="headerlink" title="5.3.2 访问元组元素"></a>5.3.2 访问元组元素</h3><p>在 Python 中，如果想要把元组的所有元素输出，可以直接使用 print() 函数。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span> )</span><br></pre></td></tr></table></figure><p>或者通过元组的索引获取指定的元素。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span>[<span class="number">2</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span>[-<span class="number">2</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span>[<span class="number">0</span> :<span class="number">6</span> :<span class="number">2</span>] ) <span class="comment">#前两者输出的是单个元素，这个输出的是一个新的元组</span></span><br></pre></td></tr></table></figure><p>另外，元组还可以使用 for 循环和 enumerate() 函数结合进行遍历。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>( <span class="built_in">tuple</span> ) :</span><br><span class="line">    <span class="keyword">if</span> index % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">        <span class="built_in">print</span>( item, <span class="string">&quot;,&quot;</span>, end=<span class="string">&quot;&quot;</span> )</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="built_in">print</span>( item, <span class="string">&quot;。&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="5-3-3-修改元组"><a href="#5-3-3-修改元组" class="headerlink" title="5.3.3 修改元组"></a>5.3.3 修改元组</h3><p>元组是不可变序列，所以我们不能对它单个元素的值进行修改，但是元组也不是完全不能修改。我们可以对元组重新赋值。例如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span> )</span><br><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span> )</span><br></pre></td></tr></table></figure><p>另外，还可以对元组进行连接组合。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">tuple2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( tuple1 + tuple2 )</span><br></pre></td></tr></table></figure><blockquote><p>在进行元组连接时，连接的内容必须都是元组。不能将元组和字符串或者是列表进行连接。</p></blockquote><h3 id="5-3-4-元组推导式"><a href="#5-3-4-元组推导式" class="headerlink" title="5.3.4 元组推导式"></a>5.3.4 元组推导式</h3><p>使用元组推导式可以快速成成一个元组，它的表现形式和列表推导式类似，只是将列表推导式中的中括号换成小括号。例如下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span> = (random.randint( <span class="number">10</span>, <span class="number">100</span> ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">5</span> ))</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span> )</span><br></pre></td></tr></table></figure><h3 id="5-3-5-元组与列表的区别"><a href="#5-3-5-元组与列表的区别" class="headerlink" title="5.3.5 元组与列表的区别"></a>5.3.5 元组与列表的区别</h3><ol><li>列表属于可变序列，它的元素可以随时修改或删除；而元组属于不可变序列，其中的元组不可以修改，除非<strong>整体替换</strong></li><li>列表可以使用 append() 、 extend() 、 insert() 、 remove() 和 pop() 等方法实现添加和修改列表元素；而元组没有这些方法，也不能删除元素</li><li>列表可以使用切片访问和修改列表中的元素；元组也支持切片，但是只支持切片访问元组中的元素，不支持修改</li><li>元组的访问和处理速度比列表快。所以如果只需要对其中的元组进行访问，而不进行任何修改，建议使用元组而不使用列表</li><li>列表不能作为字典的键；而元组可以</li></ol><h2 id="5-4-字典"><a href="#5-4-字典" class="headerlink" title="5.4 字典"></a>5.4 字典</h2><p>字典（dictionary）和列表类似，也是可变序列，不过与列表不同 ，它是无序可变序列，保存的内容是以“键-值对”的形式存放的。类似于 Java 或者 C++ 中的 Map 对象。</p><p>字典的主要特征如下：</p><ul><li>通过键而不是通过索引来读取</li><li>字典是任意对象的无序集合</li><li>字典是可变的，并且可以任意嵌套</li><li>字典中的键必须唯一</li><li>字典中的键必须不可变</li></ul><h3 id="5-4-1-字典的创建和删除"><a href="#5-4-1-字典的创建和删除" class="headerlink" title="5.4.1 字典的创建和删除"></a>5.4.1 字典的创建和删除</h3><p>定义字典是，每个元素都包含两个部分：“键”和“值”，并且在“键”和“值”之间，用冒号分隔，相邻两个元素使用逗号隔开，所有元素放在一个大括号中。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&#x27;key 1&#x27;</span>:<span class="string">&#x27;value 1&#x27;</span>,<span class="string">&#x27;key 2&#x27;</span>:<span class="string">&#x27;value 2&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>dictionary：表示字典的名称</li><li>key：表示元素的键，必须是唯一的，并且不可变</li><li>value：表示元素的值，可以是任何数据类型，不是必须唯一</li></ul><p>铜列表和元组一样，也可以创建空字典。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictionary = &#123;&#125;</span><br><span class="line">dictionary = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><p>Python 的 <code>dicr()</code> 方法除了可以创建一个空字典外，还可以通过已有数据快速创建字典。主要表现为以下两种形式：</p><ol><li><p>通过映射函数创建字典</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary = <span class="built_in">dict</span>(<span class="built_in">zip</span>(list1,list2))</span><br></pre></td></tr></table></figure><p>   参数说明如下：</p><ul><li>dictionary：表示字典的名称</li><li>zip() 函数：用于将多个列表或元组对应位置的元素组合成为元组，并返回包含这些内容的 zip 对象。如果想要得到元组，可以将 zip 对象使用 tuple() 函数转换为元组；如果想要得到列表，则可以使用 list() 函数将其转换成列表</li></ul></li><li><p>通过给定的键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary = <span class="built_in">dict</span>(key1 = value1,key2 = value2)</span><br></pre></td></tr></table></figure><p>   在 Python 中，还可以使用 dict 对象的 fromkeys() 方法创建值为空的字典。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary = <span class="built_in">dict</span>,fromkeys(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><p>​    参数说明：</p><ul><li>dictionary：表示字典的名称</li></ul></li></ol><ul><li>list：表示作为字典的键的列表</li></ul><h3 id="5-4-2-访问字典"><a href="#5-4-2-访问字典" class="headerlink" title="5.4.2 访问字典"></a>5.4.2 访问字典</h3><p>在 Python 中，如果想要将字典的全部元素输出，可以直接用 print() 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( dicttionary )</span><br></pre></td></tr></table></figure><p>但是，使用字典是，很少直接输出它的内容。一般根据指定的键得到相应的结果。在 python 中，访问字典元素可以通过 键 的方式实现。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( dicttionary )</span><br><span class="line"><span class="built_in">print</span>( dicttionary[<span class="string">&quot;甘雨&quot;</span>] )</span><br></pre></td></tr></table></figure><p>在实际开发过程中，很可能我们不知道当前存在什么键，所以避免该异常的产生。具体的解决方法是使用 if 语句对不存在的情况进行处理，即给定一个默认值。例如，可以将上面的代码修改为以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( dicttionary[<span class="string">&quot;神里凌华&quot;</span>] <span class="keyword">if</span> <span class="string">&quot;神里凌华&quot;</span> <span class="keyword">in</span> dicttionary <span class="keyword">else</span> <span class="string">&quot;我的字典里没有此人&quot;</span> )</span><br></pre></td></tr></table></figure><p>另外， Python 中推荐的方法 hi 是使用字典对象的 get() 方法获取指定键的值。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dicttionary.get(key[,default])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>dictionary：表示当前操作的字典对象</li><li>key：指定的键</li><li>default：可选参数，默认为 None 。用于当指定的键不存在时，返回一个默认值。</li></ul><p>例如，上面的代码可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( dicttionary.get( <span class="string">&quot;雷电将军&quot;</span> ) )</span><br></pre></td></tr></table></figure><h3 id="5-4-3-遍历字典"><a href="#5-4-3-遍历字典" class="headerlink" title="5.4.3 遍历字典"></a>5.4.3 遍历字典</h3><p>字典是以“键-值对”的形式存储数据，素以就可能需要对这些“键-值对”进行获取。Python 提供了遍历字典的方法，通过遍历可以获取字典中的全部“键-值对”。</p><p>使用字典对象的 items() 方法可以获取字典的“键-值对”列表。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary.items()</span><br></pre></td></tr></table></figure><p>其中，dictionary 为字典对象；返回值为可遍历的“键-值对”元组列表。</p><blockquote><p>在 Python 中，字典对象还提供了 values() 和 keys() 方法，用于返回字典的“值”和“键”列表</p></blockquote><h3 id="5-4-4-添加、修改和删除字典元素"><a href="#5-4-4-添加、修改和删除字典元素" class="headerlink" title="5.4.4 添加、修改和删除字典元素"></a>5.4.4 添加、修改和删除字典元素</h3><p>由于字典是可变序列，所以可以随时在其中添加“键-值对”，这和列表类似。向字典中添加元素的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary[key] = value</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>dictionary：表示字典的名称</li><li>key：表示要添加的元素的键，必须是唯一的，并且不可变</li><li>value：表示元素的值，可以是任何数据类型，不是必须唯一</li></ul><p>由于在字典中，“键”必须是唯一的，所以如果添加的新元素的“键”已经存在，则会用新元素的值替换掉旧元素的值，相当于修改字典的元素的值。</p><p>当字典中某个元素不需要时，可以使用 del 语句将其删除。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="keyword">del</span> dicttionary[<span class="string">&quot;甘雨&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>( dicttionary )</span><br></pre></td></tr></table></figure><blockquote><p>当删除一个不存在的键时，将会抛出异常</p></blockquote><h3 id="5-4-5-字典推导式"><a href="#5-4-5-字典推导式" class="headerlink" title="5.4.5 字典推导式"></a>5.4.5 字典推导式</h3><p>使用字典推导式可以快速生成一个字典，它的表现形式和列表推导式类似。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">dictionary = &#123; i : random.randint( <span class="number">10</span>, <span class="number">100</span> ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">5</span> ) &#125;</span><br><span class="line"><span class="built_in">print</span>( dictionary )</span><br></pre></td></tr></table></figure><h2 id="5-5-集合"><a href="#5-5-集合" class="headerlink" title="5.5 集合"></a>5.5 集合</h2><p>Python 中的集合（set）与数学中的集合概念类似，也是用于保存不重复元素。它有可变集合和不可变集合两种。</p><h3 id="5-5-1-创建集合"><a href="#5-5-1-创建集合" class="headerlink" title="5.5.1 创建集合"></a>5.5.1 创建集合</h3><ol><li><p>直接使用大括号创建</p><p>​    语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname = &#123;element <span class="number">1</span>,element <span class="number">2</span>,...&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>使用 set() 函数创建</p><p>​    在 Python 中，可以使用 set() 函数将列表、元组等其他可迭代对象转换为集合。 set() 函数的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname = <span class="built_in">set</span>(iteration)</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-5-2-向集合中添加和删除元素"><a href="#5-5-2-向集合中添加和删除元素" class="headerlink" title="5.5.2 向集合中添加和删除元素"></a>5.5.2 向集合中添加和删除元素</h3><ol><li><p>向集合中添加元素</p><p>​    向集合中添加元素可以使用 add() 方法实现。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname.add(element)</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>从集合中删除元素</p><p>   在 Python 中，可以使用 del 语句删除整个集合，也可以使用集合的 pop() 方法或者 remove() 方法删除一个元素，或者使用集合对象的 clear() 方法清空集合，使其变为空集合。</p></li></ol><h3 id="5-5-3-集合的交集、并集和差集运算"><a href="#5-5-3-集合的交集、并集和差集运算" class="headerlink" title="5.5.3 集合的交集、并集和差集运算"></a>5.5.3 集合的交集、并集和差集运算</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">两个集合的交集</td></tr><tr><td style="text-align:center">$\vert$</td><td style="text-align:center">两个集合的并集</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">两个集合的差集</td></tr></tbody></table></div><h1 id="第六章-字符串"><a href="#第六章-字符串" class="headerlink" title="第六章 字符串"></a>第六章 字符串</h1><h2 id="6-1-字符串编码转换"><a href="#6-1-字符串编码转换" class="headerlink" title="6.1 字符串编码转换"></a>6.1 字符串编码转换</h2><h3 id="6-1-1-使用-encode-方法编码"><a href="#6-1-1-使用-encode-方法编码" class="headerlink" title="6.1.1 使用 encode() 方法编码"></a>6.1.1 使用 encode() 方法编码</h3><p>encode() 方法为 str 对象的方法，用于将字符串转化成二进制数据，也称为“编码”。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;人活着就是为了樱岛麻衣!&quot;</span></span><br><span class="line"><span class="built_in">str</span>.encode( encoding=<span class="string">&quot;utf-8&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">str</span> )</span><br><span class="line">//<span class="built_in">str</span>.encode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>str：表示要进行转换的字符串</li><li>encoding=”utf-8”：可选参数，默认为 utf-8，用于指定进行转码时采用的字符编码</li><li>errors=”strict”：可选参数，默认值为 strict，用于指定错误的处理方式。</li></ul><blockquote><p>在使用 encode() 方法时，不会修改原字符串，只是改变显示的方式。</p></blockquote><h3 id="6-1-2-使用-decode-方法解码"><a href="#6-1-2-使用-decode-方法解码" class="headerlink" title="6.1.2 使用 decode() 方法解码"></a>6.1.2 使用 decode() 方法解码</h3><p>decode() 方法为 bytes 对象的方法，用于将二进制数据转换为字符串，即将使用 encode() 方法转换的结果再转换为字符串，也称为“解码”。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.decode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>bytes：表示要进行转换的二进制数据</li><li>encoding=”utf-8”：可选参数，默认为 utf-8，用于指定进行转码时采用的字符编码</li><li>errors=”strict”：可选参数，默认值为 strict，用于指定错误的处理方式。</li></ul><blockquote><p>在使用 decode() 方法时，不会修改原字符串，只是改变显示的方式。</p></blockquote><h2 id="6-2-字符串常用操作"><a href="#6-2-字符串常用操作" class="headerlink" title="6.2 字符串常用操作"></a>6.2 字符串常用操作</h2><h3 id="6-2-1-拼接字符串"><a href="#6-2-1-拼接字符串" class="headerlink" title="6.2.1 拼接字符串"></a>6.2.1 拼接字符串</h3><p>使用“+”运算符可完成对多个字符串的拼接，并且返回一个新的字符串。例如，定义两个字符串，然后用“+”运算符连接，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;人活着就是&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;为了樱岛麻衣!&quot;</span></span><br><span class="line"><span class="built_in">print</span>( str1 )</span><br><span class="line"><span class="built_in">print</span>( str2 )</span><br><span class="line"><span class="built_in">print</span>( str1 + str2 )</span><br></pre></td></tr></table></figure><blockquote><p>字符串不允许直接与其他类型的数据进行拼接。</p></blockquote><h3 id="6-2-2-计算字符串的长度"><a href="#6-2-2-计算字符串的长度" class="headerlink" title="6.2.2 计算字符串的长度"></a>6.2.2 计算字符串的长度</h3><p>由于不同的字符所占的字节数不同，所以要计算字符串长度，需要了解各字符所占的字节数。在 Python 中，数字、英文、小数点、下划线和空格占一个字节；一个汉字可能会占 2-4 个字节，占几个字节取决于采用的编码。下面以 Python 默认的 UTF-8 编码为例，即一个汉字占三个字节。</p><p>在 Python 中，提供了 len() 函数计算字符串的长度。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(string)</span><br></pre></td></tr></table></figure><p>在默认情况下，通过 len() 函数计算字符串长度时，不区分英文、数字和汉字，所有字符都认为是一个。</p><p>在实际开发时，有时需要获取字符串实际所占的字节数。这时，可以通过使用 encode() 方法进行编码后，在进行获取。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;人活着就是为了樱岛麻衣!&quot;</span></span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">len</span>( <span class="built_in">str</span> ) )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">len</span>( <span class="built_in">str</span>.encode() ) )</span><br></pre></td></tr></table></figure><h3 id="6-2-3-截取字符串"><a href="#6-2-3-截取字符串" class="headerlink" title="6.2.3 截取字符串"></a>6.2.3 截取字符串</h3><p>由于字符串也属于序列，所以要截取字符串，可以采用切片的方法。通过切片的方法截取字符串的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string[start:end:step]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>string：表示要截取的字符串；</li><li>satrt：表示要截取的第一个字符索引（包括该字符），可选，默认为 0 ；</li><li>end：表示要截取的最后一个字符的索引（不包含该字符），可选，默认为字符串的长度；</li><li>step：表示切片的步长，可选，默认为 1 。当省略 step 时，随后一个冒号也可以省略</li></ul><h3 id="6-2-4-分割、合并字符串"><a href="#6-2-4-分割、合并字符串" class="headerlink" title="6.2.4 分割、合并字符串"></a>6.2.4 分割、合并字符串</h3><p>在 Python 中，字符串对象提供了分割和合并字符串的方法。分割字符串是把字符串分割为列表，而合并字符串时把列表合并为字符串，它们可以看作是互逆操作。</p><ol><li><p>分割字符串</p><p>​    字符串对象的 split() 方法可以实现字符串分割。即把一个字符串按照指定的分隔符切分为字符串列表。该列表的元素中，不包含分隔符。具体的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.split(sep,maxsplit)</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>str：表示要进行分割的字符串</li><li>sep：用于指定分隔符，可以包含多个字符，默认为 None ，即所用空字符（包括空格、换行、制表符等）</li><li>maxsplit：用于指定分割的次数，可选参数。如果不指定或者为 -1 ，则分割次数没有限制，否则，返回结果列表的元素个数最多为 maxsplit+1</li><li>返回值：分割后的字符串列表</li></ul></li><li><p>合并字符串</p><p>​    合并字符串与拼接字符串不同，它会将多个字符串采用固定的分隔符连接再一起。合并字符串可以使用字符串对象的 join() 方法实现。具体语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strnew = string.join(iterable)</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>strnew：表示合并后的新字符串</li><li>string：字符串类型，用于指定合并时的分隔符</li><li>iterable：可迭代对象，该迭代对象中的所有元素（字符串）将会被合并为一个新的字符串。</li></ul></li></ol><h3 id="6-2-5-检索字符串"><a href="#6-2-5-检索字符串" class="headerlink" title="6.2.5 检索字符串"></a>6.2.5 检索字符串</h3><p>   在 Python 中，字符串对象提供了很多应用于字符串查找的方法。</p><ol><li><p>count() 方法</p><p>​    count() 方法用于检索指定字符串在另一个字符串中出现的次数。如果检索的字符串不存在，则返回 0 ；否则返回出现的次数。其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.count(sub[,start[,end]])</span><br></pre></td></tr></table></figure><p> 参数说明如下：</p><ul><li>str：表示原字符串</li><li>sub：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul></li><li><p>find() 方法</p><p>​    该方法用于检索是否包含指定的子字符串。如果检索的子字符串不存在，则返回 -1 ；反之，返回首次出现该子字符串时的索引。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.find(sub[,start[,end]])</span><br></pre></td></tr></table></figure><p> 参数说明如下：</p><ul><li>str：表示原字符串</li><li>sub：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul><blockquote><p>如果只想判断指定的字符串是否存在，可以使用 in 关键字实现。sub in string ：如果存在，就返回 Ture；反之，返回 False 。另外也可以根据 find() 方法的返回值是否大于 -1 来确定是否存在。Python 的字符串对象还提供了<code>rfind()</code> 方法，从字符串右边开始查找。</p></blockquote></li><li><p>index() 方法</p><p>​    index() 方法与 find() 方法类似，也是用于检索是否包含子字符串。只不过如果使用 index() 方法，当指定的字符串不存在时会抛出异常。其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.index(sub[,start[,end]])</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>str：表示原字符串</li><li>sub：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul></li><li><p>startswitch() 方法</p><p>​    该方法用于检索字符串是否以指定子字符串开头。如果是，返回 Ture；反之，返回 False。语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.startswitch(prefix[,start[,end]])</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>str：表示原字符串</li><li>prefix：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul></li><li><p>endswitch() 方法</p><p>​    该方法用于检索字符串是否以指定子字符串结尾。如果是，返回 Ture；反之，返回 False。语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.endswitch(prefix[,start[,end]])</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>str：表示原字符串</li><li>prefix：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul></li></ol><h3 id="6-2-6-字母的大小写转换"><a href="#6-2-6-字母的大小写转换" class="headerlink" title="6.2.6 字母的大小写转换"></a>6.2.6 字母的大小写转换</h3><p>在 Python 中，字符串对象提供了 lower() 方法和 upper() 方法进行字母的大小写转换。</p><ol><li><p>lower() 方法</p><p>​     lower() 方法用于将字符串中的全部大写字母转换成小写字母。字符串长度与原字符串长度相同。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.lower()</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>upper() 方法</p><p>​    用于将字符串中的全部小写字母转换成大写字母。字符串长度与原字符串长度相同。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.upper()</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2-7-去除字符串中的空格和特殊字符"><a href="#6-2-7-去除字符串中的空格和特殊字符" class="headerlink" title="6.2.7 去除字符串中的空格和特殊字符"></a>6.2.7 去除字符串中的空格和特殊字符</h3><p>用户在输入数据时，可能会无意中输入多余的空格，或在一些情况下，字符串前后不允许出现空格和特殊字符，此时就需要去除字符串中的空格和特殊字符。</p><ol><li><p>strip() 方法</p><p>​    该方法用于去掉字符串左、右两侧空格和特殊字符。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.strip([chars])</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>str：要去除字符的字符串</li><li>chars：可选参数，用于指定要去除的字符，可以指定多个，默认指定空格、制表符、回车符和换行符。</li></ul></li><li><p>lstrip() 方法</p><p>​    该方法用于去掉字符串左侧的空格和特殊字符，其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.lstrip([chars])</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>str：要去除字符的字符串</li><li>chars：可选参数，用于指定要去除的字符，可以指定多个，默认指定空格、制表符、回车符和换行符。</li></ul></li><li><p>rstrip() 方法</p><p>​    该方法用于去掉字符串右侧的空格和特殊字符，其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.rstrip([chars])</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>str：要去除字符的字符串</li><li>chars：可选参数，用于指定要去除的字符，可以指定多个，默认指定空格、制表符、回车符和换行符。</li></ul></li></ol><h3 id="6-2-8-格式化字符串"><a href="#6-2-8-格式化字符串" class="headerlink" title="6.2.8 格式化字符串"></a>6.2.8 格式化字符串</h3><p>格式化字符串的意思是先制定一个模板，在这个模板中预留几个位置，然后再根据需要填上相应的内容。这些空位需要通过指定的符号标记（也称为占位符），而这些符号还不会显示出来。在 Python 中，格式化字符串有两种方法。</p><ol><li><p>使用 % 操作符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%[-][+][0][m][.n]格式化字符&quot;</span>%exp</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>-：可选参数，用于指定左对齐，正数前方无符号，负数前方加负号</li><li>+：可选参数，用于指定右对齐，正数前方加正号，负数前方加负号</li><li>0：可选参数，表示右对齐，正数前方无符号，负数前方加负号，用 0 填充数字空白处（一般与 m 参数一起使用）</li><li>m：可选参数，表示占有宽度（或数字显示出的位数）</li><li>.n：可选参数，表示小数点后保留的位数</li><li>格式化字符：用于指定字符的类型</li><li>exp：要转换的项。如果要制定的项有多个，需要通过元组的形式进行指定，但是不能使用列表。</li></ul></li><li><p>使用字符出对象的 fornat() 方法</p><p>​    字符串对象提供了 format() 方法用于进行字符串格式化。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.<span class="built_in">format</span>(args)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p>str：用于指定字符串的显示样式（即模板）</p><p>下面重点介绍如何创建模板。在创建模板时，需要使用大括号和冒号指定占位符。基本语法如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; [index] [ : [ [fill] align] [sign] [<span class="comment">#] [width] [.precision] [type] ] &#125;</span></span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li><p>index：可选参数，用于指定要设置格式对象在参数列表中的索引位置，索引值从 0 开始，默认根据值得先后顺序自动分配</p></li><li><p>fill：可选参数，用于指定空白处填充得字符</p></li><li><p>align：可选参数，用于指定对齐方式，需要配合 width 一起使用</p><ul><li>&lt;：表示内容左对齐</li><li>> ：表示内容右对齐</li><li>=：表示内容右对齐，将符号放在填充内容的最左侧，且只对数字类型有效</li><li>^：表示内容居中</li></ul></li><li><p>sign：可选参数，用于指定有无符号数</p><ul><li>+：表示正数加正号，负数加负号</li><li>-：表示正数不变，负数加负号</li><li>空格：表示正数加空格，负数加负号</li></ul></li><li><p>#：可选参数，对于二进制、八进制和十六进制，如果加上 # ，表示会显示 0b 0o 0x 前缀，否则不显示前缀</p></li><li><p>width：可选参数，用于指定所占宽度</p></li><li><p>.precision：可选参数，用于指定保留得小数位数</p></li><li><p>type：可选参数，用于指定类型</p></li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">格式字符</th><th style="text-align:center">说明</th><th style="text-align:center">格式字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串</td><td style="text-align:center">%r</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">单个字符</td><td style="text-align:center">%o</td><td style="text-align:center">八进制整数</td></tr><tr><td style="text-align:center">%d 或者%i</td><td style="text-align:center">十进制整数</td><td style="text-align:center">%e</td><td style="text-align:center">指数（基底写为 e）</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">十六进制整数</td><td style="text-align:center">%E</td><td style="text-align:center">指数（基底写为 E）</td></tr><tr><td style="text-align:center">%f 或者%F</td><td style="text-align:center">浮点数</td><td style="text-align:center">%%</td><td style="text-align:center">字符%</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">格式化字符</th><th style="text-align:center">说明</th><th style="text-align:center">格式化字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">对字符串类型进行格式化</td><td style="text-align:center">b</td><td style="text-align:center">将十进制整数自动转换成二进制，再格式化</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">十进制整数</td><td style="text-align:center">0</td><td style="text-align:center">将十进制整数自动转换成八进制，再格式化</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">将十进制整数自动转换成对应的 Unicode 字符</td><td style="text-align:center">x 或者 X</td><td style="text-align:center">将十进制整数自动转换成十六进制，再格式化</td></tr><tr><td style="text-align:center">e 或者 E</td><td style="text-align:center">转换为科学计数法表示，再格式化</td><td style="text-align:center">f 或者 F</td><td style="text-align:center">转换为浮点数（默认小数点后保留 6 位），再格式化</td></tr><tr><td style="text-align:center">g 或者 G</td><td style="text-align:center">自动在科学计数法和浮点数中切换</td><td style="text-align:center">%</td><td style="text-align:center">显示百分比（默认显示小数点后 6 位）</td></tr></tbody></table></div><h1 id="第七章-正则表达式"><a href="#第七章-正则表达式" class="headerlink" title="第七章 正则表达式"></a>第七章 正则表达式</h1><h2 id="7-1-正则表达式语法"><a href="#7-1-正则表达式语法" class="headerlink" title="7.1 正则表达式语法"></a>7.1 正则表达式语法</h2><p>在处理字符串时，经常会有查找符合某些复杂规则的字符串的需求。正则表达式就是用于描述这些规则的工具。</p><h3 id="7-1-1-行定位符"><a href="#7-1-1-行定位符" class="headerlink" title="7.1.1 行定位符"></a>7.1.1 行定位符</h3><p>行定位符就是用来描述字符串的边界。“^”表示行的开始；“$”表示行的结尾。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^tm     <span class="comment">#从字符串的开头匹配tm</span></span><br><span class="line">tm$     <span class="comment">#从字符串的结尾匹配tm</span></span><br><span class="line">tm      <span class="comment">#从字符串的内部匹配tm</span></span><br></pre></td></tr></table></figure><h3 id="7-1-2-元字符"><a href="#7-1-2-元字符" class="headerlink" title="7.1.2 元字符"></a>7.1.2 元字符</h3><p>常用的元字符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母或数字或下划线或汉字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任意的空白符</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串的开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串的结束</td></tr></tbody></table></div><h3 id="7-1-3-重复"><a href="#7-1-3-重复" class="headerlink" title="7.1.3 重复"></a>7.1.3 重复</h3><p>使用“\\w*”匹配任意数量的字母或数字。如果想匹配特定数量的字符，正则表达式为我们提供了限定符（指定数量的字符）来实现该功能。</p><p>常用的限定符如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">限定符</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">？</td><td style="text-align:center">匹配前面的字符零次或一次</td><td style="text-align:center">colou?r，该表达式可以匹配 colour 和 color</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配前面的字符一次或多次</td><td style="text-align:center">go+gle，该表达式可以匹配 gogle 到 go…gle</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配前面的字符零次或多次</td><td style="text-align:center">go*gle，该表达式可以匹配 ggle 到 go…gle</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">匹配前面的字符 n 次</td><td style="text-align:center">go{2}gle，该表达式只匹配 google</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">匹配前面的字符最少 n 次</td><td style="text-align:center">go{2,}，该表达式可以匹配 google 到 goo…gle</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">匹配前面的字符最少 n 次，最多 m 次</td></tr></tbody></table></div><h3 id="7-1-4-字符类"><a href="#7-1-4-字符类" class="headerlink" title="7.1.4 字符类"></a>7.1.4 字符类</h3><p>正则表达式查找数字和字母是很简单的，因为已经有了对应这些字符集合的元字符（如：\d、\w），但是如果想要匹配没有预定义的元字符集合（比如：假名），应该怎么办？</p><p>很简单，只需要在方括号“[ ]”里列出它们就行。也可以指定一个字符范围，例如：[0-9a-zA-Z]，也完全等同于 \w （只考虑英文）</p><blockquote><p><strong>想要匹配给定字符串中的任意一个汉字，可以使用[\\u4e00-\\u9fa5]</strong></p></blockquote><h3 id="7-1-5-排除字符"><a href="#7-1-5-排除字符" class="headerlink" title="7.1.5 排除字符"></a>7.1.5 排除字符</h3><p>前面几节列出的是匹配符合指定字符集合的字符串。现在反过来，匹配不符合指定字符串集合的字符串。正则表达式提供了 “^” 字符。这里放到中括号中，表示排除的意思。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^a-zA-Z]</span><br></pre></td></tr></table></figure><p>该表达式用于匹配一个不是字母的字符。</p><h3 id="7-1-6-选择字符"><a href="#7-1-6-选择字符" class="headerlink" title="7.1.6 选择字符"></a>7.1.6 选择字符</h3><p>如何匹配身份证号码呢？身份证号码长度位 15 位或者 18 位。如果位 15 位，则全是数字；如果是 18 位，前 17 位位数字，最后一位是校验位，可能为数字或字符 X 。</p><p>在上面的描述中，包含者条件选逻辑，这就需要使用选择字符（“|”）来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ^ \d&#123;<span class="number">15</span>&#125; $ ) | ( ^ \d&#123;<span class="number">18</span>&#125; $ ) | ( (^ \d&#123;<span class="number">17</span>&#125; ) ( \d | X | x) $)</span><br></pre></td></tr></table></figure><h3 id="7-1-7-转义字符"><a href="#7-1-7-转义字符" class="headerlink" title="7.1.7 转义字符"></a>7.1.7 转义字符</h3><p>正则表达式中的转义字符与 Python 中的大同小异，都是将特殊字符变为普通字符。</p><h3 id="7-1-8-分组"><a href="#7-1-8-分组" class="headerlink" title="7.1.8 分组"></a>7.1.8 分组</h3><p>小括号字符的第一个作用就是可以改变限定符的作用范围。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( thir | four ) th</span><br></pre></td></tr></table></figure><p>小括号的第二个作用就是分组，也就是子表达式。</p><h3 id="7-1-9-在-Python-中使用正则表达式语法"><a href="#7-1-9-在-Python-中使用正则表达式语法" class="headerlink" title="7.1.9 在 Python 中使用正则表达式语法"></a>7.1.9 在 Python 中使用正则表达式语法</h3><p>在 Python 中使用正则表达式时，是将其作为模式字符串使用的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[^0-9a-z]&quot;</span></span><br><span class="line"><span class="string">&quot;\\bm\\w*\\b&quot;</span></span><br></pre></td></tr></table></figure><p>由于模式字符串可能包括大量的特殊字符和反斜杠，所以需要写为原生字符串，即在模式字符串前加 r 或 R 。例如，上面的模式字符串采用原生字符串表示就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">r&quot;\bm\w*\b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="7-2-使用-re-模块实现正则表达式操作"><a href="#7-2-使用-re-模块实现正则表达式操作" class="headerlink" title="7.2 使用 re 模块实现正则表达式操作"></a>7.2 使用 re 模块实现正则表达式操作</h2><p>本章节将介绍如何在 Python 中使用正则表达式。</p><p>re 模块在使用时，需要应先导入 import 语句引入，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h3 id="7-2-1-匹配字符串"><a href="#7-2-1-匹配字符串" class="headerlink" title="7.2.1 匹配字符串"></a>7.2.1 匹配字符串</h3><p>匹配字符串可以使用 re 模块的 match() 、 search() 和 findall() 方法。</p><ol><li><p>使用 <code>match()</code> 方法进行匹配</p><p>match() 方法用于从字符串的开始处进行匹配，如果在起始位置匹配成功，则返回 Match 对象，否则返回 None 。其语法格式如下：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(pattern,string [,flags])</span><br></pre></td></tr></table></figure><p> 参数说明如下：</p><ul><li><p>pattern：表示模式字符串，由要匹配的正则表达式转换而来</p></li><li><p>string：表示要匹配的字符串</p></li><li><p>flags：可选参数，表示标志位，用于控制匹配方式，如：是否区分大小写等。</p></li></ul><ol><li><p>使用 search() 方法进行匹配</p><p>search() 方法用于在整个字符串中搜索第一个匹配的值，如果在起始位置匹配成功，则返回 Match 对象，否则返回 None 。语法如下：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern,string [,flags])</span><br></pre></td></tr></table></figure><ol><li><p>使用 findall() 方法进行匹配</p><p>findall() 方法用于在整个字符串中搜索所有符合正则表达式的字符串，并以列表的形式返回。如果匹配成功，则返回包含匹配结果的列表，否则返回空列表。其语法格式如下;</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(pattern,string [,flags])</span><br></pre></td></tr></table></figure><p> 常用的标志如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">标志位</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">A 或 ASCII</td><td style="text-align:center">对于\\w \\W \\b \\B \\d \\D \\s \\S 只进行 ASCII 匹配（仅适用于 Python3）</td></tr><tr><td style="text-align:center">I 或者 IGNORECASE</td><td style="text-align:center">执行不区分字母大小写的匹配</td></tr><tr><td style="text-align:center">M 或者 MULTILING</td><td style="text-align:center">将^和$用于包括整个字符串的开始和结尾的每一行</td></tr><tr><td style="text-align:center">S 或者 DOTALL</td><td style="text-align:center">使用“.”字符匹配所有字符，包括换行符</td></tr><tr><td style="text-align:center">X 或者 VERBOSE</td><td style="text-align:center">忽略模式字符串中未转义的空格和注释</td></tr></tbody></table></div><h3 id="7-2-2-替换字符串"><a href="#7-2-2-替换字符串" class="headerlink" title="7.2.2 替换字符串"></a>7.2.2 替换字符串</h3><p>sub() 方法用于实现字符串的替换。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern,repl,string,count,flags)</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>pattern：表示模式字符串，由要匹配的正则表达式转换而来</li><li>repl：表示要替换的字符串</li><li>string：表示要被查找替换的原始字符串</li><li>count：可选参数，表示模式匹配后替换的最大次数，默认值为 0 ，表示替换所有的匹配</li><li>flags：可选参数，表示标志位，用于控制匹配方式，如：是否区分大小写等</li></ul><h3 id="7-2-3-使用正则表达式分割字符串"><a href="#7-2-3-使用正则表达式分割字符串" class="headerlink" title="7.2.3 使用正则表达式分割字符串"></a>7.2.3 使用正则表达式分割字符串</h3><p>split() 方法用于实现根据正则表达式分割字符串，并以列表对的形式返回。其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern,string [,maxsplit] [,flags])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>pattern：表示模式字符串，由要匹配的正则表达式转换而来</li><li>string：表示要被怕匹配的字符串</li><li>maxsplit：可选参数，表示最大的拆分次数</li><li>flags：可选参数，表示标志位，用于控制匹配方式，如：是否区分大小写等</li></ul><h1 id="第八章-函数"><a href="#第八章-函数" class="headerlink" title="第八章 函数"></a>第八章 函数</h1><h2 id="8-1-函数的创建和调用"><a href="#8-1-函数的创建和调用" class="headerlink" title="8.1 函数的创建和调用"></a>8.1 函数的创建和调用</h2><h3 id="8-1-1-创建一个函数"><a href="#8-1-1-创建一个函数" class="headerlink" title="8.1.1 创建一个函数"></a>8.1.1 创建一个函数</h3><p>创建函数也被称为定义函数。使用 def 关键字实现。具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[parameterlist]</span>):</span><br><span class="line">    [<span class="string">&quot;&quot;&quot;comments&quot;&quot;&quot;</span>]</span><br><span class="line">    [functionbody]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>functionname：函数名称，在调用函数时使用</li><li>parameterlist：可选参数，用于指定向函数中传递的参数。参数之间用逗号分隔</li><li>“””comments”””：可选参数，表示为函数指定的注释</li><li>functionbody：可选参数，用于指定函数体，即该函数被被调用之后，要执行的功能代码。</li></ul><blockquote><p>如果想定义一个什么也不做的空函数，可以使用 pass 语句作为占位符</p></blockquote><h3 id="8-1-2-调用函数"><a href="#8-1-2-调用函数" class="headerlink" title="8.1.2 调用函数"></a>8.1.2 调用函数</h3><p>调用函数也就是执行函数。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionname([parametersvalue])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>functionname：函数名称，要调用的函数名称必须是已经创建好的</li><li>parametersvalue：可选参数，用于指定各个参数的值。参数之间用逗号隔开</li></ul><h2 id="8-2-参数传毒"><a href="#8-2-参数传毒" class="headerlink" title="8.2 参数传毒"></a>8.2 参数传毒</h2><h3 id="8-2-1-形式参数和实际参数"><a href="#8-2-1-形式参数和实际参数" class="headerlink" title="8.2.1 形式参数和实际参数"></a>8.2.1 形式参数和实际参数</h3><p>在使用函数时，经常会用到形式参数和实际参数。下面从两个角度了解这两种参数。</p><ol><li>通过作用理解<ul><li>形式参数：在定义函数时，函数名后面括号中的参数为<strong>形式参数</strong></li><li>实际参数：在调用一个函数时，函数名后面的括号中的参数为<strong>实际参数</strong></li></ul></li></ol><h3 id="8-2-2-位置参数"><a href="#8-2-2-位置参数" class="headerlink" title="8.2.2 位置参数"></a>8.2.2 位置参数</h3><p>位置参数也称必备参数，是必须按照正确的顺序传到函数中，即调用时的数量和位置必须和定义时是一样的。</p><ol><li><p>数量必须与定义时一致</p><p>​    在调用函数时，指定的实际参数的数量必须与形式参数的数量一致，否则将会抛出 TypError 异常，提示缺少必要的位置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params"> a, b, c, d </span>) :</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    上面代码运行的结果为：</p></li><li><p>位置必须与定义时一致</p><p>​    在调用函数时，指定的实际参数的位置必须与形式参数的位置一致，否则将产生以下两种结果。</p><ul><li><p>抛出 TypError 异常</p><p>​    实际参数的类型与形式参数的类型不符，并且在函数中，这两种类型不能正常转换。</p></li><li><p>产生的结果与预期不符</p></li></ul></li></ol><h3 id="8-2-3-关键字参数"><a href="#8-2-3-关键字参数" class="headerlink" title="8.2.3 关键字参数"></a>8.2.3 关键字参数</h3><p>关键字参数是指使用形式参数的名字来确定输入的参数值。通过这种方式指定实际参数时，不再需要与形式参数的位置完全一致，只需要将参数名写正确即可。</p><p>例如，下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params"> a, b, c, d </span>) :</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nothing( a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">3</span> )</span><br></pre></td></tr></table></figure><h3 id="8-2-4-为参数设置默认值"><a href="#8-2-4-为参数设置默认值" class="headerlink" title="8.2.4 为参数设置默认值"></a>8.2.4 为参数设置默认值</h3><p>调用函数时，如果没有指定某个参数将抛出异常，为了解决这个问题，我们可以为参数设置默认值，即<strong>在定义函数时，直接指定形式参数的默认值</strong>。这样，当没有传入参数时，直接使用定义函数时设置的默认值。</p><p>定义带有默认值参数的函数的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params"> ... [parameter <span class="number">1</span> = value <span class="number">1</span> , .... ] </span>):</span><br><span class="line">    [functionbody]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>functionname：函数名称</li><li>parameter 1 = value 1：可选参数，用于指定向函数中传递的参数，并且为该参数设置默认值为 value 1</li><li>functionbody：可选参数，用于指定函数体</li></ul><blockquote><p>在定义函数时，指定的默认的形式参数必须在所有参数的后面，否则将会产生语法错误</p></blockquote><h3 id="8-2-5-可变参数"><a href="#8-2-5-可变参数" class="headerlink" title="8.2.5 可变参数"></a>8.2.5 可变参数</h3><p>在 Python 中，还可以定义可变参数。可变参数也称为不定长参数，即传入函数的实际参数可以是 0 个、1 个 到任意个。</p><ol><li><p>*parameter</p><p> 这种形式表示接收任意多个实际参数并将其放到一个元组中。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">yuanshen</span>(<span class="params"> *name </span>) :</span><br><span class="line">    string = <span class="string">&quot;原神有：&#123;&#125; 角色&quot;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> name :</span><br><span class="line">        <span class="built_in">print</span>( string.<span class="built_in">format</span>( item ), end=<span class="string">&quot;     &quot;</span> )</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;&quot;</span> )</span><br><span class="line">    yuanshen( <span class="string">&quot;胡桃&quot;</span> )</span><br><span class="line">    yuanshen( <span class="string">&quot;胡桃&quot;</span>, <span class="string">&quot;雷电将军&quot;</span>, <span class="string">&quot;八重神子&quot;</span> )</span><br></pre></td></tr></table></figure></li><li><p>parameter</p><p>这种形式表示接收任意多个类似关键字参数一样的显式赋值的实际参数，并将其放到一个字典中。</p></li></ol><h2 id="8-3-返回值"><a href="#8-3-返回值" class="headerlink" title="8.3 返回值"></a>8.3 返回值</h2><p>   在 Python 中，可以在函数体内使用 return 语句为函数指定返回返回值，该返回值可以是任意类型，并且无论 return 语句出现在函数的什么位置，只要得到执行，会直接结束当前执行的函数。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [value]</span><br></pre></td></tr></table></figure><h2 id="8-4-变量的作用域"><a href="#8-4-变量的作用域" class="headerlink" title="8.4 变量的作用域"></a>8.4 变量的作用域</h2><p>变量的作用域是指程序代码能够访问该变量的区域，如果超出该区域，在访问时就会出现错误。在程序中，一般会根据变量的有效作用范围，将变量分为<strong>局部变量</strong>和<strong>全局变量</strong>。</p><h3 id="8-4-1-局部变量"><a href="#8-4-1-局部变量" class="headerlink" title="8.4.1 局部变量"></a>8.4.1 局部变量</h3><p>局部变量是指在函数内部定义并使用的变量，它只在函数内部有效。</p><h3 id="8-4-2-全局变量"><a href="#8-4-2-全局变量" class="headerlink" title="8.4.2 全局变量"></a>8.4.2 全局变量</h3><p>与局部变量对应，全局变量能够作用于函数内外的变量。</p><h2 id="8-5-匿名函数"><a href="#8-5-匿名函数" class="headerlink" title="8.5 匿名函数"></a>8.5 匿名函数</h2><p>匿名函数（lambda）是指没有名字的函数，应用在需要一个函数但又不想费神去命名这个函数的场合。通常情况下，这种函数只会使用一次。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">lambda</span> [arg1] : expression</span><br></pre></td></tr></table></figure><h1 id="第九章-面向对象程序设计"><a href="#第九章-面向对象程序设计" class="headerlink" title="第九章 面向对象程序设计"></a>第九章 面向对象程序设计</h1><h2 id="9-1-面向对象概述"><a href="#9-1-面向对象概述" class="headerlink" title="9.1 面向对象概述"></a>9.1 面向对象概述</h2><p>面向对象（Object Oriented）的英文缩写是 OO，它是一种设计思想。从 20 世纪 60 年代提出面向对象的概念到现在，他已经发展成为一种比较成熟的编程思想，并且逐步成为目前软件开发领域的主流技术。</p><p>面向对象中的对象，通常是指客观世界中存在的对象，这个对象具有唯一性，对象之间各不相同，各有各的特点，每个对象都有自己的运动规律和内部状态；对象之间又是可以 i 相互联系、互相作用的。另外，对象也可以是一个抽象的事物。例如，可以从圆形、正方形、三角形等图形抽象出一个简单图形，简单图形就是一个对象，它有自己的属性和行为。</p><h3 id="9-1-1-对象"><a href="#9-1-1-对象" class="headerlink" title="9.1.1 对象"></a>9.1.1 对象</h3><p>对象，表示任意存在的食物。<strong>世间万物皆对象</strong>。</p><p>通常将对象划分为两个部分，即<strong>静态部分</strong>与<strong>动态部分</strong>。静态部分被称为“属性”，任何对象都具备自身的属性，如：人的性别；动态部分只对象的行为，即对象执行的动作，如：人可以行走。</p><h3 id="9-1-2-类"><a href="#9-1-2-类" class="headerlink" title="9.1.2 类"></a>9.1.2 类</h3><p>类是封装对象的属性和行为的载体，反过来说，具有统一属性的行为的一类实体被称为类。</p><h3 id="9-1-3-面向对象程序设计的特点"><a href="#9-1-3-面向对象程序设计的特点" class="headerlink" title="9.1.3 面向对象程序设计的特点"></a>9.1.3 面向对象程序设计的特点</h3><p>面向对象程序设计具有三大基本特征：<strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>。</p><ol><li><p>封装</p><p>​    封装是面向对象编程的核心思想，将对象的属性和行为封装起来，而将对象的属性和行为封装起来的载体就是类。类通常对客户隐藏其实现细节，这就是封装的思想，简单来说，用户访问类的成员时，加以一定的访问限制。</p><p>​    采用封装思想，保证了类内部数据结构的完整性，使用该类的用户不能直接看到类中的数据结构，而只能执行类允许公开的数据，这样就避免了外部对内部数据的影响，提高了程序的可维护性。</p></li><li><p>继承</p><p>​    继承是实现重复利用的重要手段，子类通过继承父类的属性和行为的同时，又添加了子类特有的属性和行为。</p></li><li><p>多态</p><p>​    将父类对象应用于子类的特征就是多态。</p></li></ol><h2 id="9-2-类的定义和使用"><a href="#9-2-类的定义和使用" class="headerlink" title="9.2 类的定义和使用"></a>9.2 类的定义和使用</h2><h3 id="9-2-1-定义类"><a href="#9-2-1-定义类" class="headerlink" title="9.2.1 定义类"></a>9.2.1 定义类</h3><p>在 Python 中，类的定义使用 class 关键字来实现，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;类的说明信息&quot;&quot;&quot;</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>ClassName：用于指定类名，一般采用 Pascal 命名法</li><li>BaseClass：继承的父类的类名，如果没有继承可不写（同时可以省略括号）</li><li>“””类的说明信息”””：用于指定类的文档字符串，定义该字符串后，在创建类时，输入类名和括号，将会显示该信息</li><li>statement：类体，包含该类的所有成员</li></ul><h3 id="9-2-2-创建类的实例"><a href="#9-2-2-创建类的实例" class="headerlink" title="9.2.2 创建类的实例"></a>9.2.2 创建类的实例</h3><p>定义完类后，并不会真正创建一个实例。创建类的实例的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(parameterlist)</span><br></pre></td></tr></table></figure><h3 id="9-2-3-创建-init-方法"><a href="#9-2-3-创建-init-方法" class="headerlink" title="9.2.3 创建__init__() 方法"></a>9.2.3 创建__init__() 方法</h3><p>在创建类后，通常会创建一个 __init__() 方法。该方法是一个特殊的方法，类似 Java 或 C# 的构造函数。每当创建一个类的实例化时， Python 都会自动执行它。__init__() 必须包含一个 self 参数，并且必须是第一个参数。self 参数是一个指向实例本身的引用，用于访问类中的属性和方法。在方法调用时，会自动传递实际参数 self 。因此，当__init__() 方法只有一个参数是，在创建类的实例时，就不需要指定实际参数了。</p><blockquote><p>__init__() 方法的名称中，开头结尾是<strong>双下划线</strong>，这是一种约定。</p></blockquote><h3 id="9-2-4-创建类的成员并访问"><a href="#9-2-4-创建类的成员并访问" class="headerlink" title="9.2.4 创建类的成员并访问"></a>9.2.4 创建类的成员并访问</h3><p>在 Python 中，类的成员有三种：类属性、实例属性、实例方法。</p><ol><li><p>创建实例方法并访问</p><p>​    所谓实例方法，是在类中定义的函数。实例方法的第一个参数必须是 self ，并且必须包含一个 self 参数。创建实例方法的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">self,parameterlist</span>):</span><br><span class="line">    block</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>functionname：用于指定方法名，一般使用小写字母开头</li><li>self：必要参数，表示类的实例，其名称可以是 self 以外的单词，使用 self 只是一个习惯而已</li><li>parameterlist：用于指定除 self 参数以外的参数</li><li><p>block：方法体，实现的具体功能</p><p> 实例方法创建完成后，可以通过类的实例名和（ . ）操作符进行访问。</p></li></ul></li><li><p>创建数据成员并访问</p><ul><li><p>类属性</p><p>​     类属性是指定义在类中，并且在类方法之外的属性。类属性可以在类的所有实例之间共享值，也就是在所有实例化的对象中公用。</p><p> 类属性可以通过类名加 “ . ” 进行访问，也可以用实例名加 “ . ” 进行访问</p></li><li><p>实例属性</p><p>​     实例属性是指定义在类的方法中的属性，只作用于当前实例。对于实例属性，可以通过实例名称修改，但是并不会影响到另一个实例中的相应的实例属性。</p></li></ul></li><li><p>💰 类属性和实例属性的区别</p><ol><li>在内存上，每个实例对象都会在内存中开辟一块空间，用于存储自身的实例属性，因此，实例属性之间不会相互影响；</li><li>类属性只会开辟一份内存空间，所有实例对象的类属性共用一块内存，因此，在实例 A 中修改类属性，会导致实例 B ….等所有当前存在的实例对象的类属性发生变化</li></ol></li></ol><h3 id="9-2-5-self-参数的详细解读"><a href="#9-2-5-self-参数的详细解读" class="headerlink" title="9.2.5 self 参数的详细解读"></a>9.2.5 self 参数的详细解读</h3><p>self 有两个基本作用：</p><ul><li>区别类属性和实例属性（类属性没有 self），同时区分传入类的参数与实例属性</li><li>占位符，表示对当前操作对象的引用</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> :</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self, a, b </span>) :</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line">zhangsan = Person( <span class="number">1</span>, <span class="number">2</span> )</span><br><span class="line">lisi = Person(<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>( Person.a )</span><br><span class="line"><span class="built_in">print</span>( zhangsan.a )</span><br><span class="line"><span class="built_in">print</span>( zhangsan.b )</span><br></pre></td></tr></table></figure><ol><li><p>首先，传入类的构造方法的参数 a、b，为了区分实例属性 a 和 b</p></li><li><p>当创建 zhangsan 时，self 将代表着 zhangsan，类中的所有 self 均可以被替换为 zhangsan（前提是当前操作的是 zhangsan 这个实例对象）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#伪代码</span></span><br><span class="line">zhangsan = Person(a = <span class="number">1</span>,b = <span class="number">2</span>):</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> zhangsan, a, b </span>) :</span><br><span class="line">        zhangsan.a = a</span><br><span class="line">        zhangsan.b = b</span><br></pre></td></tr></table></figure><p>​     当创建 list 时，就是把 self 替换成 list 由此可见，self 代表着对当前对象的引用。</p></li></ol><h3 id="9-2-6-访问限制"><a href="#9-2-6-访问限制" class="headerlink" title="9.2.6 访问限制"></a>9.2.6 访问限制</h3><p>在类的内部可以定义属性和方法，而在类的外部则可以直接调用属性或方法来操作数据，从而隐藏了类内部的复杂逻辑。但是，Python 并没有对属性和方法的访问权限进行限制。为了保护类内部的某些属性或方法不被外部访问，可以在属性或方法名前添加单下划线、双下划线或者首尾加双下划线，从而限制访问权限。</p><ul><li>_foo：以单下划线开头的表示 保护（protected）类型的成员，只允许该类本身和子类进行访问，但是不能使用 “ from module import * ” 语句导入</li><li>__foo：以双下划线开头的表示 private（私有）类型的成员，只允许定义该方法的类本身进行访问，而且也不能通过类的实例进行访问，但是可以通过 “ 类的实例名.类名.__xxx ” 进行访问</li><li>__foo__：首尾双下划线表示特殊定义方法，一般是系统定义名字，如：__init__</li></ul><h2 id="9-3-属性"><a href="#9-3-属性" class="headerlink" title="9.3 属性"></a>9.3 属性</h2><p>本章节介绍的属性与前面的类属性和实例属性不同。本章节要介绍的属性是一种特殊的属性，访问它时将计算它的值。</p><h3 id="9-3-1-创建用于计算的属性"><a href="#9-3-1-创建用于计算的属性" class="headerlink" title="9.3.1 创建用于计算的属性"></a>9.3.1 创建用于计算的属性</h3><p>在 Python 中，可以通过 @property（修饰器）将一个方法转换为属性，从而实现用于计算的属性。将方法转换为属性后，可直接通过方法名来访问方法，而不需要在添加一对小括号，这样可以让代码更加简洁。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methodname</span>(<span class="params">self</span>):</span><br><span class="line">        block</span><br><span class="line"></span><br><span class="line">tmp = ClassName()</span><br><span class="line"><span class="built_in">print</span>(tmp.methodname)</span><br></pre></td></tr></table></figure><h3 id="9-3-2-为属性添加安全保护机制"><a href="#9-3-2-为属性添加安全保护机制" class="headerlink" title="9.3.2 为属性添加安全保护机制"></a>9.3.2 为属性添加安全保护机制</h3><p>在 Python 中，默认情况下，创建的类属性或者实例属性可以在类体外进行修改，如果想要限制其不能在类体外修改，可以将其设置为私有，但是设置为私有后，在类体外也不能获取它的值。如果想要创建一个可以读取，但是不能修改的属性，那么可以使用 @property（修饰器）实现只读属性。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">YuanShen</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>) :</span><br><span class="line">        self.__company = <span class="string">&quot;米哈游&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">company</span>(<span class="params"> self </span>) :</span><br><span class="line">        <span class="keyword">return</span> self.__company</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">game = YuanShen()</span><br><span class="line"><span class="built_in">print</span>( game.company )</span><br></pre></td></tr></table></figure><h2 id="9-4-继承"><a href="#9-4-继承" class="headerlink" title="9.4 继承"></a>9.4 继承</h2><p>在编写类时，并不是每次都要从空白开始。当要编写的类和另一个已经存在的类之间存在一定的继承关系，就可以通过继承来达到代码重用的目的，提高开发效率。</p><h3 id="9-4-1-继承的基本语法"><a href="#9-4-1-继承的基本语法" class="headerlink" title="9.4.1 继承的基本语法"></a>9.4.1 继承的基本语法</h3><p>继承是面向对象编程最重要的特性之一。</p><p>具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>(<span class="title class_ inherited__">baseclasslist</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;类的帮助信息&quot;&quot;&quot;</span></span><br><span class="line">    Statement</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>baseclasslist：用于指定继承的父类，可以有多个。如果不指定，将使用所有 Python 对象的根类 Object 。</li></ul><h3 id="9-4-2-方法重写"><a href="#9-4-2-方法重写" class="headerlink" title="9.4.2 方法重写"></a>9.4.2 方法重写</h3><p>父类的成员都会被子类继承（除了私有成员），当父类中的某个方法不完全适用于子类时，就需要在子类中重新定义这个方法，这和 Java 语言中的方法重写是一样的。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> :</span><br><span class="line">    color = <span class="string">&quot;绿色&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">harvest</span>(<span class="params"> self, color </span>) :</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&quot;水果的颜色是：&quot;</span>, color, <span class="string">&quot;的！&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>( <span class="title class_ inherited__">Fruit</span> ) :</span><br><span class="line">    color = <span class="string">&quot;红色&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">harvest</span>(<span class="params"> self, color </span>) :</span><br><span class="line">        <span class="built_in">print</span>( color, <span class="string">&quot;是水果的颜色&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apple = Apple()</span><br><span class="line">apple.harvest( <span class="string">&quot;白色&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="9-4-3-子类调用父类的-init-方法"><a href="#9-4-3-子类调用父类的-init-方法" class="headerlink" title="9.4.3 子类调用父类的__init__() 方法"></a>9.4.3 子类调用父类的__init__() 方法</h3><p>在子类中定义__init__() 方法时，不会自动调用父类的__init__() 方法。因此，要让子类调用父类的__init__() 方法进行必要的初始化，需要在子类的__init__() 方法里面使用 super() 函数调用父类的__init__() 方法。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> :</span><br><span class="line">    color = <span class="string">&quot;绿色&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>) :</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&quot;我是父类&quot;</span> )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">harvest</span>(<span class="params"> self, color </span>) :</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&quot;水果的颜色是：&quot;</span>, color, <span class="string">&quot;的！&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>( <span class="title class_ inherited__">Fruit</span> ) :</span><br><span class="line">    color = <span class="string">&quot;红色&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>) :</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&quot;我是子类&quot;</span> )</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">harvest</span>(<span class="params"> self, color </span>) :</span><br><span class="line">        <span class="built_in">print</span>( color, <span class="string">&quot;是水果的颜色&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apple = Apple()</span><br></pre></td></tr></table></figure><h1 id="第十章-模块"><a href="#第十章-模块" class="headerlink" title="第十章 模块"></a>第十章 模块</h1><h2 id="10-1-模块概述"><a href="#10-1-模块概述" class="headerlink" title="10.1 模块概述"></a>10.1 模块概述</h2><p>在 Python 中，一个扩展名为 .py 的文件就称为一个模块。通常情况下，我们把能够实现某一特定功能的代码放置在一个文件中作为一个模块，从而方便其他程序和脚本导入并使用。另外，使用模块也可以避免函数名和变量名冲突。</p><h2 id="10-2-自定义模块"><a href="#10-2-自定义模块" class="headerlink" title="10.2 自定义模块"></a>10.2 自定义模块</h2><p>在 Python 中，自定义模块有两个作用，意识规范代码，让代码更易阅读，另一个是方便其他程序使用已经编写好的代码，提高开发效率。自定义模块的主要分为两部分，一部分是创建模块，另一部分是导入模块。</p><h3 id="10-2-1-创建模块"><a href="#10-2-1-创建模块" class="headerlink" title="10.2.1 创建模块"></a>10.2.1 创建模块</h3><p>创建模块可以将模块中的相关代码编写在一个单独的文件中，并且将该文件命名为“ 模块名.py ” 的形式。</p><blockquote><p>创建模块时，设置的模块名不能是 Python 自带的标准模块名称。模块文件的扩展名必须是 .py</p></blockquote><h3 id="10-2-2-导入模块"><a href="#10-2-2-导入模块" class="headerlink" title="10.2.2 导入模块"></a>10.2.2 导入模块</h3><p>创建模块后，就可以在其他程序中使用该模块。使用模块需要先以模块的形式加载模块中的代码，这可以使用 import 语句实现。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> modulename [<span class="keyword">as</span> alias]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>modulename：要导入的模块的名称</li><li>as alias：给模块起的别名，通过别名也可以使用模块</li></ul><p>使用 import 语句还可以一次性导入多个模块，在导入多个模块时，模块名之间用逗号隔开。</p><p>在使用 import 语句导入模块时，每执行一条 import 语句，都会创建一个新的命名空间（namespace），并且在该命名空间中执行与 .py 文件相关的所有语句。所以，在执行时，需要在具体的变量、函数和类名前加上 “模块名” 前缀。如果不想再每次导入模块时都创建一个新的命名空间，而是将具体的定义导入当前的命名空间中，这时可以使用 from…import 语句。具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modulename <span class="keyword">import</span> member</span><br><span class="line"><span class="keyword">from</span> modulename <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>modulename：要导入的模块名称</li><li>member：用于指定导入的变量、函数或类等</li><li>使用星号 ✳：表示导入模块里面的全部内容</li></ul><blockquote><p>使用 import 导入模块时，模块名是区分大小写的</p></blockquote><h3 id="10-2-3-模块搜索目录"><a href="#10-2-3-模块搜索目录" class="headerlink" title="10.2.3 模块搜索目录"></a>10.2.3 模块搜索目录</h3><p>当使用 import 语句导入模块时，默认情况下，会按照以下顺序进行查找：</p><ol><li>当前执行的 Python 脚本所在目录</li><li>到 PYTHONPATH（环境变量）下的每个目录中查找</li><li>到 Python 的默认安装位置目录下查找</li></ol><p>以上各个目录的具体位置保存在标准模块 sys 的 sys.path 变量中。可以通过下面代码查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( sys.path )</span><br></pre></td></tr></table></figure><p>如果导入的模块不在 上述代码运行结果的目录 中，那么在导入模块是将会抛出异常。这时，我们可以通过以下 3 中方法添加指定的目录到 sys.path 中。</p><ol><li><p>临时添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;E:/xx/xx&quot;</span></span><br><span class="line">sys.path.append( path )</span><br></pre></td></tr></table></figure></li><li><p>增加 .pth 文件（🎆 推荐用法）</p><p>​    在 Python 安装目录下的 Lib\\site-package 子目录中，创建一个扩展名为 .pth 的文件，文件名任意。在该文件中添加要导入的模块所在目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.pth 文件</span></span><br><span class="line">E:/xx/xx</span><br></pre></td></tr></table></figure><blockquote><p>创建 .pth 文件后，需要重新打开要执行导入模块的 Python 文件，否则新添加的目录不起作用。</p></blockquote></li><li><p>在 PYTHONPATH 环境变量中添加</p></li></ol><h2 id="10-3-Python-中的包"><a href="#10-3-Python-中的包" class="headerlink" title="10.3 Python 中的包"></a>10.3 Python 中的包</h2><p>使用模块可以避免函数名和变量名重名引发为错误。那么，模块名重复则么办呢？在 Python 中提出了包（package）的概念。包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下。这样，既可以起到规范代码的作用，又可以避免模块名重复引起的错误。</p><h3 id="10-3-1-Python-程序的包的结构"><a href="#10-3-1-Python-程序的包的结构" class="headerlink" title="10.3.1 Python 程序的包的结构"></a>10.3.1 Python 程序的包的结构</h3><h3 id="10-3-2-创建和使用包"><a href="#10-3-2-创建和使用包" class="headerlink" title="10.3.2 创建和使用包"></a>10.3.2 创建和使用包</h3><ol><li><p>创建包</p><p>​    创建包实际上就是创建一个文件夹，并且在该文件夹中创建一个名为“__init__.py” 的 Python 文件。在__init__.py 文件中，可以不编写任何代码，也可以编写一些 Python 代码。在__init__.py 文件中所编写的代码，在导入包时会自动执行。</p></li><li><p>使用包</p><ul><li>使用 “import + 完整包名 + 模块名”</li><li>使用 “from + 完整包名 import 模块名”</li><li>使用 “import + 完整包名 + 模块名 + import + 定义名”</li></ul></li></ol><h3 id="10-3-4-以主程序的形式执行"><a href="#10-3-4-以主程序的形式执行" class="headerlink" title="10.3.4 以主程序的形式执行"></a>10.3.4 以主程序的形式执行</h3><p>在 Python 中，执行的脚本文件在导入模块时，会执行模块里面的代码，如果模块里面存在测试代码，如：<code>print()</code> 等，同样也会执行该函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;米哈游&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是测试代码！&quot;</span>)</span><br></pre></td></tr></table></figure><p>这显然不是我们想看到的，我们希望导入的模块的函数不会自动执行，而是我们手动去调用。因此，在模块里面，添加下列代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;米哈游&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是测试代码！&quot;</span>)</span><br></pre></td></tr></table></figure><p>将模块里面的测试代码放入“if __name__ == “__main__“:” 里面。当模块里面的代码以主程序运行时，就会执行测试代码，而模块以库导入其他主程序时，就不会执行测试代码。</p><h2 id="10-4-引用其他模块"><a href="#10-4-引用其他模块" class="headerlink" title="10.4 引用其他模块"></a>10.4 引用其他模块</h2><p>在 Python 中，除了自定义的模块外，还可以引用其他模块，主要包括标准模块和第三方模块。</p><h3 id="10-4-1-导入和使用标准模块"><a href="#10-4-1-导入和使用标准模块" class="headerlink" title="10.4.1 导入和使用标准模块"></a>10.4.1 导入和使用标准模块</h3><p>Python 中提供了 200 多个内置的标准模块，涵盖了 Python 运行时服务、文字模式匹配、操作系统接口、数学运算、对象永久保存、网络和 Internet 脚本和 GUI 构建等方面。可以在 Python 的<a href="https://docs.python.org/">帮助文档</a>查看。</p><h3 id="10-4-2-第三方模块的下载与安装"><a href="#10-4-2-第三方模块的下载与安装" class="headerlink" title="10.4.2 第三方模块的下载与安装"></a>10.4.2 第三方模块的下载与安装</h3><p>在进行 Python 程序开发时，除了可以使用 Python 内置的标准模块，还有很多第三方模块可以让我们使用。对于这些第三方模块，可在 Python 的官网推出的<a href="https://pypi.org/">皮皮 ·Python 包索引)</a>中可以让我们找到。</p><ol><li><p>安装第三方模块</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install modulename</span><br></pre></td></tr></table></figure></li><li><p>卸载第三方模块</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall modulename</span><br></pre></td></tr></table></figure></li><li><p>查看已经安装的第三方模块</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure></li></ol><h1 id="第十一章-异常处理"><a href="#第十一章-异常处理" class="headerlink" title="第十一章 异常处理"></a>第十一章 异常处理</h1><h2 id="11-1-异常概述"><a href="#11-1-异常概述" class="headerlink" title="11.1 异常概述"></a>11.1 异常概述</h2><p>在程序运行过程中，经常会遇到各种错误，这些错误统称为异常。</p><div class="table-container"><table><thead><tr><th style="text-align:center">异常</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">NameError</td><td style="text-align:center">尝试访问一个没有声明变量引发的错误</td></tr><tr><td style="text-align:center">IndexError</td><td style="text-align:center">索引超出序列范围引发的错误</td></tr><tr><td style="text-align:center">IndentionError</td><td style="text-align:center">缩进错误</td></tr><tr><td style="text-align:center">ValueError</td><td style="text-align:center">传入的值错误</td></tr><tr><td style="text-align:center">KeyError</td><td style="text-align:center">请求一个不存在的字典关键字引发的错误</td></tr><tr><td style="text-align:center">IOError</td><td style="text-align:center">输入输出错误</td></tr><tr><td style="text-align:center">ImpotyError</td><td style="text-align:center">当 import 语句无法找到模块或 from 无法在模块中找到相应的名称时引发的错误</td></tr><tr><td style="text-align:center">AttributeError</td><td style="text-align:center">尝试访问未知的对象属性引发的错误</td></tr><tr><td style="text-align:center">TypeError</td><td style="text-align:center">类型不合适引发的错误</td></tr><tr><td style="text-align:center">MemoryError</td><td style="text-align:center">内存不足</td></tr><tr><td style="text-align:center">ZeroDivisionError</td><td style="text-align:center">除数为 0 引发的错误</td></tr></tbody></table></div><blockquote><p>上述所示的异常，了解即可。</p></blockquote><h2 id="11-2-异常处理语句"><a href="#11-2-异常处理语句" class="headerlink" title="11.2 异常处理语句"></a>11.2 异常处理语句</h2><h3 id="11-2-1-try…except-语句"><a href="#11-2-1-try…except-语句" class="headerlink" title="11.2.1 try…except 语句"></a>11.2.1 try…except 语句</h3><p>具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    block1</span><br><span class="line"><span class="keyword">except</span> [ExceptionName [<span class="keyword">as</span> alias]]:</span><br><span class="line">    block2</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>block1：表示可能出现的错误的代码块</li><li>ExceptionName [as alias]：可选参数，用于指定要捕获的异常</li><li>block2：表示进行异常处理的代码块</li></ul><blockquote><p>使用 try…except 语句捕获异常后，当程序出现错误时，程序会继续执行</p></blockquote><h3 id="11-2-2-try…except…else-语句"><a href="#11-2-2-try…except…else-语句" class="headerlink" title="11.2.2 try…except…else 语句"></a>11.2.2 try…except…else 语句</h3><p>与 try…except 不同的时，在 try 语句没有发生异常的时候，就会执行 else 中的代码</p><h3 id="11-2-3-try…except…finally-语句"><a href="#11-2-3-try…except…finally-语句" class="headerlink" title="11.2.3 try…except…finally 语句"></a>11.2.3 try…except…finally 语句</h3><p>完整的异常处理应该包含 finally 代码块，通常情况下，无论程序中有无异常产生， finally 代码块中的代码总会执行。</p><h3 id="11-2-4-使用-raise-语句抛出异常"><a href="#11-2-4-使用-raise-语句抛出异常" class="headerlink" title="11.2.4 使用 raise 语句抛出异常"></a>11.2.4 使用 raise 语句抛出异常</h3><p>如果某个函数或方法可能会产生异常，但不想在当前函数或方法中处理这个异常，则可以使用 raise 语句在函数或方法中抛出异常。raise 语句的基本格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raisl [ExceptionName[(reason)]]</span><br></pre></td></tr></table></figure><h2 id="11-3-程序调试"><a href="#11-3-程序调试" class="headerlink" title="11.3 程序调试"></a>11.3 程序调试</h2><h1 id="第十二章-文件及目录操作"><a href="#第十二章-文件及目录操作" class="headerlink" title="第十二章 文件及目录操作"></a>第十二章 文件及目录操作</h1><h2 id="12-1-基本文件操作"><a href="#12-1-基本文件操作" class="headerlink" title="12.1 基本文件操作"></a>12.1 基本文件操作</h2><p>在 Python 中，内置了文件（File）对象。在使用文件对象时，首先需要通过内置的 open() 方法创建一个文件对象，然后通过该对象提供的一些方法进行一些基本文件操作。</p><h3 id="12-1-1-创建和打开文件"><a href="#12-1-1-创建和打开文件" class="headerlink" title="12.1.1 创建和打开文件"></a>12.1.1 创建和打开文件</h3><p>在 Python 中，想要操作文件需要首先创建或打开指定文件并创建文件对象，这样可以使用内置的 open() 方法实现。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(filename [, mode [, buffering]] )</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>file：被创建的文件对象</li><li>filename：要创建或打开的文件的名称，需要使用单引号或者双引号括起来。如果打开的文件和当前文件在同一目录下，直接使用文件名即可，否则需要制定完整的路径</li><li>mode：可选参数，用于指定文件的打开模式</li><li>buffering：可选参数，用于指定读写文件的缓冲模式，值为 0 表示不缓存；值为 1 表示缓存；如果大于 1 ，则表示缓冲区的大小。默认为缓存模式</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">打开模式</th><th style="text-align:left">说明</th><th style="text-align:center">注意</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:left">以只读模式打开文件。文件的指针将会放在文件的开头</td><td style="text-align:center">文件必须存在</td></tr><tr><td style="text-align:center">rb</td><td style="text-align:left">以二进制格式打开文件，并且采用只读模式。文件的指针将会在文件的开头。一般用于非文本文件，如：图片、声音等</td><td style="text-align:center">文件必须存在</td></tr><tr><td style="text-align:center">r+</td><td style="text-align:left">打开文件后，可以读取文件内容，也可以写入新的内容覆盖原有内容（从文件开头进行覆盖）</td><td style="text-align:center">文件必须存在</td></tr><tr><td style="text-align:center">rb+</td><td style="text-align:left">以二进制格式打开文件，并且采用读写模式。文件的指针将会在文件的开头。一般用于非文本文件，如：图片、声音等</td><td style="text-align:center">文件必须存在</td></tr><tr><td style="text-align:center">w</td><td style="text-align:left">以只写模式打开文件</td><td style="text-align:center">文件存在，则将其覆盖；反之，则创建新文件</td></tr><tr><td style="text-align:center">wb</td><td style="text-align:left">以二进制格式打开文件，并且采用只写模式。文件的指针将会在文件的开头。一般用于非文本文件，如：图片、声音等</td><td style="text-align:center">文件存在，则将其覆盖；反之，则创建新文件</td></tr><tr><td style="text-align:center">w+</td><td style="text-align:left">打开文件后，先清空原有内容，使其变为一个空文件，对这个空文件有读写权限</td><td style="text-align:center">文件存在，则将其覆盖；反之，则创建新文件</td></tr><tr><td style="text-align:center">wb+</td><td style="text-align:left">以二进制格式打开文件，并且采用读写模式。文件的指针将会在文件的开头。一般用于非文本文件，如：图片、声音等</td><td style="text-align:center">文件存在，则将其覆盖；反之，则创建新文件</td></tr><tr><td style="text-align:center">a</td><td style="text-align:left">以追加模式打开一个文件，并且采用追加模式。如果该文件已经存在，文件指针将放在文件的末尾（即新内容会被写入到已有内容之后），否则，创建新文件用于读写</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ab</td><td style="text-align:left">以二进制模式打开一个文件，并且采用追加模式。如果该文件已经存在，文件指针将放在文件的末尾（即新内容会被写入到已有内容之后），否则，创建新文件用于读写</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">a+</td><td style="text-align:left">以读写模式打开一个文件。如果该文件已经存在，文件指针将放在文件的末尾（即新内容会被写入到已有内容之后），否则，创建新文件用于读写</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ab+</td><td style="text-align:left">以二进制模式打开一个文件，并且采用追加模式。如果该文件已经存在，文件指针将放在文件的末尾（即新内容会被写入到已有内容之后），否则，创建新文件用于读写</td></tr></tbody></table></div><h3 id="12-1-2-关闭文件"><a href="#12-1-2-关闭文件" class="headerlink" title="12.1.2 关闭文件"></a>12.1.2 关闭文件</h3><p>打开文件后，需要及时关闭，以免对文件造成不必要的破坏。关闭文件可以使用 close() 方法实现。语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>file：为打开的文件对象</li></ul><h3 id="12-1-3-打开文件时使用-with-语句"><a href="#12-1-3-打开文件时使用-with-语句" class="headerlink" title="12.1.3 打开文件时使用 with 语句"></a>12.1.3 打开文件时使用 with 语句</h3><p>打开文件后，要将其及时关闭，，如果忘记关闭，可能会出现意想不到的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> expression <span class="keyword">as</span> target:</span><br><span class="line">    <span class="keyword">with</span> - body</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>expression：用于指定一个表达式</li><li>target：用以指定一个变量，并且将 expression 结果保存到该变量中</li><li>with - body：用于指定 with 语句体，其中可以是执行 with 语句后相关的一些操作语句。</li></ul><h3 id="12-1-4-写入文件"><a href="#12-1-4-写入文件" class="headerlink" title="12.1.4 写入文件"></a>12.1.4 写入文件</h3><p>前面我们学习了如何创建文件，但是该文件没有任何内容，它的大小是 0 KB。Python 的文件对象提供了 write() 方法，可以向该文件中写入内容。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.write(string)</span><br></pre></td></tr></table></figure><blockquote><p>在我们写入文件后，写入的内容会先保存在缓冲区，只有当调用了 flush() 或 close() 方法后，操作系统才会把缓冲区的内容写入磁盘。</p></blockquote><h3 id="12-1-5-读取文件"><a href="#12-1-5-读取文件" class="headerlink" title="12.1.5 读取文件"></a>12.1.5 读取文件</h3><ol><li><p>读取指定字符</p><p>​    文件对象提供了 read() 方法，读取指定个数的字符。语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.read([size])</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>file：为打开的文件对象</li><li>size：为可选参数，用于指定要读取的字符个数，默认省略为读取所有内容</li></ul></li></ol><p>   ​    使用上述方法读取文件时，是从开头开始读取的。如果想要读取部分内容，可以先使用文件对象的 seek() 方法将文件指针移动到新位置，然后再用 read() 方法读取。语法如下：</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.seek( offset [, whence ] )</span><br></pre></td></tr></table></figure><p>   ​    参数说明如下;</p><ul><li>file：表示已经打开的文件</li><li>offset：用于指定移动的字符个数，其具体位置与 whence 有关</li><li>whence：可选参数，用于指定从什么位置开始计算。值为 0 表示从文件头部开始计算，1 表示从文件当前位置开始计算，2 表示从文件尾部开始计算，默认省略为 0</li></ul><ol><li><p>读取一行</p><p>​    在使用 read() 方法读取文件时，如果文件很大，一次读取全部内容到内存，容易造成内存不足，所以通常会采用逐行读取。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filereadline()</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>读取全部行</p><p>​    读取全部行的作用与 read() 方法一样，只不过读取全部行时，返回的是一个字符串列表，每个元素为文件的一行内容。其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.readlines()</span><br></pre></td></tr></table></figure></li></ol><h2 id="12-2-目录操作"><a href="#12-2-目录操作" class="headerlink" title="12.2 目录操作"></a>12.2 目录操作</h2><h3 id="12-2-1-os-和-os-path-模块"><a href="#12-2-1-os-和-os-path-模块" class="headerlink" title="12.2.1 os 和 os.path 模块"></a>12.2.1 os 和 os.path 模块</h3><p>在 Python 中，内置了 os 模块以及其子模块 os.path 用于对目录或文件进行操作。在使用 os 模块或者 os.path 模块时，需要用 import 语句进行导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br></pre></td></tr></table></figure><p>os 模块常用的变量有：</p><ul><li>name：用于获取操作系统的类型<ul><li>输出为 nt ，则代表为 Windows 操作系统</li><li>输出为 posix ，则表示为 Linux</li></ul></li><li>linesep：用于获取当前操作系统上的换行符</li><li>sep：用于获取当前操作系统所使用的路径分隔符</li></ul><p>os 模块提供的一些操作目录的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">getcwd()</td><td>返回当前的工作目录</td></tr><tr><td style="text-align:center">listdir(path)</td><td>返回指定路径下的文件和目录信息</td></tr><tr><td style="text-align:center">mkdir(path[,mode])</td><td>创建目录</td></tr><tr><td style="text-align:center">makedirs(path1/path2/path3…[,mode])</td><td>创建多级目录</td></tr><tr><td style="text-align:center">rmdir(path)</td><td>删除目录</td></tr><tr><td style="text-align:center">remove(path1/path2)</td><td>删除多级目录</td></tr><tr><td style="text-align:center">chdir(path)</td><td>把 path 设置为当前工作目录</td></tr><tr><td style="text-align:center">walk(top[,topdown[,onerror]])</td><td>遍历目录树，该方法返回一个元组，包括所有的路径、所有目录列表和文件列表三个元素</td></tr></tbody></table></div><p>os.path 模块提供一些操作目录的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">abspath(path)</td><td>用于获取文件或目录的绝对路径</td></tr><tr><td style="text-align:center">exists(path)</td><td>用于判断目录或文件是否存在，如果存在则返回 Ture；反之，返回 False</td></tr><tr><td style="text-align:center">join(path,name)</td><td>将目录与目录或文件名拼接起来</td></tr><tr><td style="text-align:center">splitext()</td><td>分离文件名或扩展名</td></tr><tr><td style="text-align:center">basename(path)</td><td>从一个目录中提取文件名</td></tr><tr><td style="text-align:center">dirname(path)</td><td>从一个路径中提取文件，不包括文件名</td></tr><tr><td style="text-align:center">isdir(path)</td><td>用于判断是否为有效路径</td></tr></tbody></table></div><h3 id="12-2-2-路径"><a href="#12-2-2-路径" class="headerlink" title="12.2.2 路径"></a>12.2.2 路径</h3><ol><li><p>相对路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.getcwd()) <span class="comment"># 输出当前目录</span></span><br></pre></td></tr></table></figure></li><li><p>绝对路径</p><p> 获取某文件的绝对路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.abspath(path)</span><br></pre></td></tr></table></figure></li><li><p>拼接路径</p><p>如果想要将两个或者多个路径拼接在一起，组成一个新的路径，可以使用 <code>os.path</code> 模块的 <code>join()</code> 函数实现。具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.join(path1,path2,path3...)</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-2-3-判断目录是否存在"><a href="#12-2-3-判断目录是否存在" class="headerlink" title="12.2.3 判断目录是否存在"></a>12.2.3 判断目录是否存在</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(path)</span><br></pre></td></tr></table></figure><h3 id="12-2-4-创建目录"><a href="#12-2-4-创建目录" class="headerlink" title="12.2.4 创建目录"></a>12.2.4 创建目录</h3><ol><li><p>创建一级目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.mkdir(path,mode=<span class="number">0o777</span>)</span><br></pre></td></tr></table></figure><p> 参数说明：</p><ul><li>path：用于指定要创建的目录，可以使用绝对路径或相对路径</li><li>mode：用于指定数值模式，默认为 0777。该参数在非 <code>UNIX</code> 系统上无效</li></ul></li><li><p>创建多级目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(name,mode=<span class="number">0o777</span>)</span><br></pre></td></tr></table></figure><p> 参数说明：</p><ul><li>name：用于指定要创建的目录，可以使用绝对路径或相对路径</li><li>mode：用于指定数值模式，默认为 0777。该参数在非 <code>UNIX</code> 系统上无效</li></ul></li></ol><h3 id="12-2-5-删除目录"><a href="#12-2-5-删除目录" class="headerlink" title="12.2.5 删除目录"></a>12.2.5 删除目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rmdir(path)</span><br></pre></td></tr></table></figure><h3 id="12-2-6-遍历目录"><a href="#12-2-6-遍历目录" class="headerlink" title="12.2.6 遍历目录"></a>12.2.6 遍历目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.walk(top,topdown,oneerro,followlinks)</span><br></pre></td></tr></table></figure><h2 id="12-3-高级文件操作"><a href="#12-3-高级文件操作" class="headerlink" title="12.3 高级文件操作"></a>12.3 高级文件操作</h2><p>Python 内置的 os 模块除了可以对目录进行操作，还可以对文件进行一些高级操作，具体函数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">access(path,accessmode)</td><td>获取对文件是否有指定的访问权限</td></tr><tr><td style="text-align:center">chmod(path,mode)</td><td>修改 path 指定文件的访问权限</td></tr><tr><td style="text-align:center">remove(path)</td><td>删除 path 指定的文件路径</td></tr><tr><td style="text-align:center">rename(src,dst)</td><td>将文件或目录 src 重命名为 dst</td></tr><tr><td style="text-align:center">stat(path)</td><td>返回 path 指定的文件信息</td></tr><tr><td style="text-align:center">startfile(path[,operation])</td><td>使用关联的应用程序打开 path 指定的文件</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> Web开发 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 数据可视化 </tag>
            
            <tag> 自动化运维开发 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxxxx</title>
      <link href="/Hexo/demo.html"/>
      <url>/Hexo/demo.html</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>[TOC]</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>标题样式来自<a href="https://github.com/Theigrams/My-Typora-Themes" title="本样式修改自zj主题（这是一个链接引用）">zj 主题</a>^<a href="https://github.com/Theigrams/My-Typora-Themes" title="本样式修改自zj主题（这是一个链接引用）">1</a>^（这是一个参考链接，按住<kbd>ctrl</kbd>键并点击将自动打开浏览器并跳转至相关链接，其中上标<code>[1]</code>只是一个额外的标注）</p><p>注：部分样式需要在偏好设置中开启，如上下标、行内公式、图表等。Markdown 写法参考说明文档<sup><a href="https://support.typora.io/Markdown-Reference" alt="ref">🚀</a></sup>，试用其他如印象等在线 Markdown 编辑器<span alt="ref">[<a href="https://www.zybuluo.com/mdeditor">Ref 1</a>,<a href="https://maxiang.io/">Ref 2</a>,<a href="https://editoe.com/">Ref 3</a>,<a href="https://b3log.org/vditor">Ref 4</a>]</span></p><p>行内公式：$\lim\limits_{x \to \infty} \exp(-x)=0$，行间公式：</p><script type="math/tex; mode=display">E_0 = mc^2 \\\quad\text{—— Albert Einstein}</script><p>推荐：<a href="http://draw.mathpix.com/">latex 手写公式识别</a>、<a href="https://www.latexlive.com/">latex 公式编辑器</a></p><p>可以直接用尖括号包裹 URL 链接或邮箱：<a href="https://emojixd.com/">https://emojixd.com/</a></p><blockquote><p>提示块标签</p><blockquote><p>嵌套提示块</p></blockquote></blockquote><p>其他型号提示块：</p><blockquote alt="success"><p>成功型提示块</p></blockquote><blockquote alt="question"><p>问题型提示块</p></blockquote><blockquote alt="warn"><p>警告型提示块</p></blockquote><blockquote alt="danger"><p>危险型提示块</p></blockquote><ul><li><p>无序列表 1</p></li><li><p>无序列表 2</p></li></ul><ol><li>有序列表 1<sup><a href="#fn_1" id="reffn_1">1</a></sup></li><li>有序列表 2</li></ol><p>==文本高亮==，<strong>加粗</strong>，_斜体_，==<strong>_斜体高亮加粗_</strong>==，<del>删除线</del>，<u>下划线</u>。<code>&lt;font&gt;</code>标签被我用于一款小标签样式（<a href="https://www.antmoe.com/posts/3b43914f/">小康</a>）：<font>红色小标签</font>，可以通过设置<code>background-color</code>属性控制背景色，如：<font style="background-color:#8bc34a">绿色小标签</font>，为了方便，我提供了五种预定义的颜色（包括前面的红色、<span alt="glow">绿色</span>）：<font title="blue">蓝色小标签</font>、<font title="yellow">黄色小标签</font>、<font title="gray">灰色小标签</font>。一些强调型格式：<span alt="underline">下划线</span>、<span alt="emp">着重号</span>、<span alt="wavy">波浪线</span>。其他：<span alt="hide">隐藏文本</span>，<span alt="hollow">空心字</span>，<span alt="blink">字体闪烁</span></p><p><span alt="rainbow">彩虹变换字体特效</span>（嫖自<a href="https://www.heson10.com/posts/21347.html">黑石大佬</a>🙇‍♀️），<span alt="modern">欢迎光临</span>（嫖自<a href="https://7bxing.com/friends/">QinXS</a>🙇‍♀️），<span alt="shake">抖音字效</span>（嫖自<a href="https://www.nykee.cn/">NyKee</a>🙇‍♀️）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ 新增行</span></span><br><span class="line"><span class="deletion">- 删除行</span></span><br><span class="line">其他行</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">表头 1</th><th style="text-align:center">表头 2</th><th style="text-align:right">表头 3</th></tr></thead><tbody><tr><td style="text-align:left">muggledy</td><td style="text-align:center">celestezj</td><td style="text-align:right">2021.9.25</td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td></tr></tbody></table></div><p>提供另一种常见表格样式：</p><div alt="three-table"> <!--alt还可取值为"notitle-table"，一种无表头的小型表格--><table>  <tr>    <th alt="left">标题1</th>    <th alt="center">标题2</th>    <th alt="right">标题3</th>  </tr>  <tr>    <td alt="left">居左：alt="left"</td>    <td alt="center">居中：alt="center"</td>    <td alt="right">居右：alt="right"</td>  </tr>  <tr>    <td alt="left">x</td>    <td alt="center">y</td>    <td alt="right">z</td>  </tr></table></div><div alt="fig">表1.&nbsp;&nbsp;&nbsp;&nbsp;三线表</div><p><a href="#二级标题">跳转</a>至指定标题（锚点），也可以在任意位置通过<code>&lt;a name=&quot;锚点名&quot; alt=&quot;none&quot;&gt; &lt;/a&gt;</code>（为了方便编辑，typora 会显示空标签或<code>style=&quot;display:none&quot;</code>的标签，但填充一个空格就可以被隐藏，在导出为 HTML 文件时，由于该款超链接样式有一个 padding 宽度，所以空链接还是会显示下划线，<code>alt=&quot;none&quot;</code>用于避免该问题，如果自定义的锚点有文字说明，则不要使用<code>alt=&quot;none&quot;</code>）设定锚点，示例：<a href="#star">求点个赞呗</a></p><p><a href="#" alt="null">无样式链接</a>，主要用于图片超链接等，如：<a href="#" alt="null"><img src="https://img.shields.io/badge/-GitHub-181717?style=flat-square&logo=github"><img src="https://img.shields.io/badge/-Git-F05032?style=flat-square&logo=git&logoColor=white"></a>（行内图片）</p><p>上下标：X^2^, H~2~o，下标如果是多个单词或字符并以空格分隔，需要对空格进行转义，即在空格前面加<code>\</code>，譬如<code>X~下标1\ 下标2~</code>（X~下标 1\ 下标 2~）。要显示*特殊字符等，也是通过反斜杠转义</p><p><ruby>Base<rp> (</rp><rt>top</rt><rp>) </rp></ruby>、<ruby>佐天泪子<rp> (</rp><rt>xiān qún kuáng mó</rt><rp>) </rp></ruby>、<ruby>超電磁砲<rp> (</rp><rt>レールガン</rt><rp>) </rp></ruby></p><p><img src="./temp/demo.jpg" style="zoom: 67%;" alt="shadow-可惜默认不支持图释" /></p><p>注：按<code>![shadow-随便写]()</code>（或<code>&lt;img src=&quot;...&quot; alt=&quot;shadow-随便写&quot;&gt;</code>）插入图片时会显示阴影，否则没有，类似的，设为<code>alt=&quot;blur-随便写&quot;</code>时会有模糊效果，设为<code>alt=&quot;gray-随便写&quot;</code>时图片默认为暗灰色。右键图片可以进行指定比例的缩放，任意比例可以通过<code>style=&quot;zoom:0.x&quot;</code>属性实现</p><p>目前会对图片自动编号，但要正确显示图释（<code>alt</code>属性值），还需额外修改<u>frame.js</u>源码（在安装路径<span alt="str">Typora/resources/app/app/window/</span>下），分别定位到<code>h=&quot;&lt;span md-inline=&#39;&quot;+v+&quot;&#39;&quot;+S+&quot; contenteditable=&#39;false&#39; class=&#39;md-image&quot;+L+&quot;&#39; data-src=&#39;&quot;+F+&quot;&#39; &quot;+b+&quot;&gt;</code>以及<code>h=&quot;&lt;span md-inline=&#39;&quot;+v+&quot;&#39;&quot;+S+&quot; contenteditable=&#39;false&#39; class=&#39;md-image md-img-loaded&quot;+w+&quot;&#39; &quot;+b+&quot;&gt;</code>处（适用于 Typora v0.9.98，注意版本不同，相关代码可能稍有区别），将两处末尾的<code>&quot;&gt;</code>都替换为以下字符串即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; alt=&#x27;&quot;</span>+ (k.<span class="title function_">getAttribute</span>(<span class="string">&quot;alt&quot;</span>) ? <span class="string">&quot;. &quot;</span>+(<span class="regexp">/^(shadow-|blur-|gray-)?(.*)$/</span>.<span class="title function_">exec</span>(k.<span class="title function_">getAttribute</span>(<span class="string">&quot;alt&quot;</span>))[<span class="number">2</span>]) : <span class="string">&quot;&quot;</span>) +<span class="string">&quot;&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>Typora v1.4.7：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&quot;&lt;span md-inline=&#x27;&quot;</span>+g+<span class="string">&quot;&#x27;&quot;</span>+S+<span class="string">&quot; contenteditable=&#x27;false&#x27; class=&#x27;md-image&quot;</span>+L+<span class="string">&quot;&#x27; data-src=&#x27;&quot;</span>+k+<span class="string">&quot;&#x27; &quot;</span>+b+<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">s=&quot;</span>&lt;span md-inline=<span class="string">&#x27;&quot;+g+&quot;&#x27;</span><span class="string">&quot;+S+&quot;</span> contenteditable=<span class="string">&#x27;false&#x27;</span> <span class="keyword">class</span>=<span class="string">&#x27;md-image md-img-loaded&quot;+w+&quot;&#x27;</span> <span class="string">&quot;+b+&quot;</span>&gt;</span><br><span class="line"><span class="comment">//替换为：</span></span><br><span class="line"><span class="string">&quot; alt=&#x27;&quot;</span>+ (F.<span class="title function_">getAttribute</span>(<span class="string">&quot;alt&quot;</span>) ? <span class="string">&quot;. &quot;</span>+(<span class="regexp">/^(shadow-|blur-|gray-)?(.*)$/</span>.<span class="title function_">exec</span>(F.<span class="title function_">getAttribute</span>(<span class="string">&quot;alt&quot;</span>))[<span class="number">2</span>]) : <span class="string">&quot;&quot;</span>) +<span class="string">&quot;&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>或者直接在图片下方手动写图释（适用于非 img 标签）：<code>&lt;div alt=&quot;fig&quot;&gt;图释说明&lt;/div&gt;</code></p><blockquote><p>Typora 导出的 HTML 文件，图片不显示注释及阴影等特效，部分样式地址为<span alt="str">file://</span>本地文件，一旦将 HTML 文件拷贝到其他计算机，就会显示异常，这些问题可以通过脚本修复，执行<code>python export_html_help.py &lt;HTML文件&gt;</code>，这会在 HTML 文件所在目录下生成一个<span alt="str">.temp/</span>文件夹，其中是<span alt="str">file://</span>本地文件的拷贝，为方便，可考虑将引用的资源（图片、视频等）文件均放在此目录下，当然，也可以通过<code>--output</code>参数更改默认的<span alt="str">.temp</span>名字</p></blockquote><audio controls="controls">  <source src="./temp/The Sound Of Silence.mp3" type="audio/mp3" /></audio><blockquote><p>可以将<code>&lt;audio&gt;</code>音频包裹在<code>&lt;center&gt;&lt;/center&gt;</code>中居中显示</p></blockquote><p>插入网易云的外链播放器（<code>&lt;iframe&gt;</code>，可嵌入油管等平台视频）：</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" src="//music.163.com/outchain/player?type=2&id=1342183925&auto=0"></iframe><video src="./temp/难破船.mp4"></video><details>    <summary>折叠标签</summary>    青青子衿，悠悠我心</details><blockquote><p>关于 Typora 对 HTML 的支持说明：<a href="https://support.typora.io/HTML/">https://support.typora.io/HTML/</a></p></blockquote><p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji 表情符号</a>：:smile:（<code>:smile:</code>），Decimal NCRs 或 Hexadecimal NCRs^<a href="https://www.ifreesite.com/unicode/" title="Unicode图标编码在线转换">2</a>^编码也是受支持的，譬如“&#31505;&#21741;”：&#128514;（<code>&amp;#128514;</code>）或&#x1F602;（<code>&amp;#x1F602;</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Pie Chart</span><br><span class="line">    &quot;Dogs&quot; : 386</span><br><span class="line">    &quot;Cats&quot; : 85</span><br><span class="line">    &quot;Rats&quot; : 150</span><br></pre></td></tr></table></figure><p><a href="https://mermaid.live/edit">在线 Mermaid 编辑器</a>、<a href="https://mubu.com/home">幕布脑图</a>（MD 文档以 OPML 格式导出然后借助幕布转换为思维脑图）</p><blockquote><p>更多绘图参考<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/" title="Typora流程图绘制说明">官方文档</a>（这是另一种参考链接写法）</p></blockquote><center><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" height="400px" viewBox="-0.5 -0.5 1071 773" content="&lt;mxfile host=&quot;app.diagrams.net&quot; modified=&quot;2021-11-15T07:08:52.373Z&quot; agent=&quot;5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&quot; etag=&quot;aOnjZZMrixLFimZz001-&quot; version=&quot;15.7.3&quot; type=&quot;google&quot;&gt;&lt;diagram id=&quot;07fea595-8f29-1299-0266-81d95cde20df&quot; name=&quot;Page-1&quot;&gt;7Zpdk5o8FMc/jZfrkDeEy3Xdtjed6cx25rnOIylmisbGuGI/fQMEAZN1sY2uW+qNchKS8P9xPOcERuhhmX+UdL34LBKWjWCQ5CM0G0F4F4NQfxWWvbGEpDKkkieVCTSGJ/6TGWNgrFuesE2noxIiU3zdNc7FasXmqmOjUopdt9s3kXVnXdOUWYanOc1s6388UQtjBWHcNHxiPF2YqSM4qRr+p/PvqRTblZlvJVasalnSehhzjZsFTcSuZUKPI/QghVDVr2X+wLJC1lqx6rwPL7QelizZSvU5YQJRdcozzbbmus3K1L4WYrfgij2t6bw43mnYIzT9xrPsQWRCll0QgPf3U6LtqaQJ15PXbeW1N+YZlxoVFyvdxOhGr3G6UVJ8Z0f9F2qZ6SNQzCSa0fRMEGFM9Oqn9qWaq39mUrG8ZTKX/pGJJVNyr7uYVojjydjclOYmBTjEYxI0HyPHrnUH1PAWLfgAGSM1d116mK2RX/8wBF6igYdMI7RpEIxr02sESDAO2tyQDx5kyDwih3fEvXmAwItHhAMmgAIHAdifwMQLgcnrBFiiI6c5fFWhyj8PytaxFVlat/u+qGYx9Ukt2yoFp+5TyTKq+HM3+rukM3N8EVyvpRVMkP331bhLPdBGbOWcmXPbkbnHcABYwykqU6as4UqqBxF6go68uNqHIJoE787VXKkAQm+ZCsReaDxGJMTwb6ABgy6Nvn+CXmjUgwzTNxyJGYrwGMfNJ+pJg8TjuH2ajywNAS9w3qmruOCQ3jmCH++AQ/YOR5pcRo6eHhF6IeCnjH+nLuAgAPq7AIi8EOhRuv9Lk72nyQiRPsN5TJORvSfwhUqqh2CyXNcxdX0Xlw6iPY+v0q9C+93sjtjszQ4oiOpjM0TBdV2svLwWMh2R2Uv+5sGZEAptQSPocKbIcZdAL65k1/w56C8rzXha/DHNtQgaCZoWF8/nNLs3DUueJMUolsongFwPgCv3JXF43YBu1/y5/Xf21xJwbURem4BdjOdoOAQcEf3qBPwU4O905xFaYTV2bv0i0tl1BwC7cHR35usdxT/Cg4dckZd42uX3ESrSLc7jG8I25Frd5VXAk1cd+vwZHruS/7pfM205IwFriWmHjHZQIb5ktaJFDOLOZiGwJL5Y9ortUtxIeEYGdQsSkreT0K6ljYRnpEC3IGH8dhKerlL3v6XjuVWqh0QQ2YlgEJFrVqPYrkb3t1aN+qg6A3Is9OuvwiDXRhHsbvFPvKQNdkG6v7WC9DIQ3FvJ1xPerkP3t1aHXkb48nnjGwrvKj/DTBk9OvqHP7aibrjblErdF8EyWOdlbKvb9a+0+J5xqhPkpe6iuNJjmHH1mqqhq14Xo1yhRMERdXA6aPugbG09R87HBBFwUMbEA1Uy6KrV8ToTmpzxgp8PAIOuPx0AYNj/QRnwQsAuMXN8YxHlgo9XHAguu7OpD5v3yasHXs37+ujxFw==&lt;/diagram&gt;&lt;/mxfile&gt;" onclick="(function(svg){var src=window.event.target||window.event.srcElement;while (src!=null&amp;&amp;src.nodeName.toLowerCase()!='a'){src=src.parentNode;}if(src==null){if(svg.wnd!=null&amp;&amp;!svg.wnd.closed){svg.wnd.focus();}else{var r=function(evt){if(evt.data=='ready'&amp;&amp;evt.source==svg.wnd){svg.wnd.postMessage(decodeURIComponent(svg.getAttribute('content')),'*');window.removeEventListener('message',r);}};window.addEventListener('message',r);svg.wnd=window.open('https://viewer.diagrams.net/?client=1&amp;page=0&amp;edit=_blank');}}})(this);" style="cursor:pointer;max-width:100%;max-height:773px;"><defs/><g><rect x="100.5" y="610.5" width="120" height="130" fill="#12aab5" stroke="none" pointer-events="all"/><rect x="300.5" y="690.5" width="120" height="50" fill="#12aab5" stroke="none" pointer-events="all"/><rect x="500.5" y="640.5" width="120" height="100" fill="#12aab5" stroke="none" pointer-events="all"/><rect x="700.5" y="570.5" width="120" height="170" fill="#12aab5" stroke="none" pointer-events="all"/><path d="M 40.5 740.5 L 40.5 270.6" fill="none" stroke="#000000" stroke-width="3" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 40.5 263.85 L 45 272.85 L 40.5 270.6 L 36 272.85 Z" fill="#000000" stroke="#000000" stroke-width="3" stroke-miterlimit="10" pointer-events="all"/><rect x="100.5" y="480.5" width="120" height="130" fill="#f08705" stroke="none" pointer-events="all"/><rect x="100.5" y="350.5" width="120" height="130" fill="#e85642" stroke="none" pointer-events="all"/><rect x="300.5" y="530.5" width="120" height="160" fill="#f08705" stroke="none" pointer-events="all"/><rect x="300.5" y="500.5" width="120" height="30" fill="#e85642" stroke="none" pointer-events="all"/><rect x="500.5" y="480.5" width="120" height="160" fill="#f08705" stroke="none" pointer-events="all"/><rect x="500.5" y="300.5" width="120" height="180" fill="#e85642" stroke="none" pointer-events="all"/><path d="M 40.5 740.5 L 950.4 740.5" fill="none" stroke="#000000" stroke-width="3" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 957.15 740.5 L 948.15 745 L 950.4 740.5 L 948.15 736 Z" fill="#000000" stroke="#000000" stroke-width="3" stroke-miterlimit="10" pointer-events="all"/><rect x="970.5" y="728.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 731px; margin-left: 973px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Parameter x</div></div></div></foreignObject><text x="973" y="749" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px">Parameter...</text></switch></g><rect x="100.5" y="742.5" width="120" height="30" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 755px; margin-left: 161px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">x1</div></div></div></foreignObject><text x="161" y="760" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px" text-anchor="middle">x1</text></switch></g><rect x="300.5" y="742.5" width="120" height="30" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 755px; margin-left: 361px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">x2</div></div></div></foreignObject><text x="361" y="760" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px" text-anchor="middle">x2</text></switch></g><rect x="500.5" y="742.5" width="120" height="30" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 755px; margin-left: 561px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">x3</div></div></div></foreignObject><text x="561" y="760" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px" text-anchor="middle">x3</text></switch></g><rect x="860.5" y="140.5" width="35" height="30" fill="#12aab5" stroke="none" pointer-events="all"/><rect x="860.5" y="100.5" width="35" height="30" fill="#f08705" stroke="none" pointer-events="all"/><rect x="860.5" y="60.5" width="35" height="30" fill="#e85642" stroke="none" pointer-events="all"/><rect x="900.5" y="65.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 68px; margin-left: 903px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="display: inline-block; font-size: 15px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Type 1</div></div></div></foreignObject><text x="903" y="83" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="15px">Type 1</text></switch></g><rect x="900.5" y="105.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 108px; margin-left: 903px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="display: inline-block; font-size: 15px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Type 2</div></div></div></foreignObject><text x="903" y="123" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="15px">Type 2</text></switch></g><rect x="900.5" y="145.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 148px; margin-left: 903px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="display: inline-block; font-size: 15px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Type 3</div></div></div></foreignObject><text x="903" y="163" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="15px">Type 3</text></switch></g><rect x="0.5" y="231.5" width="80" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe flex-start; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 234px; margin-left: 3px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: left;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">Parameter y</div></div></div></foreignObject><text x="3" y="252" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px">Parameter...</text></switch></g><rect x="8.5" y="610.5" width="30" height="130" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 673px; margin-left: 24px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">y1</div></div></div></foreignObject><text x="24" y="678" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px" text-anchor="middle">y1</text></switch></g><rect x="8.5" y="480.5" width="30" height="130" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 543px; margin-left: 24px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">y2</div></div></div></foreignObject><text x="24" y="548" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px" text-anchor="middle">y2</text></switch></g><rect x="8.5" y="350.5" width="30" height="130" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 413px; margin-left: 24px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">y3</div></div></div></foreignObject><text x="24" y="418" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px" text-anchor="middle">y3</text></switch></g><rect x="40.5" y="0.5" width="810" height="45" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 21px; margin-left: 446px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 30px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; font-weight: bold; white-space: nowrap;"><font style="font-size: 30px">Diagram title</font></div></div></div></foreignObject><text x="446" y="30" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="30px" text-anchor="middle" font-weight="bold">Diagram title</text></switch></g><rect x="700.5" y="520.5" width="120" height="50" fill="#f08705" stroke="none" pointer-events="all"/><rect x="700.5" y="410.5" width="120" height="110" fill="#e85642" stroke="none" pointer-events="all"/><rect x="700.5" y="742.5" width="120" height="30" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 755px; margin-left: 761px;"><div data-drawio-colors="color: rgba(0, 0, 0, 1); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 18px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">x4</div></div></div></foreignObject><text x="761" y="760" fill="rgba(0, 0, 0, 1)" font-family="Helvetica" font-size="18px" text-anchor="middle">x4</text></switch></g></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://www.diagrams.net/doc/faq/svg-export-text-problems" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Viewer does not support full SVG 1.1</text></a></switch></svg></center><div alt="fig">图2.&nbsp;&nbsp;&nbsp;&nbsp;柱状图</div><p><a href="https://app.diagrams.net/?src=about#G1XbVy9iD3kEJMiCqG2IceUlNBIzMbcJYS">在线编辑地址</a>，该图表由<a href="https://www.diagrams.net/">drawio</a>提供支持（提供 iframe 嵌入代码和 svg 嵌入代码），还支持 UML 类图、Network 网络拓扑图、Flowcharts 流程图、Tables 表格等众多图表类型</p><p>时间轴（Volantis）：</p><div alt="timeline">    <div alt="timenode">        <div alt="meta">2019.9 ~ 2022.6 <a href="#">家里蹲B</a></div>        <div alt="body">            人言落日是天涯，望极天涯不见家。            已恨碧山相阻隔，碧山还被暮云遮。        </div>    </div>    <div alt="timenode">        <div alt="meta">2015.9 ~ 2019.6 <a href="#">家里蹲A</a></div>        <div alt="body">            看花开花落，谈笑风生...        </div>    </div></div><p>任务列表：</p><ul><li>[ ] 未完成任务 1</li><li>[ ] 未完成任务 2</li><li>[x] 已完成任务 1</li><li>[x] 已完成任务 2</li></ul><blockquote><p>本主题（typora-dyzj-theme）的很多样式来自 Hexo 的<span alt="btn"><a href="https://butterfly.js.org">butterfly</a></span>及<span alt="btn"><a href="https://volantis.js.org/">Volantis</a></span>主题，再次表达感谢 🙇‍♀️</p></blockquote><hr><p><a name="star" alt="none"> </a>都看到这里了，如果您喜欢的话，点个赞:+1:再走吧：</p><iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px" height="20px" src="https://ghbtns.com/github-btn.html?user=muggledy&repo=typora-dyzj-theme&type=star&count=true" > </iframe><blockquote id="fn_1"><sup>1</sup>. 该样式来自<a href="https://butterfly.js.org">Butterfly 主题</a>（这是一个脚注）<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> xxxx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxxx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
