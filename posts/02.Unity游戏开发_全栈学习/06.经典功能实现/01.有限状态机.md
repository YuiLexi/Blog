---
title: 有限状态机【Unity】
date: 2024/01/04 00:00:11
updated: 

categories: [Unity, 经典功能实现]
tags: [Unity, Csharp, 有限状态机, 游戏开发]
keywords: 
description: 

mathjax: 
katex: 

imghost_path: Blog/Post/02.Unity游戏开发_全栈学习/06.经典功能实现/01.有限状态机.md/

top_img: 
comments: 
cover: https://imagehost.yuilexi.cn/Blog/Post/02.Unity游戏开发_全栈学习/06.经典功能实现/01.有限状态机.md/Cover.png

toc: 
toc_number: 
toc_style_simple: 
copyright: 
copyright_author: 
copyright_author_href: 
copyright_url: 
copyright_info: 
aplayer: 
highlight_shrink: 
aside: 
---

# 什么是有限状态机

有限状态机(Finite state machine)是非常重要的一个概念，是一种用来进行对象行为建模的工具，其作用主要是**描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件**。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。其实，有限状态机的概念和应用遍布生活中的每一个角落。

有限状态机有两个主要特征：状态是有限的，同一时刻只能存在一种状态；一般归为4个要素，即：现态、条件、动作、次态。“现态”和“条件”是原因，“动作”和“次态”是结果。详解如下：

1. 现态：是指当前所处的状态；

2. 条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移；

3. 动作：条件满足后执行的动作。

    动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态；

4. 次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。

# Unity中实现FSM

## 1 框架结构

![FSM框图](https://imagehost.yuilexi.cn/Blog/Post/02.Unity游戏开发_全栈学习/06.经典功能实现/01.有限状态机.md/FSM框图.svg)

## 2 代码结构

首先，定义一个接口：`IState`，该结构声明三个状态的基础方法：进入状态`OnEnterState`、更新状态`OnUpdateState`、退出状态`OnExitState`。

~~~c#
interface IState
{
    /// <summary>
    /// 进入状态
    /// </summary>
    void OnEnterState();
    /// <summary>
    /// 更新状态
    /// </summary>
    void OnUpdateState();
    /// <summary>
    /// 退出状态
    /// </summary>
    void OnExitState();
}
~~~

所有状态都要继承该接口，例如：

~~~c#
public class State1 : IState
{
    void OnEnterState()
    {
        // 代码;
    }
    void OnUpdateState()
    {
        // 代码;
    }
    void OnExitState()
    {
        // 代码;
    }
}

public class State2 : IState
{
    void OnEnterState()
    {
        // 代码;
    }
    void OnUpdateState()
    {
        // 代码;
    }
    void OnExitState()
    {
        // 代码;
    }
}

// ......
~~~

然后构造一个FSM的抽象父类，需要继承自`MonoBehaviour`，里面包含**当前状态字段**、**状态切换方法**，代码如下：

~~~c#
using UnityEngine;

public abstract class FSM<T> : MonoBehaviour where T : struct
{
    [SerializeField] protected IState _currentState;
    protected Dictionary<T, IState> _stateDic = new Dictionary<T, IState>();

    /// <summary>
    /// 初始化状态机
    /// </summary>
    protected abstract void Awake();
    
    /// <summary>
    /// 初始化状态机的状态
    /// </summary>
    protected abstract void Start();
    
    /// <summary>
    /// 更新状态机
    /// </summary>
    protected virtual void Update()
    {
        if (_currentState != null)
        {
            _currentState.OnUpdateState();
        }
    }

    /// <summary>
    /// 状态切换
    /// </summary>
    /// <param name="stateType"></param>
    /// <exception cref="Exception"></exception>
    public virtual void TransitionState(T stateType)
    {
        if (_currentState != null)
        {
            _currentState.OnExitState();
        }

        _currentState = _stateDic.TryGetValue(stateType);
        if (_currentState == null)
        {
            throw new Exception($"状态机中没有找到对应的状态：{stateType}");
        }
        _currentState.OnEnterState();
    }
}
~~~

上面的FSM类使用了泛型，泛型参数是不同对象的状态枚举类型，例如：玩家有Idle、Move、Attack等状态，将这些状态定义为枚举变量，即为FSM抽象父类的泛型参数。使用抽象泛型的目的是为了，是不同的对象可以有不同的状态机来控制，不同对象的状态条件不同，但是状态的切换和更新功能是一致的，

FSM类里面有两个字段：

- `_currentState` ：存放当前对象的当前状态；
- `_stateDic`：存放当前对象的所有状态类型，并且以状态枚举值作为字典的键，以状态对象作为字典的值。

FSM还要构造出抽象的 `Awake()` 与 `Start()` 函数，其目的是为继承的子类去初始化状态机，特别向字典中添加所有的状态类型。

FSM里面还包括两个虚函数 `Update()` 和 `TransitionState(T stateType)` ，前者是状态更新函数，后者是状态切换函数，使用虚函数，便于子类进行多态扩展。



## 3 具体实现

根据上述提供的状态接口和FSM父类，实现一个具体对象的状态：

1.玩家的状态枚举：

~~~c#
// 玩家的状态枚举
public enum PlayerStateEnum
{
    None = 0, // 无状态
    Idle = 1, // 空闲
    Move = 2, // 移动状态
    Attack = 3, // 攻击状态
    Hurt = 4, // 受伤状态
    Dead = 5, // 死亡状态
}
~~~

2.玩家的所有状态：

~~~c#

// 空闲状态
public class IdleState : IState
{
    private PlayerFSM _fsm; // 对该状态对象所在状态机对象的引用
    public IdleState(PlayerFSM fsm)
    {
        _fsm = fsm;
    }
    public IdleState()
    {
        Debug.Log("创建Idle状态");
    }
    public void OnEnterState()
    {
        Debug.Log("进入Idle状态");
    }

    public void OnUpdateState()
    {
    }
    public void OnExitState()
    {
        Debug.Log("退出Idle状态");
    }
}

// 攻击状态
public class AttackState : IState
{
    private PlayerFSM _fsm;
    public AttackState(PlayerFSM fsm)
    {
        _fsm = fsm;
    }
    public void OnEnterState()
    {
        Debug.Log("进入Attack状态");
    }

    public void OnUpdateState() { }

    public void OnExitState()
    {
        Debug.Log("退出Attack状态");
    }
}

// 其他状态......
// ......
~~~

3.玩家的FSM

~~~c#
using UnityEngine;
using UnityEngine.InputSystem; // 引入Unity的InputSystem命名空间

public class PlayerFSM : FSM<PlayerStateEnum>
{
    [SerializeField] private PlayerProperty _playerProperty; // 玩家属性
    private Vector2 _moveDirection; // 移动方向
    public Vector2 MoveDirection => _moveDirection; // 移动方向
    protected override void Awake()
    {
        _stateDic.Add(PlayerStateEnum.Idle, new IdleState(this));
        _stateDic.Add(PlayerStateEnum.Move, new MoveState(this));
        _stateDic.Add(PlayerStateEnum.Attack, new AttackState(this));
        _stateDic.Add(PlayerStateEnum.Hurt, new HurtState(this));
        _stateDic.Add(PlayerStateEnum.Dead, new DeadState(this));

    }
    protected override void Start()
    {
        TransitionState(PlayerStateEnum.Idle);
    }
    
    // 玩家移动状态切换
    public void OnMove(InputAction.CallbackContext context)
    {
        _moveDirection = context.ReadValue<Vector2>();
        if (context.performed)
        {
            TransitionState(PlayerStateEnum.Move);
        }
        else if (context.canceled)
        {
            TransitionState(PlayerStateEnum.Idle);
        }
    }

    public void OnAttack(InputAction.CallbackContext context)
    {
        if (context.performed)
        {
            TransitionState(PlayerStateEnum.Attack);
        }
        else if (context.canceled)
        {
            if (_moveDirection != Vector2.zero)
            {
                TransitionState(PlayerStateEnum.Move);
            }
            else
            {
                TransitionState(PlayerStateEnum.Idle);
            }
        }
    }

    public void OnHurt(InputAction.CallbackContext context)
    {
        if (context.performed)
        {
            TransitionState(PlayerStateEnum.Hurt);
        }
    }
}
~~~



## 4 扩展

根据上面的结构，就可以在具体的状态中，调整玩家的各项属性和行为，建议将玩家的属性和各种组件放在FSM中，便于不用的状态进行引用修改。

