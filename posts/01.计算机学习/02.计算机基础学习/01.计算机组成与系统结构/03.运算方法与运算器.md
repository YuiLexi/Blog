---
title: 第三章 运算方法与运算器【计算机组成与系统结构】
date: 2023-9-5:00:00:03
categories:
  - [大学学习, 考研]
  - [计算机学习，计算机组成，计算机系统结构]
tags: [计算机学习, 大学学习, 考研, 计算机组成, 计算机系统结构]
description: 了解计算机体系结构和基本工作原理。
mathjax: true
katex: true
image_path: 计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/
---

# 前言

# 一、定点数运算

## 1.1 加法运算

有符号定点数的编码可以用**原码**、**反码**、**补码**、**移码**等形式表示。实际中用得最多、最普遍的是**补码**。**补码加减运算过程中，参加运算的操作数及运算结果均用补码表示**。

### 1.1.1 补码加减法

补码加法的运算法则为：
$$
\displaystyle \left [ X +  Y\right ] _{\text{补码} } =\left [ X \right ] _{\text{补码} } +\left [ Y \right ] _{\text{补码} } 
$$
**两数和的补码就等于两数补码之和**。



> 在数值的补码表示法中，**对一个正数求补：对该数包括符号位在内的各位取反再加1，即可得到该数的负数**；若对该负数再求补，则又可得到原来的正数。
>
> 补码减法的运算法则为：
> $$
> \displaystyle\left [  \left [ X \right ] _{\text{补码} }  \right ] _{\text{求补} }= \left [ -X \right ] _{\text{补码} }
> $$

综上所述，补码加减运算的规则是：

1. 参加运算的操作数用补码表示；
2. 符号位参加运算；
3. 若相加，则两个数的补码直接相加；若相减，则将减数连同符号位一起取反加1后，与被减数相加；
4. 运算结果为补码表示。

### 1.1.2 溢出判断

溢出的概念：**运算结果超出规定的数值范围，而造成错误的现象称为溢出**。发生溢出时，运算结果一定是错误的，所以必须采取措施防止溢出。

> 只有当同号相加或者异号相减时，运算结果才有可能溢出。



**溢出的判定**😨😨😨😨

1. **双符号位（变形码）判决法**（双符号位）

    如果运算结果的两符号分别用 $\displaystyle S_{2} S_{1} $ 表示，则溢出的标志 $\displaystyle OF$ 的逻辑表达式为：
    $$
    \displaystyle OF= S_{2} \oplus S_{1} 
    $$
    当 $\displaystyle OF=0$ ，未发生溢出；当 $\displaystyle OF=1$ ，发生溢出。

2. **进位判决法**（单符号位）

    如果 $\displaystyle C_{n-1} $ 表示最高数值为产生的进位， $\displaystyle C_{n} $ 表示符号产生的进位（即进位标志 $\displaystyle CF $），则溢出的标志 $\displaystyle OF$ 的逻辑表达式为：
    $$
    \displaystyle OF = C_{n-1} \oplus C_{n}
    $$

3. 根据运算结果的符号位和进位标志判别

    **该方法适用于两个同号数求和或异号数求差时判别溢出**。溢出的标志 $\displaystyle OF$ 的逻辑表达式为：
    $$
    \displaystyle OF = SF\oplus CF
    $$

4. 根据运算前后的符号位进行判别

### 1.1.3 一位全加器

设一位全加器的输入分别为 $\displaystyle X_{i} $ 和 $\displaystyle Y_{i} $ ，低位进位为 $\displaystyle C_{i} $ ，全加器的结果为 $\displaystyle Z_{i} $ ，向高位进位为 $\displaystyle C_{i+1} $ ，则实现一位全加器的逻辑表达式为：
$$
\begin{align}\displaystyle &Z_{i} = X_{i} \oplus Y_{i} \oplus C_{i} \\\displaystyle &C_{i+1} = (X_{i} Y_{i} ) + (X_{i} +Y_{i} )C_{i} = (X_{i} Y_{i} ) + (X_{i} \oplus Y_{i} )C_{i} \end{align}
$$
![一位全加器逻辑电路及其框图](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/一位全加器逻辑电路及其框图.svg)

### 1.1.4 n位全加器

1. **行波进位加法器**💤💤

    将 $n$ 个“一位全加器”串接在一起，构成 $n$ 位二进制数加法器。进位的产生是由三级门形成的，**因为任何一级门均有延时，所以生成进位是需要花时间的**。

    ![行波进位加法器)](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/行波进位加法器.png)

    行波进位加法器:

    - 加法器的“进位”逐位产生。**高位运算必须等待低位运算产生进位后，方能进行计算**。

    - 加法器的“和”逐位产生**。**

        如果一位全加器的延时是 $\displaystyle \Delta t$ ，那么完成 $n$ 位加法需要的时间为 $\displaystyle n\Delta t$ 。**显然，行波进位加法器的速度是难以令人满意的**。

    - 利用“异或门”实现了溢出判别逻辑。

2. 并/先行进位加法器（CLA）：同时生成所有低位向高位的进位。

    在加法运算之前，将各位全加器所需要的进位并行生成，以此加快加法运算速度。

    ![并行进位加法器](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/并行进位加法器.png)

    并行进位加法器：

    - **如果一位全加器的延时是 $\displaystyle \Delta t$ ，并行进位产生电路的延时是 $\displaystyle \tau $ ，那么，完成 $n$ 位加法仅需要 $\displaystyle \Delta t+\tau $ 时间**。
    - 随着位数的增加，电路会越来越复杂。（因此，在设计加法器时，会将多位加法器分组。）

3. 组内并行<u>组间串行</u>进位加法器，又称为**单级先行进位**。

    组间进位是串行的，即每个组的进位输入是相邻低位组的进位输出，而每个组的进位输出是相邻高位组的进位输入。**串行进位链的总延迟时间与分组数目成正比**。

    ![组内并行组间串行进位加法器](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/组内并行组间串行进位加法器.png)

4. 组内并行<u>组间并行</u>进位加法器，又称为**多级先行进位加法器**。

    这种加法器利用每组的 G+3 和 P4s 信号再次组成先行进位链，即构成组内先行进位，组间也为先行进位的进位逻辑。

    ![组内并行组间并行进位加法器](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/组内并行组间并行进位加法器.png)

5. 加法/减法器

    利用异或门和控制信号 $\displaystyle M$ 可实现减法运算。

    ![行波进位的n位加减法器](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/行波进位的n位加减法器.png)

- 当 $\displaystyle M=0$ 时，异或门输出 $\displaystyle Y$ ，实现加法 $\displaystyle X+Y$ 的功能；
- 当 $\displaystyle M=0$ 时，异或门输出 $\displaystyle \overline{Y} $ ，$\displaystyle \overline{Y} $ 与最低进位 $\displaystyle C_{0} =M=1$ 相加，实现减数求补，然后与 $\displaystyle X$ 做加法，从而实现减法 $\displaystyle X-Y$ 的功能。



### 1.1.5 BCD 加法器

“8421BCD”码的对照表：

| BCD  | 十进制 |   BCD    | 十进制 |
| :--: | :----: | :------: | :----: |
| 0000 |   0    |   1000   |   8    |
| 0001 |   1    |   1001   |   9    |
| 0010 |   2    | **1010** | **10** |
| 0011 |   3    | **1011** | **11** |
| 0100 |   4    | **1100** | **12** |
| 0101 |   5    | **1101** | **13** |
| 0110 |   6    | **1110** | **14** |
| 0111 |   7    | **1111** | **15** |

1. “8421BCD码”的使用方式

    1. 压缩BCD数：用一个字节（8位二进制数）表示2位BCD数，即高4位表示1位BCD数，低4位表示1位BCD数。
    2. 非压缩BCD数：用一个字节表示1位BCD数，即高4位为0，低4位为1位BCD数。

2. 加法运算

    十进制数用8421BCD码编码后，其形式是一个二进制数，因此可以用 $n$ 位加法器进行加法运算，但其运算结果需要校正。

3. 校正：（对于一个字节的压缩BCD数加法进行校正的法则）

    - 运算中**低4位相加结果大于9**或者**有bit3向bit4的进位**，则结果加 `06H` ；
    - 运算中**高四位相加的结果大于9**或**有bit7向更高位的进位**，则结果加 `60H` ，同时进位为“1”，且将其看作相加结果的最高位；
    - 若高四位和低四位均不满足上述条件，则无须校正。

4. BCD码加法器

    ![BCD码加法电路](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/BCD码加法电路.png)

    将 $n$ 个一位 BCD 码加法器进位链串接起来，即可构成“ $n$ 位行波进位BCD加法器"。

### 1.1.6 移码加减法

1. 运算规则：

    1. 两运算数据为移码编码；
    2. 对两个移码求和/差；
    3. 对结果进行修正：**将结果符号取反，即得到正确结果**。

    >  根据该规则，将前述的 $n$ 位加/减法运算器结果输出端的最高位（即符号位）加一个反相器，即可构成移码加/减法运算器。

2. 移码运算注意的问题

    1. 对移码运算的结果需要加以修正。

        $n$ 位数的修正量为 $\displaystyle 2^{n-1} $ ，即对结果的符号位取反后，才是移码形式的正确结果；

    2. 移码表示中，0有唯一的编码，为 `1000 …00` 。当编码出现 `000 …00` 时，表示十进制数 $\displaystyle -2^{n-1} $ 。

        该编码若出现在“IEEE754”格式的浮点数阶码中，则**表示浮点数出现下溢，此时浮点数按机器零处理**。

## 1.2 乘法运算

1. **乘法运算可以用软件来实现**，若CPU硬件结构简单，则这**种做法实现乘法所用的时间较长，速度很慢**。
2. 在ALU等硬件的基础上，增加一些硬件构成乘法器。硬件复杂，但速度比较快。
3. **速度最快的是全部由硬件实现的阵列乘法器，其硬件更加复杂**。

### 1.2.1 原码乘法运算

1. 原码一位乘法规则：

    1. 乘积的符号为：“被乘数的符号位”与“乘数的符号位”相异或

    2. 乘积的数值为“被乘数的数值”与“乘数的数值”之积；

    3. 乘积的原码
        $$
        \displaystyle \left [ Z \right ] _{\text{原码} } = \left [ X\times Y \right ] _{\text{原码} } = (x_{0} \oplus y_{0} )(\left | X \right |\times \left | Y \right |  )
        $$

2. 原码一位乘法的实现思路

    ![原码一位乘法的实现思路](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/原码一位乘法的实现思路.png)

    在CPU中，一个ALU一次只能完成两个数的相加，上述求和要通过3～4次相加才能获得结果，其中每次相加的结果称为部分积。

3. 原码一位乘法的算法流程图：

    - 寄存器 $\displaystyle D$ ：初始化为“0”；运算中存放“部分积的高位”；运算结束存放“数值乘积的高位”。
    - 寄存器 $\displaystyle A$ ：初始化“存放乘数”；运算中与寄存器 $\displaystyle D$ 一起右移，接受来自 $\displaystyle D$ 的位数据；运算结束存放数值乘积的低位。
    - 寄存器 $B$ ：一直存放被乘数。

    ![源码一位乘法的算法流程](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/源码一位乘法的算法流程.png)

4. 原码一位乘法器的框图：

    ![原码一位乘法器的框图](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/原码一位乘法器的框图.png)

### 1.2.2 补码乘法运算

**计算机中经常采用补码表示数据**，较多计算机采取补码进行乘法运算。**一种经典的补码乘法算法为“布斯法”，补码一位乘法的一种，是由布斯(Booth)夫妇提出的**。

设被乘数 $\displaystyle X$ 与乘数 $\displaystyle Y$ 均用补码表示的纯小数，分别为：
$$
\begin{align}\displaystyle \left [ X \right ] _{\text{补码} } &=X_{0} .X_{-1} X_{-2} \cdots X_{-(n-1)} \\\displaystyle \left [ Y \right ] _{\text{补码} } &=Y_{0} .Y_{-1} Y_{-2} \cdots Y_{-(n-1)} \\\end{align}
$$
布斯法补码一位乘法的公式为：
$$
\begin{align}\displaystyle \left [ X\times Y \right ] _{\text{补码} }  = \left [ X\right ] _{\text{补码} } \times[ &(Y_{-1} -Y_{0} )\times 2^{0} +(Y_{-2} -Y_{-1} )\times 2^{-1} +\cdots +\\&(Y_{-(n-1)} -Y_{-(n-2)} )\times 2^{-(n-2)} +({\color{Red} 0}  -Y_{-(n-1)} )\times 2^{-(n-1)}] \end{align}
$$


| $\displaystyle Y_{i} $ | $\displaystyle Y_{i-1} $ | $\displaystyle Y_{i-1}-Y_{i} $ |                             操作                             |
| :--------------------: | :----------------------: | :----------------------------: | :----------------------------------------------------------: |
|           0            |            0             |               0                |                +0；$\displaystyle DA$右移一位                |
|           0            |            1             |               1                | $\displaystyle +\left [ X \right ] _{\text{补码} } $；$\displaystyle DA$右移一位 |
|           1            |            0             |               -1               | $\displaystyle +\left [ -X \right ] _{\text{补码} } $；$\displaystyle DA$右移一位 |
|           1            |            1             |               0                |                +0；$\displaystyle DA$右移一位                |

**布斯算法描述**：

1. 乘数与被乘数均用补码表示，符号位参加运算；
2. 乘数最低位后增加一个附加位（用 $\displaystyle A_{-1} $ 表示），初始值为 0 ；
3. 从附加位开始，根据上表完成各位的操作。

实现布斯算法的流程图如下：

![布斯算法流程图](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/布斯算法流程图png)

不死算法乘法器的硬件框图：

![布斯算法乘法器的硬件框图](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/布斯算法乘法器的硬件框图.png)

### 1.2.3 阵列乘法器

上述乘法运算，是利用简单的硬件进行多次加法和多次移位来实现乘法的。显然，这样难以获得高的运算速度。为了提高运算速度，可以采取类似人工手算的方法。

设二进制数 $\displaystyle X=X_{3} X_{2}X_{1}X_{0}$ 和 $\displaystyle Y=Y_{3} Y_{2}Y_{1}Y_{0}$ 。计算 $\displaystyle Z=X\times Y$ ，列式如下：

![乘法手算单元](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/乘法手算单元.png)



每一对相与求和操作可以用基本乘加单元电路来实现。 如下图：

![基本乘加单元电路](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/基本乘加单元电路.png)

利用手算算式的结构及乘加单元电路，可以方便地实现无符号数阵列乘法器。利用无符号数阵列乘法器完成原码的数值相乘，再加入一个完成符号运算的异或门，就构成了“原码阵列乘法器”。

[![无符号数阵列乘法器](https://imageshack.yuilexi.cn/University/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/3/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%98%B5%E5%88%97%E4%B9%98%E6%B3%95%E5%99%A8.png)](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/无符号数阵列乘法器.png)

**补码的阵列乘法器**：在无符号数阵列乘法器的基础上，很容易实现补码阵列乘法器。其基本思路是：**先求被乘数与乘数的绝对值（无符号数），然后进行无符号数阵列乘法，最后根据被乘数与乘数的符号决定最终乘积的符号**。

[![求补电路](https://imageshack.yuilexi.cn/University/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/3/%E6%B1%82%E8%A1%A5%E7%94%B5%E8%B7%AF.png)](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/求补电路.png)

**适于流水线工作的阵列乘法器**：上述阵列乘法器的最大缺点是，每一步部分积的计算都是用串行进位加法器来实现的，因此即使采用硬件电路，其运算速度仍然很慢，令乘法器的使用者无法接受。

## 1.3 除法运算

### 1.3.1 原码除法运算

原码除法运算规则：

1. 除数不能为零。

    - 对于定点纯小数，被除数 < 除数；
    - 对于定点纯整数，被除数 > 除数；

2. 分别处理**商符**和**商值**。

    商符等于被除数的符号与除数的符号相异或；商值等于被除数的数值除以除数的数值；

3. 将商符与商值拼接在一起即可得到商的原码。

4. 除法是通过**逐次减除数**来实现的，也就是被除数（或余数）每次减去“右移一位”的除数，以此来决定商值。

5. 在手算过程中，人通过眼睛和大脑来判断被除数或余数是否够减除数，以决定商是 “0” 还是 “1” 。**而在CPU中，必须完成相减操作方能判断余数是否够减。当发现不够减时，由于余数已经减掉了除数，因此必须在下一步操作之前恢复余数。这就是“恢复余数法”**。

恢复余数法：

1. 被除数左移一位，减除数，若够减 ，上商为 “1” ；若不够减，上商为 “0”，同时加除数——**恢复余数**；
2. 余数左移一位，减除数，若够减，上商为 “1” ；若不够减，上商为“0”，同时加除数——**恢复余数**；
3. 重复此过程，直到除尽或精度达到要求为止。

**恢复余数法的最大缺点**：在运算位数相同的情况下，不同的被除数和除数在运算中何时需恢复余数不相同，运算时间不一致，实现起来不便于控制。

因此，恢复余数法在计算机中并不常用，由此法演变出了另一种更有效的计算方法：**加减交替法**。

加减交替法：

1. 加减交替算法可描述如下：①若余数 $\displaystyle R\ge 0$ ，则商上“1”，余数左移一位，减除数；②若余数 $\displaystyle R < 0$ ，则商上“0”，余数左移一位，加除数。

2. 加减交替除法器硬件电路

    ![加减交替除法器硬件电路](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/加减交替除法器硬件电路.png)



# 二、逻辑与移位运算

除了加减乘除四则运算外，目前的运算器还包括“逻辑与移位运算”。

## 2.1 逻辑运算

基本的逻辑运算包括“与**、**或、非、异或”等运算。计算机以“1”和“0”分别表示逻辑数据的真和假两个状态。此时 $n$ 个 0 和 1 的数字组合不是算术数字，而是没有符号位的逻辑数据。 

逻辑运算按位进行操作，各位之间互不影响，**运算结果没有进位、借位、溢出等问题**。

### 2.1.1 基本逻辑运算

| $\displaystyle X$ | $\displaystyle Y$ | $\displaystyle XY$ | $\displaystyle X+Y$ | $\displaystyle X\oplus Y$ | $\displaystyle \overline{X}$ |
| :---------------: | :---------------: | :----------------: | :-----------------: | :-----------------------: | :--------------------------: |
|         0         |         0         |         0          |          0          |             0             |              1               |
|         0         |         1         |         0          |          1          |             1             |              1               |
|         1         |         0         |         0          |          1          |             1             |              0               |
|         1         |         1         |         1          |          1          |             0             |              0               |

1. 逻辑与(AND) 运算：也称为**逻辑乘运算**，是指对两个操作数进行按位相与，用符号 ∧ 或 ⋅ 来表示；
2. 逻辑或(OR) 运算：也称为**逻辑加运算**，是指对两个操作数进行按位相或，用符号 ∨ 或 + 来表示；
3. 逻辑异或(XOR) 运算：也称为**按位加**，是指按位求两个数模 2 相加的和，用符号 ⊕ 表示；
4. 逻辑非(NOT) 运算：也称为**求反**，是指对数据位进行取反操作， 1 和 0 分别转换为 0 和 1 。

### 2.1.2 逻辑运算部件

![逻辑运算部件](https://imagehost.yuilexi.cn/计算机/计算机基础/计算机组成与系统结构/3_运算方法与运算器.md/逻辑运算部件.svg)

## 2.2 移位运算

对于无限长度二进制数，左移或者右移 $\displaystyle n$ 位相当于该数乘以或者除以 $\displaystyle 2^{n} $ 。

由于计算的机器数字长是固定的，因此当机器数左移或右移 $\displaystyle n$ 位时，必然会使数据的低位或者高位出现 $\displaystyle n$ 个空位。**空位填写“0”还是“1”，取决于机器数采用的是“无符号数”还是“有符号数”**。

![移位运算执行过程](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/移位运算执行过程.png)

### 2.2.1 逻辑移位

逻辑移位包括**逻辑左移**和**逻辑右移**两种操作。逻辑移位的操作数被认为是无符号数或逻辑数据，不存在符号问题，所有数据位都参与移位运算。

1. 逻辑左移（SHL）：操作数的**最高位向左移出**，存入状态寄存器的进位标志位 CF ，其他位依次向左移位，**最低位补“0”**；
2. 逻辑右移（SHR）：操作数的**最低位向左移出**，存入状态寄存器的进位标志位 CF ，其他位依次向右移位，**最高位补“0”**。

### 2.2.2 算术移位

**算术移位是指将操作数据当作有符号数进行运算，在算术移位过程中必须保持移位前后的符号位不变**。

1. 算术左移（SAL）：数值位与逻辑左移操作方法相同。其原码、补码和反码与真值相等，**在不超出编码表示范围的前提下，算术左移1位等于对操作数做乘2运算**；
2. 算术右移（SAR）：数值位与逻辑左移操作方法相同，**最高位用符号位填入**。对于补码而言，算术右移1位等于对操作数作除2运算。

### 2.2.3 循环移位

循环移位是指将数据的首尾相连进行移位，在整个移位过程中，数据各位信息没有丢失，可用于多字节数据的高低字节交换等操作。

根据进位是否参与循环，循环移位可分为**不带进位循环移位**和**带进位循环移位**：

- 不带进位循环左移（ROL）：数据各位依次向左移位，**移出的最高位移入空出的最低位**，同时存入 CF 标志位；
- 不带进位循环右移（ROR）：数据各位依次向右移位，**移出的最低位移入空出的最高位**，同时存入 CF 标志位；
- 带进位循环左移（RCL）：数据各位依次向左移位，移出的最高位移入 CF 标志位，同时原 CF 标志位的内容移入空出的最低位；
- 带进位循环右移（RCR）：数据各位依次向右移位，移出的最低位移入 CF 标志位，同时原 CF 标志位的内容移入空出的最高位。

### 2.3.4 移位运算部件

上述 8 种（实质为 7 种）移位运算的功能实现电路，其中**核心器件为 16 个 D 触发器构成的 16 位移位寄存器**（通过增加 D 触发器的数目，可以扩充移位寄存器的位数）。通过与或逻辑电路控制 D 触发器的输人端 D 移位寄存器可实现所期望的移位操作。

![移位运算功能的移位寄存器](https://imageshack.yuilexi.cn/University/计算机组成与系统结构/计算机组成与系统结构/3/移位运算功能的移位寄存器.png)

# 三、浮点数运算

## 3.1 浮点数加减运算

设两个规格化浮点数 $\displaystyle X = M_{x} \times 2^{E_{x} } $ 和 $\displaystyle Y = M_{y} \times 2^{E_{y} } $ 。

### 3.1.1 对阶

一般情况下，两浮点数的阶码不会相同。也就是说，两数的小数点没有对齐。

和我们所熟悉的十进制小数加减一样，在进行浮点数加减运算前需将小数点对齐，这称为**对阶**。只有当两数的阶码相同时才能进行尾数的加减运算。 对**阶的原则是小阶对大阶，也就是将小阶码浮点数的阶码变成大阶码浮点数的阶码**。

具体做法是：小阶码每增加 “1” ，该浮点数的尾数右移一位，直到小阶码增大到与大阶码相同。*这样在对阶时丢失的是尾数的低位，造成的误差很小。若是大阶对小阶，将丢失尾数的高位，从而导致错误的结果*。

## 3.2 浮点数乘除运算

## 3.3 浮点数运算实现方法



# 四、运算器基本结构

## 4.1 三种基本结构

## 4.2 运算器实例