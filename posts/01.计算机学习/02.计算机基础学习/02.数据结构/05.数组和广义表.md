---
title: 第五章 数组和广义表【数据结构】
date: 2023-4-29 00:00:05
categories:
	- [大学学习, 考研]
	- [C语言, 数据结构]
tags: [C语言, 数据结构, 考研, 大学学习]
description: 数据结构(C语言版)学习笔记，包括线性表、栈、队列、串、树、图、查找、排序等内容。
mathjax: true
katex: true
imagehost_path: Blog/Post/01.计算机学习/02.计算机基础学习/02.数据结构/05.数组和广义表.md/
---

# 前言

> 快速导航：
>
> - [第一章 绪论【数据结构】](./01.绪论)
> - [第二章 线性表【数据结构】](./02.线性表)
> - [第三章 栈和队列【数据结构】](./03.栈和队列)
> - [第四章 串【数据结构】](./04.串)
> - [第五章 数组和广义表【数据结构】](./05.数组和广义表)
> - [第六章 数和二叉树【数据结构】](./06.数和二叉树)
> - [第七章 图(Graph)【数据结构】](./07.图Graph)
> - [第九章 查找【数据结构】](./09.查找)

数组和广义表可以看成是线性表在下述含义上的扩展：线性表中的元素本身也可能是一个数据结构。

# 一、数组的定义

数组的抽象数据模型为：

```伪c
ADT Array
{
    数据对象:i, j, D;
    数据关系:R;
    基本操作:
    	Statue InitArray(&A, n, bound[n]); // 初始化操作，建立一个n维数组A，构造成功返回OK，否则返回ERROR
    	DestroyArray(&A);                  // 销毁数组A
    	Value(A, &e, index[]);             // 将数组A中下标为 index[] 的元素值返回给e
    	Assign(&A, e, index[]);            // 将e的值赋给数组A中下标为 index[] 的元素
}
```

> 数组一旦被定义，它的**维数**和**维界**就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。

# 二、数组的顺序表示和实现

由于**数组一般不做插入或者删除操作**，也就是说，一旦建立了数组，则结构中的元素个数和元素之间的关系就不再发生变动。对二维数组可有两种存储方式：**以列序优先**和**以行序有限**。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/二维数组的存储模式.svg" alt="二维数组的存储模式.svg" style="zoom: 36%">

> 通常情况下，二维数组的存储**以行序优先**，并且在大多的计算机编程语言中（包含 `C` 语言），都是**以行序优先**来存储二维数组。

假设每个数据元素占 $L$ 个存储单元，并且以行序优先，则二维数组 $A$ 中，任一元素 $\displaystyle a_{ij} $ 的存储位置可由下式确定：

$$
\displaystyle \mathrm{Loc}(i,j) = \mathrm{Loc}(0,0) +(i\times n+j)
$$

式中， $\displaystyle \mathrm{Loc}(i,j)$ 是 $\displaystyle a_{ij} $ 的存储位置； $\displaystyle \mathrm{Loc}(0,0)$ 是 $a_{00}$ 的存储位置，即**二维数组 $A$ 的起始存储位置，也称为基址地址或者基址**。

> 由于计算各个域元素存储位置的时间相等，所以存取数组中任一元素的时间也相等。称具有这一特点的存储结构为**随机存储结构**。

# 三、矩阵的压缩

## 3.1 特殊矩阵

### 3.1.1 零元矩阵和全 $k$ 阵

只需要存储三个数字：矩阵的行、列数以及矩阵元素的值。

### 3.1.2 对称矩阵

如果 $n$ 阶矩阵 $A$ 中的元素，满足 $\displaystyle a_{i,j} =a_{j,i} $ ，则称矩阵 $A$ 为**对称矩阵**。

对于对称矩阵，可以为**每一对对称元**分配一个存储空间，即将 $\displaystyle n^{2} $ 和元素压缩存储到 $\displaystyle \frac{n(n+1)}{2} $ 个元的空间中。因此，原矩阵的下标（注意：**这里的下标从 0 开始**）与压缩后的一维数组的下标的对应关系为：

$$
\displaystyle k=\left\{\begin{matrix}\frac{i(i-1)}{2}+j-1 & \text{当}i\ge j \\\frac{j(j-1)}{2}+i-1 & \text{当}i<  j\end{matrix}\right.
$$

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/对称矩阵的压缩.svg" alt="对称矩阵的压缩.svg" style="zoom: 100%">

因此，对应的转换算法为：

```c
// 对称矩阵的压缩
int *Compression(int **matrix, int n)
{
    int *result = (int *)malloc(sizeof(int) * n * (n + 1) / 2);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j <= i; j++)
        {
            result[i * (i + 1) / 2 + j] = matrix[i][j];
        }
    }
    return result;
}
// 对称矩阵的解压缩
int **Decompression(int *matrix, int n)
{
    int **result = (int **)malloc(sizeof(int *) * n);
    for (int i = 0; i < n; i++)
    {
        result[i] = (int *)malloc(sizeof(int) * n);
        for (int j = 0; j <= i; j++)
        {
            result[i][j] = matrix[i * (i + 1) / 2 + j];
        }
    }
    return result;
}
```

### 3.1.3 上三角矩阵和下三角矩阵

由于对称矩阵是将矩阵转化为上三角或者下三角矩阵来进行计算的，因此，压缩和解压缩的过程与对称矩阵类似。

### 3.1.4 对角矩阵

有 $n$ 阶矩阵，主对角线元素不全为 0 ，其余元素全为 0 的矩阵，称为**对角矩阵**。对角矩阵的压缩较为简单，只需要将对角线上所有元素转化为一维数组即可。

## 3.2 稀疏矩阵

假设在 $\displaystyle m\times n$ 矩阵中，有 $\displaystyle t$ 个元素不为 0 。令 $\displaystyle \delta =\frac{t}{m\times n} $ ，称 $\displaystyle \delta $ 为**稀疏因子**。通常认为 $\displaystyle \delta\le 0.05$ 时称为**稀疏矩阵**。

现有稀疏矩阵 $M$ ：

$$
\displaystyle {\large M=\begin{bmatrix} 0 &{\color{Red} 12} & {\color{Red} 9}  & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 0 & 0\\{\color{Red}  -3}  & 0 & 0 & 0 & 0 & {\color{Red} 14}  & 0\\ 0 & 0 & {\color{Red} 24}  & 0 & 0 & 0 & 0\\ 0 & {\color{Red} 18}  & 0 & 0 & 0 & 0 & 0\\ {\color{Red} 15}  & 0 & 0 & {\color{Red} -7}  & 0 & 0 & 0\end{bmatrix} }
$$

以及转置矩阵：

$$
 \displaystyle {\large T=\begin{bmatrix} 0 & 0 & {\color{Red} -3}  & 0 & 0 & {\color{Red} 15}\\ {\color{Red} 12}  & 0 & 0 & 0 & {\color{Red} 18}  & 0 \\{\color{Red}  9}  & 0 & 0 & {\color{Red} 24} & 0 & 0\\ 0 & 0 &  0 & 0 & 0 & {\color{Red}  -7}\\ 0 & 0 & 0 & 0 & 0 & 0 \\ 0& 0 & {\color{Red} 14} & 0 & 0 & 0 \\ 0& 0 & 0 & 0 & 0 & 0 \end{bmatrix} }
$$

### 3.2.1 三元组表

假设以顺序存储结构来表示三元组表，得到稀疏矩阵压缩的一种方式——**三元组顺序表**。

**三元组顺序表的数据结构**如下：

```c
#define MAXSIZE 12500 // 假设非零元个数的最大值为12500
// 表示三元组的结构体
typedef struct Triple
{
    int i, j;
    Element e;
} Triple;
typedef struct TSMatrix
{
    Triple data[MAXSIZE + 1]; // 非零元三元组表，data[0]未用
    int mu;                   // 矩阵的行数和列数
    int nu;                   // 矩阵的行数和列数
    int tu;                   // 矩阵的非零元个数
} TSMatrix;
```

那么，构造对应的压缩算法为：

```c
TSMatrix *Compression(Element **matrix, int m, int n, int count)
{
    TSMatrix *result = (TSMatrix *)malloc(sizeof(TSMatrix));
    result->mu = m;
    result->nu = n;
    result->tu = count;
    int k = 1;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (matrix[i][j].value != 0)
            {
                result->data[k].i = i;
                result->data[k].j = j;
                result->data[k].data = matrix[i][j];
                k++;
            }
        }
    }
    return result;
}
```

其结果为：`a.data` ：

|   i   |  0  |  0  |  2  |  2  |  3  |  4  |  5  |  5  |
| :---: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|   j   |  1  |  2  |  0  |  5  |  2  |  1  |  0  |  4  |
| value | 12  |  9  | -3  | 14  | 24  | 18  | 15  | -7  |

---

矩阵的转置运算：方法一

@算法 5-1 ：用三元组表进行矩阵的转置：

```c
// 算法 5-1 ：用三元组表进行矩阵的转置：
void Transform(TSMatrix matrix, TSMatrix &result)
{
    // 交换行列值
    result.mu = matrix.nu;
    result.nu = matrix.mu;
    result.tu = matrix.tu;
    int q = 1;
    // 交换每一个三元组的行列值
    for (int col = 0; col < matrix.nu; col++)
    {
        for (int p = 1; p <= matrix.tu; p++)
        {
            if (matrix.data[p].j == col)
            {
                result.data[q].i = matrix.data[p].j;
                result.data[q].j = matrix.data[p].i;
                result.data[q].data = matrix.data[p].data;
                q++;
            }
        }
    }
}
```

> 一般的矩阵转置算法，其**时间复杂度为： $\displaystyle O(m\times n)$** 。但是如果非零元个数与 $\displaystyle m\times n$ 同数量级时，**三元组顺序表的转置算法**的时间复杂度就变成了 $\displaystyle O(m\times n^{2} )$ 。
>
> 因此，**用三元组表进行矩阵的转置**，仅仅适合 $\displaystyle t \ll m\times n$ 的情况，即不是稀疏矩阵的情况。

矩阵的转置运算：方法二

**快速转置**：如果能预先确定矩阵 $\displaystyle M$ 中，每一列（即 $T$ 中每一行）的第一个非零元在 `b.data` 中应有的位置，那么在对 `a.data` 中的三元组依次做转置时，便可以直接放到 `b.data` 中恰当的位置。

为此，需要附设 `num` 和 `cpot` 两个向量。

- `num[co]` 表示矩阵 $M$ 中第 $col$ 列中，非零元的个数；
- `cpot[col]` 指示 $M$ 中，第 $col$ 列第一个非零元素在 `a.data` 中的恰当位置。

显然有：

$$
\displaystyle \mathrm{cpot}\left [ \mathrm{col}  \right ]  =\left\{\begin{matrix} 1& \mathrm{col}=1 \\ \mathrm{cpot}\left [ \mathrm{col} -1 \right ] +\mathrm{num} \left [ \mathrm{col} -1 \right ]  &1< \mathrm{col}\le \mathrm{a.nu}\end{matrix}\right.
$$

因此，得到的向量表为：

|    col    |  1  |  2  |  3  |  4  |  5  |  6  |  7  |
| :-------: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| num[col]  |  2  |  2  |  2  |  1  |  0  |  1  |  0  |
| cpot[col] |  1  |  3  |  5  |  7  |  8  |  8  |  9  |

@算法 5-2 ：使用带向量的三元组表进行转置的方法，称为**快速转置**：

```c
// 算法 5-2 ：使用带向量的三元组表进行转置
int FastTransposeSMatrix(TSMatrix M, TSMatrix &T)
{
    // 采用三元组顺序表存储表示，求矩阵M的转置矩阵T
    T.mu = M.nu;
    T.nu = M.mu;
    T.tu = M.tu;
    if (T.tu > 0)
    {
        int col, t;
        // 初始化num数组
        int *num = (int *)malloc(sizeof(int) * M.nu);
        for (col = 0; col < M.nu; col++)
        {
            num[col] = 0;
        }
        // 统计每一列的非零元个数
        for (t = 1; t <= M.tu; t++)
        {
            num[M.data[t].j]++; // 将每一个非零元的列下标对应的num数组的值加1，如果有重复的则会累加
        }

        // 初始化cpot数组
        int *cpot = (int *)malloc(sizeof(int) * M.nu);
        cpot[0] = 1;
        for (col = 1; col < M.nu; col++)
        {
            cpot[col] = cpot[col - 1] + num[col - 1];
        }

        // 将矩阵M的三元组表存入矩阵T的三元组表中
        for (p = 1; p <= M.tu; p++)
        {
            col = M.data[p].j;
            t = cpot[col];
            T.data[t].i = M.data[p].j;
            T.data[t].j = M.data[p].i;
            T.data[t].data = M.data[p].data;
            cpot[col]++;
        }
        return 0;
    }
    return 1;
}
```

### 3.2.2 行逻辑连接的顺序表

为了便于存取任意一行的非零元，则需要知道每一行的第一个非零元在三元组顺序表中的位置。类似上面的 `cpot` 向量一样，在表示压缩矩阵的结构体内，添加一个指示“行”信息的辅助数组。称这种“带行链接信息”的三元组表为行逻辑链接的顺序表，其类型如下：

```c
typedef struct TSMatrix
{
    Triple data[MAXSIZE + 1]; // 非零元三元组表，data[0]未用
    int rpos[MAXSIZE + 1];    // rpos[i]表示矩阵第i行第一个非零元在data中的位置
    int mu;                   // 矩阵的行数和列数
    int nu;                   // 矩阵的行数和列数
    int tu;                   // 矩阵的非零元个数
} RLSSMatrix;
```

两个矩阵相乘的经典算法为：

```c
// ......
for (int i = 0; i < m1; i++)
{
    for (int j = 0; j < n2; j++)
    {
        int t = 0;
        for (int k = 0; k < n1; k++)
        {
            t += a[i][k] * b[k][j];
        }
        c[i][j] = t;
    }
}
// ......
```

> **此算法的时间复杂度为： $\displaystyle O(m_{1} \times n_{2} \times s)$** 。

### 3.2.3 十字链表法

十字链表的稀疏矩阵的压缩，其数据模型如下：

```c
typedef struct OLNode
{
    int i, j;                    // 该非零元的行下标和列下标
    int e;                       // 该非零元的值
    struct OLNode *right, *down; // 该非零元所在行表和列表的后继链域
} OLNode, *OLink;
typedef struct
{
    OLink *rhead, *chead; // 行指针和列指针
    int mu, nu, tu;       // 矩阵的行数、列数和非零元个数
} CrossList;
```

其图示模型为：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/稀疏矩阵的十字链表.png" alt="稀疏矩阵的十字链表" style="zoom: 150%">

### 3.2.4 行/列链表法【扩展】

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/行链表法.svg" alt="行链表法" style="zoom: 70%">

# 四、广义表

广义表是线性表的推广。也有人称其为列表（Lists）。

广义表一般记作：

$$
\displaystyle \mathrm{LS} = (a_{1},a_{2},\cdots ,a_{n} )
$$

其中， $\displaystyle \mathrm{LS}$ 是广义表的名称， $n$ 是它的长度。在线性表的定义中， $\displaystyle a_{i}$ 只限于单个元素。**而在广义表中， $\displaystyle a_{i}$ 可以是单个元素，也可以是广义表，分别称为广义表的原子和子表**。当广义表非空时，称第一个元素 $\displaystyle a_{i}$ 为 $\displaystyle \mathrm{LS}$ 的表头，其余元素组成的表是 $\displaystyle \mathrm{LS}$ 的表尾。

**链表的 3 个重要结论**：

1. 列表的元素可以是子表，而子表的元素还可以是子表。由此，**列表是一个多层次的结构**，可以用图形象地表示。
2. 列表可以为其他列表所共享。
3. 列表可以是一个递归的表，即列表也可以是其本身的一个子表。（**深度无穷限，长度有限值**）

# 五、广义表的存储结构

由于广义表中的数据元素可以具有不同的结构，因此难以用顺序存储结构表示，通常使用链式存储结构，每个数据元素可用一个结点表示。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/5_数组和广义表.md/广义表的存储结构.svg" alt="广义表的存储结构.svg" style="zoom: 100%">

一个**表结点**可由 3 个域组成：

- 标志域：
- 指向表头的指针域
- 指向表尾的指针域

而**原子结点**只需要两个域：

- 标志域
- 值域

**广义表的数据结构模型**如下：

```c
typedef enum ElemTag
{
    ATOM,
    LIST
} ElemTag;
typedef struct AtomType
{
    int value;
} AtomType;

typedef struct GLNode
{
    ElemTag tag; // 公共部分，用于区分原子结点和表结点
    union
    {
        AtomType atom; // atom是原子结点的值域，AtomType由用户定义
        struct GLNode *child;
    };
    struct GLNode *next;
} *GList;
```

# 六、 $m$ 元多项式的表示

一个 $m$ 元多项式的每一项，最多有 $m$ 个变元。如果用线性表来表示，则每个数据元素需要 $m+1$ 个数据项，存储一个系数值和 $m$ 个指数值。

这将产生两个问题：

1. 无论多项式中各项的变元数是多少，如果都按照 $m$ 个变元分配存储空间，则将会造成浪费；
2. 如果都按照实际的变元数来分配存储空间，则会造成结点的大小不均，给操作带来不便
3. 对 $m$ 值不同的多项式，线性表中的结点大小也是不同的，这样会引起存储管理的不便。

任何一个 $m$ 元多项式都可以：**先分解出一个主变元，随后在分解出第二个变元**，等等。由此，一个 $m$ 元的多项式首先是它的主变元的多项式，而其系数又是第二变元的多项式，由此可用广义表来表示 $m$ 元多项式。

例如：

$$
\displaystyle P(x,y,z) = x^{10} y^{3} z^{2} +2x^{6} y^{3} z^{2} +3x^{5} y^{2} z^{2} +x^{4} y^{4} z^{} +6x^{3} y^{4} z^{} +2y^{3} z^{2} +15
$$

将 $z$ 作为主变元，则得到：

$$
\displaystyle P(x,y,z) = (x^{10} y^{3}+2x^{6} y^{3}+3x^{5} y^{2}+2y^{3} )z^{2}+(x^{4} y^{4}+6x^{3} y^{4})z  +15
$$

二对应的 $A,B,C$ 又得到一个 $m-1$ 元多项式，为：

$$
\begin{align}A(x,y) & =  (x^{10} +2x^{6} )y^{3} +3x^{5} y^{2} \\B(x,y) & =  (x^{4}+6x^{3})y^{4} +2y\\V(x,y) & = 15\\\end{align}
$$

数据结构模型为：

```c
typedef enum ElemTag
{
    ATOM,
    LIST
} ElemTag;
typedef struct MPNode
{
    ElemTag tag; // 公共部分，用于区分原子结点和表结点
    int exp;     // 指数
    union
    {
        float coef;           // 系数
        struct MPNode *child; // 指向子表
    };
    struct MPNode *next; // 指向后继结点
} MPNode, *MPLink;       // 多项式的广义表
```

# 七、广义表的递归算法

## 7.1 求广义表的深度

**广义表的深度定义为广义表中括弧的重数**，是广义表的一种量度。

> 简单来讲，有多少重的子广义表

```c
int GListDepth(GList L)
{
    int max = 0;
    int depth = 0;
    // 如果广义表为空，返回1
    if (L == NULL)
    {
        return 1;
    }
    GList p = L;
    // 如果是原子结点，返回0
    if (p->tag == ATOM)
    {
        return 0;
    }
    // 如果是表结点，递归求子表的深度
    while (p != NULL)
    {
        depth = GListDepth(p->child);
        if (depth > max)
        {
            max = depth;
        }
        p = p->next;
    }
    return max + 1; // 返回广义表的深度
}
```

## 7.2 复制广义表

**复制一个广义表，只要分别复制其表头和表尾，然后合成即可**。其代码如下：

```c
Status CopyGList(GList &T, GList L)
{
    if (L == NULL)
    {
        T = NULL;
    }
    else
    {
        T = (GList)malloc(sizeof(GLNode));
        if (T == NULL)
        {
            return ERROR;
        }
        T->tag = L->tag;
        if (L->tag == ATOM)
        {
            T->atom = L->atom;
        }
        else
        {
            CopyGList(T->child, L->child);
            CopyGList(T->next, L->next);
        }
    }
    return OK;
}
```
