---
title: 第六章 数和二叉树【数据结构】
date: 2023-4-29 00:00:06
categories:
	- [大学学习, 考研]
	- [C语言, 数据结构]
tags: [C语言, 数据结构, 考研, 大学学习]
description: 数据结构(C语言版)学习笔记，包括线性表、栈、队列、串、树、图、查找、排序等内容。
mathjax: true
katex: true
imagehost_path: Blog/Post/01.计算机学习/02.计算机基础学习/02.数据结构/06.数和二叉树.md/
---

# 前言

> 快速导航：
>
> - [第一章 绪论【数据结构】](./01.绪论)
> - [第二章 线性表【数据结构】](./02.线性表)
> - [第三章 栈和队列【数据结构】](./03.栈和队列)
> - [第四章 串【数据结构】](./04.串)
> - [第五章 数组和广义表【数据结构】](./05.数组和广义表)
> - [第六章 数和二叉树【数据结构】](./06.数和二叉树)
> - [第七章 图(Graph)【数据结构】](./07.图Graph)
> - [第九章 查找【数据结构】](./09.查找)

树形结构是一类重要的非线性数据结构。其中，以树和二叉树最为常见。

# 一、树的定义和基本术语

基本术语如下：

- **结点**：树的结点包含一个数据元素，以及若干指向其子树的分支；
- **根**：一个树最顶端的结点；
- **结点的度**：结点拥有的子树的个数；
- **叶子**或者终端结点：**结点的度**为 0 的结点；
- **分支结点**或者非终端结点：**结点的度**不为 0 的结点；
- **树的度**：树内所有**结点的度**的最大值；
- **孩子**：该结点的**子树的根**；
- **双亲**：对于某一结点的孩子来讲，该结点称为双亲；
- 兄弟：同一双亲的结点互为兄弟；
- 结点的祖先：从根到该结点所经分支上的所有结点；
- 子孙：某节点为根的子树中的任一结点，都称为该结点的子孙；
- 结点的层次：从根开始定义其，根为第一层，根的孩子为第二层。
- **树的深度**：树中结点的最大层次称为**树的深度**；
- 无序树和有序树：如果将树中结点的各子树看成从左至右是有次序的，则称该树为**有序树**，否则称为**无序树**。
- **森林**： $m$ 棵互不相交的树的集合。

# 二、二叉树

## 2.1 二叉树的定义

**二叉树**是另一种树型结构，它的特点是每个结点最多有两个孩子（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树有 5 种基本形态：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/二叉树的基本形态.svg" alt="二叉树的基本形态.svg" style="zoom: 40%">

## 2.2 二叉树的性质

**性质 1**：在二叉树的第 $i$ 层上，至多有 $\displaystyle 2^{i-1} $ 个结点。

**性质 2**：深度为 $k$ 的二叉树至多有 $\displaystyle 2^{k}-1 $ 个结点。

> 一颗深度为 $k$ 且有 $\displaystyle 2^{k}-1 $ 个结点的二叉树，称为**满二叉树**。

**性质 3**：对于任何一个二叉树 $\displaystyle T$ ，如果其叶子树为 $\displaystyle n_{0} $ ，度为 2 的结点个数为 $\displaystyle n_{2} $ ，则 $\displaystyle n_{0} =n_{2} +1$ 。

> 深度为 $k$ ，有 $n$ 个结点的二叉树，当且仅当每一个结点都与深度为 $k$ 的满二叉树种编号从 1 至 $n$ 结点一一对应时，称之为**“完全二叉树”**。

**性质 4**：具有 $n$ 个结点的完全二叉树的深度为 $\displaystyle \left \lfloor \log_{2}{n}  \right \rfloor +1$ 。

**性质 5**：如果对一棵有 $\displaystyle n$ 个结点的完全二叉树的结点，按层次序编号，有

1. 如果 $\displaystyle i=1$ ，则结点 $i$ 是二叉树的根，无双亲；如果 $\displaystyle i>1$ ，则双亲是结点 $\displaystyle \left \lfloor \frac{i}{2} \right \rfloor $ 。
2. 如果 $\displaystyle i>\frac{n}{2} $ ，则结点 $i$ 无左孩子（结点 $i$ 为叶子结点）；否则，其左孩子是结点 $2i$ 。
3. 如果 $\displaystyle 2i+1>n$ ，则结点 $i$ 无右孩子；否则其右孩子是结点 $\displaystyle 2i+1$ 。

## 2.3 二叉树的存储结构

### 2.3.1 顺序存储结构

按照顺序存储结构的定义，约定，用一组联系的存储单元，依次**自上而下、自左而右**存储完全二叉树上的结点元素，即将**完全二叉树**上编号为 $i$ 的结点元素存储在下表为 $i-1$ 的一维数组中去。

```c
#define MAX_TREE_SIZE 100 // 二叉树的最大结点数
typedef TElemType SqBiTree[MAX_TREE_SIZE]; // 0号单元存储根结点
SqBiTree bt;
```

### 2.3.2 链式存储结构

二叉树的链式存储结构的结点的图示如下：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/二叉树的链式存储.svg" alt="二叉树的链式存储.svg" style="zoom: 30%">

其数据结构模型如下：

```c
// 二叉树的二叉链表结点结构定义
typedef struct BiTNode
{
    TElemType data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;


// 二叉树的三叉链表结点结构定义
typedef struct TripleNode
{
    TElemType data;
    struct ThreadNode *lchild, *rchild;
    struct ThreadNode *parent; // 指向双亲结点
} TripleNode, *TripleTree;
```

# 三、遍历二叉树和线索二叉树

## 3.1 遍历二叉树

**遍历二叉树**：按照某种搜索路径，依次访问书中的每个结点，使得每个结点均被访问一次，而且仅仅被访问一次。

1. 先序遍历（先根遍历）

    如果二叉树为空，则空操作

   1. 访问根节点；
   2. 先序遍历左子树；
   3. 先序遍历右子树；

2. 中序遍历（中根遍历）

    如果二叉树为空，则空操作

   1. 中序遍历左子树；
   2. 访问根节点；
   3. 中序遍历右子树；

3. 后序遍历（后根遍历）

    如果二叉树为空，则空操作

   1. 后续遍历左子树；
   2. 后续遍历右子树；
   3. 访问根节点；

4. 层次遍历

   1. 从上到下，从左到右，依次遍历

> 访问对应节点的时候，采用递归函数，比较简单。

遍历二叉树的算法如下：

1. 先序遍历；

   ```c
   // 先序遍历二叉树
   Status PreOrderTraverse(BiTree T, Staus (*Visit)(TElemType e))
   {
       if (T != NULL)
       {
           if (Visit(T->data) == OK)
           {
               if (PreOrderTraverse(T->lchild, Visit) == OK)
               {
                   if (PreOrderTraverse(T->rchild, Visit) == OK)
                   {
                       return OK;
                   }
               }
               return ERROR;
           }
           else
           {
               return ERROR;
           }
       }
       else
       {
           return OK;
       }
   }
   ```

2. 中序遍历；

   ```c
   // 中序遍历二叉树
   Status InOrderTraverse(BiTree T, Staus (*Visit)(TElemType e))
   {
       if (T != NULL)
       {
           if (InOrderTraverse(T->lchild, Visit) == OK)
           {
               if (Visit(T->data) == OK)
               {
                   if (InOrderTraverse(T->rchild, Visit) == OK)
                   {
                       return OK;
                   }
               }
               return ERROR;
           }
           else
           {
               return ERROR;
           }
       }
       else
       {
           return OK;
       }
   }
   ```

3. 后序遍历。

   ```c
   // 后序遍历二叉树
   Status PostOrderTraverse(BiTree T, Staus (*Visit)(TElemType e))
   {
       if (T != NULL)
       {
           if (PostOrderTraverse(T->lchild, Visit) == OK)
           {
               if (PostOrderTraverse(T->rchild, Visit) == OK)
               {
                   if (Visit(T->data) == OK)
                   {
                       return OK;
                   }
               }
               return ERROR;
           }
           else
           {
               return ERROR;
           }
       }
       else
       {
           return OK;
       }
   }
   ```

> 显然，遍历啊二叉树的算法种的基本操作是访问结点，则不论按照哪一种次序进行遍历，对含 $n$ 个结点的二叉树，其**时间复杂度均为： $\displaystyle O(n)$** 。
>
> 所需辅助空间为遍历过程中栈的的最大容量，即树的深度，最坏的情况下为 � ，则空间复杂度也为： $\displaystyle O(n)$ 。

### 3.2 线索二叉树

遍历二叉树是以一定的规则，将二叉树中结点排列成一个线性序列，得到二叉树中结点的先序序列或者中序序列或者后序序列。

**这实质上是对一个非线性结构进行线性化操作，是每个结点在这些线性序列中有且仅有一个直接前驱和直接后继**。

但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任意序列中的前驱和后继的信息，这种信息只能在二叉树遍历的过程中动态获取到。

如何保存这种在遍历过程中得到的信息呢？**一个最简单的办法是在每个结点上增加两个指针域 `fwd` 和 `bkwd`，分别指示结点在依任一次序遍历时得到的前驱和后继信息**。

显然，这样做，使得结构的存储密度大大降低。另一方面，在有 $\displaystyle n$ 个结点的二又链表中必定存在 $\displaystyle n+1$ 个空链域。由此设想，能否利用这些空链域来存放结点的前驱和后继的信息？

---

🍁🍁🍁🍁🍁**试作如下规定**：结点若有左子树，则其 `lchild` 域指示其左孩子；若没有，则令 `lchild` 域指示其前驱。结点若有右子树，则其 `lchild` 域指示其右孩子；若没有，则令 `lchild` 域指示其后继。

为了避免混淆，尚需改变结点结构，增加两个标志域，图示如下：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/线索二叉树的结构模型.svg" alt="线索二叉树的结构模型.svg" style="zoom: 100%">

其中：

$$
\begin{align}\mathrm{LTag} &=\left\{\begin{matrix} 0 & \text{LChild域指示结点的左孩子} \\ 1 & \text{LChild域指示结点的前驱}\end{matrix}\right.\\\mathrm{RTag}&=\left\{\begin{matrix} 0 & \text{RChild域指示结点的右孩子} \\ 1 & \text{RChild域指示结点的后继}\end{matrix}\right.\\\end{align}
$$

以这种结点结构，构成的二叉树链表二叉树的存储结构，叫做**线索链表**，其中指向结点前驱和后继的指针，叫做**线索**。加上线索的二叉树称之为**线索二叉树**。对二叉树以某种次序遍历，使其成为线索二叉树的过程叫做**线索化**。

**线索二叉树的数据结构模型**如下：

```c
typedef enum PointerTag
{
    Link = 0,  // Link = 0表示指向左右孩子指针
    Thread = 1 // Thread = 1表示指向前驱或后继的线索
} PointerTag;
typedef struct BiThrNode
{
    ElemType data;                     // 结点数据
    struct BiThrNode *lchild, *rchild; // 左右孩子指针或者线索指针
    PointerTag LTag;                   // 左标志
    PointerTag RTag;                   // 右标志
} BiThrNode, *BiThrTree;
```

1. 先序遍历；
   1. 如果结点没有左子树，那么该结点的前驱就是**双亲**；
   2. 如果结点没有右子树，那么该结点的后继就是双亲的右子树；
      1. 如果该结点双亲没有右子树，双亲的双亲的右子树
2. 中序遍历；
   1. 结点的后继是遍历右子树时访问的第一个结点，即右子树中最左下的结点
3. 后序线索树中找结点后继较复杂。

# 四、树和森林

## 4.1 树的存储

### 4.1.1 双亲表示法

假设以一组连续的空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在链表中的位置，其形式说明如下：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/树的双亲表示法.svg" alt="树的双亲表示法" style="zoom: 50%">

树的双亲表示法的数据结构模型如下：

```c
#define MAX_TREE_SIZE 100
// 结点结构
typedef struct PTNode
{
    TElemType data;
    int parent; // 双亲位置
} PTNode;
// 树结构
typedef struct PTree
{
    PTNode nodes[MAX_TREE_SIZE];
    int r, n; // 根的位置和结点数
} PTree;
```

**这种存储结构利用了每个结点（除根以外）只有唯一的双亲的性质。根据孩子结点，寻找双亲结点时，比较简单且高效。但是，这种表示法中，求结点的孩子时，需要遍历整个结构**。

### 4.1.2 孩子表示法

由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域。

但是，按照这种方式构造的结点，其孩子指针域不确定。如果规定每个结点的孩子指针个数相同，则会有很多空链表；如果规定每个结点的孩子指针与其的度相等时，则会带来操作不便。

另一种方法是，把每个结点的孩子，依次排列成一个线性表，并且以单链表作为存储结构，则 $n$ 个结点有 $n$ 个孩子链表（叶子的孩子链表为空链表）。而 $n$ 个头指针又组成一个线性表，通常采用顺序存储结构。这种存储结构的模型如下：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/树的（带双亲的）孩子表示法.svg" alt="树的（带双亲的）孩子表示法" style="zoom: 36%">

**树的孩子表示法的数据结构模型**如下：

```c
#define MAX_TREE_SIZE 100
// 结点的数据类型
typedef struct TElemType
{
    int value;
} TElemType;
typedef struct CTNode
{
    int child; // 孩子结点在数组中的位置
    struct CTNode *next;
} *ChildPtr;
typedef struct
{
    TElemType data;
    ChildPtr firstchild;
} CTBox;
typedef struct
{
    CTBox nodes[MAX_TREE_SIZE];
    int r, n; // 根的位置和结点数
} CTree;
```

### 4.1.3 孩子兄弟表示法

又称为二叉树表示法，或者二叉链表表示法。即以二叉链表作为树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点。

**树的孩子兄弟表示法的数据结构模型**如下：

```c
typedef struct CTNode
{
    int child; // 孩子结点在数组中的位置
    struct CTNode *firstChild, *nextSibling;
} *ChildPtr;
```

## 4.2 树与二叉树的转换

由于树和二叉树都可以使用二叉链表作为存储结构（树：孩子兄弟法），**则以二叉链表作为媒介，可以导出树与二叉树之间的一个对应关系**。也就是说，给定一棵树，可以找到唯一的一棵二叉树与之对应。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/树与二叉树的对应关系.png" alt="树与二叉树的对应关系" style="zoom: 100%">

> 从树的二叉链表的定义可知，任何一棵和树对应的二叉树，其右子树必定为空。

如果把森林中第二课树的根结点看成是第一棵树的根结点的兄弟，则同样可以导出森林和二叉树的对应关系。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/6_数和二叉树.md/森林与二叉树之间的对应关系.png" alt="森林与二叉树之间的对应关系" style="zoom: 100%">

---

1. 森林转换成二叉树：如果 $\displaystyle F = \left \{ T_{1} ,T_{2},\cdots ,T_{m} \right \} $ 是森林，则可按照下面规则转换成一个二叉树 $\displaystyle B = (\mathrm{root},\mathrm{LB},\mathrm{RB}   )$ ：

   1. 如果 $\displaystyle F$ 是空，即 $m=0$ ，那么 $B$ 是**空树**；

   2. 如果 $\displaystyle F$ 是不为空，即 $m>0$ ，那么 $B$ 的根 $\mathrm{root}$ 即为**森林中第一棵树 $\displaystyle T_{1} $ 的 $\mathrm{root}$** ； $B$ 的左子树 $\mathrm{LB}$ 是从 $T_{1}$ 中的根结点的子树森林 $\displaystyle T_{1} = \left \{ T_{(1,1)} ,T_{(1,2)},\cdots ,T_{(1,m)}\right \} $ 转换而成的二叉树。

      >  森林转换成二叉树，简单的方法就是，增加一个虚拟的根结点，作为**森林中所有树的根结点的双亲**，然后将形成的**虚拟树**转化成二叉树。

2. 二叉树转换成森林

   1. 如果 $B$ 为空，那么 $\displaystyle F$ 是空；
   2. 如果 $B$ 不为空，那么 $\displaystyle F$ 中的第一棵树的根 $\mathrm{root}$ 就是二叉树 $B$ 的根； $T_{1}$ 中的根结点的子树森林 $F_{1}$ 就是由 $B$ 的左子树 $\mathrm{LB}$ 转换而成的森林； $\displaystyle F$ 中除 $T_{1}$ 之外的其余树，组成的森林是由 $B$ 的右子树 $\mathrm{RB}$ 转换而成的森林。

> 从上述递归定义，容易写出相互转换的递归算法。同时，森林和树的操作亦可转换成二叉树的操作来实现。

## 4.3 树和森林的遍历

由树结构的定义，可引出两种次序遍历树的方法：

- 先根（次序）遍历，即：先访问树的根结点，然后依次先根遍历根结点的每棵子树；
- 后根（次序）遍历，即：先依次后根遍历根结点的每棵子树，然后访问根节点。

按照森林和树相互递归的定义，我们可以推出森林的两种遍历方法：

1. 先序遍历森林：若森林非空，则可按下述规则遍历之
   1. 访问森林中第一棵树的根结点；
   2. 先序遍历第一棵树中根结点的子树森林；
   3. 先序遍历，除去第一棵树之后剩余的树构成的森林。
2. 中序遍历森林：若森林非空，则可按下述规则遍历之：
   1. 中序遍历森林中第一棵树的根结点的子树森林；
   2. 访问第一棵树的根结点；
   3. 中序遍历除去第一棵树之后剩余的树构成的森林。

由上节森林与二叉树之间转换的规则可知，当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，则上述森林的先序和中序遍历，即为其对应的二叉树的先序和中序遍历。

**由此可见，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历，可借用二叉树的先序遍历和中序遍历的算法实现之**。

# 五、树与等价问题

【略】

# 六、哈夫曼树及其应用

## 6.1 最优二叉树

首先给路径和路径长度的概念：从树中一个结点到另一个结点之间的分支构成两个结点之间的**路径**，路径上的分支数目叫做**路径长度**。

**树的路径长度**：是从**树的根**到每一个结点的路径长度之和。

**结点的带权路径长度**为从该结点到树根之间的路径长度与结点上权的乘积。

**树的带权路径长度**为树中所有**叶子结点**的带权路径长度之和，通常记作 $\displaystyle \mathrm{WPL} = \displaystyle \sum_{k=1}^{n} w_{k} l_{k} $ 。

假设有 $n$ 个权值 $\displaystyle \left \{ \omega _{1} ,\omega _{2},\cdots ,\omega _{n} \right \} $ ，试构造一棵有 $n$ 个叶子结点的二叉树，每个叶子结点带权为 $\displaystyle \omega _{i}$ ，则其中带权路径长度 $\displaystyle \mathrm{WPL}$ 最小的二叉树，称作**最优二叉树**或者**哈夫曼树**。

哈夫曼树的构造方法：（**哈夫曼算法**）☯️☯️☯️☯️☯️☯️☯️

1. 根据给定的 $n$ 个权值 $\displaystyle \left \{ \omega _{1} ,\omega _{2},\cdots ,\omega _{n} \right \} $ ，构成 $n$ 棵二叉树集合 $\displaystyle F = \left \{ T_{1} , T_{2},\cdots , T_{n} \right \} $ ，其中，每棵二叉树 $\displaystyle T_{i}$ 中，只有一个带权为 $\displaystyle w_{i}$ 的根节点，**其左右子树为空**；
2. 在 $\displaystyle F $ 中选取两棵根结点的权值最小的二叉树树，作为左右子树，构造一棵新的二叉树，并且新的二叉树的根结点的权值是其左、右子树上的根结点的权值之和；
3. 在 $\displaystyle F $ 中删除这两棵树，同时将新得到的二叉树加入 $\displaystyle F $ 中；
4. 重复（2）和（3）步骤，直至 $\displaystyle F $ 只含有一棵树为止；
5. 最后得到的树，便是**哈夫曼树**。

哈夫曼树的构造算法如下：

```c
#include "stdio.h"
#include "malloc.h"

typedef struct ElemType
{
    int data;
} ElemType;

typedef struct Node
{
    ElemType data;
    unsigned int weight;
    unsigned int parent, lchild, rchild;
} Node, *HuffmanTree;

unsigned int Weight[16] = {0, 5, 29, 7, 8, 14, 23, 3, 11, 3, 24, 8, 16, 3, 6, 6};

int main() { }

void Creat(HuffmanTree &HT, float *weight, int length)
{
    int nodeCount = 2 * length - 1; // 结点数
    HT = (HuffmanTree)malloc((nodeCount + 1) * sizeof(Node));
    HuffmanTree p = HT;
    int i;
    // 初始化前length个结点
    for (i = 1; i < length + 1; i++)
    {
        *(p + i) = {*(weight + i), 0, 0, 0, 0};
    }
    // 初始化后length-1个结点
    for (i = length + 1; i < nodeCount + 1; i++)
    {
        *(p + i) = {0, 0, 0, 0, 0};
    }
    // 建赫夫曼树
    for (i = length + 1; i < nodeCount + 1; i++)
    {
        // 在HT[1~i-1]选择parent为0且weight最小的两个结点，其序号分别为s1和s2
        int s1, s2;
        Select(HT, i - 1, &s1, &s2);
        // 用s1和s2的weight作为i的weight，parent指向s1和s2
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}

void Select(HuffmanTree &HT, int n, int &s1, int &s2)
{
    // 找到第一个parent为0的结点
    for (int i = 1; i < n + 1; i++)
    {
        if (HT[i].parent == 0)
        {
            s1 = i;
            break;
        }
    }
    // 找到第二个parent为0的结点
    for (int i = 1; i < n + 1; i++)
    {
        if (HT[i].parent == 0 && i != s1)
        {
            s2 = i;
            break;
        }
    }
    // 从剩余的结点中找到权值最小的两个结点
    for (i = 1; i < n + 1; i++)
    {
        if (HT[i].parent == 0 && i != s1 && i != s2)
        {
            if (HT[i].weight < HT[s1].weight)
            {
                s2 = s1;
                s1 = i;
            }
            else if (HT[i].weight < HT[s2].weight)
            {
                s2 = i;
            }
        }
    }
}
```

## 6.2 哈夫曼编码

目前，进行快速远距离通信的主要手段是**电报**，即将需要传颂的文文字转换成由二进制的字符组成的字符串。当然，在传送电文时，希望总长度尽可能的短。**如果对每个字符设计长度不等的编码，并且让电文中出现次数较多的字符，尽可能的短的编码，则传送点问的总长度便可减少**。

因此，如果要设计长短不等的编码，则必须是任意一个字符的编码都不是另一个字符的编码的前缀，这种编码称作**前缀编码**。

假设每种字符在电文中出现的次数为 $\displaystyle w_{i}$ ，其编码长度为 $\displaystyle l_{i}$ ，电文中只有 $n$ 种字符，则电文总长度为 $\displaystyle \sum_{i=1}^{n} w_{i} l_{i} $ 。对应二叉树上，如果置 $\displaystyle w_{i}$ 为叶子结点的权， $\displaystyle l_{i}$ 恰好为从根到叶子的路径长度，那么 $\displaystyle \sum_{i=1}^{n} w_{i} l_{i} $ 恰好是二叉树上带权路径长度。

**由此可见，设计电文总长度最短的二进制前缀编码，即为以 $n$ 种字符出现的频率作为权值，设计一棵哈夫曼树的问题，由此得到的二进制前缀编码，便称为哈夫曼编码**。

其哈夫曼编码的具体算法如下：

```c
// w存放n个字符的权值(均>0)，构造赫夫曼树HT，并求出n个字符的赫夫曼编码HC
void HuffmanCoding(HuffmanTree &HT, HuffmanCode &HC, int *w, int n)
{
    // 如果小于一个字符，那么就不需要构造赫夫曼树
    if (n <= 1)
        return;
    int nodeCount = 2 * n - 1;                                  // 赫夫曼树的结点数
    HT = (HuffmanTree)malloc((nodeCount + 1) * sizeof(HTNode)); // 0号单元未用
    HuffmanTree p = HT;
    int i;
    // 初始化前n个结点
    for (i = 1; i < n + 1; i++)
    {
        *(p + i) = {*(w + i), 0, 0, 0};
    }
    // 初始化后n-1个结点
    for (i = n + 1; i < nodeCount + 1; i++)
    {
        *(p + i) = {0, 0, 0, 0};
    }
    // 建赫夫曼树
    for (i = n + 1; i < nodeCount + 1; i++)
    {
        // 在HT[1~i-1]选择parent为0且weight最小的两个结点，其序号分别为s1和s2
        int s1, s2;
        Select(HT, i - 1, &s1, &s2);
        // 用s1和s2的weight作为i的weight，parent指向s1和s2
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
    // 从叶子到根逆向求每个字符的赫夫曼编码
    HC = (HuffmanCode)malloc((n + 1) * sizeof(char *));
    char *cd = (char *)malloc(n * sizeof(char)); // 临时存放每个字符的编码
    cd[n - 1] = '\0';                            // 编码结束符
    // 逐个字符求赫夫曼编码
    for (i = 1; i < n + 1; i++)
    {
        int start = n - 1; // 编码结束符位置
        int c = i;         // 从叶子到根逆向求编码
        int f = HT[i].parent;
        while (f != 0)
        {
            --start;
            if (HT[f].lchild == c)
                cd[start] = '0';
            else
                cd[start] = '1';
            c = f;
            f = HT[f].parent;
        }
        HC[i] = (char *)malloc((n - start) * sizeof(char)); // 为第i个字符编码分配空间
        strcpy(HC[i], &cd[start]);                          // 把求得的编码从临时空间cd复制到HC
    }
    free(cd);
}
void Select(HuffmanTree &HT, int n, int &s1, int &s2)
{
    int i;
    // 找到第一个parent为0的结点
    for (i = 1; i < n + 1; i++)
    {
        if (HT[i].parent == 0)
        {
            s1 = i;
            break;
        }
    }
    // 找到第二个parent为0的结点
    for (i = 1; i < n + 1; i++)
    {
        if (HT[i].parent == 0 && i != s1)
        {
            s2 = i;
            break;
        }
    }
    // 从剩余的结点中找到权值最小的两个结点
    for (i = 1; i < n + 1; i++)
    {
        if (HT[i].parent == 0 && i != s1 && i != s2)
        {
            if (HT[i].weight < HT[s1].weight)
            {
                s2 = s1;
                s1 = i;
            }
            else if (HT[i].weight < HT[s2].weight)
            {
                s2 = i;
            }
        }
    }
}
```

# 七、回溯法与树的遍历

【略】
