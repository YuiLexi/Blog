---
title: 第九章 查找【数据结构】
date: 2023-4-29 00:00:09
categories:
	- [大学学习, 考研]
	- [C语言, 数据结构]
tags: [C语言, 数据结构, 考研, 大学学习]
description: 数据结构(C语言版)学习笔记，包括线性表、栈、队列、串、树、图、查找、排序等内容。
mathjax: true
katex: true
imagehost_path: Blog/Post/01.计算机学习/02.计算机基础学习/02.数据结构/09.查找.md/
---

# 前言

> 快速导航：
>
> - [第一章 绪论【数据结构】](./01.绪论)
> - [第二章 线性表【数据结构】](./02.线性表)
> - [第三章 栈和队列【数据结构】](./03.栈和队列)
> - [第四章 串【数据结构】](./04.串)
> - [第五章 数组和广义表【数据结构】](./05.数组和广义表)
> - [第六章 数和二叉树【数据结构】](./06.数和二叉树)
> - [第七章 图(Graph)【数据结构】](./07.图Graph)
> - [第九章 查找【数据结构】](./09.查找)

**查找表(Search Table)**是由同一类型的数据元素(或记录)构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构。

对查找表经常进行的操作有：

1. 查询数据元素是否在查找表中
2. 检索数据元素的各种属性
3. 在查找表中插人一个数元素
4. 从表中某个删去数据元素。

若对查找表只作前两种统称为“查找”的操作，则称此类查找表为**静态查找表(Static Search Table)**。若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为**动态查找表(Dynamic Search Table)**。

**关键字(Key)**是数据元素（或记录）中某个数据项的值，用它可以标识（识别）一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为**主关键字（Primary Key）**。反之，称用以识别若于记录的关键字为**次关键字（Secondary Key）**。当数据元素只有一个数据项时，其关键字即为该数据元素的值。

**查找(Searching)**：根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。

- 若表中存在这样的一个记录，则称**查找是成功的**，此时查找的结果为给出整个记录的信息，或指示该记录在查找表中的位置；
- 若表中不存在关键字等于给定值的记录，则称**查找不成功**，此时查找的结果可给出一个“空”记录或“空”指针。



# 一、静态查找表

## 1.1 顺序表的查找

**顺序查找**的过程：从表中最后一个记录开始，逐个进行比较**给定值**和**访问的记录的关键字**，如果二者相等，则查找成功；反之，如果直至第一个记录，其关键字和给定值比较都不相等，则查找不成功。

~~~c
int Search_Seq(SSTable ST, KeyType key)
{
    // 在顺序表 ST 中，顺序查找关键字等于 key 的数据元素
    // 返回该元素在表中的位置，否则为 0
    ST.elem[0].key = key; // 把要找的元素放在 0 位置；如果表中找不到其他对应的数据，那么找到的只有 0 位置元素，返回的结果是 0 ；表示：查找失败
    int i;
    for (i = ST.length; !EQ(ST.elem[i].key, key); i--) { }
    return i;
}
~~~



这个算法的思想和第2章中的函数 `LocateElbm_Sq`一致。只是在 `Search_Seq` 中查找之前，先对 `ST.elem[0]` 的关键字赋值 `key`，**目的在于免去查找过程中每一步都要检测整个表是否查找完毕**。



其改进形式的算法如下：

~~~c
int Search_Seq(SSTable ST, KeyType key)
{
    int i = ST.length;
    while (i > 0)
    {
        if (EQ(ST.elem[i].key, key))
        {
            return i;
        }
        i++;
    }
    return 0;
}
~~~

其中， `EQ(a,b)` 函数是判断两个关键字是否相等的函数。



## 1.(1.5) 查找的性能分析

**定义**：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的**平均查找长度(Average Search Length)**。

对于含有 $n$ 个记录的表，查找成功时的平均查找长度为：
$$
\displaystyle \mathrm{ASL} = \sum_{i=1}^{n}  P_{i} C_{i} 
$$
其中： $\displaystyle P_{i} $ 为查找表中第 $i$ 个记录的概率，并且 $\displaystyle \mathrm{ASL} = \sum_{i=1}^{n}  P_{i} =1$ 。



## 1.2 有序表的查找

**折半查找**的过程是：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或者找不到记录位置。

假设指针 $\displaystyle \mathrm{low} $ 和 $\displaystyle \mathrm{high} $ 分别指示待查元素，所在范围的下界和上界，指针 $\displaystyle \mathrm{mid} $ 指示区间的中间位置，即 $\displaystyle \mathrm{mid} =\left \lfloor \frac{(\mathrm{low}+\mathrm{high}  )}{2}  \right \rfloor $ 。

- 如果 $\displaystyle \mathrm{ST.elem}\left [ \mathrm{mid}  \right ]  .\mathrm{key } < \mathrm{key } $ ，则令 $\displaystyle \mathrm{low} = \mathrm{mid}+1  $ ；
- 如果 $\displaystyle \mathrm{ST.elem}\left [ \mathrm{mid}  \right ]  .\mathrm{key } > \mathrm{key } $ ，则令 $\displaystyle \mathrm{high} = \mathrm{mid}-1  $ ；直至找到或者找不到对应的记录。

~~~c
int Search_Bin(SSTable ST, KeyType key)
{
    int low = 1;
    int high = ST.length;
    while (low <= high)
    {
        int mid = (low + high) / 2;
        if (EQ(ST.elem[mid].key, key))
        {
            return mid;
        }
        else if (LT(ST.elem[mid].key, key))
        {
            low = mid + 1;
        }
        else
        {
            high = mid - 1;
        }
    }
    return 0;
}
~~~

**性能分析**：平均查找长度：
$$
\begin{align}\displaystyle \mathrm{ASL} &=\sum_{i=1}^{n}P_{i} C _{i} \\&=\frac{1}{n} \sum_{j=1}^{h}j\cdot 2^{j-1}  \\&=\frac{n+1}{n} \log_{2}{(n+1)}-1 \end{align}
$$


对任意的 $n$ ，当 $n$ 比较大时（  $n>50$  ），可由下列近似结果：
$$
\displaystyle \mathrm{ASL}_{bs}  = \log_{2}{(n+1)}-1 
$$


## 1.3 静态树的查找

前面的对有序表的查找性能的讨论，是在**等概率**的前提下进行的。如果有序表中个记录的查找概率不相等，该如何呢？

如果只考虑查找成功的话，则是查找性能达到最佳的判定树，是其带权路径长度之和 $\displaystyle \mathrm{PH}$ 值：
$$
\displaystyle \mathrm{PH}=\sum_{i=1}^{n}w_{i} h _{i} 
$$
取最小的二叉树。其中： $\displaystyle n$ 为二叉树上结点的个数（即：有序表的长度）； $\displaystyle h_{i} $ 为第 $\displaystyle i$ 个结点的在二叉树上的层次树；结点的权 $\displaystyle w_{i} =cp_{i} $ ，其中 $\displaystyle p_{i} $ 为结点的查找概率， $\displaystyle c$ 为某个常量。并且称 $\displaystyle \mathrm{PH}$ 值取最小的二叉树为**静态最优查找树**。



由于构造静态最优查找树所花费的时间代价较高，因此不做详细讨论。在此介绍一种构造近似最优查找树的有效算法。

已知一个按关键字有序的记录序列
$$
\displaystyle (r_{a},r_{a+1},\cdots ,r_{h})
$$
其中： $\displaystyle r_{a}.key < r_{a+1}.key < \cdots  < r_{h}.key < $ ；与每个记录相应的权值为： $\displaystyle w_{a} ,w_{a+1} ，\cdots ，w_{h} $ 。现构造一棵二叉树，使得这棵二叉树的带权路径长度 $\displaystyle \mathrm{PH} $ 值在所有具有同样权值的二叉树中，近似最小，称这类二叉树为**次优查找树**。



**构造次优查找树的递归算法**如下：

~~~c
void SecondOptimal(BiTree &T, ElemType R[], float sw[], int low, int high)
{
    int i = low; // 用于记录最小值的下标
    float min = fabs(sw[high] - sw[low]); // 用于记录最小值
    float dw = sw[high] + sw[low - 1]; // 用于记录当前的权值和
    for (int j = low + 1; j <= high; j++) // 从low+1开始遍历
    {
        float temp = fabs(dw - sw[j] - sw[j - 1]); // 计算当前的权值和
        if (temp < min)
        {
            min = temp;
            i = j;
        }
    }
    T = (BiTree)malloc(sizeof(BiTNode)); // 生成结点
    T->data = R[i]; // 赋值
    if (i == low)
    {
        T->lchild = NULL;
    }
    else
    {
        SecondOptimal(T->lchild, R, sw, low, i - 1); // 递归生成左子树
    }
    if (i == high)
    {
        T->rchild = NULL;
    }
    else
    {
        SecondOptimal(T->rchild, R, sw, i + 1, high); // 递归生成右子树
    }
}
~~~



<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/构造次优二叉查找树的简单示例.png" alt="构造次优二叉查找树的简单示例" style="zoom: 100%">



## 1.4 分块查找

如果以索引表表示静态查找表，则可用**分块查找**来实现。

**分块查找**又称为索引顺序查找，这是顺序查找的一种改进方法。在此查找方法中，除了表本身以外，尚需建立一个“索引表”。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/分块查找的表及其索引表.png" alt="分块查找的表及其索引表" style="zoom: 100%">



分块查找的平均查找长度为：
$$
\displaystyle \mathrm{ASL}_{bs} = L_{b}+L_{w}  
$$
其中： $\displaystyle L_{b}$ 为查找索引表确定所在块的平均查找长度， $\displaystyle L_{w}$ 为在块中查找元素的平均查找长度。如果用顺序表查找确定所在块，则分块查找的平均查找长度为：
$$
\begin{align}\displaystyle \mathrm{ASL}_{bs} & = L_{b}+L_{w}  = \frac{1}{b}\sum_{j=1}^{b}j+\frac{1}{s} \sum_{i=1}^{s}i\\&=\frac{b+1}{2}+\frac{s+1}{2} = \frac{1}{2} (\frac{n}{s} +s)+1    \end{align}
$$
如果用折半查找确定所在块，则分块查找的平局查找长度为:
$$
\displaystyle {\mathrm{ASL}_{bs} }'   \approx \log_{2}{(\frac{n}{s} +s)}+\frac{s}{2}  
$$


# 二、动态表的查找

## 2.1 二叉排序树

**二叉排序树**是具有下列性质的二叉树：

1. 如果它的左子树不为空，则左子树上**所有结点**的值**均小于**他的根节点的值；
2. 如果它的右子树不为空，则右子树上**所有结点**的值**均大于**他的根节点的值；
3. 它的左右子树也分别为二叉排序树；
4. 二叉排序树也可能是一棵空树。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/二叉排序树的简单示例.png" alt="二叉排序树的简单示例" style="zoom: 100%">



**二叉排序树又称二叉查找树**，根据上述定义的结构特点可见，它的查找过程和次优二叉树类似。即：当二叉排序树不空时，首先将给定值和根结点的关键字比较；若相等，则查找成功；否则，将依据给定值和根结点的关键字之间的大小关系，分别在左子树或右子树上继续进行查找。



二叉排序树的查找算法：

~~~c
BiTree SearchBST(BiTree T, KeyType key)
{
    if (T == NULL || EQ(key, T->data.key)) // 如果为空或者相等，返回
    {
        return T;
    }
    else if (LT(key, T->data.key))
    {
        return SearchBST(T->lchild, key); // 在左子树中继续查找
    }
    else
    {
        return SearchBST(T->rchild, key); // 在右子树中继续查找
    }
}
~~~



二叉排序树是一种动态树表。其特点是：树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时，再进行插入。**新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或者右孩子结点**。



改进的查找插入算法如下：

~~~c
Statue SearchBST(BiTree T, KeyType key, BiTree f, BiTree &p)
{
    if (T == NULL) // 如果为空，返回
    {
        p = f;
        return FALSE;
    }
    else if (EQ(key, T->data.key)) // 如果相等，返回
    {
        p = T;
        return TRUE;
    }
    else if (LT(key, T->data.key))
    {
        return SearchBST(T->lchild, key, T, p); // 在左子树中继续查找
    }
    else
    {
        return SearchBST(T->rchild, key, T, p); // 在右子树中继续查找
    }
}
~~~



并且，二叉排序树的插入算法：

~~~c
Statue InsertBST(BiTree &T, ElemType e)
{
    BiTree p;
    if (!SearchBST(T, e.key, NULL, p)) // 如果不存在，插入
    {
        BiTree s = (BiTree)malloc(sizeof(BiTNode));
        s->data = e;
        s->lchild = s->rchild = NULL;
        if (p == NULL) // 如果为空，直接插入
        {
            T = s;
        }
        else if (LT(e.key, p->data.key))
        {
            p->lchild = s; // 插入左子树
        }
        else
        {
            p->rchild = s; // 插入右子树
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
~~~



若从空树出发，经过一系列的查找插入操作之后，可生成一棵二叉树。设查找的关键字序列为 (45,24,53,45,12,24,90) ，则生成的二叉排序树如下图所示：

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/二叉排序树的构造过程.png" alt="二叉排序树的构造过程" style="zoom: 100%">



在二叉查找树中，删除一个结点，有三种情况讨论：

1. 如果 `指针p` 结点为叶子结点，那么只需要修改双亲结点的指针即可；
2. 如果 `指针p` 结点只有左子树或者只有右子树，那么直接让子树成为其双亲结点的左子树（或者右子树）即可；
3. 如果 `指针p` 结点仅有左子树，又有右子树。
    1. 方法一：令 `指针p` 结点的左子树（右子树）为其双亲的左子树（右子树），而结点的左子树（右子树）为其双亲的左子树（右子树），而 `指针p` 的右子树（左子树）为的右子树（左子树）为的右子树（左子树）；
    2. 方法二：令 `指针p` 的直接前驱或者直接后继替代的直接前驱或者直接后继替代 `指针p` ，然后再从二叉排序树中删去它的直接前驱或者直接后继；

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/二叉排序树删除对应的结点元素.png" alt="二叉排序树删除对应的结点元素" style="zoom: 100%">



在二叉排序树上删除一个结点的算法如下：

~~~c
Staute DeleteBSF(BiTree &T, KeyType key)
{
    if (T == NULL) // 如果为空，返回
    {
        return FALSE;
    }
    else
    {
        if (EQ(key, T->data.key)) // 如果相等，删除
        {
            return Delete(T);
        }
        else if (LT(key, T->data.key))
        {
            return DeleteBST(T->lchild, key); // 在左子树中继续查找
        }
        else
        {
            return DeleteBST(T->rchild, key); // 在右子树中继续查找
        }
    }
}
Statue Delete(BiTree &p)
{
    BiTree q, s;
    if (p->rchild == NULL) // 如果右子树为空，直接删除
    {
        q = p;
        p = p->lchild;
        free(q);
    }
    else if (p->lchild == NULL) // 如果左子树为空，直接删除
    {
        q = p;
        p = p->rchild;
        free(q);
    }
    else
    {
        q = p;
        s = p->lchild;
        while (s->rchild != NULL) // 找到左子树的最右结点
        {
            q = s;
            s = s->rchild;
        }
        p->data = s->data; // 用最右结点的值替换
        if (q != p)
        {
            q->rchild = s->lchild; // 用最右结点的左子树替换
        }
        else
        {
            q->lchild = s->lchild; // 用最右结点的左子树替换
        }
        free(s);
    }
    return TRUE;
}
~~~



二叉排序树的查找分析：

**含有 $\displaystyle n$ 个结点的二叉排序树的平均查找长度和树的形态有关**。树的深度为 $\displaystyle n$ ，其平均查找长度为 $\displaystyle \frac{n+1}{2} $ ，这是最差的情况。显然，最好的情况是二叉排序树和折半查找的判定树相同，这是最差的情况。



## 2.2 平衡二叉树

**平衡二叉树（Balanced Binay Tree 或者 Height-Balanced Tree）**又称 AVL 树（`Adelson-Velskii and Landis`）。它的特点是：

- 它可能是一棵空树；
- 它的左子树和右子树都是平衡二叉树；
- 左子树和右子树的深度只差绝对值不超过 1 。



如果将二叉树上结点的平衡因子 $\displaystyle \mathrm{BF(Balance\quad Factor)} $ 定义为该结点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是 -1、 0 、 1。

> 只要二叉树上有一个结点的平衡因子的绝对值大于 1，则该二叉树就是不平衡的。



在一般情况下，假设由于在二叉排序树上插入结点，而失去平衡的最小子树根结点为 $A$ ，则失去平衡后进行调整的规律可归纳为下列四种情况：

1. 单向右旋平衡处理：如果在 `A` 的左子树的根结点的左侧插入结点， `A` 的平衡因子由 1 变为 2 ，则需要进行一次向右的顺时针旋转操作；
2. 单向左旋平衡处理：如果在 `A` 的右子树的根结点的右侧插入结点， `A` 的平衡因子由 -1 变为 -2 ，则需要进行一次向左的逆时针旋转操作；（图 c）
3. 双向旋转（先左后右）平衡处理：如果在 `A` 的左子树的根结点的右子树上插入结点， `A` 的平衡因子由 1 变为 2 ，则需要进行两次旋转操作（先左旋后右旋）；（图 b）
4. 双向旋转（先右后左）平衡处理：由于在 `A` 的右子树的根结点的左子树上插入结点， `A` 的平衡因子由 -1 变为 -2 ，则需要进行两次旋转操作（先右旋后左旋）。（图 d）

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/平衡旋转问题.png" alt="平衡旋转问题" style="zoom: 100%">



在平衡的二叉排序树 BBST上插人一个新的数据元素 $\displaystyle e$ 的递归算法可描述如下：

1. 若BBST为空树，则插人一个数据元素为 $\displaystyle e$ 的新结点作为 BBST 的根结点，树的深度增 1 ；

2. 若 $\displaystyle e$ 的关键字和 BBST的根结点的关键字相等，则不进行插入

3. 若 $\displaystyle e$ 的关键字小于BBST的根结点的关键字，而且在 BBST 的左子树中，不存在和 $\displaystyle e$ 有相同关键字的结点，则将 e 插人在 BBST的左子树上，并且当插之后的左子树深度增加 (+1) 时，分别就下列不同情况处理之：

    1. BBST 的根结点的平衡因子为-1（右子树的深度大于左子树的深度）：则将根结点的平很椅子改为 0 ，BBST 的深度不变；

    2. BBST 的根结点的平衡因子为 0 （左、右子树的深度相等），将根结点的因子更改为 1 ， BBST 的深度增 1 ；

    3. BBST 的根结点的平衡因子为 1（左子的深度大于子的深度）： BBST 的左子树根结点的平衡因子为 1，则需进行单向右旋平衡处理；并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为 0 ，树的深度不变；

        ​    若 BBST 的左子树根结点的平衡因子为 -1 ，则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后，修改根结点和其左、右子树根结点的平衡因子，树的深度不变；

4. 若  $\displaystyle e$  的关键字大于 BBST 的根结点的关键字，而且在 BBST的子树中不存在和  $\displaystyle e$  有相同关键字的结点，则将  $\displaystyle e$  插入在 BBST 的右子树上，并且当插入之后的右子树深度增加(+1)时，分别就不同情况处理之。其处理操作和(三)中所述相对称。



二叉排序树的类型定义为：

~~~c
#define LH +1 // 左高
#define EH 0  // 等高
#define RH -1 // 右高

/* ============================ 数据结构 ============================ */
typedef struct ElemType
{
} ElemType;

typedef struct BSTNode
{
    ElemType data;
    int bf;                          // 平衡因子
    struct BSTNode *lchild, *rchild; // 左右孩子指针
} BSTNode, *BSTree;

/* =========================== 旋转操作 ============================== */
void R_Rotate(BSTree &p)
{
    BSTree lc = p->lchild; // lc指向p的左子树根结点
    p->lchild = lc->rchild;
    lc->rchild = p;
    p = lc; // p指向新的根结点
}
void L_Rotate(BSTree &p)
{
    BSTree rc = p->rchild; // rc指向p的右子树根结点
    p->rchild = rc->lchild;
    rc->lchild = p;
    p = rc; // p指向新的根结点
}
void LeftBalance(BSTree &T)
{
    BSTree lc = T->lchild; // lc指向T的左子树根结点
    switch (lc->bf)
    {
    case LH: // 新结点插入在T的左孩子的左子树上，要做单右旋处理
        T->bf = lc->bf = EH;
        R_Rotate(T);
        break;
    case RH:                    // 新结点插入在T的左孩子的右子树上，要做双旋处理
        BSTree rd = lc->rchild; // rd指向T的左孩子的右子树根
        switch (rd->bf)
        {
        case LH:
            T->bf = RH;
            lc->bf = EH;
            break;
        case EH:
            T->bf = lc->bf = EH;
            break;
        case RH:
            T->bf = EH;
            lc->bf = LH;
            break;
        }
        rd->bf = EH;
        L_Rotate(T->lchild); // 对T的左子树做左旋平衡处理
        R_Rotate(T);         // 对T做右旋平衡处理
    }
}
void RightBalance(BSTree &T)
{
    BSTree rc = T->rchild; // rc指向T的右子树根结点
    switch (rc->bf)
    {
    case RH: // 新结点插入在T的右孩子的右子树上，要做单左旋处理
        T->bf = rc->bf = EH;
        L_Rotate(T);
        break;
    case LH:                    // 新结点插入在T的右孩子的左子树上，要做双旋处理
        BSTree ld = rc->lchild; // ld指向T的右孩子的左子树根
        switch (ld->bf)
        {
        case RH:
            T->bf = LH;
            rc->bf = EH;
            break;
        case EH:
            T->bf = rc->bf = EH;
            break;
        case LH:
            T->bf = EH;
            rc->bf = RH;
            break;
        }
        ld->bf = EH;
        R_Rotate(T->rchild); // 对T的右子树做右旋平衡处理
        L_Rotate(T);         // 对T做左旋平衡处理
    }
}
~~~



那么，构造对应的插入算法如下：

~~~c
Status InsertAVL(BSTree &T, ElemType e, bool &taller)
{
    if (T == NULL) // 插入新结点，树长高
    {
        T = (BSTree)malloc(sizeof(BSTNode));
        T->data = e;
        T->lchild = T->rchild = NULL;
        T->bf = EH;
        taller = true;
    }
    else
    {
        if (EQ(e.key, T->data.key)) // 树中已存在和e有相同关键字的结点则不再插入
        {
            taller = false;
            return FALSE;
        }
        if (LT(e.key, T->data.key)) // 应继续在T的左子树中进行搜索
        {
            if (!InsertAVL(T->lchild, e, taller)) // 未插入
            {
                return FALSE;
            }
            if (taller) // 已插入到T的左子树中且左子树“长高”
            {
                switch (T->bf)
                {
                case LH: // 原本左子树比右子树高，需要做左平衡处理
                    LeftBalance(T);
                    taller = false;
                    break;
                case EH: // 原本左右子树等高，现因左子树增高而使树增高
                    T->bf = LH;
                    taller = true;
                    break;
                case RH: // 原本右子树比左子树高，现左右子树等高
                    T->bf = EH;
                    taller = false;
                    break;
                }
            }
        }
        else // 应继续在T的右子树中进行搜索
        {
            if (!InsertAVL(T->rchild, e, taller)) // 未插入
            {
                return FALSE;
            }
            if (taller) // 已插入到T的右子树中且右子树“长高”
            {
                switch (T->bf)
                {
                case LH: // 原本左子树比右子树高，现左右子树等高
                    T->bf = EH;
                    taller = false;
                    break;
                case EH: // 原本左右子树等高，现因右子树增高而使树增高
                    T->bf = RH;
                    taller = true;
                    break;
                case RH: // 原本右子树比左子树高，需要做右平衡处理
                    RightBalance(T);
                    taller = false;
                    break;
                }
            }
        }
    }
    return TRUE;
}
~~~

> 平衡树的查找分析：时间复杂度为 $\displaystyle O(\log_{}{n} )$ 。



## 2.3 B-树和B+树

**B-树**是一种平衡的多路查找树。一棵 $\displaystyle m$ 阶的B-树，或为空树，或为满足下列特性的 $\displaystyle m$ 叉树：

1. 树中每个结点至多有 $\displaystyle m$ 棵子树；

2. 如果根结点不是叶子结点，则至少有两棵子树；

3. 除根结点之外的所有非终端结点，至少有 $\displaystyle \frac{m}{2} $ 棵子树；

4. 所有的非终端结点中包含下列信息：
    $$
    \displaystyle (n,A_{0},K_{1},A_{1},K_{2},A_{2},\cdots ,K_{n},A_{n})
    $$
    ​    其中， $\displaystyle K_{i}$ 为关键字，且 $\displaystyle K_{i}<K_{i+1}$ ； $\displaystyle A_{i}$ 指向子树根结点的指针，且指针 $\displaystyle A_{i-1}$ 所指子树中，所有结点的关键字均小于 $\displaystyle K_{i}$ ， $\displaystyle A_{n}$ 所指子树中所有结点的关键字均大于 $\displaystyle K_{n}$ ， $\displaystyle n$ 为关键字的个数（或者 $\displaystyle n+1$ 为子树个数）。

5. 所有的叶子结点都出现在同一层次上，并且不带信息。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/一棵4阶的B-树.png" alt="一棵4阶的B-树" style="zoom: 100%">



<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/B树的结点详解.png" alt="B树的结点详解" style="zoom: 100%">



在B-树上进行查找的过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程。

假设结点类型如下：

~~~c
#define m 3 // B-树的阶，暂设为3
typedef struct KeyType
{
    int key; // 关键字项
} KeyType;
typedef struct Record
{
} Record;
typedef struct BTNode
{
    int keynum;                // 结点中关键字个数，即结点的大小
    struct BTNode *parent;     // 指向双亲结点
    KeyType key[m + 1];        // 关键字向量，0号单元未用
    struct BTNode *ptr[m + 1]; // 子树指针向量
    Record *recptr[m + 1];     // 记录指针向量
} BTNode, *BTree;
typedef struct Result
{
    BTNode *pt; // 指向找到的结点
    int i;      // 1..m，在结点中的关键字序号
    int tag;    // 1:查找成功，0:查找失败
} Result;
~~~



简单的查找操作如下：

~~~c
int Search(BTNode *p, KeyType K)
{
    int i = 0;
    for (i = 1; i <= p->keynum && LT(p->key[i].key, K.key); i++)
        ;
    return i;
}
Result SearchBTree(BTree T, KeyType K)
{
    BTNode *p = T, *q = NULL; // 初始化，p指向待查结点，q指向p的双亲
    int found = 0, i = 0;     // 初始化，found指示是否查找成功，i为查找关键字的序号
    while (p != NULL && !found)
    {
        i = Search(p, K); // 在p->key[1..keynum]中查找K.key
        if (i > 0 && EQ(p->key[i].key, K.key))
        {
            found = 1; // 查找成功
        }
        else
        {
            q = p;
            p = p->ptr[i];
        }
    }
    if (found)
    {
        return Result(p, i, 1);
    }
    else
    {
        return Result(q, i, 0);
    }
}
~~~



> B-树的查找分析：在含有 $N$ 个关键字的 B-树上进行查找时，从根结点到关键字所在结点的路径上设计的结点数不超过：
> $$
> \displaystyle \log_{\displaystyle \frac{m}{2} }{(\frac{N+1}{2} )} +1
> $$



B-树的插入和删除：

~~~c
Status InsertBTree(BTree &T, KeyType K, BTree q, int i)
{
    int s = 0, finished = 0; // finished指示插入是否完成，s为插入的关键字序号
    KeyType x = K;           // x为待插入的关键字
    BTree ap = NULL, p = q;  // ap为新的右子树指针，p为新的右子树指针
    while (p && !finished)   // 自底向上查找待插入位置
    {
        Insert(p, i, x, ap); // 将x和ap分别插入到p->key[i+1]和p->ptr[i+1]
        if (p->keynum < m)   // 结点未满，插入完成
        {
            finished = 1;
        }
        else // 结点已满，沿双亲链进行结点分裂
        {
            s = (m + 1) / 2;
            x = p->key[s];
            Split(p, s, ap); // 将p->key[s+1..m],p->ptr[s..m]和p->recptr[s..m]移入新结点*ap
            p = p->parent;
            if (p)
            {
                i = Search(p, x);
            }
        }
    }
    if (!finished) // T是空树(参数q为NULL)或根结点已分裂为结点(参数q不为NULL)
    {
        NewRoot(T, p, x, ap); // 生成含信息(T,x,ap)的新的根结点*T，原T和ap为子树指针
    }
    return OK;
}
void Insert(BTNode *p, int i, KeyType K, BTree ap)
{
    int j = 0;
    for (j = p->keynum; j > i; j--)
    {
        p->key[j + 1] = p->key[j];
        p->ptr[j + 1] = p->ptr[j];
    }
    p->key[i + 1] = K;
    p->ptr[i + 1] = ap;
    if (ap)
    {
        ap->parent = p;
    }
    p->keynum++;
}
void Split(BTNode *p, int s, BTree &ap)
{
    int i = 0;
    ap = (BTNode *)malloc(sizeof(BTNode)); // 生成新的右结点*ap
    ap->ptr[0] = p->ptr[s];                // 复制*p中后一半的关键字和指针到*ap
    for (i = s + 1; i <= p->keynum; i++)
    {
        ap->key[i - s] = p->key[i];
        ap->ptr[i - s] = p->ptr[i];
    }
    ap->keynum = p->keynum - s;
    ap->parent = p->parent;
    for (i = 0; i <= p->keynum - s; i++) // 修改双亲指针
    {
        if (ap->ptr[i])
        {
            ap->ptr[i]->parent = ap;
        }
    }
    p->keynum = s - 1; // 修改*p中前一半的关键字和指针
}
void NewRoot(BTree &T, BTree p, KeyType K, BTree ap)
{
    BTree q = (BTNode *)malloc(sizeof(BTNode)); // 生成新的根结点*q
    q->keynum = 1;
    q->ptr[0] = T;
    q->ptr[1] = ap;
    q->key[1] = K;
    q->parent = NULL;
    if (T)
    {
        T->parent = q;
    }
    if (ap)
    {
        ap->parent = q;
    }
    T = q;
}
int Search(BTNode *p, KeyType K)
{
    int i = 0;
    for (i = 1; i <= p->keynum && LT(p->key[i].key, K.key); i++)
        ;
    return i;
}

~~~



如果在 B-树上删除一个关键字，则首先删除该关键所在的结点。如果该结点为最下层的非终端结点，且其中的关键字数目不少于 $\displaystyle \frac{m}{2} $ ，则删除完成；否则要进行 **合并结点** 的操作。

删除最下层非终端结点中关键字的情形。有下列三种可能性：

1. 被删关键字所在结点中的关键字数目不小于 $\displaystyle \frac{m}{2} $ ， 则只需从该结点中删去该关键字 $K$ 和相应指针 $A$ ，树的其他部分不变；
2. 被删关键字所在结点中的关键字数目等于 $\displaystyle \frac{m}{2}-1 $ ，而与该结点相邻的右兄弟（或左兄弟）结点中的关键字数目大于 $\displaystyle \frac{m}{2}-1 $ ，则需将其兄弟结点中的最小（或最大）的关键字上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移关键字的关键字下移至被删关键字所在结点中；
3. 被删关键字所在结点和其相邻的兄弟结点中的关键字数目均等于 $\displaystyle \frac{m}{2}-1 $ 。假设该结点有右兄弟，且其右兄弟结点地址由双亲结点中的指针 $A$ 所指，则在删去关键字之后，它所在结点中剩余的关键字和指针加上双亲结点中的关键字 $K$ 一起，合并到 $A$ 所指兄弟结点中（若没有右兄弟，则合并至左兄弟结点中）。



**B+树**：B+树是应文件系统所需而出的一种 B-树的型树。一个 $m$ 阶的B+树和 $m$ 阶的B-树的差异在于：

1. 有 $n$ 棵子树的结点中含有 $n$ 个关键字；
2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；
3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。

<img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/B+树.png" alt="B+树" style="zoom: 100%">







# 三、哈希表

## 3.1 什么是哈希表

在前面讨论的各种结构（线性表、树等）中，记录在结构中的相对位置是随机的，和记录的关键字之间不存在确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。

这一类查找方法建立在“比较”的基础上。在顺序查找时，比较的结果为“`=`”与“`!=`”两种可能；在折半查找二叉排序树查找和 B-树查找时，比较的结果为“<”、“=”和“>”3种可能。

查找的效率依赖于查找过程中所进行的比较次数。



**理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系 $\displaystyle f$ ，使每个关键字和结构中一个唯一的存储位置相对应**。因而在查找时，只要根据这个对应关系 $\displaystyle f$ ，找到给定值 $K$ 的像 $\displaystyle f(K)$ 。

若结构中存在关键字和 $K$ 相等的记录，则必定在 $\displaystyle f(K)$ 的存储位置上，由此，不需要进行比较便可直接取得所查记录。在此，我们称这个对应关系为**哈希(Hash)函数**，按这个思想建立的表为**哈希表**。

1. 哈希函数是一个映像，因此设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许范围之内即可；
2. 对不同的关键字可能得到同一哈希地：即 $\displaystyle \mathrm{key1} \ne \mathrm{key2}$ ，而 $\displaystyle f(\mathrm{key1}) = f(\mathrm{key2})$ ，这种现象称**冲突(collision)**。具有相同函数值的关键字对该哈希函数来说称做**同义词synonym)**。

> 然而，在一般情况下，冲突只能尽可能地少，而不能完全避免。因为，**哈希函数是从关键字集合到地址集合的映像**



## 3.2 哈希函数的构造方法

常用的构造哈希函数的方法有：

1. 直接定址法

    ​    **取关键字**或者**关键字的某个线性函数值**作为哈希地址。即：
    $$
    \displaystyle H(K) = K \quad  or H(K) = a\cdot K+b
    $$
    ​    例如：（1）以年龄作为关键字，哈希函数其关键字本身。（2）关键字是年份，哈希函数取**关键字 + 常数**。

    <img src="https://picture.yuilexi.cn/计算机/计算机基础/数据结构/9_查找.md/直接定址法哈希函数.png" alt="直接定址法哈希函数" style="zoom: 100%">

2. 数字分析法

    ​    假设关键字是以 $r$ 为基的数（如:以 10 为基的十进制数），并且**哈希表中可能出现的关键字都是事先知道的**，则可取关键字的若干数位组成哈希地址。

3. 平方取中法

    ​    **取关键字平方后的中间几位为哈希地址**。这是一种较常用的构造哈希函数的方法，通常在选定哈希函数时不一定能知道关键字的全部情况，取其中哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。

4. 折叠法

    ​    将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加和（舍去进位）作为哈希地址，这方法称为**折叠法(olding)**。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到哈希地址。

5. 除留余数法

    ​    **取关键字被某个不大于哈希表表长 $m$ 的数 $p$ 除后，所得的余数为哈希地址**。即：
    $$
    \displaystyle H(K) = K \quad \mathrm{mod}\quad p
    $$
    这是一种最简单，也最常用的构造哈希函数的方法。它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。

    > 值得注意的是，在使用除留余数法时，对 $p$ 的选择很重要。若 $p$ 选的不好，容易产生同义词。

6. 随机数法

    ​    选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 $\displaystyle H(K) = \mathrm{random}(K) $ ，其中 `random` 为**随机函数**。通常，当关键字长度不等时，采用此法构造哈希函数较恰当。



实际工作中需视不同的情况采用不同的哈希函数。通常,考虑的因素有：

1. 计算哈希函数所需时间（包括硬件指令的因素）；
2. 关键字的长度；
3. 哈希表的大小；
4. 关键字的分布情况；
5. 记录的查找频率。



## 3.3 处理冲突的方法

通常用的处理冲突的方法有下列几种：

1. 开放定址法
    $$
    \displaystyle H_{i} (K) = \left [ H(K) +d_{i} \right ]  \quad \mathrm{mod} \quad  m 
    $$
    其中： H(K) 为**哈希函数**； $m$ 为哈希表表长； $\displaystyle d_{i}$ 为增量序列，可有 3 种取法：

    1. $\displaystyle d_{i} =1,2,3,\cdots ,m-1$ ，称为**线性探测再散列**；
    2. $\displaystyle d_{i} =\pm 1^{2} ,\pm 2^{2} ,\pm 3^{2} ,\cdots ,\pm (m-1)^{2} $ ，称为**二次探测再散列**；
    3. $$\displaystyle d_{i} = \text{伪随机数序列} $$ ，称为**随机探测再散列**。

2. 再哈希法
    $$
    \displaystyle H_{i}(K) = RH_{i} (K)
    $$
    ​    $\displaystyle RH_{i} (K)$ 均是不同的哈希函数，即在同义词产生地址冲突时，计算另一个哈希函数地址，直到冲突不再发生。这种方法不易产生**“聚集”**，但是增加了计算的时间。

3. 链地址法

    ​    将所有关键字为同义词的记录存储在同一线性链表中。假设某哈希函数产生的哈希地址在区间 $\displaystyle \left [ 0,m-1 \right ] $ 上，则设立一个指针型向量：
    $$
    \displaystyle \mathrm{Chain}\quad \mathrm{ChainHash}\left ( m \right )
    $$
    ​    其每个分量的初始状态都是空指针。凡哈希地址为 $i$ 的记录都插入到头指针为 $\mathrm{ChainHash}\left ( m \right )   $ 的链表中。在链表中的插入位置可以在表头或者表尾；也可以在中间，以保持同义词在同一线性表中，按关键字有序。

4. 建立一个公共溢出区

    ​    假设哈希函数的值域为 $\displaystyle \left [ 0,m-1 \right ] $ ，则向量 $\displaystyle \mathrm{HashTable} \left [ 0..m-1 \right ] $ 为基本表，每个分量存放一个记录，另设立向量 $\displaystyle \mathrm{OverTable} \left [ 0..v \right ] $ 为溢出表。所有关键字和基本表中的关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。



## 3.4 哈希表的查找及其分析

哈希表的查找算法如下：

~~~c
#include "stdio.h"

typedef enum Status
{
    ERROR,
    OK
} Status;

#define SUCCESS 1
#define UNSUCCESS 0
#define DUPLICATE -1
int hashsize[] = {997}; // 哈希表容量递增表，一个合适的素数序列
typedef struct ElemType
{
} ElemType;
typedef struct
{
    ElemType *elem; // 数据元素存储基址，动态分配数组
    int count;      // 当前数据元素个数
    int sizeindex;  // 动态分配数组容量，以hashsize[sizeindex]为当前容量
} HashTable;

int main()
{
    return 0;
}

Status SearchHash(HashTable H, ElemType K, int &p, int &c)
{
    p = Hash(K);                                   // 求得哈希地址
    while (H.elem[p] != NULL && !EQ(K, H.elem[p])) // 该位置中已有元素且不相等
    {
        c++;
        if (c < hashsize[H.sizeindex] / 2)
        {
            p = (p + 1) % hashsize[H.sizeindex]; // 求得下一个哈希地址
        }
        else
        {
            p = (p + 1) % hashsize[++H.sizeindex]; // 求得下一个哈希地址
            c = 0;
        }
    }
    if (EQ(K, H.elem[p])) // 查找成功
    {
        return SUCCESS;
    }
    else
    {
        return UNSUCCESS;
    }
}
int Hash(ElemType K)
{
    /* 由于不同的哈希函数构造方法不同，这里不做具体的实现 */
    return 0;
}
~~~

哈希表的插入算法：

~~~c
Status InsertHash(HashTable &H, ElemType e)
{
    int c = 0, p;
    if (SearchHash(H, e, p, c) == SUCCESS) // 表中已有与e有相同关键字的元素
    {
        return DUPLICATE;
    }
    else if (c < hashsize[H.sizeindex] / 2) // 插入e
    {
        H.elem[p] = e;
        H.count++;
        return SUCCESS;
    }
    else // 重建哈希表
    {
        ReCreateHashTable(H);
        return UNSUCCESS;
    }
}
~~~



从哈希表的查找过程可得：

1. 虽然哈希表在关键字与记录的存储位置之间建立了直接映像，但**由于“冲突”的产生，使得哈希表的查找过程仍然是一个给定值和关键字进行比较的过程**。因此，仍需以平均查找长度作为衡量哈希表的查找效率的量度。
2. 查找过程中需和给定值进行比较的关键字的个数取决于下列三个因素：哈希函数、处理冲突的方法和哈希表的装填因子。

哈希函数的“好坏”首先影响出现冲突的频繁程度。但是，对于“均匀的”哈希函数可以假定：不同的哈希函数对同一组随机的关键字，产生冲突的可能性相同，因为一般情况下设定的哈希函数是均匀的，则可不考虑它对平均查找长度的影响。对同样一组关键字，设定相同的哈希函数，则不同的处理冲突的方法得到的哈希表不同，它们的平均查找长度也不同。

对同样的一组关键字，设定相同的哈希函数，则不同的处理冲突的方法得到的哈希表不同，它们的平均查找长度不同。**在一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子**。

**哈希表的装填因子**定义为：



# 四、查找算法的分析总结